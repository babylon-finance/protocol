const hre = require('hardhat');
const { expect } = require('chai');
const ethers = hre.ethers;
const { createStrategy, executeStrategy, finalizeStrategy } = require('../fixtures/StrategyHelper');
const { MAX_UINT_256, ADDRESS_ZERO } = require('../../lib/constants');
const { setupTests } = require('../fixtures/GardenFixture');
const { createGarden } = require('../fixtures/GardenHelper');
const addresses = require('../../lib/addresses');
const { impersonateAddress } = require('../../lib/rpc');

describe('Locking Funds Attack', function () {
  let signer1;
  let signer2;
  let DAI;
  let WETH;
  let compoundBorrowIntegration;
  let compoundLendIntegration;

  beforeEach(async () => {
    ({ keeper, signer1, signer2, signer3, compoundBorrowIntegration, compoundLendIntegration } = await setupTests()());
    DAI = await ethers.getContractAt('IERC20', addresses.tokens.DAI);
    WETH = await ethers.getContractAt('IERC20', addresses.tokens.WETH);
  });

  describe('Strategy locking funds attacks by unexpected balances on exit', function () {
    it(`should protect from the attack to blocking funds in a strategy by having more balance than debt for a repay`, async function () {
      const token = WETH.address;
      userBalanceBefore = await ethers.provider.getBalance(signer1.address);
      // signer1 creates with 1 ETH contribution
      const garden = await createGarden({ reserveAsset: token, signer: signer1 });
      // Create strategy with lend and borrow operations for exploit simplicity
      const strategyContract = await createStrategy(
        'borrow',
        'dataset',
        [signer1],
        [compoundLendIntegration.address, compoundBorrowIntegration.address],
        garden,
        false,
        [ADDRESS_ZERO, 0, DAI.address, 0],
      );
      const userGardenTokens = await garden.balanceOf(signer1.address);
      await strategyContract.connect(keeper).resolveVoting([signer1.address], [userGardenTokens], 0, { gasPrice: 0 });

      const amount = ethers.utils.parseEther('0.9');
      await executeStrategy(strategyContract, { amount });
      // Send extra borrowed tokens to strategy
      whaleSigner = await impersonateAddress('0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643');
      await DAI.connect(whaleSigner).transfer(strategyContract.address, ethers.utils.parseEther('1'), {
        gasPrice: 0,
      });
      // not to be reverted
      await finalizeStrategy(strategyContract);
      await garden
        .connect(signer1)
        .withdraw(await garden.balanceOf(signer1.address), 1, signer1.address, false, strategyContract.address, {
          gasPrice: 0,
        });
      const userBalanceAfter = await ethers.provider.getBalance(signer1.address);
      expect(userBalanceAfter).to.closeTo(userBalanceBefore, ethers.utils.parseEther('1'));
    });
  });
});
