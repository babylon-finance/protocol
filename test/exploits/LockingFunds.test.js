const hre = require('hardhat');
const { expect } = require('chai');
const ethers = hre.ethers;
const { createStrategy, executeStrategy, finalizeStrategy } = require('fixtures/StrategyHelper');
const { MAX_UINT_256, ADDRESS_ZERO } = require('lib/constants');
const { setupTests } = require('fixtures/GardenFixture');
const { createGarden } = require('fixtures/GardenHelper');
const addresses = require('lib/addresses');
const { impersonateAddress } = require('lib/rpc');
const { increaseTime, normalizeDecimals, getERC20, getContract, parse, from, eth } = require('utils/test-helpers');

describe('Locking Funds Attack', function () {
  let aaveBorrowIntegration;
  let aaveLendIntegration;
  let babController;
  let rewardsDistributor;
  let owner;
  let signer1;
  let signer2;
  let signer3;
  let DAI;
  let WETH;
  let compoundLendIntegration;
  let compoundBorrowIntegration;
  let keeper;

  // Deploys aave oracle with changed ETH price and inject its code into real aave oracle contract
  // code is available in AaveOracle.sol
  // constructor args are dai, dai source, fallback oracle, weth, took from etherscan
  async function changeETHPriceInAaveOracle(WETH) {
    const oracles = await ethers.getContractFactory('AaveOracleMock');
    const oracle = await oracles.deploy(
      ['0x6B175474E89094C44Da98b954EedeAC495271d0F'],
      ['0x773616E4d11A78F511299002da57A0a94577F1f4'],
      '0x5B09E578cfEAa23F1b11127A658855434e4F3e09',
      WETH.address,
    );
    const code = await hre.network.provider.send('eth_getCode', [oracle.address]);
    await hre.network.provider.send('hardhat_setCode', ['0xA50ba011c48153De246E5192C8f9258A2ba79Ca9', code]);
  }

  // Health factor see aave docs
  async function getHealthFactor(lendingPool, borrower) {
    const data = await lendingPool.getUserAccountData(borrower);
    return data.healthFactor;
  }

  // useless when amount < 1
  function normalizeToken(amount) {
    return amount.div(ethers.utils.parseEther('0.001')).toNumber() / 1000;
  }

  beforeEach(async () => {
    ({
      aaveLendIntegration,
      aaveBorrowIntegration,
      babController,
      rewardsDistributor,
      keeper,
      owner,
      signer1,
      signer2,
      signer3,
      compoundBorrowIntegration,
      compoundLendIntegration,
    } = await setupTests()());
    DAI = await getERC20(addresses.tokens.DAI);
    WETH = await getERC20(addresses.tokens.WETH);
  });

  describe('Strategy locking funds attacks by unexpected balances on exit', function () {
    it(`strategy finalization should work despite an unexpected partial liquidation before exiting a borrow operation`, async function () {
      // The attack tried to exploit updateMaxCollateralFactor and sweep leaving stucked funds
      const token = WETH.address;
      const asset1 = WETH;
      const asset2 = DAI;
      const userBalanceBefore = await ethers.provider.getBalance(signer1.address);
      // signer1 creates with 1 ETH contribution
      const garden = await createGarden({ reserveAsset: token, signer: signer1 });
      // Create strategy with lend and borrow operations for exploit simplicity
      const strategyContract = await createStrategy(
        'borrow',
        'dataset',
        [signer1],
        [aaveLendIntegration.address, aaveBorrowIntegration.address],
        garden,
        false,
        [asset1.address, 0, asset2.address, 0],
      );
      const deposited = userBalanceBefore.sub(await ethers.provider.getBalance(signer1.address));
      const userGardenTokens = await garden.balanceOf(signer1.address);
      await strategyContract.connect(keeper).resolveVoting([signer1.address], [userGardenTokens], 0, { gasPrice: 0 });

      const lendingPool = await ethers.getContractAt('ILendingPool', '0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9');
      // Set maxCollateralFactor to 80% before strategy execution, max available for WETH collateral 80%, liquidate rate is 82.5%
      // The following call reverts "Transaction reverted: function call to a non-contract account" as we added the modifier isSystemContract
      // It was part of the original exploit and it worked until the fix was implemented, now it throws the exception: 'function call to a non-contract account'
      //expect(await aaveBorrowIntegration.connect(signer2).updateMaxCollateralFactor(ethers.utils.parseEther('0.8'))).to.be.reverted;

      // Now that we avoid anyone calling, only a system contract can call it, we try the hack calling it from the strategy contract to check sweep fix
      const strategyAddress = await impersonateAddress(strategyContract.address);

      await aaveBorrowIntegration
        .connect(strategyAddress)
        .updateMaxCollateralFactor(ethers.utils.parseEther('0.8'), { gasPrice: 0 });
      const amount = ethers.utils.parseEther('0.994');
      await executeStrategy(strategyContract, { amount });

      // health factor is around 1.03
      await getHealthFactor(lendingPool, strategyContract.address);
      // modify ETH price
      // for simplicity we changed WETH price
      await changeETHPriceInAaveOracle(WETH);
      // here is 0.99
      await getHealthFactor(lendingPool, strategyContract.address);

      // Send tokens to signer2 for liquidation
      const whaleSigner = await impersonateAddress('0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643');
      await DAI.connect(whaleSigner).transfer(signer2.address, ethers.utils.parseEther('100000'), {
        gasPrice: 0,
      });

      // Liquidate CDP with health factor < 1
      await DAI.connect(signer2).approve(lendingPool.address, MAX_UINT_256, { gasPrice: 0 });
      const attackerMaxBalance = normalizeToken(await DAI.balanceOf(signer2.address));

      await lendingPool
        .connect(signer2)
        .liquidationCall(WETH.address, DAI.address, strategyContract.address, MAX_UINT_256, false, { gasPrice: 0 });
      // await strategyContract.connect(signer3).sweep(DAI.address, {gasPrice: 0});
      // finalize strategy

      const attackerNewBalance = normalizeToken(await DAI.balanceOf(signer2.address));
      const attackUsedBalance = attackerMaxBalance - attackerNewBalance;

      await finalizeStrategy(strategyContract);

      await garden
        .connect(signer1)
        .withdraw(await garden.balanceOf(signer1.address), 1, signer1.address, false, strategyContract.address, {
          gasPrice: 0,
        });
      const userBalanceAfter = await ethers.provider.getBalance(signer1.address);
      // some losses (0.16) due to gas included
      if (userBalanceAfter.lt(userBalanceBefore)) {
        const loss = userBalanceBefore.sub(userBalanceAfter);
      } else {
        const profit = userBalanceAfter.sub(userBalanceBefore);
      }
      // ONLY_CONTRIBUTOR force to be contributor, so we deposit into the garden
      await garden.connect(signer1).deposit(ethers.utils.parseEther('1'), 1, signer1.getAddress(), false, {
        value: ethers.utils.parseEther('1'),
        gasPrice: 0,
      });
      await strategyContract.connect(signer1).sweep(DAI.address);
      const userBalanceAfterSweep = await ethers.provider.getBalance(signer1.address);
      await garden
        .connect(signer1)
        .withdraw(await garden.balanceOf(signer1.address), 1, signer1.address, false, strategyContract.address, {
          gasPrice: 0,
        });
      const userBalanceAfterSweepAndWithdraw = await ethers.provider.getBalance(signer1.address);

      if (userBalanceAfterSweepAndWithdraw.lt(userBalanceBefore)) {
        const loss = userBalanceBefore.sub(userBalanceAfterSweepAndWithdraw);
      } else {
        const profit = userBalanceAfterSweepAndWithdraw.sub(userBalanceBefore);
      }
      // We check that we now get funds back after recovering them from the strategy with 2% accuracy
      expect(userBalanceAfterSweepAndWithdraw).to.be.closeTo(userBalanceBefore, userBalanceBefore.div(50));
    });

    it(`should protect from the attack blocking funds in a strategy by having more balance than debt for a repay`, async function () {
      const token = WETH.address;
      const userBalanceBefore = await ethers.provider.getBalance(signer1.address);
      // signer1 creates with 1 ETH contribution
      const garden = await createGarden({ reserveAsset: token, signer: signer1 });
      // Create strategy with lend and borrow operations for exploit simplicity
      const strategyContract = await createStrategy(
        'borrow',
        'dataset',
        [signer1],
        [compoundLendIntegration.address, compoundBorrowIntegration.address],
        garden,
        false,
        [ADDRESS_ZERO, 0, DAI.address, 0],
      );
      const userGardenTokens = await garden.balanceOf(signer1.address);
      await strategyContract.connect(keeper).resolveVoting([signer1.address], [userGardenTokens], 0, { gasPrice: 0 });

      const amount = ethers.utils.parseEther('0.9');
      await executeStrategy(strategyContract, { amount });
      // Send extra borrowed tokens to strategy
      const whaleSigner = await impersonateAddress('0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643');
      await DAI.connect(whaleSigner).transfer(strategyContract.address, ethers.utils.parseEther('1'), {
        gasPrice: 0,
      });
      // not to be reverted
      await finalizeStrategy(strategyContract);
      await garden
        .connect(signer1)
        .withdraw(await garden.balanceOf(signer1.address), 1, signer1.address, false, strategyContract.address, {
          gasPrice: 0,
        });
      const userBalanceAfter = await ethers.provider.getBalance(signer1.address);
      expect(userBalanceAfter).to.closeTo(userBalanceBefore, userBalanceBefore.div(50));
    });
  });

  describe('Garden profits locking funds attacks', function () {
    it(`Check that after strategy ends all rewards are go back to LP and do not lock in the garden`, async function () {
      const userBalanceBefore = await ethers.provider.getBalance(signer1.address);
      await babController.connect(owner).enableBABLMiningProgram();
      // signer1 creates with 1 ETH contribution
      const garden = await createGarden({ reserveAsset: WETH.address, signer: signer1 });
      // Create strategy with lend and borrow operations for exploit simplicity
      const strategyContract = await createStrategy('lend', 'dataset', [signer1], aaveLendIntegration.address, garden);
      await garden
        .connect(signer1)
        .deposit(ethers.utils.parseEther('10'), 1, signer1.address, false, { value: ethers.utils.parseEther('10') });

      const userGardenTokens = await garden.balanceOf(signer1.address);
      await strategyContract.connect(keeper).resolveVoting([signer1.address], [userGardenTokens], 0, { gasPrice: 0 });

      const amount = ethers.utils.parseEther('10');
      await executeStrategy(strategyContract, { amount });

      // const nav = await strategyContract.getNAV();

      await increaseTime(15000000);

      // const nav2 = await strategyContract.getNAV();

      // finalize strategy
      await finalizeStrategy(strategyContract);

      // Check pending rewards for signer 1
      // rewards[0]: Strategist BABL , rewards[1]: Strategist Profit, rewards[2]: Steward BABL, rewards[3]: Steward Profit, rewards[4]: LP BABL, rewards[5]: total BABL, rewards[6]: total Profits

      const signer1Rewards = await rewardsDistributor.getRewards(garden.address, signer1.address, [
        strategyContract.address,
      ]);
      const signer1Profit = signer1Rewards[6];
      const balanceBeforeClaim = await ethers.provider.getBalance(signer1.address);
      // Claim rewards
      await garden.connect(signer1).claimReturns([strategyContract.address], { gasPrice: 0 });
      expect(await ethers.provider.getBalance(signer1.address)).to.be.closeTo(
        balanceBeforeClaim.add(signer1Profit),
        balanceBeforeClaim.add(signer1Profit).div(50),
      );
      // Check pending rewards for signer 1 after claim
      const signer1Rewards2 = await rewardsDistributor.getRewards(garden.address, signer1.address, [
        strategyContract.address,
      ]);
      const signer1Profit2 = signer1Rewards2[6];
      expect(ethers.BigNumber.from(signer1Profit2)).to.equal(0);

      // Withdraw all from garden
      const userBal = await garden.balanceOf(signer1.address);
      await increaseTime(3024000);
      await garden
        .connect(signer1)
        .withdraw(userBal, 0, signer1.address, false, strategyContract.address, { gasPrice: 0 });
      // some tx costs
      expect(await ethers.provider.getBalance(signer1.address)).to.be.closeTo(
        userBalanceBefore,
        userBalanceBefore.div(50),
      );
    });
  });
});
