{
  "language": "Solidity",
  "sources": {
    "contracts/BabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {RewardsDistributor} from './token/RewardsDistributor.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IGardenFactory} from './interfaces/IGardenFactory.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IIntegration} from './interfaces/IIntegration.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabController is OwnableUpgradeable, IBabController {\n    using AddressArrayUtils for address[];\n    using AddressUpgradeable for address;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n    event GardenAdded(address indexed _garden, address indexed _factory);\n    event GardenRemoved(address indexed _garden);\n\n    event ControllerIntegrationAdded(address _integration, string indexed _integrationName);\n    event ControllerIntegrationRemoved(address _integration, string indexed _integrationName);\n    event ControllerIntegrationEdited(address _newIntegration, string indexed _integrationName);\n    event ControllerOperationSet(uint8 indexed _kind, address _address);\n    event DefaultTradeIntegrationChanged(address indexed _newTradeIntegration, address _oldTradeIntegration);\n\n    event ReserveAssetAdded(address indexed _reserveAsset);\n    event ReserveAssetRemoved(address indexed _reserveAsset);\n    event LiquidityMinimumEdited(uint256 _minRiskyPairLiquidityEth);\n\n    event PriceOracleChanged(address indexed _priceOracle, address _oldPriceOracle);\n    event RewardsDistributorChanged(address indexed _rewardsDistributor, address _oldRewardsDistributor);\n    event TreasuryChanged(address _newTreasury, address _oldTreasury);\n    event IshtarGateChanged(address _newIshtarGate, address _oldIshtarGate);\n    event GardenValuerChanged(address indexed _gardenValuer, address _oldGardenValuer);\n    event GardenFactoryChanged(address indexed _gardenFactory, address _oldGardenFactory);\n\n    event StrategyFactoryEdited(address indexed _strategyFactory, address _oldStrategyFactory);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    address public constant UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address public override gardenValuer;\n    address public override priceOracle;\n    address public override gardenFactory;\n    address public override rewardsDistributor;\n    address public override ishtarGate;\n    address public override strategyFactory;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations;\n    // Address of the default trade integration used by the protocol\n    address public override defaultTradeIntegration;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public override enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public override isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) public assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Recipient of protocol fees\n    address public override treasury;\n\n    // Strategy cooldown period\n    uint256 public constant MIN_COOLDOWN_PERIOD = 6 hours;\n    uint256 public constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    // Strategy Profit Sharing\n    uint256 public strategistProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsProfitPercentage; //\n\n    // Strategy BABL Rewards Sharing\n    uint256 public strategistBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsBABLPercentage; //\n\n    uint256 public gardenCreatorBonus;\n\n    // Assets\n    // Absolute Min liquidity of assets for risky gardens 1000 ETH\n    uint256 public override minRiskyPairLiquidityEth;\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public override gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public override bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public override allowPublicGardens;\n\n    uint256 public override protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public override protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 public override protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 public override protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        gardenTokensTransfersEnabled = false;\n        bablMiningProgramEnabled = false;\n        allowPublicGardens = false;\n        minRiskyPairLiquidityEth = 1000 * 1e18;\n\n        strategistProfitPercentage = 10e16;\n        stewardsProfitPercentage = 5e16;\n        lpsProfitPercentage = 80e16;\n\n        strategistBABLPercentage = 8e16;\n        stewardsBABLPercentage = 17e16;\n        lpsBABLPercentage = 75e16;\n\n        gardenCreatorBonus = 15e16;\n    }\n\n    /* ============ External Functions ============ */\n\n    // ===========  Garden related Gov Functions ======\n    /**\n     * Creates a Garden smart contract and registers the Garden with the controller.\n     *\n     * @param _reserveAsset           Reserve asset of the Garden. Initially just weth\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _gardenParams           Array of numeric garden params\n     * @param _tokenURI               Garden NFT token URI\n     * @param _seed                   Seed to regenerate the garden NFT\n     */\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams\n    ) external payable override returns (address) {\n        require(defaultTradeIntegration != address(0), 'Need a default trade integration');\n        require(enabledOperations.length > 0, 'Need operations enabled');\n        require(IIshtarGate(ishtarGate).canCreate(msg.sender), 'User does not have creation permissions');\n        address newGarden =\n            IGardenFactory(gardenFactory).createGarden{value: msg.value}(\n                _reserveAsset,\n                address(this),\n                msg.sender,\n                _name,\n                _symbol,\n                _tokenURI,\n                _seed,\n                _gardenParams\n            );\n\n        require(!isGarden[newGarden], 'Garden already exists');\n        isGarden[newGarden] = true;\n        gardens.push(newGarden);\n        emit GardenAdded(newGarden, msg.sender);\n        return newGarden;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a Garden\n     *\n     * @param _garden               Address of the Garden contract to remove\n     */\n    function removeGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        require(!IGarden(_garden).active(), 'The garden needs to be disabled.');\n        gardens = gardens.remove(_garden);\n\n        delete isGarden[_garden];\n\n        emit GardenRemoved(_garden);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to disable a garden\n     *\n     * @param _garden               Address of the garden\n     */\n    function disableGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.active(), 'The garden needs to be active.');\n        garden.setActive(false);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to enable a garden\n     *\n     * @param _garden               Address of the garden\n     */\n    function enableGarden(address _garden) external onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        IGarden garden = IGarden(_garden);\n        require(!garden.active(), 'The garden needs to be disabled.');\n        garden.setActive(true);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 gardenTokens\n     * Can only happen after 2021 is finished.\n     */\n    function enableGardenTokensTransfers() external override onlyOwner {\n        require(block.timestamp > 1641024000000, 'Transfers cannot be enabled yet');\n        gardenTokensTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 BABL Tokens\n     * Can only happen after the protocol is fully decentralized.\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows public gardens\n     */\n    function setAllowPublicGardens() external override onlyOwner {\n        allowPublicGardens = true;\n    }\n\n    // ===========  Protocol related Gov Functions ======\n\n    /**  PRIVILEGED GOVERNANCE FUNCTION. Enable and starts the BABL Mining program by the Rewards Distributor\n     * Can only happen after public launch of the protocol.\n     */\n    function enableBABLMiningProgram() external override onlyOwner {\n        if (bablMiningProgramEnabled == false) {\n            // Can only be activated once\n            bablMiningProgramEnabled = true;\n            RewardsDistributor(rewardsDistributor).startBABLRewards(); // Sets the timestamp\n        }\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid keeper to the list\n     *\n     * @param _keeper Address of the keeper\n     */\n    function addKeeper(address _keeper) external override onlyOwner {\n        keeperList[_keeper] = true;\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Removes a keeper\n     *\n     * @param _keeper Address of the keeper\n     */\n    function removeKeeper(address _keeper) external override onlyOwner {\n        require(keeperList[_keeper], 'Keeper is whitelisted');\n        delete keeperList[_keeper];\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a list of assets to the whitelist\n     *\n     * @param _keepers List with keeprs of the assets to whitelist\n     */\n    function addKeepers(address[] memory _keepers) external override onlyOwner {\n        for (uint256 i = 0; i < _keepers.length; i++) {\n            keeperList[_keepers[i]] = true;\n        }\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid reserve asset for gardens\n     *\n     * @param _reserveAsset Address of the reserve assset\n     */\n    function addReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(!validReserveAsset[_reserveAsset], 'Reserve asset already added');\n        validReserveAsset[_reserveAsset] = true;\n        reserveAssets.push(_reserveAsset);\n        emit ReserveAssetAdded(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a reserve asset\n     *\n     * @param _reserveAsset               Address of the reserve asset to remove\n     */\n    function removeReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(validReserveAsset[_reserveAsset], 'Reserve asset does not exist');\n\n        reserveAssets = reserveAssets.remove(_reserveAsset);\n\n        delete validReserveAsset[_reserveAsset];\n\n        emit ReserveAssetRemoved(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the price oracle\n     *\n     * @param _priceOracle               Address of the new price oracle\n     */\n    function editPriceOracle(address _priceOracle) external override onlyOwner {\n        require(_priceOracle != priceOracle, 'Price oracle already exists');\n\n        require(_priceOracle != address(0), 'Price oracle must exist');\n\n        address oldPriceOracle = priceOracle;\n        priceOracle = _priceOracle;\n\n        emit PriceOracleChanged(_priceOracle, oldPriceOracle);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the Ishtar Gate Address\n     *\n     * @param _ishtarGate               Address of the new Ishtar Gate\n     */\n    function editIshtarGate(address _ishtarGate) external override onlyOwner {\n        require(_ishtarGate != ishtarGate, 'Ishtar Gate already exists');\n\n        require(_ishtarGate != address(0), 'Ishtar Gate oracle must exist');\n\n        address oldIshtarGate = ishtarGate;\n        ishtarGate = _ishtarGate;\n\n        emit IshtarGateChanged(_ishtarGate, oldIshtarGate);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the garden valuer\n     *\n     * @param _gardenValuer Address of the new garden valuer\n     */\n    function editGardenValuer(address _gardenValuer) external override onlyOwner {\n        require(_gardenValuer != gardenValuer, 'Garden Valuer already exists');\n\n        require(_gardenValuer != address(0), 'Garden Valuer must exist');\n\n        address oldGardenValuer = gardenValuer;\n        gardenValuer = _gardenValuer;\n\n        emit GardenValuerChanged(_gardenValuer, oldGardenValuer);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol fee recipient\n     *\n     * @param _newTreasury      Address of the new protocol fee recipient\n     */\n    function editTreasury(address _newTreasury) external override onlyOwner {\n        require(_newTreasury != address(0), 'Address must not be 0');\n\n        address oldTreasury = treasury;\n        treasury = _newTreasury;\n\n        emit TreasuryChanged(_newTreasury, oldTreasury);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the rewards distributor\n     *\n     * @param _newRewardsDistributor      Address of the new rewards distributor\n     */\n    function editRewardsDistributor(address _newRewardsDistributor) external override onlyOwner {\n        require(_newRewardsDistributor != address(0), 'Address must not be 0');\n\n        address oldRewardsDistributor = rewardsDistributor;\n        rewardsDistributor = _newRewardsDistributor;\n\n        emit RewardsDistributorChanged(_newRewardsDistributor, oldRewardsDistributor);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden factory\n     *\n     * @param _newGardenFactory      Address of the new garden factory\n     */\n    function editGardenFactory(address _newGardenFactory) external override onlyOwner {\n        require(_newGardenFactory != address(0), 'Address must not be 0');\n\n        address oldGardenFactory = gardenFactory;\n        gardenFactory = _newGardenFactory;\n\n        emit GardenFactoryChanged(_newGardenFactory, oldGardenFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy factory\n     *\n     * @param _newStrategyFactory      Address of the new strategy factory\n     */\n    function editStrategyFactory(address _newStrategyFactory) external override onlyOwner {\n        require(_newStrategyFactory != address(0), 'Address must not be 0');\n\n        address oldStrategyFactory = strategyFactory;\n        strategyFactory = _newStrategyFactory;\n\n        emit StrategyFactoryEdited(_newStrategyFactory, oldStrategyFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol default trde integration\n     *\n     * @param _newDefaultTradeIntegation      Address of the new default trade integration\n     */\n    function setDefaultTradeIntegration(address _newDefaultTradeIntegation) external override onlyOwner {\n        require(_newDefaultTradeIntegation != address(0), 'Address must not be 0');\n        require(_newDefaultTradeIntegation != defaultTradeIntegration, 'Address must be different');\n        require(\n            enabledIntegrations[_nameHash(IIntegration(_newDefaultTradeIntegation).getName())] ==\n                _newDefaultTradeIntegation,\n            'Integration needs to be valid'\n        );\n        address oldDefaultTradeIntegration = defaultTradeIntegration;\n        defaultTradeIntegration = _newDefaultTradeIntegation;\n\n        emit DefaultTradeIntegrationChanged(_newDefaultTradeIntegation, oldDefaultTradeIntegration);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Add a new integration to the registry\n     *\n     * @param  _name             Human readable string identifying the integration\n     * @param  _integration      Address of the integration contract to add\n     */\n    function addIntegration(string memory _name, address _integration) public override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n        require(enabledIntegrations[hashedName] == address(0), 'Integration exists already.');\n        require(_integration != address(0), 'Integration address must exist.');\n\n        enabledIntegrations[hashedName] = _integration;\n\n        emit ControllerIntegrationAdded(_integration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing integration on the registry\n     *\n     * @param  _name         Human readable string identifying the integration\n     * @param  _integration      Address of the integration contract to edit\n     */\n    function editIntegration(string memory _name, address _integration) public override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n\n        require(enabledIntegrations[hashedName] != address(0), 'Integration does not exist.');\n        require(_integration != address(0), 'Integration address must exist.');\n\n        enabledIntegrations[hashedName] = _integration;\n\n        emit ControllerIntegrationEdited(_integration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Remove an existing integration on the registry\n     *\n     * @param  _name         Human readable string identifying the integration\n     */\n    function removeIntegration(string memory _name) external override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n        require(enabledIntegrations[hashedName] != address(0), 'Integration does not exist.');\n\n        address oldIntegration = enabledIntegrations[hashedName];\n        delete enabledIntegrations[hashedName];\n\n        emit ControllerIntegrationRemoved(oldIntegration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing operation on the registry\n     *\n     * @param  _kind             Operation kind\n     * @param  _operation        Address of the operation contract to set\n     */\n    function setOperation(uint8 _kind, address _operation) public override onlyOwner {\n        require(_kind < MAX_OPERATIONS, 'Max operations reached');\n        require(enabledOperations[_kind] != _operation, 'Operation already set');\n        require(_operation != address(0), 'Operation address must exist.');\n        enabledOperations[_kind] = _operation;\n\n        emit ControllerOperationSet(_kind, _operation);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edits the minimum liquidity an asset must have on Uniswap\n     *\n     * @param  _minRiskyPairLiquidityEth       Absolute min liquidity of an asset to grab price\n     */\n    function editLiquidityMinimum(uint256 _minRiskyPairLiquidityEth) public override onlyOwner {\n        require(_minRiskyPairLiquidityEth > 0, '_minRiskyPairLiquidityEth > 0');\n        minRiskyPairLiquidityEth = _minRiskyPairLiquidityEth;\n\n        emit LiquidityMinimumEdited(_minRiskyPairLiquidityEth);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    function owner() public view override(IBabController, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    function getUniswapFactory() external pure override returns (address) {\n        return UNISWAP_FACTORY;\n    }\n\n    function getGardens() external view override returns (address[] memory) {\n        return gardens;\n    }\n\n    function getOperations() external view override returns (address[20] memory) {\n        return enabledOperations;\n    }\n\n    function getReserveAssets() external view returns (address[] memory) {\n        return reserveAssets;\n    }\n\n    function getMinCooldownPeriod() external pure override returns (uint256) {\n        return MIN_COOLDOWN_PERIOD;\n    }\n\n    function getMaxCooldownPeriod() external pure override returns (uint256) {\n        return MAX_COOLDOWN_PERIOD;\n    }\n\n    function isValidReserveAsset(address _reserveAsset) external view override returns (bool) {\n        return validReserveAsset[_reserveAsset];\n    }\n\n    function isValidKeeper(address _keeper) external view override returns (bool) {\n        return keeperList[_keeper];\n    }\n\n    /**\n     * Returns the percentages of a strategy Profit Sharing\n     *\n     * @return            Strategist, Stewards, Lps, creator bonus\n     */\n    function getProfitSharing()\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (strategistProfitPercentage, stewardsProfitPercentage, lpsProfitPercentage);\n    }\n\n    /**\n     * Returns the percentages of BABL Profit Sharing\n     *\n     * @return            Strategist, Stewards, Lps, creator bonus\n     */\n    function getBABLSharing()\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (strategistBABLPercentage, stewardsBABLPercentage, lpsBABLPercentage, gardenCreatorBonus);\n    }\n\n    /**\n     * Get the integration address associated with passed human readable name\n     *\n     * @param  _name         Human readable integration name\n     *\n     * @return               Address of integration\n     */\n    function getIntegrationByName(string memory _name) external view override returns (address) {\n        return enabledIntegrations[_nameHash(_name)];\n    }\n\n    /**\n     * Get integration integration address associated with passed hashed name\n     *\n     * @param  _nameHashP     Hash of human readable integration name\n     *\n     * @return               Address of integration\n     */\n    function getIntegrationWithHash(bytes32 _nameHashP) external view override returns (address) {\n        return enabledIntegrations[_nameHashP];\n    }\n\n    /**\n     * Check if integration name is valid\n     *\n     * @param  _name         Human readable string identifying the integration\n     *\n     * @return               Boolean indicating if valid\n     */\n    function isValidIntegration(string memory _name, address _integration) external view override returns (bool) {\n        return enabledIntegrations[_nameHash(_name)] == _integration;\n    }\n\n    /**\n     * Check if a contract address is a garden or one of the system contracts\n     *\n     * @param  _contractAddress           The contract address to check\n     */\n    function isSystemContract(address _contractAddress) external view override returns (bool) {\n        return (isGarden[_contractAddress] ||\n            gardenValuer == _contractAddress ||\n            priceOracle == _contractAddress ||\n            owner() == _contractAddress ||\n            _contractAddress == address(this) ||\n            _isOperation(_contractAddress) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).isStrategy(_contractAddress)));\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * Hashes the string and returns a bytes32 value\n     */\n    function _nameHash(string memory _name) private pure returns (bytes32) {\n        return keccak256(bytes(_name));\n    }\n\n    function _isOperation(address _address) private view returns (bool) {\n        for (uint8 i = 0; i < MAX_OPERATIONS; i++) {\n            if (_address == enabledOperations[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/token/RewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards of the BABL Mining Program\n * along the time reserved for executed strategies. It implements a supply curve to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared to the whole protocol usage.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses to specific profiles\n * which are actively contributing to the protocol growth and their communities (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributor is Ownable, IRewardsDistributor {\n    using SafeMath for uint256;\n    using SafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n    using Safe3296 for uint256;\n    using Safe3296 for int256;\n    using Safe3296 for uint96;\n    using Safe3296 for uint32;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the call is not from a valid strategy\n     */\n    modifier onlyStrategy {\n        _require(controller.isSystemContract(address(IStrategy(msg.sender).garden())), Errors.ONLY_STRATEGY);\n        _;\n    }\n    /**\n     * Throws if the call is not from a valid active garden\n     */\n    modifier onlyActiveGarden(address _garden, uint256 _pid) {\n        if (_pid != 0 || gardenPid[address(_garden)] > 1) {\n            // Enable deploying flow with security restrictions\n            _require(IBabController(controller).isSystemContract(address(_garden)), Errors.NOT_A_SYSTEM_CONTRACT);\n            _require(IBabController(controller).isGarden(address(_garden)), Errors.ONLY_ACTIVE_GARDEN);\n        }\n        _require(msg.sender == address(_garden), Errors.ONLY_ACTIVE_GARDEN);\n        _require(IGarden(_garden).active(), Errors.ONLY_ACTIVE_GARDEN);\n        _;\n    }\n\n    /**\n     * Throws if the BABL Rewards mining program is not active\n     */\n    modifier onlyMiningActive() {\n        _require(IBabController(controller).bablMiningProgramEnabled(), Errors.ONLY_MINING_ACTIVE);\n        _;\n    }\n    /**\n     * Throws if the sender is not the controller\n     */\n    modifier onlyController() {\n        _require(IBabController(controller).isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        _require(address(controller) == msg.sender, Errors.ONLY_CONTROLLER);\n        _;\n    }\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 public constant override Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 public constant override DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 public constant override EPOCH_DURATION = 90 days;\n\n    // solhint-disable-next-line\n    uint256 public override START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 public immutable BABL_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable BABL_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable BABL_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable PROFIT_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable PROFIT_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable PROFIT_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 public immutable PROFIT_PROTOCOL_FEE;\n    // solhint-disable-next-line\n    uint256 public immutable CREATOR_BONUS;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        // Protocol allocation checkpoints per timestamp along the time\n        uint256 principal; // Protocol principal allocation\n        uint256 time; // Time of the checkpoint\n        uint256 quarterBelonging; // # Quarter checkpoint belonging since START_TIME\n        uint256 timeListPointer; // Pointer to the array of timestamps to enable the possibility of struct iteration\n        uint256 power; // Protocol power checkpoint (power is proportional to = principal * duration)\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // Checkpoint to keep track on accumulated protocol principal per quarter\n        uint256 quarterNumber; // # Quarter since START_TIME\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // Supply per quarter\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 principal; // Checkpoint to keep track on garden allocation\n        uint256 timestamp; // Checkpoint timestamps\n        uint256 power; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // Array of timestamps for each user in each garden\n        uint256 pid; // Garden contributor checkpoints counter to enable iteration\n        mapping(uint256 => TimestampContribution) tsContributions; // Sub-mapping all the contributor checkpoints\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 principal; // Principal of user in each garden\n        uint256 timestamp; // Checkpoint time\n        uint256 timePointer; // Pointer\n        uint256 power; // Contributor power per checkpoint\n    }\n    struct Checkpoints {\n        // Checkpoints for contributor power calculations where a certain window (from -> to) is queried\n        uint256 fromDepositAt; // First contributor checkpoint within the provided window\n        uint256 lastDepositAt; // Last contributor checkpoint within the provided window\n        uint256 gardenFromDepositAt; // First contributor checkpoint within the provided window\n        uint256 gardenLastDepositAt; // Last garden checkpoint within the provided window\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController public controller;\n\n    // BABL Token contract\n    TimeLockedToken public babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal) in all strategy pools.\n    uint256 public override protocolPrincipal;\n    mapping(uint256 => ProtocolPerTimestamp) public protocolPerTimestamp; // Mapping of all protocol checkpoints\n    uint256[] public timeList; // Array of all protocol checkpoints\n    uint256 public override pid; // Initialization of the ID assigning timeListPointer to the checkpoint number\n\n    mapping(uint256 => ProtocolPerQuarter) public protocolPerQuarter; // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => bool) public isProtocolPerQuarter; // Check if the protocol per quarter data has been initialized\n\n    // Strategy overhead control. Only used if each strategy has power overhead due to changes overtime\n    mapping(address => mapping(uint256 => uint256)) public rewardsPowerOverhead; // Overhead control to enable high level accuracy calculations for strategy rewards\n    // Contributor power control\n    mapping(address => mapping(address => ContributorPerGarden)) public contributorPerGarden; // Enable high level accuracy calculations\n    mapping(address => mapping(address => Checkpoints)) private checkpoints;\n    // Garden power control\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) public gardenPowerByTimestamp;\n    mapping(address => uint256[]) public gardenTimelist;\n    mapping(address => uint256) public gardenPid;\n\n    /* ============ Constructor ============ */\n\n    constructor(TimeLockedToken _bablToken, IBabController _controller) {\n        require(address(_bablToken) != address(0), 'Token needs to exist');\n        require(address(_controller) != address(0), 'Controller needs to exist');\n        babltoken = _bablToken;\n        controller = _controller;\n\n        (BABL_STRATEGIST_SHARE, BABL_STEWARD_SHARE, BABL_LP_SHARE, CREATOR_BONUS) = controller.getBABLSharing();\n        (PROFIT_STRATEGIST_SHARE, PROFIT_STEWARD_SHARE, PROFIT_LP_SHARE) = controller.getProfitSharing();\n        PROFIT_PROTOCOL_FEE = controller.protocolPerformanceFee();\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Function that adds the capital received to the total principal of the protocol per timestamp\n     * @param _capital                Amount of capital in WETH\n     */\n    function addProtocolPrincipal(uint256 _capital) external override onlyStrategy onlyMiningActive {\n        IStrategy strategy = IStrategy(msg.sender);\n        if (strategy.enteredAt() >= START_TIME) {\n            // onlyMiningActive control, it does not create a checkpoint if the strategy is not part of the Mining Program\n            _updateProtocolPrincipal(address(strategy), _capital, true);\n        }\n    }\n\n    /**\n     * Function that removes the capital received to the total principal of the protocol per timestamp\n     * @param _capital                Amount of capital in WETH\n     */\n    function substractProtocolPrincipal(uint256 _capital) external override onlyStrategy onlyMiningActive {\n        IStrategy strategy = IStrategy(msg.sender);\n        if (strategy.enteredAt() >= START_TIME) {\n            // onlyMiningActive control, it does not create a checkpoint if the strategy is not part of the Mining Program\n            _updateProtocolPrincipal(address(strategy), _capital, false);\n        }\n    }\n\n    /**\n     * Gets the total amount of rewards for a given strategy\n     * @param _strategy                Strategy to check\n     */\n    function getStrategyRewards(address _strategy) external view override returns (uint96) {\n        IStrategy strategy = IStrategy(_strategy);\n        _require(strategy.exitedAt() != 0, Errors.STRATEGY_IS_NOT_OVER_YET);\n        if ((strategy.enteredAt() >= START_TIME) && (START_TIME != 0)) {\n            // We avoid gas consuming once a strategy got its BABL rewards during its finalization\n            uint256 rewards = strategy.strategyRewards();\n            if (rewards != 0) {\n                return Safe3296.safe96(rewards, 'overflow 96 bits');\n            }\n            // If the calculation was not done earlier we go for it\n            (uint256 numQuarters, uint256 startingQuarter) =\n                _getRewardsWindow(strategy.executedAt(), strategy.exitedAt());\n            uint256 bablRewards = 0;\n            if (numQuarters <= 1) {\n                bablRewards = _getStrategyRewardsOneQuarter(_strategy, startingQuarter); // Proportional supply till that moment within the same epoch\n                _require(\n                    bablRewards <= protocolPerQuarter[startingQuarter].supplyPerQuarter,\n                    Errors.OVERFLOW_IN_SUPPLY\n                );\n                _require(\n                    strategy.capitalAllocated().mul(strategy.exitedAt().sub(strategy.executedAt())).sub(\n                        strategy.rewardsTotalOverhead()\n                    ) <= protocolPerQuarter[startingQuarter].quarterPower,\n                    Errors.OVERFLOW_IN_POWER\n                );\n            } else {\n                // The strategy takes longer than one quarter / epoch\n                // We need to calculate the strategy vs. protocol power ratio per each quarter\n                uint256[] memory strategyPower = new uint256[](numQuarters); // Strategy power in each Epoch\n                uint256[] memory protocolPower = new uint256[](numQuarters); // Protocol power in each Epoch\n                for (uint256 i = 0; i <= numQuarters.sub(1); i++) {\n                    uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION)); // Initialization timestamp at the end of the first slot where the strategy starts its execution\n\n                    // We iterate all the quarters where the strategy was active\n                    uint256 percentage = 1e18;\n                    if (strategy.executedAt().add(EPOCH_DURATION) > slotEnding) {\n                        // We are in the first quarter of the strategy\n\n                        strategyPower[i] = strategy.capitalAllocated().mul(slotEnding.sub(strategy.executedAt())).sub(\n                            rewardsPowerOverhead[address(strategy)][_getQuarter(strategy.executedAt())]\n                        );\n                    } else if (\n                        strategy.executedAt() < slotEnding.sub(EPOCH_DURATION) && slotEnding < strategy.exitedAt()\n                    ) {\n                        // We are in an intermediate quarter different from starting or ending quarters\n                        strategyPower[i] = strategy\n                            .capitalAllocated()\n                            .mul(slotEnding.sub(slotEnding.sub(EPOCH_DURATION)))\n                            .sub(rewardsPowerOverhead[address(strategy)][_getQuarter(slotEnding.sub(45 days))]);\n                    } else {\n                        // We are in the last quarter of the strategy\n                        percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                            slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                        );\n\n                        strategyPower[i] = strategy\n                            .capitalAllocated()\n                            .mul(strategy.exitedAt().sub(slotEnding.sub(EPOCH_DURATION)))\n                            .sub(rewardsPowerOverhead[address(strategy)][_getQuarter(strategy.exitedAt())]);\n                    }\n                    protocolPower[i] = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n\n                    _require(strategyPower[i] <= protocolPower[i], Errors.OVERFLOW_IN_POWER);\n\n                    bablRewards = bablRewards.add(\n                        strategyPower[i]\n                            .preciseDiv(protocolPower[i])\n                            .preciseMul(uint256(protocolPerQuarter[startingQuarter.add(i)].supplyPerQuarter))\n                            .preciseMul(percentage)\n                    );\n                }\n            }\n\n            // Babl rewards will be proportional to the total return (profit) with a max cap of x2\n            uint256 percentageMul = strategy.capitalReturned().preciseDiv(strategy.capitalAllocated());\n            if (percentageMul > 2e18) percentageMul = 2e18;\n            bablRewards = bablRewards.preciseMul(percentageMul);\n            return Safe3296.safe96(bablRewards, 'overflow 96 bits');\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Sends BABL tokens rewards to a contributor after a claim is requested to the protocol.\n     * @param _to                Address to send the tokens to\n     * @param _amount            Amount of tokens to send the address to\n     */\n    function sendTokensToContributor(address _to, uint96 _amount) external override onlyMiningActive {\n        _require(controller.isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        _safeBABLTransfer(_to, _amount);\n    }\n\n    /**\n     * Starts BABL Rewards Mining Program from the controller.\n     */\n    function startBABLRewards() external onlyController {\n        if (START_TIME == 0) {\n            // It can only be activated once to avoid overriding START_TIME\n            START_TIME = block.timestamp;\n        }\n    }\n\n    /**\n     * Calculates the profits and BABL that a contributor should receive from a series of finalized strategies\n     * @param _garden                   Garden to which the strategies and the user must belong to\n     * @param _contributor              Address of the contributor to check\n     * @param _finalizedStrategies      List of addresses of the finalized strategies to check\n     */\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view override returns (uint256, uint96) {\n        uint256 contributorTotalProfits = 0;\n        uint256 bablTotalRewards = 0;\n        for (uint256 i = 0; i < _finalizedStrategies.length; i++) {\n            (uint256 strategyProfits, uint256 strategyBABL) =\n                _getStrategyProfitsAndBABL(_garden, _finalizedStrategies[i], _contributor);\n            contributorTotalProfits = contributorTotalProfits.add(strategyProfits);\n            bablTotalRewards = bablTotalRewards.add(strategyBABL);\n        }\n\n        return (contributorTotalProfits, Safe3296.safe96(bablTotalRewards, 'R28'));\n    }\n\n    /* ========== View functions ========== */\n\n    /**\n     * Gets the contributor power from one timestamp to the other\n     * @param _garden      Address of the garden where the contributor belongs to\n     * @param _contributor Address if the contributor\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) external view override returns (uint256) {\n        return _getContributorPower(_garden, _contributor, _from, _to);\n    }\n\n    function updateGardenPower(address _garden, uint256 _pid) external override onlyActiveGarden(_garden, _pid) {\n        _updateGardenPower(_garden);\n    }\n\n    function setContributorTimestampParams(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw,\n        uint256 _pid\n    ) external override onlyActiveGarden(_garden, _pid) {\n        _setContributorTimestampParams(_garden, _contributor, _previousBalance, _depositOrWithdraw);\n    }\n\n    function tokenSupplyPerQuarter(uint256 quarter) external pure override returns (uint96) {\n        return _tokenSupplyPerQuarter(quarter);\n    }\n\n    function checkProtocol(uint256 _time)\n        external\n        view\n        override\n        returns (\n            uint256 principal,\n            uint256 time,\n            uint256 quarterBelonging,\n            uint256 timeListPointer,\n            uint256 power\n        )\n    {\n        return (\n            protocolPerTimestamp[_time].principal,\n            protocolPerTimestamp[_time].time,\n            protocolPerTimestamp[_time].quarterBelonging,\n            protocolPerTimestamp[_time].timeListPointer,\n            protocolPerTimestamp[_time].power\n        );\n    }\n\n    function checkQuarter(uint256 _num)\n        external\n        view\n        override\n        returns (\n            uint256 quarterPrincipal,\n            uint256 quarterNumber,\n            uint256 quarterPower,\n            uint96 supplyPerQuarter\n        )\n    {\n        return (\n            protocolPerQuarter[_num].quarterPrincipal,\n            protocolPerQuarter[_num].quarterNumber,\n            protocolPerQuarter[_num].quarterPower,\n            protocolPerQuarter[_num].supplyPerQuarter\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _updateProtocolPrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) internal {\n        IStrategy strategy = IStrategy(_strategy);\n        ProtocolPerTimestamp storage protocolCheckpoint = protocolPerTimestamp[block.timestamp];\n        if (_addOrSubstract == false) {\n            // Substract\n            protocolPrincipal = protocolPrincipal.sub(_capital);\n        } else {\n            protocolPrincipal = protocolPrincipal.add(_capital);\n        }\n        protocolCheckpoint.principal = protocolPrincipal;\n        protocolCheckpoint.time = block.timestamp;\n        protocolCheckpoint.quarterBelonging = _getQuarter(block.timestamp);\n        protocolCheckpoint.timeListPointer = pid;\n        if (pid == 0) {\n            // The very first strategy of all strategies in the mining program\n            protocolCheckpoint.power = 0;\n        } else {\n            // Any other strategy different from the very first one (will have an antecesor)\n            protocolCheckpoint.power = protocolPerTimestamp[timeList[pid.sub(1)]].power.add(\n                protocolCheckpoint.time.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time).mul(\n                    protocolPerTimestamp[timeList[pid.sub(1)]].principal\n                )\n            );\n        }\n        timeList.push(block.timestamp); // Register of added strategies timestamps in the array for iteration\n        // Here we control the accumulated protocol power per each quarter\n        // Create the quarter checkpoint in case the checkpoint is the first in the epoch\n        _addProtocolPerQuarter(block.timestamp);\n        // We update the rewards overhead if any\n        _updatePowerOverhead(strategy, _capital);\n        pid++;\n    }\n\n    function _getStrategyProfitsAndBABL(\n        address _garden,\n        address _strategy,\n        address _contributor\n    ) private view returns (uint256, uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        _require(address(strategy.garden()) == _garden, Errors.STRATEGY_GARDEN_MISMATCH);\n        uint256 contributorProfits = 0;\n        uint256 contributorBABL = 0;\n        // We get the state of the strategy in terms of profit and distance from expected to accurately calculate profits and rewards\n        (bool profit, uint256 profitValue, bool distance, uint256 distanceValue) =\n            _getStrategyRewardsContext(address(strategy));\n\n        (, uint256 initialDepositAt, uint256 claimedAt, , , ) = IGarden(_garden).getContributor(_contributor);\n        // Positive strategies not yet claimed\n        if (\n            strategy.exitedAt() > claimedAt &&\n            strategy.executedAt() >= initialDepositAt &&\n            address(strategy.garden()) == _garden\n        ) {\n            uint256 contributorPower =\n                _getContributorPower(address(_garden), _contributor, strategy.executedAt(), strategy.exitedAt());\n            // If strategy returned money we give out the profits\n            if (profit == true) {\n                // We reserve 5% of profits for performance fees\n                profitValue = profitValue.sub(profitValue.multiplyDecimal(PROFIT_PROTOCOL_FEE));\n            }\n            // Get strategist rewards in case the contributor is also the strategist of the strategy\n            contributorBABL = contributorBABL.add(\n                _getStrategyStrategistBabl(\n                    address(strategy),\n                    _contributor,\n                    profit,\n                    profitValue,\n                    distance,\n                    distanceValue\n                )\n            );\n\n            contributorProfits = contributorProfits.add(\n                _getStrategyStrategistProfits(address(strategy), _contributor, profit, profitValue)\n            );\n\n            // Get steward rewards\n            contributorBABL = contributorBABL.add(\n                _getStrategyStewardBabl(address(strategy), _contributor, profit, profitValue, distance, distanceValue)\n            );\n\n            contributorProfits = contributorProfits.add(\n                _getStrategyStewardProfits(\n                    address(strategy),\n                    _contributor,\n                    profit,\n                    profitValue,\n                    distance,\n                    distanceValue\n                )\n            );\n\n            // Get LP rewards\n\n            contributorBABL = contributorBABL.add(\n                uint256(strategy.strategyRewards()).multiplyDecimal(BABL_LP_SHARE).preciseMul(\n                    contributorPower.preciseDiv(strategy.capitalAllocated())\n                )\n            );\n\n            // Get a multiplier bonus in case the contributor is the garden creator\n            if (_contributor == IGarden(_garden).creator()) {\n                contributorBABL = contributorBABL.add(contributorBABL.multiplyDecimal(CREATOR_BONUS));\n            }\n        }\n        return (contributorProfits, contributorBABL);\n    }\n\n    function _getStrategyRewardsContext(address _strategy)\n        private\n        view\n        returns (\n            bool,\n            uint256,\n            bool,\n            uint256\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 returned = strategy.capitalReturned();\n        uint256 expected =\n            strategy.capitalAllocated().add(strategy.capitalAllocated().preciseMul(strategy.expectedReturn()));\n        uint256 allocated = strategy.capitalAllocated();\n        bool profit;\n        bool distance;\n        uint256 profitValue;\n        uint256 distanceValue;\n        if (returned > allocated && returned >= expected) {\n            // The strategy went equal or above expectations\n            profit = true; // positive\n            distance = true; // positive\n            profitValue = returned.sub(allocated);\n            distanceValue = returned.sub(expected);\n        } else if (returned >= allocated && returned < expected) {\n            // The strategy went worse than expected but with some profits\n            profit = true; // positive or zero profits\n            distance = false; // negative vs expected return (got less than expected)\n            profitValue = returned.sub(allocated);\n            distanceValue = expected.sub(returned);\n        } else if (returned < allocated && returned < expected) {\n            // Negative profits - bad investments has penalties\n            profit = false; // negative - loosing capital\n            distance = false; // negative vs expected return (got less than expected)\n            profitValue = allocated.sub(returned); // Negative number, there were no profits at all\n            distanceValue = expected.sub(returned);\n        }\n\n        return (profit, profitValue, distance, distanceValue);\n    }\n\n    function _getStrategyStewardBabl(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256, /* _profitValue */\n        bool _distance,\n        uint256 _distanceValue\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyRewards = strategy.strategyRewards();\n        int256 userVotes = strategy.getUserVotes(_contributor);\n        uint256 bablCap;\n        uint256 expected =\n            strategy.capitalAllocated().add(strategy.capitalAllocated().preciseMul(strategy.expectedReturn()));\n\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 babl = 0;\n        if (userVotes > 0 && _profit == true && _distance == true) {\n            // Voting in favor of the execution of the strategy with profits and positive distance\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(userVotes).preciseDiv(strategy.totalPositiveVotes())\n            );\n        } else if (userVotes > 0 && _profit == true && _distance == false) {\n            // Voting in favor positive profits but below expected return\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(userVotes).preciseDiv(strategy.totalPositiveVotes())\n            );\n            babl = babl.sub(babl.preciseMul(_distanceValue.preciseDiv(expected))); // We discount the error of expected return vs real returns\n        } else if (userVotes > 0 && _profit == false) {\n            // Voting in favor of a non profitable strategy get nothing\n            babl = 0;\n        } else if (userVotes < 0 && _distance == false) {\n            // Voting against a strategy that got results below expected return provides rewards to the voter (helping the protocol to only have good strategies)\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(Math.abs(userVotes)).preciseDiv(strategy.totalNegativeVotes())\n            );\n\n            bablCap = babl.mul(2); // Max cap\n            babl = babl.add(babl.preciseMul(_distanceValue.preciseDiv(expected))); // We add a bonus inverse to the error of expected return vs real returns\n\n            if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n        } else if (userVotes < 0 && _distance == true) {\n            babl = 0;\n        }\n        return babl;\n    }\n\n    function _getStrategyStewardProfits(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256 _profitValue,\n        bool _distance,\n        uint256 /* _distanceValue */\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 profits = 0;\n        int256 userVotes = strategy.getUserVotes(_contributor);\n        if (_profit == true) {\n            if (userVotes > 0) {\n                profits = _profitValue.multiplyDecimal(PROFIT_STEWARD_SHARE).preciseMul(uint256(userVotes)).preciseDiv(\n                    strategy.totalPositiveVotes()\n                );\n            } else if ((userVotes < 0) && _distance == false) {\n                profits = _profitValue\n                    .multiplyDecimal(PROFIT_STEWARD_SHARE)\n                    .preciseMul(uint256(Math.abs(userVotes)))\n                    .preciseDiv(strategy.totalNegativeVotes());\n            } else if ((userVotes < 0) && _distance == true) {\n                // Voted against a very profit strategy above expected returns, get no profit at all\n                profits = 0;\n            }\n        } else profits = 0; // No profits at all\n\n        return profits;\n    }\n\n    function _getStrategyStrategistBabl(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256, /* _profitValue */\n        bool _distance,\n        uint256 /* _distanceValue */\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyRewards = strategy.strategyRewards();\n        uint256 babl;\n        uint256 bablCap;\n        uint256 expected =\n            strategy.capitalAllocated().add(strategy.capitalAllocated().preciseMul(strategy.expectedReturn()));\n        if (strategy.strategist() == _contributor) {\n            babl = strategyRewards.multiplyDecimal(BABL_STRATEGIST_SHARE); // Standard calculation to be ponderated\n            if (_profit == true && _distance == true) {\n                // Strategy with equal or higher profits than expected\n                bablCap = babl.mul(2); // Max cap\n                // The more the results are close to the expected the more bonus will get (limited by a x2 cap)\n                babl = babl.add(babl.preciseMul(expected.preciseDiv(strategy.capitalReturned())));\n                if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n            } else if (_profit == true && _distance == false) {\n                //under expectations\n                // The more the results are close to the expected the less penalization it might have\n                babl = babl.sub(babl.sub(babl.preciseMul(strategy.capitalReturned().preciseDiv(expected))));\n            } else {\n                // No positive profit\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n\n        return babl;\n    }\n\n    function _getStrategyStrategistProfits(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256 _profitValue\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 profits;\n        if (_profit == true) {\n            if (strategy.strategist() == _contributor) {\n                // If the contributor was the strategist of the strategy\n                profits = _profitValue.multiplyDecimal(PROFIT_STRATEGIST_SHARE);\n            }\n        } else profits = 0; // No profits at all\n\n        return profits;\n    }\n\n    function _addProtocolPerQuarter(uint256 _time) private onlyMiningActive {\n        ProtocolPerQuarter storage protocolCheckpoint = protocolPerQuarter[_getQuarter(_time)];\n\n        if (!isProtocolPerQuarter[_getQuarter(_time).sub(1)]) {\n            // The quarter is not yet initialized then we create it\n            protocolCheckpoint.quarterNumber = _getQuarter(_time);\n            if (pid == 0) {\n                // The first strategy added in the first epoch\n                protocolCheckpoint.quarterPower = 0;\n                protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(_getQuarter(_time));\n            } else {\n                // Each time a new epoch starts with either a new strategy execution or finalization\n                // We just take the proportional power for this quarter from previous checkpoint\n                uint256 powerToSplit =\n                    protocolPerTimestamp[_time].power.sub(protocolPerTimestamp[timeList[pid.sub(1)]].power);\n                if (protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging == _getQuarter(_time).sub(1)) {\n                    // There were no intermediate epochs without checkpoints\n                    // We re-initialize the protocol power counting for this new quarter\n                    protocolCheckpoint.quarterPower = powerToSplit\n                        .mul(_time.sub(START_TIME.add(_getQuarter(_time).mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                        .div(_time.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time));\n                    protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(_getQuarter(_time));\n\n                    protocolPerQuarter[_getQuarter(_time).sub(1)].quarterPower = protocolPerQuarter[\n                        _getQuarter(_time).sub(1)\n                    ]\n                        .quarterPower\n                        .add(powerToSplit.sub(protocolCheckpoint.quarterPower));\n                } else {\n                    // There were intermediate epochs without checkpoints - we need to create their protocolPerQuarter's and update the last one\n                    // We have to update all the quarters including where the previous checkpoint is and the one were we are now\n                    for (\n                        uint256 i = 0;\n                        i <= _getQuarter(_time).sub(protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging);\n                        i++\n                    ) {\n                        ProtocolPerQuarter storage newCheckpoint =\n                            protocolPerQuarter[protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging.add(i)];\n                        uint256 slotEnding =\n                            START_TIME.add(\n                                protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging.add(i).mul(EPOCH_DURATION)\n                            );\n                        if (i == 0) {\n                            // We are in the first quarter to update, we add the corresponding part\n\n                            newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                                powerToSplit.mul(slotEnding.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time)).div(\n                                    _time.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time)\n                                )\n                            );\n                            newCheckpoint.quarterPrincipal = protocolPerTimestamp[timeList[pid.sub(1)]].principal;\n                        } else if (\n                            i < _getQuarter(_time).sub(protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging)\n                        ) {\n                            // We are in an intermediate quarter\n                            newCheckpoint.quarterPower = powerToSplit.mul(EPOCH_DURATION).div(\n                                _time.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time)\n                            );\n                            newCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(\n                                protocolPerTimestamp[timeList[pid.sub(1)]].quarterBelonging.add(i)\n                            );\n                            newCheckpoint.quarterNumber = protocolPerTimestamp[timeList[pid.sub(1)]]\n                                .quarterBelonging\n                                .add(i);\n                            newCheckpoint.quarterPrincipal = protocolPerTimestamp[timeList[pid.sub(1)]].principal;\n                        } else {\n                            // We are in the last quarter of the strategy\n                            protocolCheckpoint.quarterPower = powerToSplit\n                                .mul(\n                                _time.sub(START_TIME.add(_getQuarter(_time).mul(EPOCH_DURATION).sub(EPOCH_DURATION)))\n                            )\n                                .div(_time.sub(protocolPerTimestamp[timeList[pid.sub(1)]].time));\n                            protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(_getQuarter(_time));\n                            protocolCheckpoint.quarterNumber = _getQuarter(_time);\n                            protocolCheckpoint.quarterPrincipal = protocolPrincipal;\n                        }\n                    }\n                }\n            }\n            isProtocolPerQuarter[_getQuarter(_time).sub(1)] = true;\n        } else {\n            // Quarter checkpoint already created, it must have been filled with general info\n            // We update the power of the quarter by adding the new difference between last quarter checkpoint and this checkpoint\n            protocolCheckpoint.quarterPower = protocolCheckpoint.quarterPower.add(\n                protocolPerTimestamp[_time].power.sub(protocolPerTimestamp[timeList[pid.sub(1)]].power)\n            );\n        }\n        protocolCheckpoint.quarterPrincipal = protocolPrincipal;\n    }\n\n    function _updatePowerOverhead(IStrategy _strategy, uint256 _capital) private onlyMiningActive {\n        if (_strategy.updatedAt() != 0) {\n            // There will be overhead after the first execution not before\n            if (_getQuarter(block.timestamp) == _getQuarter(_strategy.updatedAt())) {\n                // The overhead will remain within the same epoch\n                rewardsPowerOverhead[address(_strategy)][_getQuarter(block.timestamp)] = rewardsPowerOverhead[\n                    address(_strategy)\n                ][_getQuarter(block.timestamp)]\n                    .add(_capital.mul(block.timestamp.sub(_strategy.updatedAt())));\n            } else {\n                // We need to iterate since last update of the strategy capital\n                (uint256 numQuarters, uint256 startingQuarter) =\n                    _getRewardsWindow(_strategy.updatedAt(), block.timestamp);\n                uint256 overheadPerQuarter = _capital.mul(block.timestamp.sub(_strategy.updatedAt())).div(numQuarters);\n                for (uint256 i = 0; i <= numQuarters.sub(1); i++) {\n                    rewardsPowerOverhead[address(_strategy)][startingQuarter.add(i)] = rewardsPowerOverhead[\n                        address(_strategy)\n                    ][startingQuarter.add(i)]\n                        .add(overheadPerQuarter);\n                }\n            }\n        }\n    }\n\n    function _getStrategyRewardsOneQuarter(address _strategy, uint256 _startingQuarter)\n        private\n        view\n        onlyMiningActive\n        returns (uint256)\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyOverTime =\n            strategy.capitalAllocated().mul(strategy.exitedAt().sub(strategy.executedAt())).sub(\n                strategy.rewardsTotalOverhead()\n            );\n        return\n            strategyOverTime\n                .preciseDiv(protocolPerQuarter[_startingQuarter].quarterPower)\n                .preciseMul(uint256(protocolPerQuarter[_startingQuarter].supplyPerQuarter))\n                .mul(strategy.exitedAt().sub(_startingQuarter))\n                .div(block.timestamp.sub(_startingQuarter));\n    }\n\n    // Safe BABL transfer function, just in case if rounding error causes DistributorRewards to not have enough BABL.\n    function _safeBABLTransfer(address _to, uint96 _amount) private onlyMiningActive {\n        uint256 bablBal = babltoken.balanceOf(address(this));\n        if (_amount > bablBal) {\n            SafeERC20.safeTransfer(babltoken, _to, bablBal);\n        } else {\n            SafeERC20.safeTransfer(babltoken, _to, _amount);\n        }\n    }\n\n    /**\n     * Gets the contributor power from one timestamp to the other\n     * @param _contributor Address if the contributor\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n\n    function _getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256) {\n        _require(_to >= IGarden(_garden).gardenInitializedAt() && _to >= _from, Errors.GET_CONTRIBUTOR_POWER);\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][address(_contributor)];\n        Checkpoints memory powerCheckpoints = checkpoints[address(_garden)][address(_contributor)];\n\n        if (contributor.initialDepositAt == 0 || contributor.initialDepositAt > _to) {\n            return 0;\n        } else {\n            if (_from <= IGarden(_garden).gardenInitializedAt()) {\n                // Avoid division by zero in case of _from parameter is not passed\n                _from = IGarden(_garden).gardenInitializedAt();\n            }\n            // Find closest point to _from and _to either contributor and garden checkpoints at their left\n\n            (powerCheckpoints.fromDepositAt, powerCheckpoints.lastDepositAt) = _locateCheckpointsContributor(\n                _garden,\n                _contributor,\n                _from,\n                _to\n            );\n            (powerCheckpoints.gardenFromDepositAt, powerCheckpoints.gardenLastDepositAt) = _locateCheckpointsGarden(\n                _garden,\n                _from,\n                _to\n            );\n\n            _require(\n                powerCheckpoints.fromDepositAt <= powerCheckpoints.lastDepositAt &&\n                    powerCheckpoints.gardenFromDepositAt <= powerCheckpoints.gardenLastDepositAt,\n                Errors.GET_CONTRIBUTOR_POWER\n            );\n            uint256 contributorPower;\n            uint256 gardenPower;\n\n            // \"FROM power calculations\" PART\n            // Avoid underflows\n\n            if (_from < powerCheckpoints.fromDepositAt) {\n                // Contributor still has no power but _from is later than the start of the garden\n                contributorPower = 0;\n            } else if (_from > powerCheckpoints.fromDepositAt) {\n                contributorPower = contributor.tsContributions[powerCheckpoints.fromDepositAt].power.add(\n                    (_from.sub(powerCheckpoints.fromDepositAt)).mul(\n                        contributor.tsContributions[powerCheckpoints.fromDepositAt].principal\n                    )\n                );\n            } else {\n                // _from == fromDepositAt\n                contributorPower = contributor.tsContributions[powerCheckpoints.fromDepositAt].power;\n            }\n            gardenPower = gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenFromDepositAt].power.add(\n                (_from.sub(powerCheckpoints.gardenFromDepositAt)).mul(\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenFromDepositAt].principal\n                )\n            );\n            // \"TO power calculations\" PART\n            // We go for accurate power calculations avoiding overflows\n            _require(contributorPower <= gardenPower, Errors.GET_CONTRIBUTOR_POWER);\n            if (_from == _to) {\n                // Requested a specific checkpoint calculation (no slot)\n                if (gardenPower == 0) {\n                    return 0;\n                } else {\n                    return contributorPower.preciseDiv(gardenPower);\n                }\n                // Not a checkpoint anymore but a slot\n            } else if (_to < powerCheckpoints.lastDepositAt) {\n                // contributor has not deposited yet\n                return 0;\n            } else if (\n                _to == powerCheckpoints.lastDepositAt &&\n                powerCheckpoints.fromDepositAt == powerCheckpoints.lastDepositAt\n            ) {\n                // no more contributor checkpoints in the slot\n                gardenPower = (\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.gardenLastDepositAt)).mul(\n                            gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].principal\n                        )\n                    )\n                )\n                    .sub(gardenPower);\n                _require(contributorPower <= gardenPower, Errors.GET_CONTRIBUTOR_POWER);\n                return contributorPower.preciseDiv(gardenPower);\n            } else {\n                contributorPower = (\n                    contributor.tsContributions[powerCheckpoints.lastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.lastDepositAt)).mul(\n                            contributor.tsContributions[powerCheckpoints.lastDepositAt].principal\n                        )\n                    )\n                )\n                    .sub(contributorPower);\n\n                gardenPower = (\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.gardenLastDepositAt)).mul(\n                            gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].principal\n                        )\n                    )\n                )\n                    .sub(gardenPower);\n                _require(contributorPower <= gardenPower, Errors.GET_CONTRIBUTOR_POWER);\n\n                return contributorPower.preciseDiv(gardenPower);\n            }\n        }\n    }\n\n    function _locateCheckpointsContributor(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256, uint256) {\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][address(_contributor)];\n\n        uint256 lastDepositAt = contributor.timeListPointer[contributor.timeListPointer.length.sub(1)]; // Initialized with lastDeposit\n        uint256 fromDepositAt = contributor.timeListPointer[0]; // Initialized with initialDeposit\n\n        if (lastDepositAt > _to || fromDepositAt < _from) {\n            // We go to find the closest deposits of the contributor to _from and _to\n            for (uint256 i = 0; i <= contributor.timeListPointer.length.sub(1); i++) {\n                if (contributor.timeListPointer[i] <= _to) {\n                    lastDepositAt = contributor.timeListPointer[i];\n                }\n                if (contributor.timeListPointer[i] <= _from) {\n                    fromDepositAt = contributor.timeListPointer[i];\n                }\n            }\n        }\n        return (fromDepositAt, lastDepositAt);\n    }\n\n    function _locateCheckpointsGarden(\n        address _garden,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256, uint256) {\n        uint256 gardenLastCheckpoint = gardenTimelist[address(_garden)].length.sub(1);\n        uint256 gardenLastDepositAt = gardenTimelist[address(_garden)][gardenLastCheckpoint]; // Initialized to the last garden checkpoint\n        uint256 gardenFromDepositAt = gardenTimelist[address(_garden)][0]; // Initialized to the first garden checkpoint\n\n        if (gardenLastDepositAt > _to || gardenFromDepositAt < _from) {\n            // We go for the closest timestamp of garden to _to and _from\n            for (uint256 i = 0; i <= gardenLastCheckpoint; i++) {\n                uint256 gardenTime = gardenTimelist[address(_garden)][i];\n                if (gardenTime <= _to) {\n                    gardenLastDepositAt = gardenTime;\n                }\n                if (gardenTime <= _from) {\n                    gardenFromDepositAt = gardenTime;\n                }\n            }\n        }\n        return (gardenFromDepositAt, gardenLastDepositAt);\n    }\n\n    /**\n     * Function that keeps checkpoints of the garden power (deposits and withdrawals) per timestamp\n     */\n    function _updateGardenPower(address _garden) private {\n        IGarden garden = IGarden(_garden);\n        GardenPowerByTimestamp storage gardenTimestamp = gardenPowerByTimestamp[address(garden)][block.timestamp];\n        gardenTimestamp.principal = IERC20(address(IGarden(_garden))).totalSupply();\n\n        gardenTimestamp.timestamp = block.timestamp;\n\n        if (gardenPid[address(_garden)] == 0) {\n            // The very first deposit of all contributors in the mining program\n            gardenTimestamp.power = 0;\n        } else {\n            // Any other deposit different from the very first one (will have an antecesor)\n            gardenTimestamp.power = gardenPowerByTimestamp[address(garden)][\n                gardenTimelist[address(garden)][gardenPid[address(garden)].sub(1)]\n            ]\n                .power\n                .add(\n                gardenTimestamp\n                    .timestamp\n                    .sub(\n                    gardenPowerByTimestamp[address(garden)][\n                        gardenTimelist[address(garden)][gardenPid[address(garden)].sub(1)]\n                    ]\n                        .timestamp\n                )\n                    .mul(\n                    gardenPowerByTimestamp[address(garden)][\n                        gardenTimelist[address(garden)][gardenPid[address(garden)].sub(1)]\n                    ]\n                        .principal\n                )\n            );\n        }\n\n        gardenTimelist[address(garden)].push(block.timestamp); // Register of deposit timestamps in the array for iteration\n        gardenPid[address(garden)]++;\n    }\n\n    /**\n     * Updates contributor timestamps params\n     */\n    function _setContributorTimestampParams(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw\n    ) private {\n        // We make checkpoints around contributor deposits to avoid fast loans and give the right rewards afterwards\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][_contributor];\n\n        contributor.tsContributions[block.timestamp].principal = IERC20(address(IGarden(_garden))).balanceOf(\n            address(_contributor)\n        );\n\n        contributor.tsContributions[block.timestamp].timestamp = block.timestamp;\n\n        contributor.tsContributions[block.timestamp].timePointer = contributor.pid;\n\n        if (contributor.pid == 0) {\n            // The very first deposit\n            contributor.tsContributions[block.timestamp].power = 0;\n        } else {\n            // Any other deposits or withdrawals different from the very first one (will have an antecesor)\n            contributor.tsContributions[block.timestamp].power = contributor.tsContributions[contributor.lastDepositAt]\n                .power\n                .add(\n                (block.timestamp.sub(contributor.lastDepositAt)).mul(\n                    contributor.tsContributions[contributor.lastDepositAt].principal\n                )\n            );\n        }\n        if (_depositOrWithdraw == true) {\n            // Deposit\n            if (_previousBalance == 0 || contributor.initialDepositAt == 0) {\n                contributor.initialDepositAt = block.timestamp;\n            }\n            contributor.lastDepositAt = block.timestamp;\n        } else {\n            // Withdrawals\n            if (IERC20(address(IGarden(_garden))).balanceOf(address(_contributor)) == 0) {\n                contributor.lastDepositAt = 0;\n                contributor.initialDepositAt = 0;\n                delete contributor.timeListPointer;\n            }\n        }\n\n        contributor.timeListPointer.push(block.timestamp);\n        contributor.pid++;\n    }\n\n    function _tokenSupplyPerQuarter(uint256 quarter) internal pure returns (uint96) {\n        _require(quarter >= 1, Errors.QUARTERS_MIN_1);\n        if (quarter >= 513) {\n            return 0;\n        } else {\n            uint256 firstFactor = (SafeDecimalMath.unit().add(DECAY_RATE)).powDecimal(quarter.sub(1));\n            uint256 supplyForQuarter = Q1_REWARDS.divideDecimal(firstFactor);\n            return Safe3296.safe96(supplyForQuarter, 'overflow 96 bits');\n        }\n    }\n\n    function _getQuarter(uint256 _now) internal view returns (uint256) {\n        uint256 quarter = (_now.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        return quarter.add(1);\n    }\n\n    function _getRewardsWindow(uint256 _from, uint256 _to) internal view returns (uint256, uint256) {\n        uint256 quarters = (_to.sub(_from).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        uint256 startingQuarter = (_from.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        return (quarters.add(1), startingQuarter.add(1));\n    }\n}\n"
    },
    "contracts/interfaces/IGarden.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IGarden\n * @author Babylon Finance\n *\n * Interface for operating with a Garden.\n */\ninterface IGarden {\n    /* ============ Functions ============ */\n    function makeGardenPublic() external;\n\n    function setActive(bool _val) external;\n\n    function active() external view returns (bool);\n\n    function guestListEnabled() external view returns (bool);\n\n    function controller() external view returns (address);\n\n    function nftAddress() external view returns (address);\n\n    function creator() external view returns (address);\n\n    function getContributor(address _contributor)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function reserveAsset() external view returns (address);\n\n    function totalContributors() external view returns (uint256);\n\n    function gardenInitializedAt() external view returns (uint256);\n\n    function minContribution() external view returns (uint256);\n\n    function maxContributors() external view returns (uint256);\n\n    function minLiquidityAsset() external view returns (uint256);\n\n    function principal() external view returns (uint256);\n\n    function reserveAssetRewardsSetAside() external view returns (uint256);\n\n    function reserveAssetPrincipalWindow() external view returns (uint256);\n\n    function absoluteReturns() external view returns (int256);\n\n    function totalStake() external view returns (uint256);\n\n    function minVotersQuorum() external view returns (uint256);\n\n    function minStrategyDuration() external view returns (uint256);\n\n    function maxStrategyDuration() external view returns (uint256);\n\n    function strategyCooldownPeriod() external view returns (uint256);\n\n    function getStrategies() external view returns (address[] memory);\n\n    function getFinalizedStrategies() external view returns (address[] memory);\n\n    function isStrategy(address _strategy) external view returns (bool);\n\n    function startWithdrawalWindow(\n        uint256 _amount,\n        uint256 _profits,\n        int256 _returns,\n        address _strategy\n    ) external;\n\n    function allocateCapitalToStrategy(uint256 _capital) external;\n\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external;\n\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to\n    ) external payable;\n\n    function withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    ) external;\n\n    function claimReturns(address[] calldata _finalizedStrategies) external;\n\n    function getGardenTokenMintQuantity(uint256 _netReserveFlows, bool isDeposit) external view returns (uint256);\n\n    function getExpectedReserveWithdrawalQuantity(uint256 _gardenTokenQuantity) external view returns (uint256);\n\n    function getLockedBalance(address _contributor) external view returns (uint256);\n\n    function reenableEthForStrategies() external;\n\n    function rebalanceStrategies(uint256 _fee) external;\n\n    function expireCandidateStrategy(address _strategy) external;\n\n    function burnStrategistStake(address _strategist, uint256 _amount) external;\n\n    function payKeeper(address payable _keeper, uint256 _fee) external;\n}\n"
    },
    "contracts/interfaces/IGardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IGardenFactory\n * @author Babylon Finance\n *\n * Interface for the garden factory\n */\ninterface IGardenFactory {\n    function createGarden(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams\n    ) external payable returns (address);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title IStrategy\n * @author Babylon Finance\n *\n * Interface for strategy\n */\ninterface IStrategy {\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _minRebalanceCapital,\n        address _strategyNft\n    ) external;\n\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 _absoluteTotalVotes,\n        int256 _totalVotes,\n        uint256 fee\n    ) external;\n\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external;\n\n    function executeStrategy(uint256 _capital, uint256 fee) external;\n\n    function getNAV() external view returns (uint256);\n\n    function opDatas(uint256 _index) external view returns (address);\n\n    function opIntegrations(uint256 _index) external view returns (address);\n\n    function opTypes(uint256 _index) external view returns (uint8);\n\n    function getOperationsCount() external view returns (uint256);\n\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        returns (\n            uint8,\n            address,\n            address\n        );\n\n    function finalizeStrategy(uint256 fee, string memory _tokenURI) external;\n\n    function unwindStrategy(uint256 _amountToUnwind) external;\n\n    function changeStrategyDuration(uint256 _newDuration) external;\n\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory);\n\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external;\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external returns (uint256);\n\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external;\n\n    function getStrategyDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getStrategyState()\n        external\n        view\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function isStrategyActive() external view returns (bool);\n\n    function getUserVotes(address _address) external view returns (int256);\n\n    function strategist() external view returns (address);\n\n    function strategyNft() external view returns (address);\n\n    function enteredAt() external view returns (uint256);\n\n    function enteredCooldownAt() external view returns (uint256);\n\n    function executedAt() external view returns (uint256);\n\n    function updatedAt() external view returns (uint256);\n\n    function exitedAt() external view returns (uint256);\n\n    function stake() external view returns (uint256);\n\n    function strategyRewards() external view returns (uint256);\n\n    function rewardsTotalOverhead() external view returns (uint256);\n\n    function maxCapitalRequested() external view returns (uint256);\n\n    function expectedReturn() external view returns (uint256);\n\n    function minRebalanceCapital() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function totalVotes() external view returns (int256);\n\n    function absoluteTotalVotes() external view returns (uint256);\n\n    function totalPositiveVotes() external view returns (uint256);\n\n    function totalNegativeVotes() external view returns (uint256);\n\n    function capitalReturned() external view returns (uint256);\n\n    function capitalAllocated() external view returns (uint256);\n\n    function finalized() external view returns (bool);\n\n    function active() external view returns (bool);\n\n    function garden() external view returns (IGarden);\n}\n"
    },
    "contracts/interfaces/IIshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IIshtarGate {\n    /* ============ Functions ============ */\n\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external returns (uint256);\n\n    function setCreatorPermissions(address _user, bool _canCreate) external returns (uint256);\n\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external returns (bool);\n\n    function maxNumberOfInvites() external view returns (uint256);\n\n    function tokenURI() external view returns (string memory);\n\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external;\n\n    function updateGardenURI(string memory _tokenURI) external;\n\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms) external returns (bool);\n\n    function canCreate(address _user) external view returns (bool);\n\n    function canJoinAGarden(address _garden, address _user) external view returns (bool);\n\n    function canVoteInAGarden(address _garden, address _user) external view returns (bool);\n\n    function canAddStrategiesInAGarden(address _garden, address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIntegration\n * @author Babylon Finance\n *\n * Interface for protocol integrations\n */\ninterface IIntegration {\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBabController\n * @author Babylon Finance\n *\n * Interface for interacting with BabController\n */\ninterface IBabController {\n    /* ============ Functions ============ */\n\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams\n    ) external payable returns (address);\n\n    function removeGarden(address _garden) external;\n\n    function addReserveAsset(address _reserveAsset) external;\n\n    function removeReserveAsset(address _reserveAsset) external;\n\n    function disableGarden(address _garden) external;\n\n    function editPriceOracle(address _priceOracle) external;\n\n    function editIshtarGate(address _ishtarGate) external;\n\n    function editGardenValuer(address _gardenValuer) external;\n\n    function editRewardsDistributor(address _rewardsDistributor) external;\n\n    function editTreasury(address _newTreasury) external;\n\n    function editGardenFactory(address _newGardenFactory) external;\n\n    function editStrategyFactory(address _newStrategyFactory) external;\n\n    function addIntegration(string memory _name, address _integration) external;\n\n    function editIntegration(string memory _name, address _integration) external;\n\n    function removeIntegration(string memory _name) external;\n\n    function setOperation(uint8 _kind, address _operation) external;\n\n    function setDefaultTradeIntegration(address _newDefaultTradeIntegation) external;\n\n    function addKeeper(address _keeper) external;\n\n    function addKeepers(address[] memory _keepers) external;\n\n    function removeKeeper(address _keeper) external;\n\n    function enableGardenTokensTransfers() external;\n\n    function enableBABLMiningProgram() external;\n\n    function setAllowPublicGardens() external;\n\n    function editLiquidityMinimum(uint256 _minRiskyPairLiquidityEth) external;\n\n    function owner() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    function gardenValuer() external view returns (address);\n\n    function rewardsDistributor() external view returns (address);\n\n    function gardenFactory() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function ishtarGate() external view returns (address);\n\n    function strategyFactory() external view returns (address);\n\n    function defaultTradeIntegration() external view returns (address);\n\n    function protocolDepositGardenTokenFee() external view returns (uint256);\n\n    function protocolWithdrawalGardenTokenFee() external view returns (uint256);\n\n    function gardenTokensTransfersEnabled() external view returns (bool);\n\n    function bablMiningProgramEnabled() external view returns (bool);\n\n    function allowPublicGardens() external view returns (bool);\n\n    function enabledOperations(uint256 _kind) external view returns (address);\n\n    function getProfitSharing()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getBABLSharing()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getGardens() external view returns (address[] memory);\n\n    function getOperations() external view returns (address[20] memory);\n\n    function isGarden(address _garden) external view returns (bool);\n\n    function getIntegrationByName(string memory _name) external view returns (address);\n\n    function getIntegrationWithHash(bytes32 _nameHashP) external view returns (address);\n\n    function isValidReserveAsset(address _reserveAsset) external view returns (bool);\n\n    function isValidKeeper(address _keeper) external view returns (bool);\n\n    function isSystemContract(address _contractAddress) external view returns (bool);\n\n    function isValidIntegration(string memory _name, address _integration) external view returns (bool);\n\n    function getMinCooldownPeriod() external view returns (uint256);\n\n    function getMaxCooldownPeriod() external view returns (uint256);\n\n    function protocolPerformanceFee() external view returns (uint256);\n\n    function protocolManagementFee() external view returns (uint256);\n\n    function minRiskyPairLiquidityEth() external view returns (uint256);\n\n    function getUniswapFactory() external view returns (address);\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n */\nlibrary AddressArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Returns true if there are 2 elements that are the same in an array\n     * @param A The input array to search\n     * @return Returns boolean for the first occurrence of a duplicate\n     */\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n        require(A.length > 0, 'A is empty');\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a) internal pure returns (address[] memory) {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert('Address not in array.');\n        } else {\n            (address[] memory _A, ) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * Removes specified index from array\n     * @param A The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory A, uint256 index) internal pure returns (address[] memory, address) {\n        uint256 length = A.length;\n        require(index < A.length, 'Index must be < A length');\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n\n    /**\n     * Returns the combination of the two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        address[] memory newAddresses = new address[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = 0; j < bLength; j++) {\n            newAddresses[aLength + j] = B[j];\n        }\n        return newAddresses;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/token/TimeLockedToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {RewardsDistributor} from './RewardsDistributor.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {VoteToken} from './VoteToken.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title TimeLockedToken\n * @notice Time Locked ERC20 Token\n * @author Babylon Finance\n * @dev Contract which gives the ability to time-lock tokens specially for vesting purposes usage\n *\n * By overriding the balanceOf() and transfer() functions in ERC20,\n * an account can show its full, post-distribution balance and use it for voting power\n * but only transfer or spend up to an allowed amount\n *\n * A portion of previously non-spendable tokens are allowed to be transferred\n * along the time depending on each vesting conditions, and after all epochs have passed, the full\n * account balance is unlocked. In case on non-completion vesting period, only the Time Lock Registry can cancel\n * the delivery of the pending tokens and only can cancel the remaining locked ones.\n */\n\nabstract contract TimeLockedToken is VoteToken {\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new lockout ocurr\n    event NewLockout(\n        address account,\n        uint256 tokenslocked,\n        bool isTeamOrAdvisor,\n        uint256 startingVesting,\n        uint256 endingVesting\n    );\n\n    /// @notice An event that emitted when a new Time Lock is registered\n    event NewTimeLockRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a new Rewards Distributor is registered\n    event NewRewardsDistributorRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a cancellation of Lock tokens is registered\n    event Cancel(address account, uint256 amount);\n\n    /// @notice An event that emitted when a claim of tokens are registered\n    event Claim(address _receiver, uint256 amount);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyTimeLockRegistry() {\n        require(\n            msg.sender == address(timeLockRegistry),\n            'TimeLockedToken:: onlyTimeLockRegistry: can only be executed by TimeLockRegistry'\n        );\n        _;\n    }\n\n    modifier onlyTimeLockOwner() {\n        if (address(timeLockRegistry) != address(0)) {\n            require(\n                msg.sender == Ownable(timeLockRegistry).owner(),\n                'TimeLockedToken:: onlyTimeLockOwner: can only be executed by the owner of TimeLockRegistry'\n            );\n        }\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // represents total distribution for locked balances\n    mapping(address => uint256) distribution;\n\n    /// @notice The profile of each token owner under its particular vesting conditions\n    /**\n     * @param team Indicates whether or not is a Team member or Advisor (true = team member/advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct VestedToken {\n        bool teamOrAdvisor;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => VestedToken) public vestedToken;\n\n    // vesting Cliff for Team Members and Advisors\n    uint256 private vestingCliff = 365 days;\n\n    // vesting duration for Team Members and Advisors\n    uint256 private teamVesting = 365 days * 4;\n\n    // vesting duration for Investors\n    uint256 private investorVesting = 365 days * 3;\n\n    // address of Time Lock Registry contract\n    IBabController public controller;\n\n    // address of Time Lock Registry contract\n    TimeLockRegistry public timeLockRegistry;\n\n    // address of Rewards Distriburor contract\n    RewardsDistributor public rewardsDistributor;\n\n    // Enable Transfer of ERC20 BABL Tokens\n    // Only Minting or transfers from/to TimeLockRegistry and Rewards Distributor can transfer tokens until the protocol is fully decentralized\n    bool private tokenTransfersEnabled;\n    bool private tokenTransfersWereDisabled;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) VoteToken(_name, _symbol) {\n        tokenTransfersEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disables transfers of ERC20 BABL Tokens\n     */\n    function disableTokensTransfers() external onlyOwner {\n        require(!tokenTransfersWereDisabled, 'BABL must flow');\n        tokenTransfersEnabled = false;\n        tokenTransfersWereDisabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 BABL Tokens\n     * Can only happen after the protocol is fully decentralized.\n     */\n    function enableTokensTransfers() external onlyOwner {\n        tokenTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Time Lock Registry contract to control token vesting conditions\n     *\n     * @notice Set the Time Lock Registry contract to control token vesting conditions\n     * @param newTimeLockRegistry Address of TimeLockRegistry contract\n     */\n    function setTimeLockRegistry(TimeLockRegistry newTimeLockRegistry) external onlyTimeLockOwner returns (bool) {\n        require(address(newTimeLockRegistry) != address(0), 'cannot be zero address');\n        require(address(newTimeLockRegistry) != address(this), 'cannot be this contract');\n        require(address(newTimeLockRegistry) != address(timeLockRegistry), 'must be new TimeLockRegistry');\n        emit NewTimeLockRegistration(address(timeLockRegistry), address(newTimeLockRegistry));\n\n        timeLockRegistry = newTimeLockRegistry;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Rewards Distributor contract to control either BABL Mining or profit rewards\n     *\n     * @notice Set the Rewards Distriburor contract to control both types of rewards (profit and BABL Mining program)\n     * @param newRewardsDistributor Address of Rewards Distributor contract\n     */\n    function setRewardsDistributor(RewardsDistributor newRewardsDistributor) external onlyOwner returns (bool) {\n        require(address(newRewardsDistributor) != address(0), 'cannot be zero address');\n        require(address(newRewardsDistributor) != address(this), 'cannot be this contract');\n        require(address(newRewardsDistributor) != address(rewardsDistributor), 'must be new Rewards Distributor');\n        emit NewRewardsDistributorRegistration(address(rewardsDistributor), address(newRewardsDistributor));\n\n        rewardsDistributor = newRewardsDistributor;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Register new token lockup conditions for vested tokens defined only by Time Lock Registry\n     *\n     * @notice Tokens are completely delivered during the registration however lockup conditions apply for vested tokens\n     * locking them according to the distribution epoch periods and the type of recipient (Team, Advisor, Investor)\n     * Emits a transfer event showing a transfer to the recipient\n     * Only the registry can call this function\n     * @param _receiver Address to receive the tokens\n     * @param _amount Tokens to be transferred\n     * @param _profile True if is a Team Member or Advisor\n     * @param _vestingBegin Unix Time when the vesting for that particular address\n     * @param _vestingEnd Unix Time when the vesting for that particular address\n     * @param _lastClaim Unix Time when the claim was done from that particular address\n     *\n     */\n    function registerLockup(\n        address _receiver,\n        uint256 _amount,\n        bool _profile,\n        uint256 _vestingBegin,\n        uint256 _vestingEnd,\n        uint256 _lastClaim\n    ) external onlyTimeLockRegistry returns (bool) {\n        require(balanceOf(msg.sender) >= _amount, 'insufficient balance');\n        require(_receiver != address(0), 'cannot be zero address');\n        require(_receiver != address(this), 'cannot be this contract');\n        require(_receiver != address(timeLockRegistry), 'cannot be the TimeLockRegistry contract itself');\n        require(_receiver != msg.sender, 'the owner cannot lockup itself');\n\n        // update amount of locked distribution\n        distribution[_receiver] = distribution[_receiver].add(_amount);\n\n        VestedToken storage newVestedToken = vestedToken[_receiver];\n\n        newVestedToken.teamOrAdvisor = _profile;\n        newVestedToken.vestingBegin = _vestingBegin;\n        newVestedToken.vestingEnd = _vestingEnd;\n        newVestedToken.lastClaim = _lastClaim;\n\n        // transfer tokens to the recipient\n        _transfer(msg.sender, _receiver, _amount);\n        emit NewLockout(_receiver, _amount, _profile, _vestingBegin, _vestingEnd);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors as it does not apply to investors.\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function cancelVestedTokens(address lockedAccount) external onlyTimeLockRegistry returns (uint256) {\n        return _cancelVestedTokensFromTimeLock(lockedAccount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Each token owner can claim its own specific tokens with its own specific vesting conditions from the Time Lock Registry\n     *\n     * @dev Claim msg.sender tokens (if any available in the registry)\n     */\n    function claimMyTokens() external {\n        // claim msg.sender tokens from timeLockRegistry\n        uint256 amount = timeLockRegistry.claim(msg.sender);\n        // After a proper claim, locked tokens of Team and Advisors profiles are under restricted special vesting conditions so they automatic grant\n        // rights to the Time Lock Registry to only retire locked tokens if non-compliance vesting conditions take places along the vesting periods.\n        // It does not apply to Investors under vesting (their locked tokens cannot be removed).\n        if (vestedToken[msg.sender].teamOrAdvisor == true) {\n            approve(address(timeLockRegistry), amount);\n        }\n        // emit claim event\n        emit Claim(msg.sender, amount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get unlocked balance for an account\n     *\n     * @notice Get unlocked balance for an account\n     * @param account Account to check\n     * @return Amount that is unlocked and available eg. to transfer\n     */\n    function unlockedBalance(address account) public returns (uint256) {\n        // totalBalance - lockedBalance\n        return balanceOf(account).sub(lockedBalance(account));\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. View the locked balance for an account\n     *\n     * @notice View locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n\n    function viewLockedBalance(address account) public view returns (uint256) {\n        // distribution of locked tokens\n        // get amount from distributions\n\n        uint256 amount = distribution[account];\n        uint256 lockedAmount = amount;\n\n        // Team and investors cannot transfer tokens in the first year\n        if (vestedToken[account].vestingBegin.add(365 days) > block.timestamp) {\n            return lockedAmount;\n        }\n\n        // in case of vesting has passed, all tokens are now available\n        if (block.timestamp >= vestedToken[account].vestingEnd) {\n            lockedAmount = 0;\n        } else {\n            // in case of still under vesting period, locked tokens are recalculated\n            lockedAmount = amount.mul(vestedToken[account].vestingEnd - block.timestamp).div(\n                vestedToken[account].vestingEnd - vestedToken[account].vestingBegin\n            );\n        }\n        return lockedAmount;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get locked balance for an account\n     *\n     * @notice Get locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n    function lockedBalance(address account) public returns (uint256) {\n        // get amount from distributions locked tokens (if any)\n\n        uint256 lockedAmount = viewLockedBalance(account);\n\n        // in case of vesting has passed, all tokens are now available so we set mapping to 0\n        if (block.timestamp >= vestedToken[account].vestingEnd && msg.sender == account && lockedAmount == 0) {\n            delete distribution[account];\n        } else if (msg.sender == account) {\n            vestedToken[msg.sender].lastClaim = block.timestamp;\n        }\n        return lockedAmount;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the address of Time Lock Registry\n     *\n     * @notice Get the address of Time Lock Registry\n     * @return Address of the Time Lock Registry\n     */\n    function getTimeLockRegistry() external view returns (address) {\n        return address(timeLockRegistry);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Approval of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Override of \"Approve\" function to allow the `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender` except in the case of spender is Time Lock Registry\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::approve: spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::approve: spender cannot be the msg.sender');\n\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, 'TimeLockedToken::approve: amount exceeds 96 bits');\n        }\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        if ((spender == address(timeLockRegistry)) && (amount < allowance(msg.sender, address(timeLockRegistry)))) {\n            amount = safe96(\n                allowance(msg.sender, address(timeLockRegistry)),\n                'TimeLockedToken::approve: cannot decrease allowance to timelockregistry'\n            );\n        }\n        _approve(msg.sender, spender, amount);\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Increase of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an override with respect to the fulfillment of vesting conditions along the way\n     * However an user can increase allowance many times, it will never be able to transfer locked tokens during vesting period\n     * @return Whether or not the increaseAllowance succeeded\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public override nonReentrant returns (bool) {\n        require(\n            unlockedBalance(msg.sender) >= addedValue,\n            'TimeLockedToken::increaseAllowance:Not enough unlocked tokens'\n        );\n        require(spender != address(0), 'TimeLockedToken::increaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::increaseAllowance:Spender cannot be the msg.sender');\n        _approve(msg.sender, spender, allowance(msg.sender, spender).add(addedValue));\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the decrease of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically decrease the allowance granted to `spender` by the caller.\n     *\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an override with respect to the fulfillment of vesting conditions along the way\n     * An user cannot decrease the allowance to the Time Lock Registry who is in charge of vesting conditions\n     * @return Whether or not the decreaseAllowance succeeded\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::decreaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::decreaseAllowance:Spender cannot be the msg.sender');\n        require(\n            allowance(msg.sender, spender) >= subtractedValue,\n            'TimeLockedToken::decreaseAllowance:Underflow condition'\n        );\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        require(\n            address(spender) != address(timeLockRegistry),\n            'TimeLockedToken::decreaseAllowance:cannot decrease allowance to timeLockRegistry'\n        );\n\n        _approve(\n            msg.sender,\n            spender,\n            allowance(msg.sender, spender).sub(subtractedValue, 'ERC20: decreased allowance below zero')\n        );\n        return true;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the _transfer of ERC20 BABL tokens only allowing the transfer of unlocked tokens\n     *\n     * @dev Transfer function which includes only unlocked tokens\n     * Locked tokens can always be transfered back to the returns address\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal override {\n        require(_from != address(0), 'TimeLockedToken:: _transfer: cannot transfer from the zero address');\n        require(_to != address(0), 'TimeLockedToken:: _transfer: cannot transfer to the zero address');\n        require(\n            _to != address(this),\n            'TimeLockedToken:: _transfer: do not transfer tokens to the token contract itself'\n        );\n\n        require(balanceOf(_from) >= _value, 'TimeLockedToken:: _transfer: insufficient balance');\n\n        // check if enough unlocked balance to transfer\n        require(unlockedBalance(_from) >= _value, 'TimeLockedToken:: _transfer: attempting to transfer locked funds');\n        super._transfer(_from, _to, _value);\n        // voting power\n        _moveDelegates(\n            delegates[_from],\n            delegates[_to],\n            safe96(_value, 'TimeLockedToken:: _transfer: uint96 overflow')\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disable BABL token transfer until certain conditions are met\n     *\n     * @dev Override the _beforeTokenTransfer of ERC20 BABL tokens until certain conditions are met:\n     * Only allowing minting or transfers from Time Lock Registry and Rewards Distributor until transfers are allowed in the controller\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _value);\n        _require(\n            _from == address(0) ||\n                _from == address(timeLockRegistry) ||\n                _from == address(rewardsDistributor) ||\n                _to == address(timeLockRegistry) ||\n                tokenTransfersEnabled,\n            Errors.BABL_TRANSFERS_DISABLED\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of  vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function _cancelVestedTokensFromTimeLock(address lockedAccount) internal onlyTimeLockRegistry returns (uint256) {\n        require(distribution[lockedAccount] != 0, 'TimeLockedToken::cancelTokens:Not registered');\n\n        // get an update on locked amount from distributions at this precise moment\n        uint256 loosingAmount = lockedBalance(lockedAccount);\n\n        require(loosingAmount > 0, 'TimeLockedToken::cancelTokens:There are no more locked tokens');\n        require(\n            vestedToken[lockedAccount].teamOrAdvisor == true,\n            'TimeLockedToken::cancelTokens:cannot cancel locked tokens to Investors'\n        );\n\n        // set distribution mapping to 0\n        delete distribution[lockedAccount];\n\n        // set tokenVested mapping to 0\n        delete vestedToken[lockedAccount];\n\n        // transfer only locked tokens back to TimeLockRegistry Owner (msg.sender)\n        require(\n            transferFrom(lockedAccount, address(timeLockRegistry), loosingAmount),\n            'TimeLockedToken::cancelTokens:Transfer failed'\n        );\n\n        // emit cancel event\n        emit Cancel(lockedAccount, loosingAmount);\n\n        return loosingAmount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nlibrary SafeDecimalMath {\n    using SafeMath for uint256;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint256 public constant UNIT = 10**uint256(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\n    uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint256(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint256) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\n        uint256 quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n"
    },
    "contracts/lib/PreciseUnitMath.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\n/**\n * @title PreciseUnitMath\n * @author Set Protocol\n *\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n * dYdX's BaseMath library.\n *\n * CHANGELOG:\n * - 9/21/20: Added safePower function\n */\nlibrary PreciseUnitMath {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // The number One in precise units.\n    uint256 internal constant PRECISE_UNIT = 10**18;\n    int256 internal constant PRECISE_UNIT_INT = 10**18;\n\n    // Max unsigned integer value\n    uint256 internal constant MAX_UINT_256 = type(uint256).max;\n    // Max and min signed integer value\n    int256 internal constant MAX_INT_256 = type(int256).max;\n    int256 internal constant MIN_INT_256 = type(int256).min;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnitInt() internal pure returns (int256) {\n        return PRECISE_UNIT_INT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxUint256() internal pure returns (uint256) {\n        return MAX_UINT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxInt256() internal pure returns (int256) {\n        return MAX_INT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function minInt256() internal pure returns (int256) {\n        return MIN_INT_256;\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n     * significand of a number with 18 decimals precision.\n     */\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(b).div(PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down).\n     */\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISE_UNIT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded towards 0).\n     */\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(PRECISE_UNIT_INT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0).\n     */\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, 'Cant divide by 0');\n\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n     */\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'Cant divide by 0');\n        require(a != MIN_INT_256 || b != -1, 'Invalid input');\n\n        int256 result = a.div(b);\n        if (a ^ b < 0 && a % b != 0) {\n            result -= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Multiplies value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Divides value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\n    }\n\n    /**\n     * @dev Performs the power on a specified value, reverts on overflow.\n     */\n    function safePower(uint256 a, uint256 pow) internal pure returns (uint256) {\n        require(a > 0, 'Value must be positive');\n\n        uint256 result = 1;\n        for (uint256 i = 0; i < pow; i++) {\n            uint256 previousResult = result;\n\n            // Using safemath multiplication prevents overflows\n            result = previousResult.mul(a);\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/lib/Math.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// Libraries\nimport './SafeDecimalMath.sol';\n\n// https://docs.synthetix.io/contracts/source/libraries/math\nlibrary Math {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /**\n     * @dev Uses \"exponentiation by squaring\" algorithm where cost is 0(logN)\n     * vs 0(N) for naive repeated multiplication.\n     * Calculates x^n with x as fixed-point and n as regular unsigned int.\n     * Calculates to 18 digits of precision with SafeDecimalMath.unit()\n     */\n    function powDecimal(uint256 x, uint256 n) internal pure returns (uint256) {\n        // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n\n        uint256 result = SafeDecimalMath.unit();\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = result.multiplyDecimal(x);\n            }\n            x = x.multiplyDecimal(x);\n            n /= 2;\n        }\n        return result;\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n}\n"
    },
    "contracts/lib/Safe3296.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nlibrary Safe3296 {\n    using SafeMath for uint256;\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"
    },
    "contracts/lib/BabylonErrors.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// solhint-disable\n\n/**\n * @notice Forked from https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/lib/helpers/BalancerErrors.sol\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAB#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAB#\" part is a known constant\n        // (0x42414223): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414223000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Max deposit limit needs to be under the limit\n    uint256 internal constant MAX_DEPOSIT_LIMIT = 0;\n    // Creator needs to deposit\n    uint256 internal constant MIN_CONTRIBUTION = 1;\n    // Min Garden token supply >= 0\n    uint256 internal constant MIN_TOKEN_SUPPLY = 2;\n    // Deposit hardlock needs to be at least 1 block\n    uint256 internal constant DEPOSIT_HARDLOCK = 3;\n    // Needs to be at least the minimum\n    uint256 internal constant MIN_LIQUIDITY = 4;\n    // _reserveAssetQuantity is not equal to msg.value\n    uint256 internal constant MSG_VALUE_DO_NOT_MATCH = 5;\n    // Withdrawal amount has to be equal or less than msg.sender balance\n    uint256 internal constant MSG_SENDER_TOKENS_DO_NOT_MATCH = 6;\n    // Tokens are staked\n    uint256 internal constant TOKENS_STAKED = 7;\n    // Balance too low\n    uint256 internal constant BALANCE_TOO_LOW = 8;\n    // msg.sender doesn't have enough tokens\n    uint256 internal constant MSG_SENDER_TOKENS_TOO_LOW = 9;\n    //  There is an open redemption window already\n    uint256 internal constant REDEMPTION_OPENED_ALREADY = 10;\n    // Cannot request twice in the same window\n    uint256 internal constant ALREADY_REQUESTED = 11;\n    // Rewards and profits already claimed\n    uint256 internal constant ALREADY_CLAIMED = 12;\n    // Value have to be greater than zero\n    uint256 internal constant GREATER_THAN_ZERO = 13;\n    // Must be reserve asset\n    uint256 internal constant MUST_BE_RESERVE_ASSET = 14;\n    // Only contributors allowed\n    uint256 internal constant ONLY_CONTRIBUTOR = 15;\n    // Only controller allowed\n    uint256 internal constant ONLY_CONTROLLER = 16;\n    // Only creator allowed\n    uint256 internal constant ONLY_CREATOR = 17;\n    // Only keeper allowed\n    uint256 internal constant ONLY_KEEPER = 18;\n    // Fee is too high\n    uint256 internal constant FEE_TOO_HIGH = 19;\n    // Only strategy allowed\n    uint256 internal constant ONLY_STRATEGY = 20;\n    // Only active allowed\n    uint256 internal constant ONLY_ACTIVE = 21;\n    // Only inactive allowed\n    uint256 internal constant ONLY_INACTIVE = 22;\n    // Address should be not zero address\n    uint256 internal constant ADDRESS_IS_ZERO = 23;\n    // Not within range\n    uint256 internal constant NOT_IN_RANGE = 24;\n    // Value is too low\n    uint256 internal constant VALUE_TOO_LOW = 25;\n    // Value is too high\n    uint256 internal constant VALUE_TOO_HIGH = 26;\n    // Only strategy or protocol allowed\n    uint256 internal constant ONLY_STRATEGY_OR_CONTROLLER = 27;\n    // Normal withdraw possible\n    uint256 internal constant NORMAL_WITHDRAWAL_POSSIBLE = 28;\n    // User does not have permissions to join garden\n    uint256 internal constant USER_CANNOT_JOIN = 29;\n    // User does not have permissions to add strategies in garden\n    uint256 internal constant USER_CANNOT_ADD_STRATEGIES = 30;\n    // Only Protocol or garden\n    uint256 internal constant ONLY_PROTOCOL_OR_GARDEN = 31;\n    // Only Strategist\n    uint256 internal constant ONLY_STRATEGIST = 32;\n    // Only Integration\n    uint256 internal constant ONLY_INTEGRATION = 33;\n    // Only garden and data not set\n    uint256 internal constant ONLY_GARDEN_AND_DATA_NOT_SET = 34;\n    // Only active garden\n    uint256 internal constant ONLY_ACTIVE_GARDEN = 35;\n    // Contract is not a garden\n    uint256 internal constant NOT_A_GARDEN = 36;\n    // Not enough tokens\n    uint256 internal constant STRATEGIST_TOKENS_TOO_LOW = 37;\n    // Stake is too low\n    uint256 internal constant STAKE_HAS_TO_AT_LEAST_ONE = 38;\n    // Duration must be in range\n    uint256 internal constant DURATION_MUST_BE_IN_RANGE = 39;\n    // Max Capital Requested\n    uint256 internal constant MAX_CAPITAL_REQUESTED = 41;\n    // Votes are already resolved\n    uint256 internal constant VOTES_ALREADY_RESOLVED = 42;\n    // Voting window is closed\n    uint256 internal constant VOTING_WINDOW_IS_OVER = 43;\n    // Strategy needs to be active\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_ACTIVE = 44;\n    // Max capital reached\n    uint256 internal constant MAX_CAPITAL_REACHED = 45;\n    // Capital is less then rebalance\n    uint256 internal constant CAPITAL_IS_LESS_THAN_REBALANCE = 46;\n    // Strategy is in cooldown period\n    uint256 internal constant STRATEGY_IN_COOLDOWN = 47;\n    // Strategy is not executed\n    uint256 internal constant STRATEGY_IS_NOT_EXECUTED = 48;\n    // Strategy is not over yet\n    uint256 internal constant STRATEGY_IS_NOT_OVER_YET = 49;\n    // Strategy is already finalized\n    uint256 internal constant STRATEGY_IS_ALREADY_FINALIZED = 50;\n    // No capital to unwind\n    uint256 internal constant STRATEGY_NO_CAPITAL_TO_UNWIND = 51;\n    // Strategy needs to be inactive\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_INACTIVE = 52;\n    // Duration needs to be less\n    uint256 internal constant DURATION_NEEDS_TO_BE_LESS = 53;\n    // Can't sweep reserve asset\n    uint256 internal constant CANNOT_SWEEP_RESERVE_ASSET = 54;\n    // Voting window is opened\n    uint256 internal constant VOTING_WINDOW_IS_OPENED = 55;\n    // Strategy is executed\n    uint256 internal constant STRATEGY_IS_EXECUTED = 56;\n    // Min Rebalance Capital\n    uint256 internal constant MIN_REBALANCE_CAPITAL = 57;\n    // Not a valid strategy NFT\n    uint256 internal constant NOT_STRATEGY_NFT = 58;\n    // Garden Transfers Disabled\n    uint256 internal constant GARDEN_TRANSFERS_DISABLED = 59;\n    // Tokens are hardlocked\n    uint256 internal constant TOKENS_HARDLOCKED = 60;\n    // Max contributors reached\n    uint256 internal constant MAX_CONTRIBUTORS = 61;\n    // BABL Transfers Disabled\n    uint256 internal constant BABL_TRANSFERS_DISABLED = 62;\n    // Strategy duration range error\n    uint256 internal constant DURATION_RANGE = 63;\n    // Checks the min amount of voters\n    uint256 internal constant MIN_VOTERS_CHECK = 64;\n    // Ge contributor power error\n    uint256 internal constant GET_CONTRIBUTOR_POWER = 65;\n    // Not enough ETH set aside\n    uint256 internal constant NOT_ENOUGH_ETH = 66;\n    // Garden is already public\n    uint256 internal constant GARDEN_ALREADY_PUBLIC = 67;\n    // Withdrawal with penalty\n    uint256 internal constant WITHDRAWAL_WITH_PENALTY = 68;\n    // Withdrawal with penalty\n    uint256 internal constant ONLY_MINING_ACTIVE = 69;\n    // Overflow in supply\n    uint256 internal constant OVERFLOW_IN_SUPPLY = 70;\n    // Overflow in power\n    uint256 internal constant OVERFLOW_IN_POWER = 71;\n    // Not a system contract\n    uint256 internal constant NOT_A_SYSTEM_CONTRACT = 72;\n    // Strategy vs Garden mismatch\n    uint256 internal constant STRATEGY_GARDEN_MISMATCH = 73;\n    // Minimum quarters is 1\n    uint256 internal constant QUARTERS_MIN_1 = 74;\n    // Too many strategy operations\n    uint256 internal constant TOO_MANY_OPS = 75;\n    // Only operations\n    uint256 internal constant ONLY_OPERATION = 76;\n    // Strat params wrong length\n    uint256 internal constant STRAT_PARAMS_LENGTH = 77;\n    // Garden params wrong length\n    uint256 internal constant GARDEN_PARAMS_LENGTH = 78;\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title IRewardsDistributor\n * @author Babylon Finance\n *\n * Interface for the distribute rewards of the BABL Mining Program.\n */\n\ninterface IRewardsDistributor {\n    // Structs\n    struct PrincipalPerTimestamp {\n        uint256 principal;\n        uint256 time;\n        uint256 timeListPointer;\n    }\n\n    function protocolPrincipal() external view returns (uint256);\n\n    function pid() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function EPOCH_DURATION() external pure returns (uint256);\n\n    // solhint-disable-next-line\n    function START_TIME() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function Q1_REWARDS() external pure returns (uint256);\n\n    // solhint-disable-next-line\n    function DECAY_RATE() external pure returns (uint256);\n\n    function addProtocolPrincipal(uint256 _capital) external;\n\n    function substractProtocolPrincipal(uint256 _capital) external;\n\n    function getStrategyRewards(address _strategy) external returns (uint96);\n\n    function sendTokensToContributor(address _to, uint96 _amount) external;\n\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view returns (uint256, uint96);\n\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) external view returns (uint256);\n\n    /**\n    function getContributor(address _garden, address _contributor)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256[] memory,\n            uint256\n        );\n    */\n    function updateGardenPower(address _garden, uint256 _pid) external;\n\n    function setContributorTimestampParams(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw,\n        uint256 _pid\n    ) external;\n\n    function tokenSupplyPerQuarter(uint256 quarter) external view returns (uint96);\n\n    function checkProtocol(uint256 _time)\n        external\n        view\n        returns (\n            uint256 principal,\n            uint256 time,\n            uint256 quarterBelonging,\n            uint256 timeListPointer,\n            uint256 power\n        );\n\n    function checkQuarter(uint256 _num)\n        external\n        view\n        returns (\n            uint256 quarterPrincipal,\n            uint256 quarterNumber,\n            uint256 quarterPower,\n            uint96 supplyPerQuarter\n        );\n}\n"
    },
    "contracts/token/TimeLockRegistry.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {TimeLockedToken} from './TimeLockedToken.sol';\n\n/**\n * @title TimeLockRegistry\n * @notice Register Lockups for TimeLocked ERC20 Token BABL (e.g. vesting)\n * @author Babylon Finance\n * @dev This contract allows owner to register distributions for a TimeLockedToken\n *\n * To register a distribution, register method should be called by the owner.\n * claim() should be called only by the BABL Token smartcontract (modifier onlyBABLToken)\n *  when any account registered to receive tokens make its own claim\n * If case of a mistake, owner can cancel registration before the claim is done by the account\n *\n * Note this contract address must be setup in the TimeLockedToken's contract pointing\n * to interact with (e.g. setTimeLockRegistry() function)\n */\n\ncontract TimeLockRegistry is Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    event Register(address receiver, uint256 distribution);\n    event Cancel(address receiver, uint256 distribution);\n    event Claim(address account, uint256 distribution);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyBABLToken() {\n        require(msg.sender == address(token), 'only BABL Token');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // time locked token\n    TimeLockedToken public token;\n\n    /// @notice The profile of each token owner under vesting conditions and its special conditions\n    /**\n     * @param team Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct TokenVested {\n        bool team;\n        bool cliff;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => TokenVested) public tokenVested;\n\n    // mapping from token owners under vesting conditions to BABL due amount (e.g. SAFT addresses, team members, advisors)\n    mapping(address => uint256) public registeredDistributions;\n\n    // vesting for Team Members\n    uint256 private teamVesting = 365 days * 4;\n\n    // vesting for Investors and Advisors\n    uint256 private investorVesting = 365 days * 3;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new Time Lock Registry and gives ownership to sender\n     * @param _token TimeLockedToken contract to use in this registry\n     */\n    constructor(TimeLockedToken _token) {\n        token = _token;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Register new account under vesting conditions (Team, Advisors, Investors e.g. SAFT purchaser)\n     *\n     * @notice Register new account under vesting conditions (Team, Advisors, Investors e.g. SAFT purchaser)\n     * @param receiver Address belonging vesting conditions\n     * @param distribution Tokens amount that receiver is due to get\n     * @return Whether or not the registration succeeded\n     */\n    function register(\n        address receiver,\n        uint256 distribution,\n        bool investorType,\n        uint256 vestingStartingDate\n    ) external onlyOwner returns (bool) {\n        require(receiver != address(0), 'TimeLockRegistry::register: cannot register the zero address');\n        require(\n            receiver != address(this),\n            'TimeLockRegistry::register: Time Lock Registry contract cannot be an investor'\n        );\n        require(distribution != 0, 'TimeLockRegistry::register: Distribution = 0');\n        require(\n            registeredDistributions[receiver] == 0,\n            'TimeLockRegistry::register:Distribution for this address is already registered'\n        );\n        require(block.timestamp >= 1614553200, 'Cannot register earlier than March 2021'); // 1614553200 is UNIX TIME of 2021 March the 1st\n\n        // register distribution\n        registeredDistributions[receiver] = distribution;\n\n        // register token vested conditions\n        TokenVested storage newTokenVested = tokenVested[receiver];\n        newTokenVested.team = investorType;\n        newTokenVested.vestingBegin = vestingStartingDate;\n\n        if (newTokenVested.team == true) {\n            newTokenVested.vestingEnd = vestingStartingDate.add(teamVesting);\n        } else {\n            newTokenVested.vestingEnd = vestingStartingDate.add(investorVesting);\n        }\n        newTokenVested.lastClaim = vestingStartingDate;\n\n        tokenVested[receiver] = newTokenVested;\n        // TODO CHECK IF ALLOWANCE AS OF TODAY IS THE FINAL MODEL\n        // IN CASE OF A DIRECT MINT TO TIME LOCK REGISTRY ADDRESS THE TOKEN TRANSFER MIGHT BE UPDATED\n        // transfer tokens from owner who might have enough allowance of tokens by BABL Token owner\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), distribution);\n\n        // emit register event\n        emit Register(receiver, distribution);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel distribution registration\n     * @dev A claim has not to be done earlier\n     * @param receiver Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelRegistration(address receiver) external onlyOwner returns (bool) {\n        require(registeredDistributions[receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[receiver];\n\n        // set distribution mapping to 0\n        delete registeredDistributions[receiver];\n\n        // set tokenVested mapping to 0\n        delete tokenVested[receiver];\n\n        // TODO CHECK THE PROCESS ADDRESS(THIS) VS. OWNER\n        // transfer tokens back to owner\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n\n        // emit cancel event\n        emit Cancel(receiver, amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel already delivered tokens. It might only apply when non-completion of vesting period of Team members or Advisors\n     * @dev An automatic override allowance is granted during the claim process\n     * @param account Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelDeliveredTokens(address account) external onlyOwner returns (bool) {\n        uint256 loosingAmount = token.cancelVestedTokens(account);\n\n        // emit cancel event\n        emit Cancel(account, loosingAmount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Recover tokens in Time Lock Registry smartcontract address by the owner\n     *\n     * @notice Send tokens from smartcontract address to the owner.\n     * It might only apply after a cancellation of vested tokens\n     * @param amount Amount to be recovered by the owner of the Time Lock Registry smartcontract from its balance\n     * @return Whether or not it succeeded\n     */\n    function transferToOwner(uint256 amount) external onlyOwner returns (bool) {\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Claim locked tokens by the registered account\n     *\n     * @notice Claim tokens due amount.\n     * @dev Claim is done by the user in the TimeLocked contract and the contract is the only allowed to call\n     * this function on behalf of the user to make the claim\n     * @return The amount of tokens registered and delivered after the claim\n     */\n    function claim(address _receiver) external onlyBABLToken returns (uint256) {\n        require(registeredDistributions[_receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[_receiver];\n        tokenVested[_receiver].lastClaim = block.timestamp;\n\n        // set distribution mapping to 0\n        delete registeredDistributions[_receiver];\n\n        // register lockup in TimeLockedToken\n\n        // this will transfer funds from this contract and lock them for sender\n        token.registerLockup(\n            _receiver,\n            amount,\n            tokenVested[_receiver].team,\n            tokenVested[_receiver].vestingBegin,\n            tokenVested[_receiver].vestingEnd,\n            tokenVested[_receiver].lastClaim\n        );\n\n        // set tokenVested mapping to 0\n        delete tokenVested[_receiver];\n\n        // emit claim event\n        emit Claim(_receiver, amount);\n\n        return amount;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    function checkVesting(address address_)\n        external\n        view\n        returns (\n            bool team,\n            uint256 start,\n            uint256 end,\n            uint256 last\n        )\n    {\n        return (\n            tokenVested[address_].team,\n            tokenVested[address_].vestingBegin,\n            tokenVested[address_].vestingEnd,\n            tokenVested[address_].lastClaim\n        );\n    }\n\n    function checkRegisteredDistribution(address address_) external view returns (uint256 amount) {\n        return registeredDistributions[address_];\n    }\n}\n"
    },
    "contracts/token/VoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title VoteToken\n * @notice Custom token which tracks voting power for governance\n * @dev This is an abstraction of a fork of the Compound governance contract\n * VoteToken is used by BABL to allow tracking voting power\n * Checkpoints are created every time state is changed which record voting power\n * Inherits standard ERC20 behavior\n */\n\nabstract contract VoteToken is Context, ERC20, Ownable, IVoteToken, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegating votes from msg.sender to delegatee\n     *\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n\n    function delegate(address delegatee) external override {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegate votes using signature to 'delegatee'\n     *\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'VoteToken::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory] + 1, 'VoteToken::delegateBySig: invalid nonce');\n        nonces[signatory]++;\n        require(block.timestamp <= expiry, 'VoteToken::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Check Delegate votes using signature to 'delegatee'\n     *\n     * @notice Get current voting power for an account\n     * @param account Account to get voting power for\n     * @return Voting power for an account\n     */\n    function getCurrentVotes(address account) external view virtual override returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get voting power at a specific block for an account\n     *\n     * @param account Account to get voting power for\n     * @param blockNumber Block to get voting power at\n     * @return Voting power for an account at specific block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view virtual override returns (uint96) {\n        require(blockNumber < block.number, 'BABLToken::getPriorVotes: not yet determined');\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function getMyDelegatee() external view override returns (address) {\n        return delegates[msg.sender];\n    }\n\n    function getDelegatee(address account) external view override returns (address) {\n        return delegates[account];\n    }\n\n    function getCheckpoints(address account, uint32 id)\n        external\n        view\n        override\n        returns (uint32 fromBlock, uint96 votes)\n    {\n        Checkpoint storage getCheckpoint = checkpoints[account][id];\n        return (getCheckpoint.fromBlock, getCheckpoint.votes);\n    }\n\n    function getNumberOfCheckpoints(address account) external view override returns (uint32) {\n        return numCheckpoints[account];\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Make a delegation\n     *\n     * @dev Internal function to delegate voting power to an account\n     * @param delegator The address of the account delegating votes from\n     * @param delegatee The address to delegate votes to\n     */\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = safe96(_balanceOf(delegator), 'VoteToken::_delegate: uint96 overflow');\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _balanceOf(address account) internal view virtual returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Move the delegates\n     *\n     * @dev Internal function to move delegates between accounts\n     * @param srcRep The address of the account delegating votes from\n     * @param dstRep The address of the account delegating votes to\n     * @param amount The voting power to move\n     */\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            // It must not revert but do nothing in cases of address(0) being part of the move\n            // Sub voting amount to source in case it is not the zero address (e.g. transfers)\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'VoteToken::_moveDelegates: vote amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n            if (dstRep != address(0)) {\n                // Add it to destination in case it is not the zero address (e.g. any transfer of tokens or delegations except a first mint to a specific address)\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'VoteToken::_moveDelegates: vote amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Internal function to write a checkpoint for voting power\n     *\n     * @dev internal function to write a checkpoint for voting power\n     * @param delegatee The address of the account delegating votes to\n     * @param nCheckpoints The num checkpoint\n     * @param oldVotes The previous voting power\n     * @param newVotes The new voting power\n     */\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, 'VoteToken::_writeCheckpoint: block number exceeds 32 bits');\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/IVoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IVoteToken {\n    function delegate(address delegatee) external;\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function getMyDelegatee() external view returns (address);\n\n    function getDelegatee(address account) external view returns (address);\n\n    function getCheckpoints(address account, uint32 id) external view returns (uint32 fromBlock, uint96 votes);\n\n    function getNumberOfCheckpoints(address account) external view returns (uint32);\n}\n\ninterface IVoteTokenWithERC20 is IVoteToken, IERC20 {}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {ITradeIntegration} from '../interfaces/ITradeIntegration.sol';\nimport {IOperation} from '../interfaces/IOperation.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\n\n/**\n * @title Strategy\n * @author Babylon Finance\n *\n * Base Strategy contract. Belongs to a garden. Abstract.\n * Will be extended from specific strategy contracts.\n */\ncontract Strategy is ReentrancyGuard, IStrategy, Initializable {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for int256;\n    using SafeDecimalMath for uint256;\n    using Math for int256;\n    using Math for uint256;\n    using AddressArrayUtils for address[];\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event Invoked(address indexed _target, uint256 indexed _value, bytes _data, bytes _returnValue);\n    event StrategyVoted(address indexed _garden, uint256 _absoluteVotes, int256 _totalVotes, uint256 _timestamp);\n    event StrategyExecuted(address indexed _garden, uint256 _capital, uint256 _fee, uint256 timestamp);\n    event StrategyFinalized(address indexed _garden, uint256 _capitalReturned, uint256 _fee, uint256 timestamp);\n    event StrategyReduced(address indexed _garden, uint256 _amountReduced, uint256 timestamp);\n    event StrategyExpired(address indexed _garden, uint256 _timestamp);\n    event StrategyDeleted(address indexed _garden, uint256 _timestamp);\n    event StrategyDurationChanged(uint256 _newDuration, uint256 _oldDuration);\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the sender is not the creator of the strategy\n     */\n    modifier onlyGovernorOrGarden {\n        _require(msg.sender == address(garden) || msg.sender == controller.owner(), Errors.ONLY_PROTOCOL_OR_GARDEN);\n        _;\n    }\n\n    modifier onlyStrategist {\n        _require(msg.sender == strategist, Errors.ONLY_STRATEGIST);\n        _;\n    }\n\n    modifier onlyContributor {\n        _require(IERC20(address(garden)).balanceOf(msg.sender) > 0, Errors.ONLY_CONTRIBUTOR);\n        _;\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    modifier onlyIntegration() {\n        // Internal function used to reduce bytecode size\n        _require(\n            controller.isValidIntegration(IIntegration(msg.sender).getName(), msg.sender),\n            Errors.ONLY_INTEGRATION\n        );\n        _;\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    modifier onlyOperation() {\n        bool found = false;\n        for (uint8 i = 0; i < opTypes.length; i++) {\n            found = found || msg.sender == controller.enabledOperations(opTypes[i]);\n        }\n        // Internal function used to reduce bytecode size\n        _require(found, Errors.ONLY_OPERATION);\n        _;\n    }\n\n    /**\n     * Throws if the garden is not the caller or data is already set\n     */\n    modifier onlyGardenAndNotSet() {\n        _require(msg.sender == address(garden) && !dataSet, Errors.ONLY_GARDEN_AND_DATA_NOT_SET);\n        _;\n    }\n\n    /**\n     * Throws if the garden is not active\n     */\n    modifier onlyActiveGarden() {\n        _require(garden.active() == true, Errors.ONLY_ACTIVE_GARDEN);\n        _;\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     */\n    modifier onlyKeeper(uint256 _fee) {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n        // We assume that calling keeper functions should be less expensive than 1 million gas and the gas price should be lower than 1000 gwei.\n        _require(_fee <= MAX_KEEPER_FEE, Errors.FEE_TOO_HIGH);\n        _;\n    }\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    uint256 internal constant MAX_CANDIDATE_PERIOD = 7 days;\n    uint256 internal constant MIN_VOTERS_TO_BECOME_ACTIVE = 2;\n    uint256 internal constant ABSOLUTE_MIN_REBALANCE = 1e18;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Max Operations\n    uint256 internal constant MAX_OPERATIONS = 6;\n\n    // Keeper max fee\n    uint256 internal constant MAX_KEEPER_FEE = (1e6 * 1e3 gwei);\n\n    // Quadratic penalty for looses\n    uint256 internal constant STAKE_QUADRATIC_PENALTY_FOR_LOSSES = 175e16; // 1.75e18\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Babylon Controller Address\n    IBabController public controller;\n\n    // Type of operation.\n    // 0 = BuyOperation\n    // 1 = LiquidityOperation\n    // 2 = VaultOperation\n    // 3 = LendOperation\n\n    // Asset Status\n    // 0 = Liquid\n    // 1 = Put as collateral\n    // 2 = Borrowed\n    // 3 = staked\n\n    // Types and data for the operations of this strategy\n    uint8[] public override opTypes;\n    address[] public override opIntegrations;\n    address[] public override opDatas;\n\n    // Garden that these strategies belong to\n    IGarden public override garden;\n\n    address public override strategist; // Address of the strategist that submitted the bet\n    address public override strategyNft; // Address of the strategy nft\n\n    uint256 public override enteredAt; // Timestamp when the strategy was submitted\n    uint256 public override enteredCooldownAt; // Timestamp when the strategy reached quorum\n    uint256 public override executedAt; // Timestamp when the strategy was executed\n    uint256 public override updatedAt; // Timestamp of last capital allocation update\n    uint256 public override exitedAt; // Timestamp when the strategy was submitted\n\n    address[] public voters; // Addresses with the voters\n    int256 public override totalVotes; // Total votes staked\n    uint256 public override absoluteTotalVotes; // Absolute number of votes staked\n    uint256 public override totalPositiveVotes; // Total positive votes endorsing the strategy execution\n    uint256 public override totalNegativeVotes; // Total negative votes against the strategy execution\n    bool public override finalized; // Flag that indicates whether we exited the strategy\n    bool public override active; // Whether the strategy has met the voting quorum\n    bool public dataSet;\n\n    uint256 public override duration; // Duration of the bet\n    uint256 public override stake; // Amount of stake by the strategist (in reserve asset) needs to be positive\n    uint256 public override maxCapitalRequested; // Amount of max capital to allocate\n    uint256 public override capitalAllocated; // Current amount of capital allocated\n    uint256 public override expectedReturn; // Expect return by this strategy\n    uint256 public override capitalReturned; // Actual return by this strategy\n    uint256 public override minRebalanceCapital; // Min amount of capital so that it is worth to rebalance the capital here\n    address[] public tokensNeeded; // Positions that need to be taken prior to enter the strategy\n    uint256[] public tokenAmountsNeeded; // Amount of these positions\n\n    uint256 public override strategyRewards; // Rewards allocated for this strategy updated on finalized\n    uint256 public override rewardsTotalOverhead; // Potential extra amount we are giving in BABL rewards\n\n    // Voters mapped to their votes.\n    mapping(address => int256) public votes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the strategy for a garden\n     *\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _controller                    Address of the controller\n     * @param _maxCapitalRequested           Max Capital requested denominated in the reserve asset (0 to be unlimited)\n     * @param _stake                         Stake with garden participations absolute amounts 1e18\n     * @param _strategyDuration              Strategy duration in seconds\n     * @param _expectedReturn                Expected return\n     * @param _minRebalanceCapital           Min capital that makes executing the strategy worth it\n     * @param _strategyNft                   Address of the strategy nft\n     */\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _minRebalanceCapital,\n        address _strategyNft\n    ) external override initializer {\n        controller = IBabController(_controller);\n\n        _require(controller.isSystemContract(_garden), Errors.NOT_A_GARDEN);\n        garden = IGarden(_garden);\n        uint256 strategistUnlockedBalance =\n            IERC20(address(garden)).balanceOf(_strategist).sub(garden.getLockedBalance(_strategist));\n        _require(IERC20(address(garden)).balanceOf(_strategist) > 0, Errors.STRATEGIST_TOKENS_TOO_LOW);\n        _require(strategistUnlockedBalance >= _stake, Errors.TOKENS_STAKED);\n        // TODO: adjust this calc\n        _require(_stake > 0, Errors.STAKE_HAS_TO_AT_LEAST_ONE);\n        _require(\n            _strategyDuration >= garden.minStrategyDuration() && _strategyDuration <= garden.maxStrategyDuration(),\n            Errors.DURATION_MUST_BE_IN_RANGE\n        );\n        _require(_minRebalanceCapital >= ABSOLUTE_MIN_REBALANCE, Errors.MIN_REBALANCE_CAPITAL);\n        _require(_maxCapitalRequested >= _minRebalanceCapital, Errors.MAX_CAPITAL_REQUESTED);\n        _require(_strategyNft != address(0), Errors.NOT_STRATEGY_NFT);\n\n        strategyNft = _strategyNft;\n\n        strategist = _strategist;\n        enteredAt = block.timestamp;\n        stake = _stake;\n        duration = _strategyDuration;\n        expectedReturn = _expectedReturn;\n        capitalAllocated = 0;\n        minRebalanceCapital = _minRebalanceCapital;\n        maxCapitalRequested = _maxCapitalRequested;\n        totalVotes = _stake.toInt256();\n        votes[_strategist] = _stake.toInt256();\n        absoluteTotalVotes = _stake;\n        dataSet = false;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Sets the data for the operations of this strategy\n     * @param _opTypes                    An array with the op types\n     * @param _opIntegrations             Addresses with the integration for each op\n     * @param _opDatas                    Bytes with the params for the op in the same position in the opTypes array\n     */\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external override onlyGardenAndNotSet {\n        _require(\n            (_opTypes.length == _opIntegrations.length) && (_opIntegrations.length == _opDatas.length),\n            Errors.TOO_MANY_OPS\n        );\n        _require(_opDatas.length < MAX_OPERATIONS && _opDatas.length > 0, Errors.TOO_MANY_OPS);\n        for (uint256 i = 0; i < _opTypes.length; i++) {\n            IOperation(controller.enabledOperations(_opTypes[i])).validateOperation(\n                _opDatas[i],\n                garden,\n                _opIntegrations[i],\n                i\n            );\n            _require(\n                controller.isValidIntegration(IIntegration(_opIntegrations[i]).getName(), _opIntegrations[i]),\n                Errors.ONLY_INTEGRATION\n            );\n        }\n\n        opTypes = _opTypes;\n        opIntegrations = _opIntegrations;\n        opDatas = _opDatas;\n        dataSet = true;\n    }\n\n    /**\n     * Adds off-chain voting results on-chain.\n     * @param _voters                  An array of garden member who voted on strategy.\n     * @param _votes                   An array of votes by on strategy by garden members.\n     *                                 Votes can be positive or negative.\n     * @param _absoluteTotalVotes      Absolute number of votes. _absoluteTotalVotes = abs(upvotes) + abs(downvotes).\n     * @param _totalVotes              Total number of votes. _totalVotes = upvotes + downvotes.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     */\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 _absoluteTotalVotes,\n        int256 _totalVotes,\n        uint256 _fee\n    ) external override onlyKeeper(_fee) onlyActiveGarden {\n        _require(\n            _voters.length >= (garden.totalContributors() == 1 ? 1 : MIN_VOTERS_TO_BECOME_ACTIVE),\n            Errors.MIN_VOTERS_CHECK\n        );\n        _require(!active && !finalized, Errors.VOTES_ALREADY_RESOLVED);\n        _require(block.timestamp.sub(enteredAt) <= MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OVER);\n        active = true;\n\n        // Set votes data\n        for (uint256 i = 0; i < _voters.length; i++) {\n            votes[_voters[i]] = _votes[i];\n        }\n        totalPositiveVotes = _absoluteTotalVotes.toInt256().add(_totalVotes).div(2).toUint256();\n        totalNegativeVotes = _absoluteTotalVotes.toInt256().sub(_totalVotes).div(2).toUint256();\n        voters = _voters;\n        absoluteTotalVotes = absoluteTotalVotes + _absoluteTotalVotes;\n        totalVotes = totalVotes + _totalVotes;\n\n        // Initializes cooldown\n        enteredCooldownAt = block.timestamp;\n        emit StrategyVoted(address(garden), _absoluteTotalVotes, _totalVotes, block.timestamp);\n        garden.payKeeper(msg.sender, _fee);\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * Keeper will validate that quorum is reached, cacluates all the voting data and push it.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     */\n    function executeStrategy(uint256 _capital, uint256 _fee)\n        external\n        override\n        onlyKeeper(_fee)\n        nonReentrant\n        onlyActiveGarden\n    {\n        _require(active, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(capitalAllocated.add(_capital) <= maxCapitalRequested, Errors.MAX_CAPITAL_REACHED);\n        _require(_capital >= minRebalanceCapital, Errors.CAPITAL_IS_LESS_THAN_REBALANCE);\n        _require(\n            block.timestamp.sub(enteredCooldownAt) >= garden.strategyCooldownPeriod(),\n            Errors.STRATEGY_IN_COOLDOWN\n        );\n\n        // Execute enter operation\n        garden.allocateCapitalToStrategy(_capital);\n        capitalAllocated = capitalAllocated.add(_capital);\n        _enterStrategy(_capital);\n\n        // Add to Rewards Distributor an update of the Protocol Principal for BABL Mining Rewards calculations\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        // Sets the executed timestamp on first execution\n        if (executedAt == 0) {\n            executedAt = block.timestamp;\n        } else {\n            // Updating allocation - we need to consider the difference for the calculation\n            // We control the potential overhead in BABL Rewards calculations to keep control\n            // and avoid distributing a wrong number (e.g. flash loans)\n            if (_hasMiningStarted()) {\n                // The Mining program has not started on time for this strategy\n                rewardsTotalOverhead = rewardsTotalOverhead.add(_capital.mul(block.timestamp.sub(updatedAt)));\n            }\n        }\n        if (_hasMiningStarted()) {\n            // The Mining program has not started on time for this strategy\n            rewardsDistributor.addProtocolPrincipal(_capital);\n        }\n        garden.payKeeper(msg.sender, _fee);\n        updatedAt = block.timestamp;\n        emit StrategyExecuted(address(garden), _capital, _fee, block.timestamp);\n    }\n\n    /**\n     * Exits from an executed strategy.\n     * Returns balance back to the garden and sets the capital aside for withdrawals in ETH.\n     * Pays the keeper.\n     * Updates the reserve asset position accordingly.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     * @param _tokenURI                URL with the JSON for the strategy\n     */\n    function finalizeStrategy(uint256 _fee, string memory _tokenURI)\n        external\n        override\n        onlyKeeper(_fee)\n        nonReentrant\n        onlyActiveGarden\n    {\n        _require(executedAt > 0, Errors.STRATEGY_IS_NOT_EXECUTED);\n        _require(block.timestamp > executedAt.add(duration), Errors.STRATEGY_IS_NOT_OVER_YET);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        // Execute exit operations\n        _exitStrategy(HUNDRED_PERCENT);\n        // Mark as finalized\n        finalized = true;\n        active = false;\n        exitedAt = block.timestamp;\n        updatedAt = exitedAt;\n        // Mint NFT\n        IStrategyNFT(strategyNft).grantStrategyNFT(strategist, _tokenURI);\n        // Transfer rewards\n        _transferStrategyPrincipal(_fee);\n        // Send rest to garden if any\n        _sendReserveAssetToGarden();\n        emit StrategyFinalized(address(garden), capitalReturned, _fee, block.timestamp);\n        // Pay Keeper Fee\n        garden.payKeeper(msg.sender, _fee);\n    }\n\n    /**\n     * Partially unwinds an strategy.\n     * Triggered from an immediate withdraw in the Garden.\n     * @param _amountToUnwind              The amount of capital to unwind\n     */\n    function unwindStrategy(uint256 _amountToUnwind) external override onlyGovernorOrGarden nonReentrant {\n        _require(active && !finalized, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(_amountToUnwind <= capitalAllocated.sub(minRebalanceCapital), Errors.STRATEGY_NO_CAPITAL_TO_UNWIND);\n        // Exits and enters the strategy\n        _exitStrategy(_amountToUnwind.preciseDiv(capitalAllocated));\n        updatedAt = block.timestamp;\n        capitalAllocated = capitalAllocated.sub(_amountToUnwind);\n        // Removes protocol principal for the calculation of rewards\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        if (_hasMiningStarted()) {\n            // Only if the Mining program started on time for this strategy\n            rewardsDistributor.substractProtocolPrincipal(_amountToUnwind);\n        }\n        // Send the amount back to the warden for the immediate withdrawal\n        // TODO: Transfer the precise value; not entire balance\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n        emit StrategyReduced(address(garden), _amountToUnwind, block.timestamp);\n    }\n\n    /**\n     * Expires a candidate that has spent more than CANDIDATE_PERIOD without\n     * reaching quorum\n     * @param _fee              The keeper fee\n     */\n    function expireStrategy(uint256 _fee) external onlyKeeper(_fee) nonReentrant onlyActiveGarden {\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n        _deleteCandidateStrategy();\n        garden.payKeeper(msg.sender, _fee);\n        emit StrategyExpired(address(garden), block.timestamp);\n    }\n\n    /**\n     * Delete a candidate strategy by the strategist\n     */\n    function deleteCandidateStrategy() external onlyStrategist {\n        _deleteCandidateStrategy();\n        emit StrategyDeleted(address(garden), block.timestamp);\n    }\n\n    /**\n     * Lets the strategist change the duration of the strategy\n     * @param _newDuration            New duration of the strategy\n     */\n    function changeStrategyDuration(uint256 _newDuration) external override onlyStrategist {\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        _require(_newDuration < duration, Errors.DURATION_NEEDS_TO_BE_LESS);\n        emit StrategyDurationChanged(_newDuration, duration);\n        duration = _newDuration;\n    }\n\n    /**\n     * Any tokens (other than the target) that are sent here by mistake are recoverable by contributors\n     * Converts it to the reserve asset and sends it to the garden.\n     * @param _token             Address of the token to sweep\n     */\n    function sweep(address _token) external onlyContributor {\n        _require(_token != garden.reserveAsset(), Errors.CANNOT_SWEEP_RESERVE_ASSET);\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _require(balance > 0, Errors.BALANCE_TOO_LOW);\n\n        _trade(_token, balance, garden.reserveAsset());\n        // Send WETH to garden\n        _sendReserveAssetToGarden();\n    }\n\n    /**\n     * Helper to invoke Approve on ERC20 from integrations in the strategy context\n     */\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external override onlyIntegration {\n        IERC20(_asset).approve(_spender, _quantity);\n    }\n\n    /**\n     * Helper to invoke a call to an external contract from integrations in the strategy context\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external override onlyIntegration returns (bytes memory) {\n        return _invoke(_target, _value, _data);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external override onlyOperation returns (uint256) {\n        return _trade(_sendToken, _sendQuantity, _receiveToken);\n    }\n\n    /**\n     * Deposits or withdraws weth from an operation in this context\n     * @param _isDeposit                    Wether is a deposit or withdraw\n     * @param _wethAmount                   Amount to deposit or withdraw\n     */\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external override onlyOperation {\n        if (_isDeposit) {\n            IWETH(WETH).deposit{value: _wethAmount}();\n            return;\n        }\n        IWETH(WETH).withdraw(_wethAmount);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Returns whether this strategy is currently active or not\n     */\n    function isStrategyActive() public view override returns (bool) {\n        return executedAt > 0 && exitedAt == 0;\n    }\n\n    /**\n     * Returns the number of operations in this strategy\n     */\n    function getOperationsCount() external view override returns (uint256) {\n        return opTypes.length;\n    }\n\n    /**\n     * Get the non-state related details of a Strategy\n     *\n     */\n    function getStrategyDetails()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            address(this),\n            strategist,\n            opIntegrations.length,\n            stake,\n            absoluteTotalVotes,\n            totalVotes,\n            capitalAllocated,\n            capitalReturned,\n            duration,\n            expectedReturn,\n            maxCapitalRequested,\n            minRebalanceCapital,\n            enteredAt\n        );\n    }\n\n    /**\n     * Get the state of a Strategy\n     *\n     */\n    function getStrategyState()\n        external\n        view\n        override\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (address(this), active, dataSet, finalized, executedAt, exitedAt, updatedAt);\n    }\n\n    /**\n     * Get the operation params by index\n     *\n     */\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        override\n        returns (\n            uint8,\n            address,\n            address\n        )\n    {\n        return (opTypes[_index], opIntegrations[_index], opDatas[_index]);\n    }\n\n    /**\n     * Gets the NAV of assets under management.\n     * It is the sum of the NAV of all the operations\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV() public view override returns (uint256) {\n        uint256 nav = 0;\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(uint256(opTypes[i])));\n            nav = nav.add(operation.getNAV(opDatas[i], garden, opIntegrations[i]));\n        }\n        return nav;\n    }\n\n    /**\n     * Gets the votes casted by the contributor in this strategy\n     *\n     * @param _address           Address of the contributor\n     * @return _votes            Number of votes cast\n     */\n    function getUserVotes(address _address) external view override returns (int256) {\n        return votes[_address];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Enters the strategy.\n     * Executes all the operations in order\n     * @param _capital  Amount of capital that the strategy receives\n     */\n    function _enterStrategy(uint256 _capital) internal {\n        uint256 capitalForNexOperation = _capital;\n        address assetAccumulated = garden.reserveAsset();\n        uint8 assetStatus = 0; // liquid\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i]));\n            (assetAccumulated, capitalForNexOperation, assetStatus) = operation.executeOperation(\n                assetAccumulated,\n                capitalForNexOperation,\n                assetStatus,\n                opDatas[i],\n                garden,\n                opIntegrations[i]\n            );\n        }\n    }\n\n    /**\n     * Exits the strategy.\n     * Exists all the operations starting by the end.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function _exitStrategy(uint256 _percentage) internal {\n        for (uint256 i = opTypes.length; i > 0; i--) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i - 1]));\n            operation.exitOperation(_percentage, opDatas[i - 1], garden, opIntegrations[i - 1]);\n        }\n    }\n\n    /**\n     * Deletes this strategy and returns the stake to the strategist\n     */\n    function _deleteCandidateStrategy() internal {\n        _require(block.timestamp.sub(enteredAt) > MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OPENED);\n        _require(executedAt == 0, Errors.STRATEGY_IS_EXECUTED);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n\n        IGarden(garden).expireCandidateStrategy(address(this));\n        // TODO: Call selfdestruct??\n    }\n\n    /**\n     * Low level function that allows an integration to make an arbitrary function\n     * call to any contract from the garden (garden as msg.sender).\n     *\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function _invoke(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal returns (bytes memory _returnValue) {\n        _returnValue = _target.functionCallWithValue(_data, _value);\n        emit Invoked(_target, _value, _data, _returnValue);\n        return _returnValue;\n    }\n\n    function _sendReserveAssetToGarden() private {\n        uint256 remainingReserve = IERC20(garden.reserveAsset()).balanceOf(address(this));\n        // Sends the rest back if any\n        IERC20(garden.reserveAsset()).safeTransfer(address(garden), remainingReserve);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function _trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) internal returns (uint256) {\n        address tradeIntegration = IBabController(controller).defaultTradeIntegration();\n        // Uses on chain oracle for all internal strategy operations to avoid attacks        // Updates UniSwap TWAP\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        oracle.updateAdapters(_sendToken, _receiveToken);\n        uint256 pricePerTokenUnit = oracle.getPrice(_sendToken, _receiveToken);\n        uint256 exactAmount = _sendQuantity.preciseMul(pricePerTokenUnit);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ITradeIntegration(tradeIntegration).trade(\n            address(this),\n            _sendToken,\n            _sendQuantity,\n            _receiveToken,\n            minAmountExpected\n        );\n        return minAmountExpected;\n    }\n\n    function _transferStrategyPrincipal(uint256 _fee) internal {\n        capitalReturned = IERC20(garden.reserveAsset()).balanceOf(address(this)).sub(_fee);\n        address reserveAsset = garden.reserveAsset();\n        int256 reserveAssetDelta = capitalReturned.toInt256().sub(capitalAllocated.toInt256());\n        uint256 protocolProfits = 0;\n        // Strategy returns were positive\n        uint256 profits = capitalReturned > capitalAllocated ? capitalReturned.sub(capitalAllocated) : 0; // in reserve asset (weth)\n        if (capitalReturned >= capitalAllocated) {\n            // Send weth performance fee to the protocol\n            protocolProfits = IBabController(controller).protocolPerformanceFee().preciseMul(profits);\n            IERC20(reserveAsset).safeTransferFrom(\n                address(this),\n                IBabController(controller).treasury(),\n                protocolProfits\n            );\n            reserveAssetDelta.add(int256(-protocolProfits));\n        } else {\n            // Returns were negative\n            // Burn strategist stake and add the amount to the garden\n            uint256 burningAmount =\n                (stake.sub(capitalReturned.preciseDiv(capitalAllocated).preciseMul(stake))).multiplyDecimal(\n                    STAKE_QUADRATIC_PENALTY_FOR_LOSSES\n                );\n            if (IERC20(address(garden)).balanceOf(strategist) < burningAmount) {\n                // Avoid underflow burning more than its balance\n                burningAmount = IERC20(address(garden)).balanceOf(strategist);\n            }\n\n            garden.burnStrategistStake(strategist, burningAmount);\n            reserveAssetDelta.add(int256(burningAmount));\n        }\n        // Return the balance back to the garden\n        IERC20(reserveAsset).safeTransferFrom(address(this), address(garden), capitalReturned.sub(protocolProfits));\n        // Start a redemption window in the garden with the capital plus the profits for the lps\n        (, , uint256 lpsProfitSharing) = IBabController(controller).getProfitSharing();\n        garden.startWithdrawalWindow(\n            capitalReturned.sub(protocolProfits).sub(profits).add((profits).preciseMul(lpsProfitSharing)),\n            profits.sub(profits.preciseMul(lpsProfitSharing)).sub(protocolProfits),\n            reserveAssetDelta,\n            address(this)\n        );\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        // Substract the Principal in the Rewards Distributor to update the Protocol power value\n        if (_hasMiningStarted()) {\n            // Only if the Mining program started on time for this strategy\n            rewardsDistributor.substractProtocolPrincipal(capitalAllocated);\n        }\n        strategyRewards = rewardsDistributor.getStrategyRewards(address(this)); // Must be zero in case the mining program didnt started on time\n    }\n\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return oracle.getPrice(_assetOne, _assetTwo);\n    }\n\n    function _hasMiningStarted() internal view returns (bool) {\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        uint256 rewardsStartTime = rewardsDistributor.START_TIME();\n        bool miningStarted = ((enteredAt > rewardsStartTime) && (rewardsStartTime != 0));\n        return miningStarted;\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/interfaces/external/weth/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/ITradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ITrade\n * @author Babylon Finance\n *\n * Interface for trading protocol integrations\n */\ninterface ITradeIntegration {\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external;\n\n    function getConversionRates(\n        address _sourceToken,\n        address _destinationToken,\n        uint256 _sourceQuantity\n    ) external returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IStrategy} from './IStrategy.sol';\n\n/**\n * @title IOperation\n * @author Babylon Finance\n *\n * Interface for an strategy operation\n */\ninterface IOperation {\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external;\n\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view returns (uint256);\n\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol IPriceOracle)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPriceOracle\n * @author Babylon Finance\n *\n * Interface for interacting with PriceOracle\n */\ninterface IPriceOracle {\n    /* ============ Functions ============ */\n\n    function getPrice(address _assetOne, address _assetTwo) external view returns (uint256);\n\n    function updateAdapters(address _assetOne, address _assetTwo) external;\n}\n"
    },
    "contracts/interfaces/IStrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IStrategyNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Strategy NFT.\n */\ninterface IStrategyNFT {\n    function initialize(\n        address _controller,\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external;\n\n    function grantStrategyNFT(address _user, string memory _tokenURI) external returns (uint256);\n\n    function updateStrategyURI(string memory _tokenURI) external;\n}\n"
    },
    "contracts/strategies/StrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\n\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {StrategyNFT} from './StrategyNFT.sol';\nimport {Strategy} from './Strategy.sol';\n\n/**\n * @title StrategyFactory\n * @author Babylon Finance\n *\n * Factory to create investment strategy contracts\n */\ncontract StrategyFactory is IStrategyFactory {\n    address payable private immutable strategy;\n    address private immutable strategyNft;\n\n    constructor() {\n        strategy = address(new Strategy());\n        strategyNft = address(new StrategyNFT());\n    }\n\n    /**\n     * Creates a new investment strategy using minimal proxies\n     *\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _controller                    Address of the controller\n     * @param _stratParams                   Strat Params\n     */\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256[] calldata _stratParams\n    ) external override returns (address) {\n        address payable clone = payable(Clones.clone(strategy));\n        address cloneNFT = Clones.clone(strategyNft);\n        StrategyNFT(cloneNFT).initialize(_controller, address(clone), _name, _symbol);\n        IStrategy(clone).initialize(\n            _strategist,\n            _garden,\n            _controller,\n            _stratParams[0],\n            _stratParams[1],\n            _stratParams[2],\n            _stratParams[3],\n            _stratParams[4],\n            cloneNFT\n        );\n        return clone;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IStrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IStrategyFactory\n * @author Babylon Finance\n *\n * Interface for the strategy factory\n */\ninterface IStrategyFactory {\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256[] calldata _stratParams\n    ) external returns (address);\n}\n"
    },
    "contracts/strategies/StrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC721Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\n\n/**\n * @title StrategyNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Strategy\n */\ncontract StrategyNFT is ERC721Upgradeable, IStrategyNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event StrategyNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n    event StrategyURIUpdated(string _newValue, string _oldValue);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy {\n        require(IGarden(strategy.garden()).isStrategy(msg.sender), 'Only the strategy can mint the NFT');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n    IGarden public garden;\n    IStrategy public strategy;\n\n    // Address of the Garden JSON (Shared JSON for each garden)\n    string public tokenURI;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _strategy           Address of the strategy this NFT belongs to\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    function initialize(\n        address _controller,\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external override initializer {\n        require(address(_controller) != address(0), 'Controller must exist');\n        __ERC721_init(_name, _symbol);\n        controller = IBabController(_controller);\n        strategy = IStrategy(_strategy);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     */\n    function grantStrategyNFT(address _user, string memory _tokenURI) external override onlyStrategy returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        _updateStrategyURI(_tokenURI);\n        return _createOrGetStrategyNFT(_user);\n    }\n\n    /**\n     * Updates the token URI of the garden NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateStrategyURI(string memory _tokenURI) external override {\n        require(msg.sender == controller.owner(), 'Only owner can call this');\n        _updateStrategyURI(_tokenURI);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new nft to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetStrategyNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit StrategyNFTAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n\n    /**\n     * Updates the token URI of the strategy NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function _updateStrategyURI(string memory _tokenURI) private {\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit StrategyURIUpdated(tokenURI, oldURI);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721MetadataUpgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/EnumerableSetUpgradeable.sol\";\nimport \"../../utils/EnumerableMapUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;\n    using StringsUpgradeable for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721ReceiverUpgradeable(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[41] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMapUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol SetValuer)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\n/**\n * @title Treasury\n * @author Babylon Finance\n *\n * Contract that will receive the fees earned by the protocol.\n * Governance will be able to send funds from the treasury.\n */\ncontract Treasury is Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    /* ============ Events ============ */\n\n    event TreasuryFundsSent(address _asset, uint256 _amount, address _to);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     */\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION: Send an asset amount to an address\n     *\n     * @param _asset            Address of the asset to send\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryFunds(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external onlyOwner {\n        require(_asset != address(0), 'Asset must exist');\n        require(_to != address(0), 'Target address must exist');\n        IERC20(_asset).safeTransferFrom(address(this), _to, _amount);\n        emit TreasuryFundsSent(_asset, _amount, _to);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Send an ETH amount to an address\n     *\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryETH(uint256 _amount, address payable _to) external onlyOwner {\n        require(_to != address(0), 'Target address must exist');\n        require(address(this).balance >= _amount, 'Not enough funds in treasury');\n        Address.sendValue(_to, _amount);\n        emit TreasuryFundsSent(address(0), _amount, _to);\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n"
    },
    "contracts/gardens/Garden.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IIshtarGate} from '../interfaces/IIshtarGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\n\n/**\n * @title BaseGarden\n * @author Babylon Finance\n *\n * Class that holds common garden-related state and functions\n */\ncontract Garden is ERC20Upgradeable, ReentrancyGuard, IGarden {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event PrincipalChanged(uint256 _newAmount, uint256 _oldAmount);\n    event GardenDeposit(\n        address indexed _to,\n        uint256 reserveToken,\n        uint256 reserveTokenQuantity,\n        uint256 protocolFees,\n        uint256 timestamp\n    );\n    event GardenWithdrawal(\n        address indexed _from,\n        address indexed _to,\n        uint256 reserveToken,\n        uint256 reserveTokenQuantity,\n        uint256 protocolFees,\n        uint256 timestamp\n    );\n\n    event RewardsForContributor(address indexed _contributor, uint256 indexed _amount);\n    event BABLRewardsForContributor(address indexed _contributor, uint96 _rewards);\n\n    /* ============ State Constants ============ */\n\n    // Wrapped ETH address\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 public constant EARLY_WITHDRAWAL_PENALTY = 15e16;\n    uint256 public constant MAX_DEPOSITS_FUND_V1 = 1e21; // Max deposit per garden is 1000 eth for v1\n    uint256 public constant MAX_TOTAL_STRATEGIES = 20; // Max number of strategies\n    uint256 internal constant TEN_PERCENT = 1e17;\n    uint256 internal constant MAX_KEEPER_FEE = (1e6 * 1e3 gwei);\n    uint256 internal constant ABSOLUTE_MIN_CONTRIBUTION = 1e17;\n\n    /* ============ Structs ============ */\n\n    struct Contributor {\n        uint256 lastDepositAt;\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        uint256 claimedBABL;\n        uint256 claimedRewards;\n        uint256 withdrawnSince;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address public override reserveAsset;\n\n    // Address of the controller\n    address public override controller;\n    // Address of the nft\n    address public override nftAddress;\n    // The person that creates the garden\n    address public override creator;\n    // Whether the garden is currently active or not\n    bool public override active;\n    bool public override guestListEnabled;\n\n    // Keeps track of the reserve balance. In case we receive some through other means\n    uint256 public override principal;\n    uint256 public override reserveAssetRewardsSetAside;\n    uint256 public override reserveAssetPrincipalWindow;\n    int256 public override absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 public override minLiquidityAsset;\n\n    uint256 public depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    // Window of time after an investment strategy finishes when the capital is available for withdrawals\n    uint256 public withdrawalWindowAfterStrategyCompletes;\n    uint256 public withdrawalsOpenUntil; // Indicates until when the withdrawals are open and the ETH is set aside\n\n    // Contributors\n    mapping(address => Contributor) public contributors;\n    uint256 public override totalContributors;\n    uint256 public override maxContributors;\n    uint256 public maxDepositLimit; // Limits the amount of deposits\n\n    uint256 public override gardenInitializedAt; // Garden Initialized at timestamp\n    // TODO: Explain what pid is\n    uint256 public pid;\n\n    // Min contribution in the garden\n    uint256 public override minContribution; //wei\n    uint256 public minGardenTokenSupply;\n\n    // Strategies variables\n    uint256 public override totalStake;\n    uint256 public override minVotersQuorum = TEN_PERCENT; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 public override minStrategyDuration; // Min duration for an strategy\n    uint256 public override maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 public override strategyCooldownPeriod;\n\n    address[] private strategies; // Strategies that are either in candidate or active state\n    address[] private finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) public strategyMapping;\n\n    // Keeper debt in WETH if any, repaid upon every strategy finalization\n    uint256 public keeperDebt;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * When a new Garden is created.\n     * All parameter validations are on the BabController contract. Validations are performed already on the\n     * BabController.\n     *\n     * @param _reserveAsset           Address of the reserve asset ERC20\n     * @param _controller             Address of the controller\n     * @param _creator                Address of the creator\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _gardenParams           Array of numeric garden params\n     * @param _nftAddress             Garden NFT address\n     */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        address _nftAddress\n    ) public payable initializer {\n        _require(_creator != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(_controller != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(_reserveAsset != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(_gardenParams.length == 9, Errors.GARDEN_PARAMS_LENGTH);\n        _require(IBabController(_controller).isValidReserveAsset(_reserveAsset), Errors.MUST_BE_RESERVE_ASSET);\n        __ERC20_init(_name, _symbol);\n\n        controller = _controller;\n        reserveAsset = _reserveAsset;\n        creator = _creator;\n        maxContributors = 100;\n        nftAddress = _nftAddress;\n        guestListEnabled = true;\n\n        _start(\n            msg.value,\n            _gardenParams[0],\n            _gardenParams[1],\n            _gardenParams[2],\n            _gardenParams[3],\n            _gardenParams[4],\n            _gardenParams[5],\n            _gardenParams[6],\n            _gardenParams[7],\n            _gardenParams[8]\n        );\n        active = true;\n\n        // Deposit\n        IWETH(WETH).deposit{value: msg.value}();\n        _mintGardenTokens(creator, creator, msg.value, msg.value, 0);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * FUND LEAD ONLY.  Starts the Garden with allowed reserve assets,\n     * fees and issuance premium. Only callable by the Garden's creator\n     *\n     * @param _creatorDeposit                      Deposit by the creator\n     * @param _maxDepositLimit                     Max deposit limit\n     * @param _minGardenTokenSupply             Min garden token supply\n     * @param _minLiquidityAsset                   Number that represents min amount of liquidity denominated in ETH\n     * @param _depositHardlock                     Number that represents the time deposits are locked for an user after he deposits\n     * @param _minContribution        Min contribution to the garden\n     * @param _strategyCooldownPeriod               How long after the strategy has been activated, will it be ready to be executed\n     * @param _minVotersQuorum                  Percentage of votes needed to activate an strategy (0.01% = 1e14, 1% = 1e16)\n     * @param _minStrategyDuration                  Min duration of an strategy\n     * @param _maxStrategyDuration                  Max duration of an strategy\n     */\n    function _start(\n        uint256 _creatorDeposit,\n        uint256 _maxDepositLimit,\n        uint256 _minGardenTokenSupply,\n        uint256 _minLiquidityAsset,\n        uint256 _depositHardlock,\n        uint256 _minContribution,\n        uint256 _strategyCooldownPeriod,\n        uint256 _minVotersQuorum,\n        uint256 _minStrategyDuration,\n        uint256 _maxStrategyDuration\n    ) private {\n        _require(_minContribution >= ABSOLUTE_MIN_CONTRIBUTION, Errors.MIN_CONTRIBUTION);\n        _require(_creatorDeposit >= _minContribution, Errors.MIN_CONTRIBUTION);\n        _require(_creatorDeposit >= _minGardenTokenSupply, Errors.MIN_LIQUIDITY);\n        _require(_creatorDeposit <= _maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);\n        _require(_maxDepositLimit <= MAX_DEPOSITS_FUND_V1, Errors.MAX_DEPOSIT_LIMIT);\n        IBabController babController = IBabController(controller);\n        _require(_minGardenTokenSupply > 0, Errors.MIN_TOKEN_SUPPLY);\n        _require(_depositHardlock > 0, Errors.DEPOSIT_HARDLOCK);\n        _require(_minLiquidityAsset >= babController.minRiskyPairLiquidityEth(), Errors.MIN_LIQUIDITY);\n        _require(\n            _strategyCooldownPeriod <= IBabController(controller).getMaxCooldownPeriod() &&\n                _strategyCooldownPeriod >= IBabController(controller).getMinCooldownPeriod(),\n            Errors.NOT_IN_RANGE\n        );\n        _require(_minVotersQuorum >= TEN_PERCENT && _minVotersQuorum <= TEN_PERCENT.mul(5), Errors.VALUE_TOO_LOW);\n        _require(_maxStrategyDuration >= _minStrategyDuration, Errors.DURATION_RANGE);\n        _require(_minStrategyDuration >= 1 days && _maxStrategyDuration <= 500 days, Errors.DURATION_RANGE);\n        minContribution = _minContribution;\n        strategyCooldownPeriod = _strategyCooldownPeriod;\n        minVotersQuorum = _minVotersQuorum;\n        minStrategyDuration = _minStrategyDuration;\n        maxStrategyDuration = _maxStrategyDuration;\n        minGardenTokenSupply = _minGardenTokenSupply;\n        maxDepositLimit = _maxDepositLimit;\n        gardenInitializedAt = block.timestamp;\n        minLiquidityAsset = _minLiquidityAsset;\n        depositHardlock = _depositHardlock;\n        withdrawalWindowAfterStrategyCompletes = 7 days;\n    }\n\n    /**\n     * Deposits the reserve asset into the garden and mints the Garden token of the given quantity\n     * to the specified _to address.\n     *\n     * @param _reserveAssetQuantity  Quantity of the reserve asset that are received\n     * @param _minGardenTokenReceiveQuantity   Min quantity of Garden token to receive after issuance\n     * @param _to                   Address to mint Garden tokens to\n     */\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to\n    ) public payable override nonReentrant {\n        _onlyActive();\n        _require(\n            guestListEnabled &&\n                IIshtarGate(IBabController(controller).ishtarGate()).canJoinAGarden(address(this), msg.sender),\n            Errors.USER_CANNOT_JOIN\n        );\n        _require(msg.value >= minContribution, Errors.MIN_CONTRIBUTION);\n        // if deposit limit is 0, then there is no deposit limit\n        if (maxDepositLimit > 0) {\n            _require(principal.add(msg.value) <= maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);\n        }\n        _require(totalContributors < maxContributors, Errors.MAX_CONTRIBUTORS);\n        _require(msg.value == _reserveAssetQuantity, Errors.MSG_VALUE_DO_NOT_MATCH);\n        // Always wrap to WETH\n        IWETH(WETH).deposit{value: msg.value}();\n        // Check this here to avoid having relayers\n        reenableEthForStrategies();\n\n        _validateReserveAsset(reserveAsset, _reserveAssetQuantity);\n\n        (uint256 protocolFees, uint256 netFlowQuantity) = _getFees(_reserveAssetQuantity, true);\n\n        // Check that total supply is greater than min supply needed for issuance\n        _require(totalSupply() >= minGardenTokenSupply, Errors.MIN_TOKEN_SUPPLY);\n\n        // gardenTokenQuantity has to be at least _minGardenTokenReceiveQuantity\n        _require(netFlowQuantity >= _minGardenTokenReceiveQuantity, Errors.MIN_TOKEN_SUPPLY);\n\n        // Send Protocol Fee\n        payProtocolFeeFromGarden(reserveAsset, protocolFees);\n\n        // Mint tokens\n        _mintGardenTokens(msg.sender, _to, netFlowQuantity, principal.add(netFlowQuantity), protocolFees);\n    }\n\n    /**\n     * Withdraws the ETH relative to the token participation in the garden and sends it back to the sender.\n     *\n     * @param _gardenTokenQuantity             Quantity of the garden token to withdrawal\n     * @param _minReserveReceiveQuantity     Min quantity of reserve asset to receive\n     * @param _to                            Address to send component assets to\n     */\n    function withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    ) external override nonReentrant {\n        _onlyContributor();\n        _withdraw(_gardenTokenQuantity, _minReserveReceiveQuantity, _to);\n    }\n\n    /**\n     * Requests an immediate withdrawal taking the EARLY_WITHDRAWAL_PENALTY that stays invested.\n     *\n     * @param _gardenTokenQuantity              Quantity of the garden token to withdrawal\n     * @param _to                               Address to send component assets to\n     */\n    function withdrawWithPenalty(uint256 _gardenTokenQuantity, address payable _to) external nonReentrant {\n        _onlyContributor();\n        // Check that cannot do a normal withdrawal\n        _require(!_canWithdrawEthAmount(msg.sender, _gardenTokenQuantity), Errors.NORMAL_WITHDRAWAL_POSSIBLE);\n        uint256 netReserveFlows = _gardenTokenQuantity.sub(_gardenTokenQuantity.preciseMul(EARLY_WITHDRAWAL_PENALTY));\n        (, uint256 largestCapital, address maxStrategy) = _getActiveCapital();\n        // Check that strategy has enough capital to support the withdrawal\n        _require(\n            IStrategy(maxStrategy).minRebalanceCapital() <= largestCapital.sub(netReserveFlows),\n            Errors.WITHDRAWAL_WITH_PENALTY\n        );\n        IStrategy(maxStrategy).unwindStrategy(netReserveFlows);\n        // We burn their penalty\n        _burn(msg.sender, _gardenTokenQuantity.preciseMul(EARLY_WITHDRAWAL_PENALTY));\n        // TODO: replace the 1\n        _withdraw(netReserveFlows, 1, _to);\n    }\n\n    /**\n     * User can claim the rewards from the strategies that his principal\n     * was invested in.\n     */\n    function claimReturns(address[] calldata _finalizedStrategies) external override nonReentrant {\n        _onlyContributor();\n        Contributor storage contributor = contributors[msg.sender];\n        _require(block.timestamp > contributor.claimedAt, Errors.ALREADY_CLAIMED); // race condition check\n\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        (uint256 reserveRewards, uint256 bablRewards) =\n            rewardsDistributor.getRewards(address(this), msg.sender, _finalizedStrategies);\n\n        if (reserveRewards > 0 && address(this).balance >= reserveRewards) {\n            contributor.claimedRewards = contributor.claimedRewards.add(reserveRewards); // Rewards claimed properly\n            // Send ETH\n            Address.sendValue(msg.sender, reserveRewards);\n            reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.sub(reserveRewards);\n            emit RewardsForContributor(msg.sender, reserveRewards);\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n        }\n        if (bablRewards > 0) {\n            contributor.claimedBABL = contributor.claimedBABL.add(bablRewards); // BABL Rewards claimed properly\n            // Send BABL rewards\n\n            rewardsDistributor.sendTokensToContributor(msg.sender, uint96(bablRewards));\n            emit BABLRewardsForContributor(msg.sender, uint96(bablRewards));\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n        }\n    }\n\n    /**\n     * When an strategy finishes execution, we want to make that eth available for withdrawals\n     * from members of the garden.\n     *\n     * @param _amount                        Amount of WETH to convert to ETH to set aside until the window ends\n     * @param _rewards                       Amount of WETH to convert to ETH to set aside forever\n     * @param _returns                       Profits or losses that the strategy received\n     */\n    function startWithdrawalWindow(\n        uint256 _amount,\n        uint256 _rewards,\n        int256 _returns,\n        address _strategy\n    ) external override {\n        _require(\n            (strategyMapping[msg.sender] && address(IStrategy(msg.sender).garden()) == address(this)) ||\n                msg.sender == controller,\n            Errors.ONLY_STRATEGY_OR_CONTROLLER\n        );\n        // Updates reserve asset\n        uint256 _newTotal = principal.toInt256().add(_returns).toUint256();\n        _updatePrincipal(_newTotal);\n        if (withdrawalsOpenUntil > block.timestamp) {\n            withdrawalsOpenUntil = block.timestamp.add(\n                withdrawalWindowAfterStrategyCompletes.sub(withdrawalsOpenUntil.sub(block.timestamp))\n            );\n        } else {\n            withdrawalsOpenUntil = block.timestamp.add(withdrawalWindowAfterStrategyCompletes);\n        }\n        reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.add(_rewards);\n        reserveAssetPrincipalWindow = reserveAssetPrincipalWindow.add(_amount);\n        // Both are converted to weth\n        IWETH(WETH).withdraw(_amount.add(_rewards));\n\n        // Mark strategy as finalized\n        absoluteReturns.add(_returns);\n        strategies = strategies.remove(_strategy);\n        finalizedStrategies.push(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /**\n     * When the window of withdrawals finishes, we need to make the capital available again for investments\n     * We still keep the profits aside.\n     */\n    function reenableEthForStrategies() public override {\n        if (\n            block.timestamp >= withdrawalsOpenUntil &&\n            address(this).balance > minContribution &&\n            address(this).balance >= reserveAssetPrincipalWindow\n        ) {\n            withdrawalsOpenUntil = 0;\n            IWETH(WETH).deposit{value: reserveAssetPrincipalWindow}();\n            reserveAssetPrincipalWindow = 0;\n        }\n    }\n\n    /**\n     * Pays gas costs back to the keeper from executing transactions including the past debt\n     * @param _keeper             Keeper that executed the transaction\n     * @param _fee                The fee paid to keeper to compensate the gas cost\n     */\n    function payKeeper(address payable _keeper, uint256 _fee) external override {\n        _require(IBabController(controller).isValidKeeper(_keeper), Errors.ONLY_KEEPER);\n        keeperDebt = keeperDebt.add(_fee);\n        // Pay Keeper in WETH\n        // TOOD: Update principal\n        // TOOD: Reserve asset may be not WETH\n        if (keeperDebt > 0 && IERC20(reserveAsset).balanceOf(address(this)) >= keeperDebt) {\n            IERC20(reserveAsset).safeTransfer(_keeper, keeperDebt);\n            _updatePrincipal(principal.sub(keeperDebt));\n            keeperDebt = 0;\n        }\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Makes a previously private garden public\n     */\n    function makeGardenPublic() external override {\n        _require(msg.sender == creator, Errors.ONLY_CREATOR);\n        _require(guestListEnabled && IBabController(controller).allowPublicGardens(), Errors.GARDEN_ALREADY_PUBLIC);\n        guestListEnabled = false;\n    }\n\n    /**\n     * PRIVILEGED Manager, protocol FUNCTION. When a Garden is active, deposits are enabled.\n     */\n    function setActive(bool _newValue) external override {\n        _require(msg.sender == controller, Errors.ONLY_CONTROLLER);\n        _require(active != _newValue, Errors.ONLY_INACTIVE);\n        active = _newValue;\n    }\n\n    /* ============ Strategy Functions ============ */\n    /**\n     * Creates a new strategy calling the factory and adds it to the array\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _stratParams                   Num params for the strategy\n     * @param _opTypes                      Type for every operation in the strategy\n     * @param _opIntegrations               Integration to use for every operation\n     * @param _opDatas                      Param for every operation in the strategy\n     */\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external override {\n        _onlyActive();\n        _onlyContributor();\n        _require(\n            IIshtarGate(IBabController(controller).ishtarGate()).canAddStrategiesInAGarden(address(this), msg.sender),\n            Errors.USER_CANNOT_ADD_STRATEGIES\n        );\n        _require(strategies.length < MAX_TOTAL_STRATEGIES, Errors.VALUE_TOO_HIGH);\n        _require(_stratParams.length == 5, Errors.STRAT_PARAMS_LENGTH);\n        address strategy =\n            IStrategyFactory(IBabController(controller).strategyFactory()).createStrategy(\n                _name,\n                _symbol,\n                msg.sender,\n                address(this),\n                controller,\n                _stratParams\n            );\n        strategyMapping[strategy] = true;\n        totalStake = totalStake.add(_stratParams[1]);\n        strategies.push(strategy);\n        IStrategy(strategy).setData(_opTypes, _opIntegrations, _opDatas);\n    }\n\n    /**\n     * Rebalances available capital of the garden between the strategies that are active.\n     * We enter into the strategy and add it to the executed strategies array.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost for each strategy executed\n     */\n    function rebalanceStrategies(uint256 _fee) external override {\n        _onlyActive();\n        _require(IBabController(controller).isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n        // We assume that calling keeper functions should be less expensive\n        // than 1 million gas and the gas price should be lower than 1000 gwei.\n        _require(_fee <= MAX_KEEPER_FEE, Errors.FEE_TOO_HIGH);\n\n        uint256 liquidReserveAsset = ERC20Upgradeable(reserveAsset).balanceOf(address(this));\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            uint256 percentage = strategy.totalVotes().toUint256().preciseDiv(totalStake);\n            uint256 toAllocate = liquidReserveAsset.preciseMul(percentage);\n            if (\n                block.timestamp < strategy.executedAt().add(strategy.duration()).sub(1 days) &&\n                toAllocate >= strategy.minRebalanceCapital() &&\n                toAllocate.add(strategy.capitalAllocated()) <= strategy.maxCapitalRequested()\n            ) {\n                strategy.executeStrategy(toAllocate, _fee);\n            }\n        }\n    }\n\n    /**\n     * Allocates garden capital to an strategy\n     *\n     * @param _capital        Amount of capital to allocate to the strategy\n     */\n    function allocateCapitalToStrategy(uint256 _capital) external override {\n        _onlyStrategy();\n        _onlyActive();\n        uint256 liquidReserveAsset = IERC20(reserveAsset).balanceOf(address(this));\n        uint256 protocolMgmtFee = IBabController(controller).protocolManagementFee().preciseMul(_capital);\n        _require(_capital.add(protocolMgmtFee) <= liquidReserveAsset, Errors.MIN_LIQUIDITY);\n\n        // Take protocol mgmt fee\n        IERC20(reserveAsset).safeTransfer(IBabController(controller).treasury(), protocolMgmtFee);\n\n        // Send Capital to strategy\n        IERC20(reserveAsset).safeTransfer(msg.sender, _capital);\n    }\n\n    // Any tokens (other than the target) that are sent here by mistake are recoverable by the protocol\n    // Exchange for WETH\n    function sweep(address _token) external {\n        _onlyContributor();\n        _require(_token != reserveAsset, Errors.MUST_BE_RESERVE_ASSET);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _require(balance > 0, Errors.BALANCE_TOO_LOW);\n        IERC20(_token).safeTransfer(IBabController(controller).treasury(), balance);\n    }\n\n    /*\n     * Remove an expire candidate from the strategy Array\n     * @param _strategy      Strategy to remove\n     */\n    function expireCandidateStrategy(address _strategy) external override {\n        _onlyStrategy();\n        strategies = strategies.remove(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /*\n     * Burns the stake of the strategist of a given strategy\n     * @param _strategy      Strategy\n     */\n    function burnStrategistStake(address _strategist, uint256 _amount) external override {\n        _onlyStrategy();\n        if (_amount >= balanceOf(_strategist)) {\n            // Avoid underflow condition\n            _amount = balanceOf(_strategist);\n        }\n        _burn(_strategist, _amount);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets current strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getStrategies() external view override returns (address[] memory) {\n        return strategies;\n    }\n\n    /**\n     * Gets finalized strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getFinalizedStrategies() external view override returns (address[] memory) {\n        return finalizedStrategies;\n    }\n\n    function isStrategy(address _strategy) external view override returns (bool) {\n        return strategyMapping[_strategy];\n    }\n\n    function getContributor(address _contributor)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Contributor storage contributor = contributors[_contributor];\n        return (\n            contributor.lastDepositAt,\n            contributor.initialDepositAt,\n            contributor.claimedAt,\n            contributor.claimedBABL,\n            contributor.claimedRewards,\n            contributor.withdrawnSince\n        );\n    }\n\n    /**\n     * Get the expected reserve asset to be withdrawaled\n     *\n     * @param _gardenTokenQuantity             Quantity of Garden tokens to withdrawal\n     *\n     * @return  uint256                     Expected reserve asset quantity withdrawaled\n     */\n    function getExpectedReserveWithdrawalQuantity(uint256 _gardenTokenQuantity)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        (, uint256 netReserveFlows) =\n            _getFees(_getWithdrawalReserveQuantity(reserveAsset, _gardenTokenQuantity), false);\n\n        return netReserveFlows;\n    }\n\n    /**\n     * Checks balance locked for strategists and voters in active strategies\n     *\n     * @param _contributor                 Address of the account\n     *\n     * @return  uint256                    Returns the amount of locked garden tokens for the account\n     */\n    function getLockedBalance(address _contributor) external view override returns (uint256) {\n        uint256 lockedAmount;\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            uint256 votes = uint256(Math.abs(strategy.getUserVotes(_contributor)));\n            if (votes > 0) {\n                lockedAmount = lockedAmount.add(votes);\n            }\n        }\n        // Avoid overflows if off-chain voting system fails\n        if (balanceOf(_contributor) < lockedAmount) lockedAmount = balanceOf(_contributor);\n        return lockedAmount;\n    }\n\n    function getGardenTokenMintQuantity(\n        uint256 _reserveAssetQuantity,\n        bool isDeposit // Value of reserve asset net of fees\n    ) public view override returns (uint256) {\n        // Get valuation of the Garden with the quote asset as the reserve asset.\n        // Reverts if price is not found\n        uint8 reserveAssetDecimals = ERC20Upgradeable(reserveAsset).decimals();\n        uint256 baseUnits = uint256(10)**reserveAssetDecimals;\n        uint256 normalizedReserveQuantity = _reserveAssetQuantity.preciseDiv(baseUnits);\n        // First deposit\n        if (totalSupply() == 0) {\n            return normalizedReserveQuantity;\n        }\n        uint256 gardenValuationPerToken =\n            IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                reserveAsset\n            );\n\n        gardenValuationPerToken = gardenValuationPerToken.preciseDiv(baseUnits);\n        if (isDeposit) {\n            gardenValuationPerToken = gardenValuationPerToken.sub(normalizedReserveQuantity.preciseDiv(totalSupply()));\n        }\n        return normalizedReserveQuantity.preciseDiv(gardenValuationPerToken);\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n\n    /* ============ Modifiers ============ */\n\n    // Replaced by internal functions due to contract size limit of 24KB\n\n    /* ============ Internal Functions ============ */\n\n    function _onlyContributor() internal {\n        _require(balanceOf(msg.sender) > 0, Errors.ONLY_CONTRIBUTOR);\n    }\n\n    /**\n     * Throws if the sender is not an strategy of this garden\n     */\n    function _onlyStrategy() internal {\n        _require(strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n    }\n\n    /**\n     * Throws if the garden is not active\n     */\n    function _onlyActive() internal {\n        _require(active, Errors.ONLY_ACTIVE);\n    }\n\n    /**\n     * Function that mints the appropriate garden tokens along with the Garden NFT\n     * @param _from                            Address that triggered the transaction\n     * @param _to                              Address to mint the tokens\n     * @param _reserveAssetQuantity            Amount of garden tokens\n     * @param _newPrincipal                    New principal for that user\n     * @param _protocolFees                    Protocol Fees Paid\n     */\n    function _mintGardenTokens(\n        address _from,\n        address _to,\n        uint256 _reserveAssetQuantity,\n        uint256 _newPrincipal,\n        uint256 _protocolFees\n    ) private {\n        uint256 previousBalance = balanceOf(_to);\n        uint256 amountToMint = getGardenTokenMintQuantity(_reserveAssetQuantity, true);\n        _mint(_to, amountToMint);\n        _updateContributorDepositInfo(_from, previousBalance);\n        _updatePrincipal(_newPrincipal);\n        // Mint the garden NFT\n        IGardenNFT(nftAddress).grantGardenNFT(_to);\n        _require(totalSupply() > 0, Errors.MIN_LIQUIDITY);\n        emit GardenDeposit(_to, msg.value, _reserveAssetQuantity, _protocolFees, block.timestamp);\n    }\n\n    /**\n     * Check if the fund has ETH amount available for withdrawals.\n     * If it returns false, reserve pool would be available.\n     * @param _contributor                   Address of the contributors\n     * @param _amount                        Amount of ETH to withdraw\n     */\n    function _canWithdrawEthAmount(address _contributor, uint256 _amount) private view returns (bool) {\n        // ETH rewards cannot be withdrawn. Only claimed\n        _require(address(this).balance >= reserveAssetPrincipalWindow, Errors.NOT_ENOUGH_ETH);\n        uint256 liquidWeth = IERC20(reserveAsset).balanceOf(address(this));\n\n        // Weth already available\n        if (liquidWeth >= _amount) {\n            return true;\n        }\n\n        // Withdrawal open\n        if (block.timestamp <= withdrawalsOpenUntil) {\n            IRewardsDistributor rewardsDistributor =\n                IRewardsDistributor(IBabController(controller).rewardsDistributor());\n            // Pro rata withdrawals\n            uint256 contributorPower =\n                rewardsDistributor.getContributorPower(\n                    address(this),\n                    _contributor,\n                    contributors[_contributor].initialDepositAt,\n                    block.timestamp\n                );\n            return reserveAssetPrincipalWindow.preciseMul(contributorPower) >= _amount;\n        }\n        return false;\n    }\n\n    /**\n     * Gets the total active capital currently invested in strategies\n     *\n     * @return uint256       Total amount active\n     * @return uint256       Total amount active in the largest strategy\n     * @return address       Address of the largest strategy\n     */\n    function _getActiveCapital()\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            address\n        )\n    {\n        uint256 totalActiveCapital;\n        uint256 maxAllocation;\n        address maxStrategy = address(0);\n        for (uint8 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            if (strategy.isStrategyActive()) {\n                uint256 allocation = strategy.capitalAllocated();\n                totalActiveCapital = totalActiveCapital.add(allocation);\n                if (allocation > maxAllocation) {\n                    maxAllocation = allocation;\n                    maxStrategy = strategies[i];\n                }\n            }\n        }\n        return (totalActiveCapital, maxAllocation, maxStrategy);\n    }\n\n    /**\n     * Function that allows the principal to be updated\n     *\n     * @param _amount             Amount of the reserve balance\n     */\n    function _updatePrincipal(uint256 _amount) private {\n        uint256 oldAmount = principal;\n        principal = _amount;\n        emit PrincipalChanged(_amount, oldAmount);\n    }\n\n    /**\n     * Pays the _feeQuantity from the _garden denominated in _token to the protocol fee recipient\n     * @param _token                   Address of the token to pay with\n     * @param _feeQuantity             Fee to transfer\n     */\n    function payProtocolFeeFromGarden(address _token, uint256 _feeQuantity) private {\n        if (_feeQuantity > 0) {\n            IERC20(_token).safeTransfer(IBabController(controller).treasury(), _feeQuantity);\n        }\n    }\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 _amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, _amount);\n        _require(\n            from == address(0) || to == address(0) || IBabController(controller).gardenTokensTransfersEnabled(),\n            Errors.GARDEN_TRANSFERS_DISABLED\n        );\n    }\n\n    /**\n     * Aux function to withdraw from a garden\n     */\n    function _withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    ) private {\n        // Withdrawal amount has to be equal or less than msg.sender balance\n        _require(_gardenTokenQuantity <= balanceOf(msg.sender), Errors.MSG_SENDER_TOKENS_DO_NOT_MATCH);\n        // Flashloan protection\n        _require(\n            block.timestamp.sub(contributors[msg.sender].lastDepositAt) >= depositHardlock,\n            Errors.DEPOSIT_HARDLOCK\n        );\n        _require(\n            _gardenTokenQuantity <= balanceOf(msg.sender).sub(this.getLockedBalance(msg.sender)),\n            Errors.TOKENS_STAKED\n        ); // Strategists and Voters cannot withdraw locked stake while in active strategies\n\n        // Check this here to avoid having relayers\n        reenableEthForStrategies();\n\n        uint256 reserveAssetQuantity = _getWithdrawalReserveQuantity(reserveAsset, _gardenTokenQuantity);\n\n        (uint256 protocolFees, uint256 netFlowQuantity) = _getFees(reserveAssetQuantity, false);\n\n        uint256 newGardenTokenSupply = totalSupply().sub(_gardenTokenQuantity);\n\n        _require(_canWithdrawEthAmount(msg.sender, netFlowQuantity), Errors.MIN_LIQUIDITY);\n\n        _validateReserveAsset(reserveAsset, netFlowQuantity);\n\n        // Check that new supply is more than min supply needed for withdrawal\n        // Note: A min supply amount is needed to avoid division by 0 when withdrawaling garden token to 0\n        _require(newGardenTokenSupply >= minGardenTokenSupply, Errors.MIN_TOKEN_SUPPLY);\n\n        _require(netFlowQuantity >= _minReserveReceiveQuantity, Errors.MIN_TOKEN_SUPPLY);\n\n        _burn(msg.sender, _gardenTokenQuantity);\n\n        // Check that the withdrawal is possible\n        // Unwrap WETH if ETH balance lower than netFlowQuantity\n        if (address(this).balance < netFlowQuantity) {\n            IWETH(WETH).withdraw(netFlowQuantity.sub(address(this).balance));\n        }\n        _updateContributorWithdrawalInfo(netFlowQuantity);\n        // Send ETH\n        Address.sendValue(_to, netFlowQuantity);\n        payProtocolFeeFromGarden(reserveAsset, protocolFees);\n\n        uint256 outflow = netFlowQuantity.add(protocolFees);\n\n        // Required withdrawable quantity is greater than existing collateral\n        _require(principal >= outflow, Errors.BALANCE_TOO_LOW);\n        _updatePrincipal(principal.sub(outflow));\n\n        emit GardenWithdrawal(msg.sender, _to, netFlowQuantity, _gardenTokenQuantity, protocolFees, block.timestamp);\n    }\n\n    function _validateReserveAsset(address _reserveAsset, uint256 _quantity) private view {\n        _require(_quantity > 0, Errors.GREATER_THAN_ZERO);\n        _require(IBabController(controller).isValidReserveAsset(_reserveAsset), Errors.MUST_BE_RESERVE_ASSET);\n    }\n\n    /**\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     *\n     * Protocol Fee = (% direct fee %) * reserveAssetQuantity\n     *\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _isDeposit                    Boolean that is true when it is a deposit\n     *\n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     */\n    function _getFees(uint256 _reserveAssetQuantity, bool _isDeposit) private view returns (uint256, uint256) {\n        // Get protocol fee percentages\n        uint256 protocolFeePercentage =\n            _isDeposit\n                ? IBabController(controller).protocolDepositGardenTokenFee()\n                : IBabController(controller).protocolWithdrawalGardenTokenFee();\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees);\n\n        return (protocolFees, netReserveFlow);\n    }\n\n    function _getWithdrawalReserveQuantity(address _reserveAsset, uint256 _gardenTokenQuantity)\n        private\n        view\n        returns (uint256)\n    {\n        // Get valuation of the Garden with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 gardenValuationPerToken =\n            IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                _reserveAsset\n            );\n\n        uint256 totalWithdrawalValueInPreciseUnits = _gardenTokenQuantity.preciseMul(gardenValuationPerToken);\n        // Get reserve asset decimals\n        uint8 reserveAssetDecimals = ERC20Upgradeable(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalWithdrawalValueInPreciseUnits.preciseMul(10**reserveAssetDecimals);\n\n        return prePremiumReserveQuantity;\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorDepositInfo(address _contributor, uint256 previousBalance) private {\n        Contributor storage contributor = contributors[_contributor];\n        // If new contributor, create one, increment count, and set the current TS\n        if (previousBalance == 0 || contributor.initialDepositAt == 0) {\n            totalContributors = totalContributors.add(1);\n            contributor.initialDepositAt = block.timestamp;\n        }\n        // We make checkpoints around contributor deposits to avoid fast loans and give the right rewards afterwards\n\n        contributor.lastDepositAt = block.timestamp;\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        rewardsDistributor.updateGardenPower(address(this), pid);\n        rewardsDistributor.setContributorTimestampParams(address(this), _contributor, previousBalance, true, pid); // true = deposit\n        pid++;\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorWithdrawalInfo(uint256 _netflowQuantity) private {\n        Contributor storage contributor = contributors[msg.sender];\n        // If sold everything\n        if (balanceOf(msg.sender) == 0) {\n            contributor.lastDepositAt = 0;\n            contributor.initialDepositAt = 0;\n            contributor.withdrawnSince = 0;\n            //delete contributor.timeListPointer;\n            totalContributors = totalContributors.sub(1);\n        } else {\n            contributor.withdrawnSince = contributor.withdrawnSince.add(_netflowQuantity);\n        }\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        rewardsDistributor.updateGardenPower(address(this), pid);\n        rewardsDistributor.setContributorTimestampParams(address(this), msg.sender, 0, false, pid); // false = withdraw\n        pid++;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/interfaces/IGardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\ninterface IGardenValuer {\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256);\n\n    function getLossesGarden(address _garden, uint256 _since) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IGardenNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Garden NFT.\n */\ninterface IGardenNFT {\n    function initialize(\n        address _controller,\n        address _garden,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed\n    ) external;\n\n    function grantGardenNFT(address _user) external returns (uint256);\n\n    function updateGardenURI(string memory _tokenURI) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/gardens/GardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\n\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {Garden} from './Garden.sol';\nimport {GardenNFT} from './GardenNFT.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to create garden contracts\n */\ncontract GardenFactory is IGardenFactory {\n    address private immutable garden;\n    address private immutable gardenNFT;\n\n    constructor() {\n        garden = address(new Garden());\n        gardenNFT = address(new GardenNFT());\n    }\n\n    /**\n     * Creates a garden using minimal proxies\n     * @param _reserveAsset           Address of the reserve asset ERC20\n     * @param _controller             Address of the controller\n     * @param _creator                Address of the creator\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _tokenURI               URL of the garden NFT JSON\n     * @param _seed                   Seed to regenerate the garden NFT\n     * @param _gardenParams           Array of numeric params in the garden\n     */\n    function createGarden(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams\n    ) external payable override returns (address) {\n        address payable clone = payable(Clones.clone(garden));\n        address cloneNFT = Clones.clone(gardenNFT);\n        GardenNFT(cloneNFT).initialize(_controller, address(clone), _name, _symbol, _tokenURI, _seed);\n        Garden(clone).initialize{value: msg.value}(\n            _reserveAsset,\n            _controller,\n            _creator,\n            _name,\n            _symbol,\n            _gardenParams,\n            cloneNFT\n        );\n        return clone;\n    }\n}\n"
    },
    "contracts/gardens/GardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC721Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Garden\n */\ncontract GardenNFT is ERC721Upgradeable, IGardenNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event GardenNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n    event GardenURIUpdated(string _newValue, string _oldValue);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGarden {\n        require(msg.sender == address(garden), 'Only the garden can mint the NFT');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n    IGarden public garden;\n\n    // Address of the Garden JSON (Shared JSON for each garden)\n    string public tokenURI;\n    uint256 public seed;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _garden             Address of the garden this NFT belongs to\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     * @param _tokenURI           Initial token URI\n     * @param _seed               Seed to regenerated the Babylong Garden in 3D\n     */\n    function initialize(\n        address _controller,\n        address _garden,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed\n    ) external override initializer {\n        require(address(_controller) != address(0), 'Controller must exist');\n        __ERC721_init(_name, _symbol);\n        controller = IBabController(_controller);\n        garden = IGarden(_garden);\n        seed = _seed;\n        tokenURI = _tokenURI;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     */\n    function grantGardenNFT(address _user) external override onlyGarden returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        return _createOrGetGardenNFT(_user);\n    }\n\n    /**\n     * Updates the token URI of the garden NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateGardenURI(string memory _tokenURI) external override {\n        require(msg.sender == controller.owner(), 'Only owner can call this');\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit GardenURIUpdated(tokenURI, oldURI);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new nft to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetGardenNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit GardenNFTAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n}\n"
    },
    "contracts/strategies/operations/LendOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\n/**\n * @title LendOperatin\n * @author Babylon Finance\n *\n * Executes a lend operation\n */\ncontract LendOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the lend operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(_data != _garden.reserveAsset(), 'Receive token must be different');\n    }\n\n    /**\n     * Executes the lend operation\n     * @param _capital      Amount of capital received from the garden\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = _data;\n        if (assetToken != _asset) {\n            IStrategy(msg.sender).trade(_asset, _capital, assetToken);\n        }\n        uint256 numTokensToSupply = IERC20(assetToken).balanceOf(msg.sender);\n        uint256 exactAmount = ILendIntegration(_integration).getExpectedShares(assetToken, numTokensToSupply);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ILendIntegration(_integration).supplyTokens(msg.sender, assetToken, numTokensToSupply, minAmountExpected);\n        return (assetToken, numTokensToSupply, 1); // put as collateral\n    }\n\n    /**\n     * Exits the lend operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external override onlyStrategy {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        address assetToken = _data;\n        uint256 numTokensToRedeem =\n            IERC20(ILendIntegration(_integration).getInvestmentToken(assetToken)).balanceOf(msg.sender).preciseMul(\n                _percentage\n            );\n        ILendIntegration(_integration).redeemTokens(\n            msg.sender,\n            assetToken,\n            numTokensToRedeem,\n            ILendIntegration(_integration).getExchangeRatePerToken(assetToken).mul(\n                numTokensToRedeem.sub(numTokensToRedeem.preciseMul(SLIPPAGE_ALLOWED))\n            )\n        );\n        if (assetToken != _garden.reserveAsset()) {\n            IStrategy(msg.sender).trade(assetToken, IERC20(assetToken).balanceOf(msg.sender), _garden.reserveAsset());\n        }\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV(\n        address _assetToken,\n        IGarden _garden,\n        address _integration\n    ) external view override onlyStrategy returns (uint256) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return 0;\n        }\n        uint256 numTokensToRedeem =\n            IERC20(ILendIntegration(_integration).getInvestmentToken(_assetToken)).balanceOf(msg.sender);\n        uint256 assetTokensAmount =\n            ILendIntegration(_integration).getExchangeRatePerToken(_assetToken).mul(numTokensToRedeem);\n        uint256 price = _getPrice(_garden.reserveAsset(), _assetToken);\n        uint256 NAV = _normalizeDecimals(_assetToken, assetTokensAmount).preciseDiv(price);\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return NAV;\n    }\n}\n"
    },
    "contracts/strategies/operations/Operation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IOperation} from '../../interfaces/IOperation.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\n/**\n * @title LongStrategy\n * @author Babylon Finance\n *\n * Holds the data for a long strategy\n */\nabstract contract Operation is IOperation {\n    using SafeMath for uint256;\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy() {\n        IStrategy strategy = IStrategy(msg.sender);\n        IGarden garden = strategy.garden();\n        require(IBabController(controller).isSystemContract(address(garden)), 'Only a garden can call this');\n        require(garden.isStrategy(msg.sender), 'Sender must be a strategy');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Address of the controller\n    address public controller;\n    // Name of the operation\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) {\n        require(_controller != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ Virtual External Functions ============ */\n\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view virtual override;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external virtual override;\n\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view virtual override returns (uint256);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the operation\n     */\n    function getName() external view override returns (string memory) {\n        return name;\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle\n     */\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return oracle.getPrice(_assetOne, _assetTwo);\n    }\n\n    function _normalizeDecimals(address _asset, uint256 _quantity) internal view returns (uint256) {\n        uint8 tokenDecimals = ERC20(_asset).decimals();\n        return tokenDecimals != 18 ? _quantity.mul(10**(18 - tokenDecimals)) : _quantity;\n    }\n}\n"
    },
    "contracts/interfaces/ILendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ILendIntegration\n * @author Babylon Finance\n *\n * Interface for lending integrations such as Compound, Aave.\n */\ninterface ILendIntegration {\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external;\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external;\n\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply) external view returns (uint256);\n\n    function getExchangeRatePerToken(address _assetToken) external view returns (uint256);\n\n    function getInvestmentToken(address _assetToken) external view returns (address);\n}\n"
    },
    "contracts/integrations/lend/LendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title LendIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract LendIntegration is BaseIntegration, ReentrancyGuard, ILendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address assetToken;\n        address investment; // Investment address\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event TokensSupplied(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToSupply\n    );\n\n    event TokensRedeemed(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToRedeem,\n        uint256 protocolFee\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(\n        string memory _name,\n        address _weth,\n        address _controller\n    ) BaseIntegration(_name, _weth, _controller) {}\n\n    /* ============ External Functions ============ */\n    function getInvestmentToken(address _assetToken) external view override returns (address) {\n        return _getInvestmentToken(_assetToken);\n    }\n\n    /**\n     * Checks whether an investment address is valid\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return bool                              True if the address is a investment\n     */\n    function isInvestment(address _investmentAddress) external view returns (bool) {\n        return _isInvestment(_investmentAddress);\n    }\n\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external override {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToSupply,\n                _minAmountExpected\n            );\n\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        investmentInfo.strategy.invokeApprove(_getSpender(_assetToken), _assetToken, _numTokensToSupply);\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getSupplyCalldata(_strategy, _assetToken, _numTokensToSupply);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToSupply\n        );\n    }\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external override {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToRedeem,\n                _minAmountExpected\n            );\n\n        _validatePreExitInvestmentData(investmentInfo);\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getRedeemCalldata(_strategy, _assetToken, _numTokensToRedeem);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToRedeem\n        );\n    }\n\n    function getExchangeRatePerToken(address _assetToken) external view override returns (uint256) {\n        return _getExchangeRatePerToken(_assetToken);\n    }\n\n    /**\n     * Gets the amount of cTokens expected to get after depositing ERC20 asset.\n     *\n     * @param _numTokensToSupply                 Amount of ERC20 tokens to supply\n     * @return uint256                           Amount of supply tokens to receive\n     */\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_assetToken, _numTokensToSupply);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) ==\n                _investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction,\n            'The garden did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    function _isInvestment(\n        address //_investmentAddress\n    ) internal view virtual returns (bool);\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _assetToken,\n        address _investmentToken,\n        uint256 _investmentTokensInTransaction,\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.assetToken = _assetToken;\n        investmentInfo.investment = _investmentToken;\n        investmentInfo.investmentTokensInGarden = IERC20(_investmentToken).balanceOf(_strategy);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    function _getExpectedShares(address, uint256) internal view virtual returns (uint256);\n\n    function _getExchangeRatePerToken(address) internal view virtual returns (uint256);\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * hparam  _strategy                Address of the strat\n     * hparam  _assetToken              Address of the token\n     * hparam  _numTokensToSupply       Number of tokens\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getInvestmentToken(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/BaseIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\n\n/**\n * @title BaseIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses common Integration-related state and functions.\n */\nabstract contract BaseIntegration {\n    using SafeCast for int256;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySystemContract() {\n        require(IBabController(controller).isSystemContract(msg.sender), 'Only system can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the controller\n    address public controller;\n    // Wrapped ETH address\n    address public immutable weth;\n    // Name of the integration\n    string public name;\n    mapping(address => bool) public initializedByGarden;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n\n    constructor(\n        string memory _name,\n        address _weth,\n        address _controller\n    ) {\n        require(_controller != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n        weth = _weth;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the integration\n     */\n    function getName() external view returns (string memory) {\n        return name;\n    }\n}\n"
    },
    "contracts/integrations/lend/CompoundLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title CompoundLendIntegration\n * @author Babylon Finance Protocol\n *\n * Compound lend integration.\n */\ncontract CompoundLendIntegration is LendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyProtocol() {\n        require(msg.sender == controller, 'Only controller can call this');\n        _;\n    }\n\n    /* ============ Constant ============ */\n\n    address internal constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(address _controller, address _weth) LendIntegration('compoundlend', _weth, _controller) {\n        assetToCToken[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643; // DAI\n        assetToCToken[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984] = 0x35A18000230DA775CAc24873d00Ff85BccdeD550; // UNI\n        assetToCToken[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // WETH\n        assetToCToken[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; // USDC\n        assetToCToken[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9; // USDT\n        assetToCToken[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4; // WBTC\n        assetToCToken[0xc00e94Cb662C3520282E6f5717214004A7f26888] = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4; // COMP\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external onlyProtocol {\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        return assetToCToken[_assetToken] != address(0);\n    }\n\n    function _getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 oneCTokenInUderlying = _getExchangeRatePerToken(_assetToken);\n        return oneCTokenInUderlying.mul(_numTokensToSupply).div(10**18);\n    }\n\n    // TODO: Test this\n    function _getExchangeRatePerToken(address _assetToken) internal view override returns (uint256) {\n        address cToken = assetToCToken[_assetToken];\n        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateStored();\n        // TODO: exchangeRateCurrent reverts wit no reason. Super strange.\n        // uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateCurrent();\n        uint8 assetDecimals = ERC20(_assetToken).decimals();\n        // cTokens always have 8 decimals.\n        if (assetDecimals < 8) {\n            uint256 mantissa = 8 - assetDecimals;\n            return exchangeRateCurrent.mul(10**mantissa);\n        } else {\n            uint256 mantissa = assetDecimals - 8;\n            return exchangeRateCurrent.div(10**mantissa);\n        }\n    }\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('redeem(uint256)', _numTokensToSupply);\n\n        return (assetToCToken[_assetToken], 0, methodData);\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('mint(uint256)', _numTokensToSupply);\n        // If it is ETH, send the value\n        return (assetToCToken[_assetToken], assetToCToken[_assetToken] == cETH ? _numTokensToSupply : 0, methodData);\n    }\n\n    function _getSpender(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function repayBorrowBehalf(address borrower, uint256 amount) external payable returns (uint256);\n\n    function borrowBalanceCurrent(address account) external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/DepositVaultOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\n\n/**\n * @title DepositVaultOperation\n * @author Babylon Finance\n *\n * Executes a deposit vault operation\n */\ncontract DepositVaultOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the deposit vault operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(IPassiveIntegration(_integration).isInvestment(_data), 'Must be a valid yield vault');\n    }\n\n    /**\n     * Executes the deposit vault operation\n     * @param _capital      Amount of capital received from the garden\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address yieldVault = _data;\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        if (vaultAsset != _asset) {\n            IStrategy(msg.sender).trade(_asset, _capital, vaultAsset);\n        }\n        uint256 exactAmount = IPassiveIntegration(_integration).getExpectedShares(yieldVault, _capital);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        IPassiveIntegration(_integration).enterInvestment(\n            msg.sender,\n            yieldVault,\n            minAmountExpected,\n            vaultAsset,\n            IERC20(vaultAsset).balanceOf(msg.sender)\n        );\n        return (yieldVault, IERC20(yieldVault).balanceOf(msg.sender), 0); // liquid\n    }\n\n    /**\n     * Exits the deposit vault operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external override onlyStrategy {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        address yieldVault = _data;\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        uint256 amountVault = IERC20(yieldVault).balanceOf(msg.sender).preciseMul(_percentage);\n        IPassiveIntegration(_integration).exitInvestment(\n            msg.sender,\n            yieldVault,\n            amountVault,\n            vaultAsset,\n            IPassiveIntegration(_integration).getPricePerShare(yieldVault).mul(\n                amountVault.sub(amountVault.preciseMul(SLIPPAGE_ALLOWED))\n            )\n        );\n        if (vaultAsset != _garden.reserveAsset()) {\n            IStrategy(msg.sender).trade(vaultAsset, IERC20(vaultAsset).balanceOf(msg.sender), _garden.reserveAsset());\n        }\n    }\n\n    /**\n     * Gets the NAV of the deposit vault op in the reserve asset\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view override onlyStrategy returns (uint256) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return 0;\n        }\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(_data);\n        uint256 price = _getPrice(_garden.reserveAsset(), vaultAsset);\n        uint256 NAV =\n            IPassiveIntegration(_integration).getPricePerShare(_data).mul(IERC20(_data).balanceOf(msg.sender)).div(\n                price\n            );\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return NAV;\n    }\n}\n"
    },
    "contracts/interfaces/IPassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPassiveIntegration\n * @author Babylon Finance\n *\n * Interface for passive investments protocol integrations\n */\ninterface IPassiveIntegration {\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external;\n\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external;\n\n    function isInvestment(address _investmentAddress) external view returns (bool);\n\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount) external view returns (uint256);\n\n    function getPricePerShare(address _investmentAddress) external view returns (uint256);\n\n    function getInvestmentAsset(address _investmentAddress) external view returns (address);\n}\n"
    },
    "contracts/integrations/passive/PassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title PassiveIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract PassiveIntegration is BaseIntegration, ReentrancyGuard, IPassiveIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address investment; // Investment address\n        uint256 totalSupply; // Total Supply of the investment\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event InvestmentEntered(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        address tokenIn,\n        uint256 investmentTokensOut\n    );\n\n    event InvestmentExited(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        uint256 investmentTokensOut\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(\n        string memory _name,\n        address _weth,\n        address _controller\n    ) BaseIntegration(_name, _weth, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits tokens into an investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokensOut        Min amount of investment tokens to receive\n     * @param _tokenIn                    Token aaddress to deposit\n     * @param _maxAmountIn                Max amount of the token to deposit\n     */\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        _validatePreJoinInvestmentData(investmentInfo);\n        // Approve spending of the token\n        investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress), _tokenIn, _maxAmountIn);\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getEnterInvestmentCalldata(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit InvestmentEntered(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _investmentAddress,\n            _tokenIn,\n            _investmentTokensOut\n        );\n    }\n\n    /**\n     * Exits an outside passive investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokenIn          Quantity of investment tokens to return\n     * @param _tokenOut                   Token address to withdraw\n     * @param _minAmountOut               Min token quantities to receive from the investment\n     */\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        _validatePreExitInvestmentData(investmentInfo);\n        // Approve spending of the investment token\n        investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress), _investmentAddress, _investmentTokenIn);\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getExitInvestmentCalldata(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit InvestmentExited(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            investmentInfo.investment,\n            _investmentTokenIn\n        );\n    }\n\n    /**\n     * Checks whether an investment address is valid\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return bool                              True if the address is a investment\n     */\n    function isInvestment(address _investmentAddress) external view override returns (bool) {\n        return _isInvestment(_investmentAddress);\n    }\n\n    /**\n     * Gets the amount of shares expected to get after depositing _ethAmount\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @param _ethAmount                         Amount of eth to invest\n     * @return uint256                           Amount of investment shares to receive\n     */\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_investmentAddress, _ethAmount);\n    }\n\n    /**\n     * Gets how much eth one unit of the investment is worth\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return uint256                           Returns the price in ETH of an investment share\n     */\n    function getPricePerShare(address _investmentAddress) external view override returns (uint256) {\n        return _getPricePerShare(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset needed to enter the investment\n     *\n     * @return address                           Returns the asset that this investment needs\n     */\n    function getInvestmentAsset(address _investmentAddress) external view override returns (address) {\n        return _getInvestmentAsset(_investmentAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * @param _strategy                                 Address of the strategy\n     * @param _investment                               Address of the investment\n     * @param _investmentTokensInTransaction            Number of investment tokens involved\n     * hparam _tokenIn                                  Addresseses of the deposit token\n     * @param _limitDepositToken                        Limit quantity of the deposit/withdrawal token\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _investment,\n        uint256 _investmentTokensInTransaction,\n        address, /*_tokenIn*/\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.investment = _investment;\n        investmentInfo.totalSupply = IERC20(_investment).totalSupply();\n        investmentInfo.investmentTokensInGarden = IERC20(_investment).balanceOf(_strategy);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.investment), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.investment), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) ==\n                _investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction,\n            'The garden did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                       Addresses of tokens to send to the investment\n     * hparam  _maxAmountIn                   Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _investmentAddress */\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 /* _maxAmountIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of token to receive\n     * hparam  _minAmountOut                   Amount of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /*_strategy */\n        address, /*_investmentAddress */\n        uint256, /*_investmentTokensIn */\n        address, /*_tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _isInvestment(\n        address //_investmentAddress\n    ) internal view virtual returns (bool);\n\n    function _getExpectedShares(\n        address, //_investmentAddress\n        uint256 // _ethAmount\n    ) internal view virtual returns (uint256);\n\n    function _getPricePerShare(\n        address //_investmentAddress\n    ) internal view virtual returns (uint256);\n\n    function _getInvestmentAsset(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/passive/YearnVaultIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {YRegistry} from '../../interfaces/external/yearn/YRegistry.sol';\nimport {IVault} from '../../interfaces/external/yearn/IVault.sol';\n\n/**\n * @title YearnIntegration\n * @author Babylon Finance Protocol\n *\n * Yearn v2 Vault Integration\n */\ncontract YearnVaultIntegration is PassiveIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Kyber Network Proxy\n    YRegistry public yearnv2Registry;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _yearnRegistryAddress           Address of Balancer core factory address\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _yearnRegistryAddress\n    ) PassiveIntegration('yearnvaults', _weth, _controller) {\n        yearnv2Registry = YRegistry(_yearnRegistryAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isInvestment(address _investmentAddress) internal view override returns (bool) {\n        (address _controller, , , , ) = yearnv2Registry.getVaultInfo(_investmentAddress);\n        return _controller != address(0);\n    }\n\n    function _getSpender(address _investmentAddress) internal pure override returns (address) {\n        return _investmentAddress;\n    }\n\n    function _getExpectedShares(address _investmentAddress, uint256 _ethAmount)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        return _ethAmount.preciseDiv(IVault(_investmentAddress).getPricePerFullShare());\n    }\n\n    function _getPricePerShare(address _investmentAddress) internal view override returns (uint256) {\n        return IVault(_investmentAddress).getPricePerFullShare();\n    }\n\n    function _getInvestmentAsset(address _investmentAddress) internal view override returns (address) {\n        return IVault(_investmentAddress).token();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('deposit(uint256)', _maxAmountIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256)', _investmentTokensIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/yearn/YRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface YRegistry {\n    function getName() external pure returns (string memory);\n\n    function getVault(uint256 index) external view returns (address vault);\n\n    function getVaultsLength() external view returns (uint256);\n\n    function getVaults() external view returns (address[] memory);\n\n    function getVaultInfo(address _vault)\n        external\n        view\n        returns (\n            address controller,\n            address token,\n            address strategy,\n            bool isWrapped,\n            bool isDelegated\n        );\n\n    function getVaultsInfo()\n        external\n        view\n        returns (\n            address[] memory vaultsAddresses,\n            address[] memory controllerArray,\n            address[] memory tokenArray,\n            address[] memory strategyArray,\n            bool[] memory isWrappedArray,\n            bool[] memory isDelegatedArray\n        );\n}\n"
    },
    "contracts/interfaces/external/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IVault {\n    function token() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function controller() external view returns (address);\n\n    function governance() external view returns (address);\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function deposit(uint256) external;\n\n    function depositAll() external;\n\n    function withdraw(uint256) external;\n\n    function withdrawAll() external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/BuyOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\n\n/**\n * @title BuyOperation\n * @author Babylon Finance\n *\n * Executes a buy operation\n */\ncontract BuyOperation is Operation {\n    using PreciseUnitMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the buy operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(_data != _garden.reserveAsset(), 'Receive token must be different');\n    }\n\n    /**\n     * Executes the buy operation\n     * @param _capital      Amount of capital received from the garden\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _data,\n        IGarden, /* _garden */\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        IStrategy(msg.sender).trade(_asset, _capital, _data);\n        return (_data, IERC20(_data).balanceOf(address(msg.sender)), 0); // liquid\n    }\n\n    /**\n     * Exits the buy operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address /* _integration */\n    ) external override onlyStrategy {\n        require(_percentage <= 100e18, 'Unwind Percentage <= 100%');\n        IStrategy(msg.sender).trade(\n            _data,\n            IERC20(_data).balanceOf(address(msg.sender)).preciseMul(_percentage),\n            _garden.reserveAsset()\n        );\n    }\n\n    /**\n     * Gets the NAV of the buy op in the reserve asset\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address /* _integration */\n    ) external view override onlyStrategy returns (uint256) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return 0;\n        }\n        uint256 price = _getPrice(_garden.reserveAsset(), _data);\n        uint256 NAV = _normalizeDecimals(_data, IERC20(_data).balanceOf(msg.sender)).preciseDiv(price);\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return NAV;\n    }\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol SetValuer)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IUniswapAnchoredView} from './interfaces/external/compound/IUniswapAnchoredView.sol';\nimport {IOracleAdapter} from './interfaces/IOracleAdapter.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance\n *\n * Contract that returns the price for any given asset pair. Price is retrieved either directly from an oracle,\n * calculated using common asset pairs, or uses external data to calculate price.\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract PriceOracle is Ownable, IPriceOracle {\n    using PreciseUnitMath for uint256;\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n\n    event AdapterAdded(address _adapter);\n    event AdapterRemoved(address _adapter);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Address of uniswap anchored view contract. See https://compound.finance/docs/prices#price\n    address public immutable uniswapAnchoredView;\n\n    // List of IOracleAdapters used to return prices of third party protocols (e.g. Uniswap, Compound, Balancer)\n    address[] public adapters;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _controller                   Address of controller contract\n     * @param _uniswapAnchoredView          Address of the uniswap anchored view that compound maintains\n     * @param _adapters                     List of adapters used to price assets created by other protocols\n     */\n    constructor(\n        IBabController _controller,\n        address _uniswapAnchoredView,\n        address[] memory _adapters\n    ) {\n        controller = _controller;\n        uniswapAnchoredView = _uniswapAnchoredView;\n        adapters = _adapters;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * SYSTEM-ONLY PRIVELEGE: Find price of passed asset pair, if possible. The steps it takes are:\n     *  1) Check to see if a direct or inverse oracle of the pair exists,\n     *  2) If not, use masterQuoteAsset to link pairs together (i.e. BTC/ETH and ETH/USDC\n     *     could be used to calculate BTC/USDC).\n     *  3) If not, check oracle adapters in case one or more of the assets needs external protocol data\n     *     to price.\n     *  4) If all steps fail, revert.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return                  Price of asset pair to 18 decimals of precision\n     */\n    function getPrice(address _assetOne, address _assetTwo) external view override returns (uint256) {\n        require(controller.isSystemContract(msg.sender) || msg.sender == owner(), 'Caller must be system contract');\n        // Same asset. Returns base unit\n        if (_assetOne == _assetTwo) {\n            return 10**18;\n        }\n\n        bool priceFound;\n        uint256 price;\n\n        (priceFound, price) = _getPriceFromUniswapAnchoredView(_assetOne, _assetTwo);\n        if (!priceFound) {\n            (priceFound, price) = _getPriceFromAdapters(_assetOne, _assetTwo);\n        }\n\n        require(priceFound, 'Price not found');\n        return price;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Add new oracle adapter.\n     *\n     * @param _adapter         Address of new adapter\n     */\n    function addAdapter(address _adapter) external onlyOwner {\n        require(!adapters.contains(_adapter), 'Adapter already exists');\n        adapters.push(_adapter);\n\n        emit AdapterAdded(_adapter);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Remove oracle adapter.\n     *\n     * @param _adapter         Address of  adapter to remove\n     */\n    function removeAdapter(address _adapter) external onlyOwner {\n        adapters = adapters.remove(_adapter);\n\n        emit AdapterRemoved(_adapter);\n    }\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * Returns an array of adapters\n     */\n    function getAdapters() external view returns (address[] memory) {\n        return adapters;\n    }\n\n    /**\n     * Calls the update function in every adapter.\n     * e.g Uniswap TWAP\n     * @param _assetOne       First Asset of the pair\n     * @param _assetTwo       Second Asset of the pair\n     */\n    function updateAdapters(address _assetOne, address _assetTwo) external override {\n        for (uint256 i = 0; i < adapters.length; i += 1) {\n            IOracleAdapter(adapters[i]).update(_assetOne, _assetTwo);\n        }\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Try to calculate asset pair price by getting each asset in the pair's price relative to USD.\n     * Both prices must exist otherwise function returns false and no price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return bool             Boolean indicating if oracle exists\n     * @return uint256          Price of asset pair to 18 decimal precision (if exists, otherwise 0)\n     */\n    function _getPriceFromUniswapAnchoredView(address _assetOne, address _assetTwo)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        address assetToCheck = _assetOne;\n        if (_assetOne == WETH) {\n            assetToCheck = _assetTwo;\n        }\n        if (\n            assetToCheck == 0x6B175474E89094C44Da98b954EedeAC495271d0F || // dai\n            assetToCheck == 0x1985365e9f78359a9B6AD760e32412f4a445E862 || // rep\n            assetToCheck == 0xE41d2489571d322189246DaFA5ebDe1F4699F498 || // zrx\n            assetToCheck == 0x0D8775F648430679A709E98d2b0Cb6250d2887EF || // bat\n            assetToCheck == 0xdd974D5C2e2928deA5F71b9825b8b646686BD200 || // knc\n            assetToCheck == 0x514910771AF9Ca656af840dff83E8264EcF986CA || // link\n            assetToCheck == 0xc00e94Cb662C3520282E6f5717214004A7f26888 || // comp\n            assetToCheck == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 || // USDC\n            assetToCheck == 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984 // uni\n        ) {\n            string memory symbol1 = _assetOne == WETH ? 'ETH' : ERC20(_assetOne).symbol();\n            string memory symbol2 = _assetTwo == WETH ? 'ETH' : ERC20(_assetTwo).symbol();\n            uint256 assetOnePrice = IUniswapAnchoredView(uniswapAnchoredView).price(symbol1);\n            uint256 assetTwoPrice = IUniswapAnchoredView(uniswapAnchoredView).price(symbol2);\n\n            if (assetOnePrice > 0 && assetTwoPrice > 0) {\n                return (true, assetOnePrice.preciseDiv(assetTwoPrice));\n            }\n        }\n\n        return (false, 0);\n    }\n\n    /**\n     * Scan adapters to see if one or more of the assets needs external protocol data to be priced. If\n     * does not exist return false and no price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return bool             Boolean indicating if oracle exists\n     * @return uint256          Price of asset pair to 18 decimal precision (if exists, otherwise 0)\n     */\n    function _getPriceFromAdapters(address _assetOne, address _assetTwo) internal view returns (bool, uint256) {\n        for (uint256 i = 0; i < adapters.length; i++) {\n            (bool priceFound, uint256 price) = IOracleAdapter(adapters[i]).getPrice(_assetOne, _assetTwo);\n\n            if (priceFound) {\n                return (priceFound, price);\n            }\n        }\n\n        return (false, 0);\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/IUniswapAnchoredView.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol IOracleAdapter)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IOracleAdapter\n * @author Babylon Finance\n *\n * Interface for calling an oracle adapter.\n */\ninterface IUniswapAnchoredView {\n    function price(string memory symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOracleAdapter.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol IOracleAdapter)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IOracleAdapter\n * @author Babylon Finance\n *\n * Interface for calling an oracle adapter.\n */\ninterface IOracleAdapter {\n    /**\n     * Function for retrieving a price that requires sourcing data from outside protocols to calculate.\n     *\n     * @param  _assetOne    First asset in pair\n     * @param  _assetTwo    Second asset in pair\n     * @return                  Boolean indicating if oracle exists\n     * @return              Current price of asset represented in uint256\n     */\n    function getPrice(address _assetOne, address _assetTwo) external view returns (bool, uint256);\n\n    function update(address _assetOne, address _assetTwo) external;\n}\n"
    },
    "contracts/oracle_adapter/UniswapTWAP.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from Uniswap TWAPs\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol';\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IOracleAdapter} from '../interfaces/IOracleAdapter.sol';\n\n/**\n * @title UniswapTWAP\n * @author Babylon Finance Protocol\n *\n * Sliding window oracle that uses observations collected over a window to provide moving price averages in the past\n * `windowSize` with a precision of `windowSize / granularity`\n * note this is a singleton oracle and only needs to be deployed once per desired parameters, which\n * differs from the simple oracle which must be deployed once per pair.\n */\ncontract UniswapTWAP is Ownable, IOracleAdapter {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    struct Observation {\n        uint256 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController public controller;\n\n    // Name to identify this adapter\n    string public constant name = 'uniswapTwap';\n\n    // Address of Uniswap factory\n    address public immutable factory;\n    // the desired amount of time over which the moving average should be computed, e.g. 24 hours\n    uint256 public immutable windowSize;\n    // the number of observations stored for each pair, i.e. how many price observations are stored for the window.\n    // as granularity increases from 1, more frequent updates are needed, but moving averages become more precise.\n    // averages are computed over intervals with sizes in the range:\n    //   [windowSize - (windowSize / granularity) * 2, windowSize]\n    // e.g. if the window size is 24 hours, and the granularity is 24, the oracle will return the average price for\n    //   the period:\n    //   [now - [22 hours, 24 hours], now]\n    uint8 public immutable granularity;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint256 public immutable periodSize;\n\n    // mapping from pair address to a list of price observations of that pair\n    mapping(address => Observation[]) public pairObservations;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables\n     *\n     * @param _controller         Instance of controller contract\n     * @param _factory            Address of Uniswap factory\n     * @param _windowSize         Array of allowed Uniswap pools\n     * @param _granularity        Array of allowed Uniswap pools\n     */\n    constructor(\n        address _controller,\n        address _factory,\n        uint256 _windowSize,\n        uint8 _granularity\n    ) {\n        require(_granularity > 1, 'SlidingWindowOracle: GRANULARITY');\n        require(\n            (periodSize = _windowSize / _granularity) * _granularity == _windowSize,\n            'SlidingWindowOracle: WINDOW_NOT_EVENLY_DIVISIBLE'\n        );\n        factory = _factory;\n        controller = IBabController(_controller);\n        windowSize = _windowSize;\n        granularity = _granularity;\n    }\n\n    /* ============ External Functions ============ */\n\n    // returns the index of the observation corresponding to the given timestamp\n    function observationIndexOf(uint256 timestamp) public view returns (uint8 index) {\n        uint256 epochPeriod = timestamp / periodSize;\n        return uint8(epochPeriod % granularity);\n    }\n\n    // update the cumulative price for the observation at the current timestamp. each observation is updated at most\n    // once per epoch period.\n    function update(address tokenA, address tokenB) external override {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\n        // populate the array with empty observations (first call only)\n        for (uint256 i = pairObservations[pair].length; i < granularity; i++) {\n            pairObservations[pair].push();\n        }\n        // get the observation for the current period\n        uint8 observationIndex = observationIndexOf(block.timestamp);\n        Observation storage observation = pairObservations[pair][observationIndex];\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        uint256 timeElapsed = block.timestamp - observation.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint256 price0Cumulative, uint256 price1Cumulative, ) =\n                UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observation.timestamp = block.timestamp;\n            observation.price0Cumulative = price0Cumulative;\n            observation.price1Cumulative = price1Cumulative;\n        }\n    }\n\n    // returns the amount out corresponding to the amount in for a given token using the moving average over the time\n    // range [now - [windowSize, windowSize - periodSize * 2], now]\n    // update must have been called for the bucket corresponding to timestamp `now - windowSize`\n    function getPrice(address tokenIn, address tokenOut)\n        external\n        view\n        override\n        returns (bool found, uint256 amountOut)\n    {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        Observation storage firstObservation = getFirstObservationInWindow(pair);\n\n        uint256 timeElapsed = block.timestamp - firstObservation.timestamp;\n        require(timeElapsed <= windowSize, 'SlidingWindowOracle: MISSING_HISTORICAL_OBSERVATION');\n        // should never happen.\n        require(timeElapsed >= windowSize - periodSize * 2, 'SlidingWindowOracle: UNEXPECTED_TIME_ELAPSED');\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        (address token0, ) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        if (token0 == tokenIn) {\n            return (true, computeAmountOut(firstObservation.price0Cumulative, price0Cumulative, timeElapsed));\n        } else {\n            return (true, computeAmountOut(firstObservation.price1Cumulative, price1Cumulative, timeElapsed));\n        }\n    }\n\n    /* ============ Internal Functions ============ */\n\n    // given the cumulative prices of the start and end of a period, and the length of the period, compute the average\n    // price in terms of how much amount out is received for the amount in\n    function computeAmountOut(\n        uint256 priceCumulativeStart,\n        uint256 priceCumulativeEnd,\n        uint256 timeElapsed\n    ) private pure returns (uint256 amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage =\n            FixedPoint.uq112x112(uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed));\n        amountOut = priceAverage.mul(1).decode144();\n        amountOut = amountOut.preciseDiv(1);\n    }\n\n    // returns the observation from the oldest epoch (at the beginning of the window) relative to the current time\n    function getFirstObservationInWindow(address pair) private view returns (Observation storage firstObservation) {\n        uint8 observationIndex = observationIndexOf(block.timestamp);\n        // no overflow issue. if observationIndex + 1 overflows, result is still zero.\n        uint8 firstObservationIndex = (observationIndex + 1) % granularity;\n        firstObservation = pairObservations[pair][firstObservationIndex];\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= uint144(-1)) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & uint128(-1) > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & uint64(-1) > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & uint32(-1) > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & uint16(-1) > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & uint8(-1) > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol": {
      "content": "pragma solidity >=0.5.0;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/integrations/trade/TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol';\n\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title BorrowIntetration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with trading protocols\n */\nabstract contract TradeIntegration is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct TradeInfo {\n        IGarden garden; // Garden\n        IStrategy strategy; // Strategy\n        string exchangeName; // Which exchange to use\n        address sendToken; // Address of token being sold\n        address receiveToken; // Address of token being bought\n        uint256 gardenTotalSupply; // Total supply of Garden in Precise Units (10^18)\n        uint256 totalSendQuantity; // Total quantity of sold tokens\n        uint256 totalMinReceiveQuantity; // Total minimum quantity of token to receive back\n        uint256 preTradeSendTokenBalance; // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance; // Total initial balance of token being bought\n    }\n\n    /* ============ Events ============ */\n\n    event ComponentExchanged(\n        IGarden indexed _garden,\n        IStrategy indexed _strategy,\n        address indexed _sendToken,\n        address _receiveToken,\n        string _exchangeName,\n        uint256 _totalSendAmount,\n        uint256 _totalReceiveAmount\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(\n        string memory _name,\n        address _weth,\n        address _controller\n    ) BaseIntegration(_name, _weth, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external override nonReentrant onlySystemContract {\n        TradeInfo memory tradeInfo =\n            _createTradeInfo(_strategy, name, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity);\n        _validatePreTradeData(tradeInfo, _sendQuantity);\n        // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n        tradeInfo.strategy.invokeApprove(_getSpender(), tradeInfo.sendToken, tradeInfo.totalSendQuantity);\n        (address targetExchange, uint256 callValue, bytes memory methodData) =\n            _getTradeCallData(_strategy, tradeInfo.sendToken, tradeInfo.totalSendQuantity, tradeInfo.receiveToken);\n        tradeInfo.strategy.invokeFromIntegration(targetExchange, callValue, methodData);\n\n        uint256 exchangedQuantity = _validatePostTrade(tradeInfo);\n        uint256 newAmountSendTokens = tradeInfo.preTradeSendTokenBalance.sub(tradeInfo.totalSendQuantity);\n        uint256 newAmountReceiveTokens = tradeInfo.preTradeReceiveTokenBalance.add(exchangedQuantity);\n        emit ComponentExchanged(\n            tradeInfo.garden,\n            tradeInfo.strategy,\n            _sendToken,\n            _receiveToken,\n            tradeInfo.exchangeName,\n            newAmountSendTokens,\n            newAmountReceiveTokens\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return TradeInfo struct\n     *\n     * @param _strategy             Address of the strategy\n     * @param _exchangeName         Human readable name of the exchange in the integrations registry\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     * @param _minReceiveQuantity   Min units of token in SetToken to be received from the exchange\n     *\n     * return TradeInfo             Struct containing data for trade\n     */\n    function _createTradeInfo(\n        address _strategy,\n        string memory _exchangeName,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) internal view returns (TradeInfo memory) {\n        TradeInfo memory tradeInfo;\n\n        tradeInfo.strategy = IStrategy(_strategy);\n        tradeInfo.garden = tradeInfo.strategy.garden();\n\n        tradeInfo.exchangeName = _exchangeName;\n\n        tradeInfo.sendToken = _sendToken;\n        tradeInfo.receiveToken = _receiveToken;\n\n        tradeInfo.gardenTotalSupply = ERC20(address(tradeInfo.strategy.garden())).totalSupply();\n\n        tradeInfo.totalSendQuantity = _sendQuantity;\n\n        tradeInfo.totalMinReceiveQuantity = _minReceiveQuantity;\n\n        tradeInfo.preTradeSendTokenBalance = ERC20(_sendToken).balanceOf(_strategy);\n        tradeInfo.preTradeReceiveTokenBalance = ERC20(_receiveToken).balanceOf(_strategy);\n\n        return tradeInfo;\n    }\n\n    /**\n     * Validate pre trade data. Check exchange is valid, token quantity is valid.\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     */\n    function _validatePreTradeData(TradeInfo memory _tradeInfo, uint256 _sendQuantity) internal view {\n        require(_tradeInfo.totalSendQuantity > 0, 'Token to sell must be nonzero');\n        address pair =\n            UniswapV2Library.pairFor(\n                IBabController(controller).getUniswapFactory(),\n                _tradeInfo.sendToken,\n                _tradeInfo.receiveToken\n            );\n        uint256 minLiquidity = _tradeInfo.garden.minLiquidityAsset();\n        // Check that there is enough liquidity\n        (uint256 liquidity0, uint256 liquidity1, ) = IUniswapV2Pair(pair).getReserves();\n        require(\n            (IUniswapV2Pair(pair).token0() == weth && liquidity0 >= minLiquidity) ||\n                (IUniswapV2Pair(pair).token1() == weth && liquidity1 >= minLiquidity),\n            'Not enough liquidity'\n        );\n        require(\n            ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy)) >= _sendQuantity,\n            'Garden needs to have enough liquid tokens'\n        );\n    }\n\n    /**\n     * Validate post trade data.\n     *\n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @return uint256                  Total quantity of receive token that was exchanged\n     */\n    function _validatePostTrade(TradeInfo memory _tradeInfo) internal view returns (uint256) {\n        uint256 exchangedQuantity =\n            ERC20(_tradeInfo.receiveToken).balanceOf(address(_tradeInfo.strategy)).sub(\n                _tradeInfo.preTradeReceiveTokenBalance\n            );\n        // Get reserve asset decimals\n        uint8 tokenDecimals = ERC20(_tradeInfo.receiveToken).decimals();\n        uint256 normalizedExchangedQuantity =\n            tokenDecimals != 18 ? exchangedQuantity.mul(10**(18 - tokenDecimals)) : exchangedQuantity;\n        require(normalizedExchangedQuantity >= _tradeInfo.totalMinReceiveQuantity, 'Slippage greater than allowed');\n\n        return normalizedExchangedQuantity;\n    }\n\n    /**\n     * Return exchange calldata which is already generated from the exchange API\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the exchange\n     * hparam _sendQuantity         Units of reserve asset token sent to the exchange\n     * hparam _receiveToken         Address of the token that will be received from the exchange\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken */\n        uint256, /*_sendQuantity */\n        address /* _receiveToken */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address     Address of the contract to approve tokens to\n     */\n    function _getSpender() internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/trade/OneInchTradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IOneInchExchange} from '../../interfaces/external/1inch/IOneInchExchange.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title 1InchTradeIntegration\n * @author Babylon Finance Protocol\n *\n * 1Inch protocol trade integration\n */\ncontract OneInchTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyProtocol() {\n        require(msg.sender == controller, 'Only controller can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of 1Inch exchange address\n    address public oneInchExchangeAddress;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _weth                         Address of the WETH ERC20\n     * @param _controller                   Address of the controller\n     * @param _oneInchExchangeAddress       Address of 1inch exchange contract\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _oneInchExchangeAddress\n    ) TradeIntegration('1inch', _weth, _controller) {\n        oneInchExchangeAddress = _oneInchExchangeAddress;\n    }\n\n    /* ============ External Functions ============ */\n    /**\n     * Returns the conversion rate between the source token and the destination token\n     * in 18 decimals, regardless of component token's decimals\n     *\n     * hparam  _sourceToken        Address of source token to be sold\n     * hparam  _destinationToken   Address of destination token to buy\n     * hparam  _sourceQuantity     Amount of source token to sell\n     *\n     * @return uint256             Conversion rate in wei\n     * @return uint256             Slippage rate in wei\n     */\n    function getConversionRates(\n        address,\n        address,\n        uint256\n    ) external pure override returns (uint256, uint256) {\n        revert('not implemented');\n        return (0, 0);\n    }\n\n    function updateExchangeAddress(address _newExchangeAddress) public onlyProtocol {\n        oneInchExchangeAddress = _newExchangeAddress;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through 1Inch.\n     *\n     * hparam _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address, /*_strategy*/\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (uint256 _returnAmount, uint256[] memory _distribution) =\n            IOneInchExchange(oneInchExchangeAddress).getExpectedReturn(_sendToken, _receiveToken, _sendQuantity, 1, 0);\n\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'swap(address,address,uint256,uint256,uint256[],uint256)',\n                _sendToken,\n                _receiveToken,\n                _sendQuantity,\n                _returnAmount,\n                _distribution,\n                0\n            );\n        return (oneInchExchangeAddress, 0, methodData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender() internal view override returns (address) {\n        return oneInchExchangeAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/1inch/IOneInchExchange.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\n\ninterface IOneInchExchange {\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] memory distribution,\n        uint256 flags\n    ) external payable returns (uint256);\n\n    function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags\n    ) external view returns (uint256 returnAmount, uint256[] memory distribution);\n}\n"
    },
    "contracts/token/BABLToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title BABL Token\n * @dev The BABLToken contract is ERC20 using 18 decimals as a standard\n * Is Ownable to transfer ownership to Governor Alpha for Decentralized Governance\n * It overrides the mint and maximum supply to control the timing and maximum cap allowed along the time.\n */\n\ncontract BABLToken is TimeLockedToken {\n    using SafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new mint ocurr\n    event MintedNewTokens(address account, uint256 tokensminted);\n\n    /// @notice An event thats emitted when maxSupplyAllowed changes\n    event MaxSupplyChanged(uint256 previousMaxValue, uint256 newMaxValue);\n\n    /// @notice An event that emitted when maxSupplyAllowedAfter changes\n    event MaxSupplyAllowedAfterChanged(uint256 previousAllowedAfterValue, uint256 newAllowedAfterValue);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @dev EIP-20 token name for this token\n    string private constant NAME = 'Babylon.Finance';\n\n    /// @dev EIP-20 token symbol for this token\n    string private constant SYMBOL = 'BABL';\n\n    /// @dev Maximum number of tokens in circulation of 1 million for the first 8 years (using 18 decimals as ERC20 standard)\n    uint256 public maxSupplyAllowed = 1_000_000e18; //\n\n    /// @notice The timestamp after which a change on maxSupplyAllowed may occur\n    uint256 public maxSupplyAllowedAfter;\n\n    /// @notice Cap on the percentage of maxSupplyAllowed that can be increased per year after maxSupplyAllowedAfter\n    uint8 public constant MAX_SUPPLY_CAP = 5;\n\n    /// @notice Cap on the percentage of totalSupply that can be minted at each mint after the initial 1 Million BABL\n    uint8 public constant MINT_CAP = 2;\n\n    /// @notice The timestamp after which minting may occur after FIRST_EPOCH_MINT (8 years)\n    uint256 public mintingAllowedAfter;\n\n    /// @notice The timestamp of BABL Token deployment\n    uint256 public BABLTokenDeploymentTimestamp;\n\n    /// @dev First Epoch Mint where no more than 1 Million BABL can be minted (>= 8 Years)\n    uint32 private constant FIRST_EPOCH_MINT = 365 days * 8;\n\n    /// @dev Minimum time between mints after\n    uint32 private constant MIN_TIME_BETWEEN_MINTS = 365 days;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new BABL token and gives ownership to sender\n     */\n    constructor(TimeLockRegistry newTimeLockRegistry, IBabController newController) TimeLockedToken(NAME, SYMBOL) {\n        // Timestamp of contract deployment\n        BABLTokenDeploymentTimestamp = block.timestamp;\n\n        // Set-up the minimum time of 8 years to wait until the maxSupplyAllowed can be changed (it will also include a max cap)\n        maxSupplyAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        //Starting with a maxSupplyAllowed of 1 million for the first 8 years\n        _mint(msg.sender, 1_000_000e18);\n\n        //Set-up the minimum time of 8 years for additional mints\n        mintingAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        // Set the Time Lock Registry\n        timeLockRegistry = newTimeLockRegistry;\n\n        // Set the Babylon Controller\n        controller = newController;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows to mint new tokens\n     *\n     * @notice Mint new BABL tokens. Initial 1 Million BABL. After 8 years new BABL could be minted by governance decision\n     * @dev MINT_CAP The new maximum limit, limited by a 2% cap of totalSupply for each new mint and always limited by maxSupplyAllowed.\n     * mintingAllowedAfter Defines the next time allowed for a new mint\n     * @param _to The address of the destination account that will receive the new BABL tokens\n     * @param _amount The number of tokens to be minted\n     * @return Whether or not the mint succeeded\n     */\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        require(totalSupply().add(_amount) <= maxSupplyAllowed, 'BABLToken::mint: max supply exceeded');\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::mint: minting not allowed after the FIRST_EPOCH_MINT has passed >= 8 years'\n        );\n        require(_amount > 0, 'BABLToken::mint: mint should be higher than zero');\n        require(\n            block.timestamp >= mintingAllowedAfter,\n            'BABLToken::mint: minting not allowed yet because mintingAllowedAfter'\n        );\n        require(_to != address(0), 'BABLToken::mint: cannot transfer to the zero address');\n        require(_to != address(this), 'BABLToken::mint: cannot mint to the address of this contract');\n\n        // set-up the new time where a new (the next) mint can be allowed\n        mintingAllowedAfter = block.timestamp.add(MIN_TIME_BETWEEN_MINTS);\n\n        // mint the amount\n        uint96 amount = safe96(_amount, 'BABLToken::mint: amount exceeds 96 bits');\n\n        // After FIRST_EPOCH_MINT (8 years) a MINT_CAP applies\n        require(\n            amount <= totalSupply().mul(MINT_CAP).div(100),\n            'BABLToken::mint: exceeded mint cap of 2% of total supply'\n        );\n        _mint(_to, amount);\n\n        emit MintedNewTokens(_to, amount);\n\n        // move delegates to add voting power to the destination\n        _moveDelegates(address(0), delegates[_to], amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change maxSupplyAllowed\n     *\n     * @notice Set-up a greater maxSupplyAllowed value to allow more tokens to be minted\n     * @param newMaxSupply The new maximum limit, limited by a maximum of 5% cap per year\n     * @param newMaxSupplyAllowedAfter The new waiting period to change the maxSupplyAllowed limited for a minimum of 1 year\n     * @return Whether or not the changeMaxSupply succeeded\n     */\n    function changeMaxSupply(uint256 newMaxSupply, uint256 newMaxSupplyAllowedAfter) external onlyOwner returns (bool) {\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed until 8 years after deployment'\n        );\n        require(\n            block.timestamp >= maxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed yet'\n        );\n\n        // update the amount\n        require(\n            newMaxSupply > maxSupplyAllowed,\n            'BABLToken::changeMaxSupply: changeMaxSupply should be higher than previous value'\n        );\n        uint256 limitedNewSupply = maxSupplyAllowed.add(maxSupplyAllowed.mul(MAX_SUPPLY_CAP).div(100));\n        require(newMaxSupply <= limitedNewSupply, 'BABLToken::changeMaxSupply: exceeded of allowed 5% cap');\n        emit MaxSupplyChanged(maxSupplyAllowed, newMaxSupply);\n        maxSupplyAllowed = safe96(newMaxSupply, 'BABLToken::changeMaxSupply: potential max amount exceeds 96 bits');\n\n        // update the new waiting time until a new change could be done >= 1 year since this change\n        uint256 futureTime = block.timestamp.add(365 days);\n        require(\n            newMaxSupplyAllowedAfter >= futureTime,\n            'BABLToken::changeMaxSupply: the newMaxSupplyAllowedAfter should be at least 1 year in the future'\n        );\n        emit MaxSupplyAllowedAfterChanged(maxSupplyAllowedAfter, newMaxSupplyAllowedAfter);\n        maxSupplyAllowedAfter = safe96(\n            newMaxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: new newMaxSupplyAllowedAfter exceeds 96 bits'\n        );\n\n        return true;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the value of maxSupplyAllowed\n     *\n     * @return Returns the value of maxSupplyAllowed at the time\n     */\n    function maxSupply() external view returns (uint96, uint256) {\n        uint96 safeMaxSupply =\n            safe96(maxSupplyAllowed, 'BABLToken::maxSupplyAllowed: maxSupplyAllowed exceeds 96 bits'); // Overflow check\n        return (safeMaxSupply, maxSupplyAllowedAfter);\n    }\n}\n"
    },
    "contracts/strategies/operations/AddLiquidityOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\n\n/**\n * @title AddLiquidityOperation\n * @author Babylon Finance\n *\n * Executes a add liquidity operation\n */\ncontract AddLiquidityOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the add liquidity operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(IPoolIntegration(_integration).isPool(_data), 'Not a valid pool');\n    }\n\n    /**\n     * Executes the add liquidity operation\n     * @param _capital      Amount of capital received from the garden\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _pool,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_pool);\n        uint256[] memory _maxAmountsIn = new uint256[](poolTokens.length);\n        uint256[] memory _poolWeights = IPoolIntegration(_integration).getPoolWeights(_pool);\n        // Get the tokens needed to enter the pool\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            _maxAmountsIn[i] = _getMaxAmountTokenPool(_asset, _capital, _garden, _poolWeights[i], poolTokens[i]);\n        }\n        uint256 poolTokensOut = IPoolIntegration(_integration).getPoolTokensOut(_pool, poolTokens[0], _maxAmountsIn[0]);\n        IPoolIntegration(_integration).joinPool(\n            msg.sender,\n            _pool,\n            poolTokensOut.sub(poolTokensOut.preciseMul(SLIPPAGE_ALLOWED)),\n            poolTokens,\n            _maxAmountsIn\n        );\n        return (_pool, IERC20(_pool).balanceOf(msg.sender), 0); // liquid\n    }\n\n    /**\n     * Exits the add liquidity operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external override onlyStrategy {\n        require(_percentage <= 100e18, 'Unwind Percentage <= 100%');\n        address pool = _data;\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(pool);\n        uint256 lpTokens = IERC20(pool).balanceOf(msg.sender).preciseMul(_percentage); // Sell all pool tokens\n        uint256[] memory _minAmountsOut = IPoolIntegration(_integration).getPoolMinAmountsOut(pool, lpTokens);\n        IPoolIntegration(_integration).exitPool(\n            msg.sender,\n            pool,\n            lpTokens, // Sell all pool tokens\n            poolTokens,\n            _minAmountsOut\n        );\n        // Exit Pool tokens\n        address reserveAsset = _garden.reserveAsset();\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] != reserveAsset) {\n                if (poolTokens[i] == address(0)) {\n                    IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n                } else {\n                    IStrategy(msg.sender).trade(\n                        poolTokens[i],\n                        IERC20(poolTokens[i]).balanceOf(msg.sender),\n                        reserveAsset\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the NAV of the add liquidity op in the reserve asset\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view override onlyStrategy returns (uint256) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return 0;\n        }\n        address pool = _data;\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(pool);\n        uint256 NAV;\n        uint256 totalSupply = IERC20(pool).totalSupply();\n        uint256 lpTokens = IERC20(pool).balanceOf(msg.sender);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            uint256 price = _getPrice(_garden.reserveAsset(), poolTokens[i] != address(0) ? poolTokens[i] : WETH);\n            uint256 balance = poolTokens[i] != address(0) ? IERC20(poolTokens[i]).balanceOf(pool) : pool.balance;\n            NAV += balance.mul(lpTokens).div(totalSupply).preciseDiv(price);\n        }\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return NAV;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getMaxAmountTokenPool(\n        address _asset,\n        uint256 _capital,\n        IGarden _garden,\n        uint256 _poolWeight,\n        address _poolToken\n    ) private returns (uint256) {\n        uint256 normalizedAmount = _capital.preciseMul(_poolWeight);\n        if (_poolToken != _asset && _poolToken != address(0)) {\n            IStrategy(msg.sender).trade(_asset, normalizedAmount, _poolToken);\n            return IERC20(_poolToken).balanceOf(msg.sender);\n        }\n        if (_poolToken == address(0)) {\n            if (_asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, normalizedAmount, WETH);\n            }\n            // Convert WETH to ETH\n            IStrategy(msg.sender).handleWeth(false, normalizedAmount);\n        }\n        return normalizedAmount;\n    }\n}\n"
    },
    "contracts/interfaces/IPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPoolIntegration\n * @author Babylon Finance\n *\n * Interface for liquiditypool protocol integrations\n */\ninterface IPoolIntegration {\n    function joinPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] memory _poolTokens,\n        uint256[] memory _maxAmountsIn\n    ) external;\n\n    function exitPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] memory _poolTokens,\n        uint256[] memory _minAmountsOut\n    ) external;\n\n    function getPoolTokens(address _poolAddress) external view returns (address[] memory);\n\n    function getPoolWeights(address _poolAddress) external view returns (uint256[] memory);\n\n    function getPoolTokensOut(\n        address _poolAdress,\n        address _tokenAddress,\n        uint256 _maxAmountsIn\n    ) external view returns (uint256);\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _poolTokenAmount)\n        external\n        view\n        returns (uint256[] memory _minAmountsOut);\n\n    function isPool(address _poolAddress) external view returns (bool);\n}\n"
    },
    "contracts/integrations/pool/PoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title PoolIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with trading protocols\n */\nabstract contract PoolIntegration is BaseIntegration, ReentrancyGuard, IPoolIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct PoolInfo {\n        IGarden garden; // Garden address\n        IStrategy strategy; // Strategy address\n        address pool; // Pool address\n        uint256 totalSupply; // Total Supply of the pool\n        uint256 poolTokensInTransaction; // Pool tokens affected by this transaction\n        uint256 poolTokensInStrategy; // Pool tokens strategy balance\n        uint256[] limitPoolTokenQuantities;\n    }\n\n    /* ============ Events ============ */\n\n    event PoolEntered(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensOut);\n\n    event PoolExited(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensIn);\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(\n        string memory _name,\n        address _weth,\n        address _controller\n    ) BaseIntegration(_name, _weth, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Joins a pool\n     *\n     * @param _strategy             Address of the strategy\n     * @param _poolAddress          Address of the pool token to join\n     * @param _poolTokensOut        Min amount of pool tokens to receive\n     * @param _tokensIn             Array of token addresses to deposit\n     * @param _maxAmountsIn         Array of max token quantities to pull out from the garden\n     */\n    function joinPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _poolAddress, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        _validatePreJoinPoolData(poolInfo);\n        // Approve spending of the tokens\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            // No need to approve ETH\n            if (_tokensIn[i] != address(0)) {\n                poolInfo.strategy.invokeApprove(_getSpender(_poolAddress), _tokensIn[i], _maxAmountsIn[i]);\n            }\n        }\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getJoinPoolCalldata(_strategy, _poolAddress, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        poolInfo.poolTokensInTransaction = IERC20(poolInfo.pool).balanceOf(address(poolInfo.strategy)).sub(\n            poolInfo.poolTokensInStrategy\n        );\n        _validatePostJoinPoolData(poolInfo);\n\n        emit PoolEntered(address(poolInfo.strategy), address(poolInfo.garden), poolInfo.pool, _poolTokensOut);\n    }\n\n    /**\n     * Exits a liquidity pool. Accrue protocol fee (if any)\n     *\n     * @param _strategy               Address of the strategy\n     * @param _poolAddress            Address of the pool token to join\n     * @param _poolTokensIn           Pool tokens to exchange for the underlying tokens\n     * @param _tokensOut              Array of token addresses to withdraw\n     * @param _minAmountsOut          Array of min token quantities to receive from the pool\n     */\n    function exitPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _poolAddress, _poolTokensIn, _tokensOut, _minAmountsOut);\n        _validatePreExitPoolData(poolInfo);\n        // Approve spending of the pool token\n        poolInfo.strategy.invokeApprove(_getSpender(_poolAddress), _poolAddress, _poolTokensIn);\n\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getExitPoolCalldata(_strategy, _poolAddress, _poolTokensIn, _tokensOut, _minAmountsOut);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        _validatePostExitPoolData(poolInfo);\n\n        emit PoolExited(address(poolInfo.strategy), address(poolInfo.garden), poolInfo.pool, _poolTokensIn);\n    }\n\n    /**\n     * Checks whether a pool address is valid\n     *\n     * @param _poolAddress                 Pool address to check\n     * @return bool                        True if the address is a pool\n     */\n    function isPool(address _poolAddress) external view override returns (bool) {\n        return _isPool(_poolAddress);\n    }\n\n    function getPoolTokens(\n        address /* _poolAddress */\n    ) external view virtual override returns (address[] memory);\n\n    function getPoolWeights(\n        address /*_poolAddress */\n    ) external view virtual override returns (uint256[] memory);\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return PoolInfo struct\n     *\n     * @param _strategy                      Address of the strategy\n     * @param _pool                          Address of the pool\n     * @param _poolTokensInTransaction       Number of pool tokens involved\n     * hparam _poolTokens                    Addresseses of the pool tokens\n     * @param _limitPoolTokenQuantities      Limit quantity of the pool tokens\n     *\n     * return PoolInfo             Struct containing data for pool\n     */\n    function _createPoolInfo(\n        address _strategy,\n        address _pool,\n        uint256 _poolTokensInTransaction,\n        address[] calldata, /* _poolTokens */\n        uint256[] calldata _limitPoolTokenQuantities\n    ) internal view returns (PoolInfo memory) {\n        PoolInfo memory poolInfo;\n        poolInfo.strategy = IStrategy(_strategy);\n        poolInfo.garden = IGarden(poolInfo.strategy.garden());\n        poolInfo.pool = _pool;\n        poolInfo.totalSupply = IERC20(_pool).totalSupply();\n        poolInfo.poolTokensInStrategy = IERC20(_pool).balanceOf(_strategy);\n        poolInfo.poolTokensInTransaction = _poolTokensInTransaction;\n        poolInfo.limitPoolTokenQuantities = _limitPoolTokenQuantities;\n\n        return poolInfo;\n    }\n\n    /**\n     * Validate pre pool join data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Min pool tokens to receive must be greater than 0');\n    }\n\n    /**\n     * Validate pre pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Pool tokens to exchange must be greater than 0');\n        require(\n            _poolInfo.poolTokensInStrategy >= _poolInfo.poolTokensInTransaction,\n            'The strategy does not have enough pool tokens'\n        );\n    }\n\n    /**\n     * Validate post join pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            (IERC20(_poolInfo.pool).balanceOf(address(_poolInfo.strategy)) > _poolInfo.poolTokensInStrategy),\n            'The strategy did not receive the pool tokens'\n        );\n    }\n\n    /**\n     * Validate post exit pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            IERC20(_poolInfo.pool).balanceOf(address(_poolInfo.strategy)) ==\n                _poolInfo.poolTokensInStrategy - _poolInfo.poolTokensInTransaction,\n            'The strategy did not return the pool tokens'\n        );\n        // TODO: validate individual tokens received\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * hparam  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address, /* _poolAddress */\n        uint256, /* _poolTokensOut */\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata /* _maxAmountsIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * hparam  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address, /* _poolAddress */\n        uint256, /* _poolTokensIn */\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata /* _minAmountsOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _isPool(\n        address /* _poolAddress */\n    ) internal view virtual returns (bool);\n\n    function _getSpender(\n        address /* _poolAddress */\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/pool/UniswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IUniswapV2Router} from '../../interfaces/external/uniswap/IUniswapV2Router.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Kyber protocol trade integration\n */\ncontract UniswapPoolIntegration is PoolIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IUniswapV2Router public uniRouter;\n\n    /* ============ Constants ============ */\n\n    uint8 public immutable MAX_DELTA_BLOCKS = 5;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _uniswapRouterAddress         Address of Uniswap router\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _uniswapRouterAddress\n    ) PoolIntegration('uniswap_pool', _weth, _controller) {\n        uniRouter = IUniswapV2Router(_uniswapRouterAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        address[] memory result = new address[](2);\n        result[0] = IUniswapV2Pair(_poolAddress).token0();\n        result[1] = IUniswapV2Pair(_poolAddress).token1();\n        return result;\n    }\n\n    function getPoolWeights(\n        address /* _poolAddress */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address, /* _poolAddress */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        uint256 totalSupply = IUniswapV2Pair(_poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        result[0] = IERC20(IUniswapV2Pair(_poolAddress).token0())\n            .balanceOf(_poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = IERC20(IUniswapV2Pair(_poolAddress).token1())\n            .balanceOf(_poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal pure override returns (bool) {\n        return IUniswapV2Pair(_poolAddress).MINIMUM_LIQUIDITY() > 0;\n    }\n\n    function _getSpender(\n        address //_poolAddress\n    ) internal view override returns (address) {\n        return address(uniRouter);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address _strategy,\n        address, /* _poolAddress */\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        return (address(uniRouter), 0, _getMethodData(_strategy, _tokensIn, _maxAmountsIn));\n    }\n\n    function _getMethodData(\n        address _strategy,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) private view returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                'addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)',\n                _tokensIn[0],\n                _tokensIn[1],\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED)),\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address _strategy,\n        address, /* _poolAddress */\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)',\n                _tokensOut[0],\n                _tokensOut[1],\n                _poolTokensIn,\n                _minAmountsOut[0],\n                _minAmountsOut[1],\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n\n        return (address(uniRouter), 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV2Router.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/integrations/trade/KyberTradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IKyberNetworkProxy} from '../../interfaces/external/kyber/IKyberNetworkProxy.sol';\n\n/**\n * @title KyberTradeIntegration\n * @author Babylon Finance Protocol\n *\n * Kyber protocol trade integration\n */\ncontract KyberTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Kyber Network Proxy\n    address public kyberNetworkProxyAddress;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _kyberNetworkProxyAddress    Address of Kyber Network Proxy contract\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _kyberNetworkProxyAddress\n    ) TradeIntegration('kyber', _weth, _controller) {\n        kyberNetworkProxyAddress = _kyberNetworkProxyAddress;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the conversion rate between the source token and the destination token\n     * in 18 decimals, regardless of component token's decimals\n     *\n     * @param  _sourceToken        Address of source token to be sold\n     * @param  _destinationToken   Address of destination token to buy\n     * @param  _sourceQuantity     Amount of source token to sell\n     *\n     * @return uint256             Conversion rate in wei\n     * @return uint256             Slippage rate in wei\n     */\n    function getConversionRates(\n        address _sourceToken,\n        address _destinationToken,\n        uint256 _sourceQuantity\n    ) external view override returns (uint256, uint256) {\n        // Get Kyber expectedRate to trade with\n        return\n            IKyberNetworkProxy(kyberNetworkProxyAddress).getExpectedRate(\n                _sourceToken,\n                _destinationToken,\n                _sourceQuantity\n            );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Get calldata through Kyber.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // this has 3 percent slippage and doesn't account for the platform fee\n        (, uint256 worstRate) =\n            IKyberNetworkProxy(kyberNetworkProxyAddress).getExpectedRate(_sendToken, _receiveToken, _sendQuantity);\n\n        // Encode method data for TradeIntegration to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'trade(address,uint256,address,address,uint256,uint256,address)',\n                _sendToken,\n                _sendQuantity,\n                _receiveToken,\n                _strategy,\n                PreciseUnitMath.maxUint256(), // Sell entire amount of sourceToken\n                worstRate, // Trade with implied conversion rate\n                _strategy // Strategy address\n            );\n\n        return (kyberNetworkProxyAddress, 0, methodData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the Kyber Network\n     * Proxy address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender() internal view override returns (address) {\n        return kyberNetworkProxyAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/kyber/IKyberNetworkProxy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\ninterface IKyberNetworkProxy {\n    function getExpectedRate(\n        address _src,\n        address _dest,\n        uint256 _srcQty\n    ) external view returns (uint256, uint256);\n\n    function trade(\n        address _src,\n        uint256 _srcAmount,\n        address _dest,\n        address _destAddress,\n        uint256 _maxDestAmount,\n        uint256 _minConversionRate,\n        address _referalFeeAddress\n    ) external payable returns (uint256);\n}\n"
    },
    "contracts/integrations/lend/AaveLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {AaveToken} from '../../interfaces/external/aave/AaveToken.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/external/aave/ILendingPoolAddressesProvider.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title AaveLendIntegration\n * @author Babylon Finance Protocol\n *\n * Aave lend integration.\n */\ncontract AaveLendIntegration is LendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Constant ============ */\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _weth                   Address of the WETH ERC20\n     * @param _controller             Address of the controller\n     */\n    constructor(address _controller, address _weth) LendIntegration('aavelend', _weth, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress != address(0);\n    }\n\n    function _getExpectedShares(\n        address, /* _assetToken */\n        uint256 _numTokensToSupply\n    ) internal pure override returns (uint256) {\n        // love it \n        return _numTokensToSupply;\n    }\n\n    function _getExchangeRatePerToken(\n        address /* _assetToken */\n    ) internal pure override returns (uint256) {\n        // love it \n        return 1;\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(address,uint256,address,uint16)',\n                _assetToken,\n                _numTokensToSupply,\n                _strategy,\n                0\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Returns calldata for redeeming the collateral\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getRedeemCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('withdraw(address,uint256,address)', _assetToken, _numTokensToSupply, _strategy);\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getSpender(\n        address /* _investmentAddress */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/AaveToken.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the gardens on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the gardens\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the gardens, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if gardens can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/IshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title IshtarGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists for Babylon Finance using an NFT\n */\ncontract IshtarGate is ERC721, IIshtarGate, Ownable {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event IshtarGateAwarded(address indexed _member, uint256 indexed _newItemId);\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission, uint256 _tokenId);\n    event GardenCreationPower(address indexed _member, bool _creation, uint256 _tokenId);\n    event GateURIUpdated(string indexed _newURI, string indexed _oldURI);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    // Address of the Ishtar Gate JSON (Shared JSON)\n    string public override tokenURI;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => uint256) public gardenAccessCount;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == address(controller), 'Controller must match');\n        require(msg.sender == garden.creator(), 'Only creator can give access to garden');\n        require(gardenAccessCount[_garden] < maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _tokenURI           URL of the Ishtar Gate JSON metadata\n     */\n    constructor(IBabController _controller, string memory _tokenURI) ERC721('IshtarGate', 'ISHT') {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n        tokenURI = _tokenURI;\n        maxNumberOfInvites = 10;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Updates the token URI of the gate NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateGardenURI(string memory _tokenURI) external override onlyOwner {\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit GateURIUpdated(tokenURI, oldURI);\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override onlyGardenCreator(_garden) returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && permissionsByCommunity[_garden][_user] >= JUST_LP;\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && permissionsByCommunity[_garden][_user] >= STEWARD;\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && permissionsByCommunity[_garden][_user] >= STRATEGIST;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new gate to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetGateNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit IshtarGateAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        emit GardenAccess(_user, _garden, _permission, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate, newItemId);\n        return newItemId;\n    }\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {ITimelock} from '../interfaces/ITimelock.sol';\n\n// TODO: Do a diff to check for changes\ncontract Timelock is ITimelock {\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    uint256 public constant override GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public override delay;\n\n    mapping(bytes32 => bool) public override queuedTransactions;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY, 'Timelock::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'Timelock::setDelay: Delay must not exceed maximum delay.');\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    /* ============ Fallback ============ */\n\n    fallback() external payable {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    function setDelay(uint256 delay_) external {\n        require(msg.sender == address(this), 'Timelock::setDelay: Call must come from Timelock.');\n        require(delay_ >= MINIMUM_DELAY, 'Timelock::setDelay: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'Timelock::setDelay: Delay must not exceed maximum delay.');\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() external override {\n        require(msg.sender == pendingAdmin, 'Timelock::acceptAdmin: Call must come from pendingAdmin.');\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) external {\n        require(msg.sender == address(this), 'Timelock::setPendingAdmin: Call must come from Timelock.');\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external override returns (bytes32) {\n        require(msg.sender == admin, 'Timelock::queueTransaction: Call must come from admin.');\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            'Timelock::queueTransaction: Estimated execution block must satisfy delay.'\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external override {\n        require(msg.sender == admin, 'Timelock::cancelTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external payable override returns (bytes memory) {\n        require(msg.sender == admin, 'Timelock::executeTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], 'Transaction is not queued');\n        require(getBlockTimestamp() >= eta, 'Transaction is too young');\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), 'Transaction is stale');\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, 'Timelock::executeTransaction: Transaction execution reverted.');\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\ninterface ITimelock {\n    function delay() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ITimelock} from '../interfaces/ITimelock.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\n\n// TODO: Do a diff to check for changes\ncontract GovernorAlpha is Ownable {\n    /* ============ Events ============ */\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The name of this contract\n    string public constant name = 'BABL Governor Alpha';\n\n    /// @notice The address of the BABL Protocol Timelock\n    ITimelock public timelock;\n\n    /// @notice The address of the BABL governance token\n    IVoteToken public babl;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint256) {\n        return 40_000e18;\n    } // 4% of BABL\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint256) {\n        return 10_000e18;\n    } // 1% of BABL\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10;\n    } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint256) {\n        return 1;\n    } // 1 block TODO - CHECK DELAY TO PROPOSE\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint256) {\n        return 7 days;\n    } // TODO - CHECK AND AGREE ON THE VOTING PERIOD\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // @notice Unique id for looking up a proposal\n        uint256 id;\n        // @notice Creator of the proposal\n        address proposer;\n        // @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        // @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        // @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        // @notice The ordered list of function signatures to be called\n        string[] signatures;\n        // @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        // @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        // @notice Flag marking whether the proposal has been executed\n        bool executed;\n        // @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // @notice Whether or not a vote has been cast\n        bool hasVoted;\n        // @notice Whether or not the voter supports the proposal\n        bool support;\n        // @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,bool support)');\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a GovernorAlpha and gives ownership to sender\n     * @param timelock_ is the address of the timelock instance\n     * @param babl_ is the instance of the BABL Token instance\n     * @param guardian_ the Pause Guardian address capable of disabling protocol functionality. Used only in the event\n     * of an unforeseen vulnerability.\n     */\n\n    constructor(\n        address timelock_,\n        address babl_,\n        address guardian_\n    ) {\n        timelock = ITimelock(timelock_);\n        babl = IVoteToken(babl_);\n        guardian = guardian_;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to propose governance actions\n     *\n     * @notice Propose new governance actions. Depends on power voting capacity of idea proposer\n     * @param targets The array of addresses as destination targets\n     * @param values The array of values\n     * @param signatures The array of signatures\n     * @param calldatas The array of calldatas to be executed as part of the proposals\n     * @param description The description of the proposal\n     * @return The proposal id created if it was successfully created\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256) {\n        require(\n            babl.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(),\n            'GovernorAlpha::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'GovernorAlpha::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'GovernorAlpha::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations(), 'GovernorAlpha::propose: too many actions');\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'GovernorAlpha::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to queue a specific proposal\n     *\n     * @notice Allows to queue a specific proposal in state = Succeeded\n     * @param proposalId The ID of the proposal\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'GovernorAlpha::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to queue or revert a transaction part of a proposal within the timelock\n     *\n     * @notice Allows to queue or revert a transaction part of a proposal (not queued earlier) within the timelock\n     * @param target The addresses of the target\n     * @param value The uint values\n     * @param signature The signature\n     * @param data The data\n     * @param eta The timestamp of allowed execution\n     */\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'GovernorAlpha::_queueOrRevert: proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to execute a queued (state = queued) proposal\n     *\n     * @notice Allows to queue or revert a transaction part of a proposal (not queued earlier) within the timelock\n     * @param proposalId The ID of the proposal\n     */\n    function execute(uint256 proposalId) external payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'GovernorAlpha::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: (proposal.values[i])}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the msg.sender to cast a vote\n     *\n     * @notice Allows the msg.sender to cast a vote\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     */\n    function castVote(uint256 proposalId, bool support) external {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the cast of a vote by signature\n     *\n     * @notice Allows the cast of a vote by signature\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'GovernorAlpha::castVoteBySig: invalid signature');\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to cancel a proposal if state != executed\n     *\n     * @notice Allows the Pause Guardian to cancel a proposal if state != executed\n     * @param proposalId The ID of the proposal\n     */\n    function cancel(uint256 proposalId) external {\n        ProposalState _state = state(proposalId);\n        require(_state != ProposalState.Executed, 'GovernorAlpha::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n        // A Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(\n            msg.sender == guardian ||\n                babl.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(),\n            'GovernorAlpha::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to execute acceptAdmin in the timelock instance\n     *\n     * @notice Allows the Pause Guardian to execute acceptAdmin in the timelock instance\n     */\n    function __acceptAdmin() external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__acceptAdmin: sender must be gov guardian');\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to abdicate as Guardian\n     *\n     * @notice Allows the Pause Guardian to abdicate as Guardian\n     */\n    function __abdicate() external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__abdicate: sender must be gov guardian');\n        guardian = address(0);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to queue a set of timelock pending admin\n     *\n     * @notice Allows the Pause Guardian to queue a set of timelock pending admin\n     */\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian');\n        timelock.queueTransaction(address(timelock), 0, 'setPendingAdmin(address)', abi.encode(newPendingAdmin), eta);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to execute the set of timelock pending admin\n     *\n     * @notice Allows the Pause Guardian to execute the set of timelock pending admin\n     */\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian');\n        timelock.executeTransaction(address(timelock), 0, 'setPendingAdmin(address)', abi.encode(newPendingAdmin), eta);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to  check the list of actions of a proposal\n     *\n     * @notice Allows the caller to check the list of actions of a proposal\n     * @param proposalId The ID of the proposal\n     * @return targets of the proposalId\n     * @return values of the proposalId\n     * @return signatures of the proposalId\n     * @return calldatas of the proposalId\n     *\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to get the receipt of the voter for a specific proposalId\n     *\n     * @notice Allows the caller to get the receipt of the voter for a specific proposalId\n     * @param proposalId The ID of the proposal\n     * @param voter The ID of the proposal\n     * @return The receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to get the state a specific proposalId\n     *\n     * @notice Allows the caller to get the state a specific proposalId\n     * @return The proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, 'GovernorAlpha::state: invalid proposal id');\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the voter to cast a vote\n     *\n     * @dev Allows the voter to cast a vote\n     * @param voter The address of the voter\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     */\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(state(proposalId) == ProposalState.Active, 'GovernorAlpha::_castVote: voting is closed');\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'GovernorAlpha::_castVote: voter already voted');\n        uint96 votes = babl.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /**\n     * INTERNAL SAFE MATH FUNCTION. Safe add two uint256 values checking overflow returning uint\n     *\n     * @dev Safe add two uint256 values checking overflow\n     */\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'addition overflow');\n        return c;\n    }\n\n    /**\n     * INTERNAL SAFE MATH FUNCTION. Safe sub two uint256 values checking underflow returning uint\n     *\n     * @dev Safe sub two uint256 values checking overflow\n     */\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, 'subtraction underflow');\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/GardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\n\n/**\n * @title GardenValuer\n * @author Babylon Finance\n *\n * Contract that returns the valuation of a Garden using price oracle data used in contracts\n * that are external to the system.\n *\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract GardenValuer {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    address public controller;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _controller             Address of controller contract\n     */\n    constructor(address _controller) {\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Gets the valuation of a Garden using data from the price oracle.\n     * Adds all the active strategies plus the reserve asset and ETH.\n     * Note: this works for external\n     * positions and negative (debt) positions.\n     *\n     * Note: There is a risk that the valuation is off if airdrops aren't retrieved\n     *\n     * @param _garden          Garden instance to get valuation\n     *\n     * @return                 Token valuation in terms of quote asset in precise units 1e18\n     */\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256) {\n        IPriceOracle priceOracle = IPriceOracle(IBabController(controller).priceOracle());\n        address reserveAsset = IGarden(_garden).reserveAsset();\n\n        uint256 reservePrice;\n        // Get price of the reserveAsset in _quoteAsset\n        if (reserveAsset == _quoteAsset) {\n            // meaning 1 reserveAsset equals to 1 _quoteAsset\n            reservePrice = 1 ether;\n        } else {\n            reservePrice = priceOracle.getPrice(reserveAsset, _quoteAsset);\n        }\n\n        uint256 wethPrice;\n        // Get price of the WETH in _quoteAsset\n        if (_quoteAsset == WETH) {\n            // meaning 1 WETH equals to 1 _quoteAsset\n            // this line looks ironic. 10/10.\n            wethPrice = 1 ether;\n        } else {\n            wethPrice = priceOracle.getPrice(WETH, _quoteAsset);\n        }\n\n        address[] memory strategies = IGarden(_garden).getStrategies();\n        uint256 valuation;\n        for (uint256 j = 0; j < strategies.length; j++) {\n            IStrategy strategy = IStrategy(strategies[j]);\n            // strategies return their valuation in garden's reserveAsset\n            valuation = valuation.add(strategy.getNAV());\n        }\n\n        // Recalculate the valuation in the _quoteAsset prices\n        valuation = valuation.preciseMul(reservePrice);\n\n        // Add garden's reserve asset to calculations\n        valuation = valuation.add(IERC20(reserveAsset).balanceOf(address(_garden)).preciseMul(reservePrice));\n\n        // Adds ETH of garden in _quoteAsset prices\n        valuation = valuation.add(address(_garden).balance.preciseMul(wethPrice));\n\n        return valuation.preciseDiv(IERC20(_garden).totalSupply());\n    }\n}\n"
    },
    "contracts/mocks/BabControllerV2Mock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabControllerV2Mock is OwnableUpgradeable {\n    using AddressArrayUtils for address[];\n    using AddressUpgradeable for address;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n    address public constant UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address public gardenValuer;\n    address public priceOracle;\n    address public gardenFactory;\n    address public rewardsDistributor;\n    address public ishtarGate;\n    address public strategyFactory;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations;\n    // Address of the default trade integration used by the protocol\n    address public defaultTradeIntegration;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) public assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Recipient of protocol fees\n    address public treasury;\n\n    // Strategy cooldown period\n    uint256 public constant MIN_COOLDOWN_PERIOD = 6 hours;\n    uint256 public constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    // Strategy Profit Sharing\n    uint256 public strategistProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsProfitPercentage; //\n\n    // Strategy BABL Rewards Sharing\n    uint256 public strategistBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsBABLPercentage; //\n\n    uint256 public gardenCreatorBonus;\n\n    // Assets\n    // Absolute Min liquidity of assets for risky gardens 1000 ETH\n    uint256 public minRiskyPairLiquidityEth;\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public allowPublicGardens;\n\n    uint256 public protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 public protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 public protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    bool public newVar;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        gardenTokensTransfersEnabled = false;\n        bablMiningProgramEnabled = false;\n        minRiskyPairLiquidityEth = 1000 * 1e18;\n\n        strategistProfitPercentage = 10e16;\n        stewardsProfitPercentage = 5e16;\n        lpsProfitPercentage = 80e16;\n\n        strategistBABLPercentage = 8e16;\n        stewardsBABLPercentage = 17e16;\n        lpsBABLPercentage = 75e16;\n\n        gardenCreatorBonus = 15e16;\n    }\n\n    /* ============ External Functions ============ */\n\n    function newMethod() public pure returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "contracts/integrations/pool/SushiswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {UniswapPoolIntegration} from './UniswapPoolIntegration.sol';\n\n/**\n * @title SushiswapPoolIntegration\n * @author Babylon Finance Protocol\n *\n * Sushiswap Protocol pool integration\n */\ncontract SushiswapPoolIntegration is UniswapPoolIntegration {\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _sushiswapRouterAddress         Address of Sushiswap router\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _sushiswapRouterAddress\n    ) UniswapPoolIntegration(_controller, _weth, _sushiswapRouterAddress) {\n        name = 'sushiswap_pool';\n    }\n}\n"
    },
    "contracts/integrations/pool/OneInchPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IMooniswapFactory} from '../../interfaces/external/1inch/IMooniswapFactory.sol';\nimport {IMooniswap} from '../../interfaces/external/1inch/IMooniswap.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Kyber protocol trade integration\n */\ncontract OneInchPoolIntegration is PoolIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IMooniswapFactory public mooniswapFactory;\n\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _mooniswapFactoryAddress         Address of the Mooniswap factory\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _mooniswapFactoryAddress\n    ) PoolIntegration('oneinch_pool', _weth, _controller) {\n        mooniswapFactory = IMooniswapFactory(_mooniswapFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        return IMooniswap(_poolAddress).getTokens();\n    }\n\n    function getPoolWeights(\n        address /* _poolAddress */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address, /* _poolAddress */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address[] memory tokens = IMooniswap(_poolAddress).getTokens();\n        uint256 totalSupply = IMooniswap(_poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        uint256 token0Balance =\n            (tokens[0] != address(0) ? IERC20(tokens[0]).balanceOf(_poolAddress) : _poolAddress.balance);\n        uint256 token1Balance =\n            (tokens[1] != address(0) ? IERC20(tokens[1]).balanceOf(_poolAddress) : _poolAddress.balance);\n        result[0] = token0Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = token1Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal view override returns (bool) {\n        return IMooniswapFactory(mooniswapFactory).isPool(IMooniswap(_poolAddress));\n    }\n\n    function _getSpender(address _poolAddress) internal pure override returns (address) {\n        return _poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(uint256[2],uint256[2])',\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED * 2)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED * 2))\n            );\n        uint256 value = 0;\n        // Add ETH if one of the tokens\n        if (_tokensIn[0] == address(0)) {\n            value = _maxAmountsIn[0];\n        }\n        if (_tokensIn[1] == address(0)) {\n            value = _maxAmountsIn[1];\n        }\n\n        return (address(_poolAddress), value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (address(_poolAddress), 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './IMooniswap.sol';\nimport './IMooniswapFactoryGovernance.sol';\n\ninterface IMooniswapFactory is IMooniswapFactoryGovernance {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n\n    function isPool(IMooniswap mooniswap) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IMooniswap is IERC20 {\n    function getTokens() external view returns (address[] memory _tokens);\n\n    function tokens(uint256 i) external view returns (IERC20);\n\n    function getBalanceForAddition(IERC20 token) external view returns (uint256);\n\n    function getBalanceForRemoval(IERC20 token) external view returns (uint256);\n\n    function getReturn(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts)\n        external\n        payable\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function depositFor(\n        uint256[2] memory maxAmounts,\n        uint256[2] memory minAmounts,\n        address target\n    ) external payable returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function withdraw(uint256 amount, uint256[] memory minReturns)\n        external\n        returns (uint256[2] memory withdrawnAmounts);\n\n    function withdrawFor(\n        uint256 amount,\n        uint256[] memory minReturns,\n        address payable target\n    ) external returns (uint256[2] memory withdrawnAmounts);\n\n    function swap(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    ) external payable returns (uint256 result);\n\n    function swapFor(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral,\n        address payable receiver\n    ) external payable returns (uint256 result);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactoryGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IMooniswapFactoryGovernance {\n    function shareParameters()\n        external\n        view\n        returns (\n            uint256 _referralShare,\n            uint256 _governanceShare,\n            address _governanceWallet,\n            address _referralFeeReceiver\n        );\n\n    function defaults()\n        external\n        view\n        returns (\n            uint256 _defaultFee,\n            uint256 _defaultSlippageFee,\n            uint256 _defaultDecayPeriod\n        );\n\n    function defaultFee() external view returns (uint256);\n\n    function defaultSlippageFee() external view returns (uint256);\n\n    function defaultDecayPeriod() external view returns (uint256);\n\n    function virtualDefaultFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultSlippageFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultDecayPeriod()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function referralShare() external view returns (uint256);\n\n    function governanceShare() external view returns (uint256);\n\n    function governanceWallet() external view returns (address);\n\n    function feeCollector() external view returns (address);\n\n    function isFeeCollector(address) external view returns (bool);\n\n    function isActive() external view returns (bool);\n}\n"
    },
    "contracts/integrations/pool/BalancerIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IBFactory} from '../../interfaces/external/balancer/IBFactory.sol';\nimport {IBPool} from '../../interfaces/external/balancer/IBPool.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Kyber protocol trade integration\n */\ncontract BalancerIntegration is PoolIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Kyber Network Proxy\n    IBFactory public coreFactory;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _weth                         Address of the WETH ERC20\n     * @param _coreFactoryAddress           Address of Balancer core factory address\n     */\n    constructor(\n        address _controller,\n        address _weth,\n        address _coreFactoryAddress\n    ) PoolIntegration('balancer', _weth, _controller) {\n        coreFactory = IBFactory(_coreFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        return IBPool(_poolAddress).getCurrentTokens();\n    }\n\n    function getPoolWeights(address _poolAddress) external view override returns (uint256[] memory) {\n        address[] memory poolTokens = IBPool(_poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint8 i = 0; i < poolTokens.length; i++) {\n            result[i] = IBPool(_poolAddress).getNormalizedWeight(poolTokens[i]);\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address _poolAddress,\n        address _poolToken,\n        uint256 _maxAmountsIn\n    ) external view override returns (uint256) {\n        uint256 tokenBalance = IBPool(_poolAddress).getBalance(_poolToken);\n        return IBPool(_poolAddress).totalSupply().preciseMul(_maxAmountsIn.preciseDiv(tokenBalance));\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        uint256 lpTokensTotalSupply = IBPool(_poolAddress).totalSupply();\n        address[] memory poolTokens = IBPool(_poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            result[i] = IERC20(poolTokens[i])\n                .balanceOf(_poolAddress)\n                .mul(_liquidity)\n                .div(lpTokensTotalSupply)\n                .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        }\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal view override returns (bool) {\n        return coreFactory.isBPool(_poolAddress);\n    }\n\n    function _getSpender(address _poolAddress) internal pure override returns (address) {\n        return _poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _poolAddress              Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('joinPool(uint256,uint256[])', _poolTokensOut, _maxAmountsIn);\n\n        return (_poolAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('exitPool(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (_poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/balancer/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IBPool} from './IBPool.sol';\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n\n    function newBPool() external returns (IBPool);\n}\n"
    },
    "contracts/interfaces/external/balancer/IBPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IBPool {\n    function isPublicSwap() external view returns (bool);\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address t) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getCurrentTokens() external view returns (address[] memory tokens);\n\n    function getFinalTokens() external view returns (address[] memory tokens);\n\n    function getDenormalizedWeight(address token) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getNormalizedWeight(address token) external view returns (uint256);\n\n    function getBalance(address token) external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function getController() external view returns (address);\n\n    function setSwapFee(uint256 swapFee) external;\n\n    function setController(address manager) external;\n\n    function setPublicSwap(bool external_) external;\n\n    function finalize() external;\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function unbind(address token) external;\n\n    function gulp(address token) external;\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut);\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external returns (uint256 tokenAmountIn);\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 tokenAmountOut);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) external pure returns (uint256 spotPrice);\n\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountIn);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}