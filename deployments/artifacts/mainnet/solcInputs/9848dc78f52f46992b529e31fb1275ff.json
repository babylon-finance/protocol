{
  "language": "Solidity",
  "sources": {
    "contracts/BabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IGardenFactory} from './interfaces/IGardenFactory.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IIntegration} from './interfaces/IIntegration.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\nimport {LowGasSafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabController is OwnableUpgradeable, IBabController {\n    using AddressArrayUtils for address[];\n    using AddressUpgradeable for address;\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n    event GardenAdded(address indexed _garden, address indexed _factory);\n    event GardenRemoved(address indexed _garden);\n\n    event ControllerIntegrationAdded(address _integration, string indexed _integrationName);\n    event ControllerIntegrationRemoved(address _integration, string indexed _integrationName);\n    event ControllerIntegrationEdited(address _newIntegration, string indexed _integrationName);\n    event ControllerOperationSet(uint8 indexed _kind, address _address);\n    event DefaultTradeIntegrationChanged(address indexed _newTradeIntegration, address _oldTradeIntegration);\n\n    event ReserveAssetAdded(address indexed _reserveAsset);\n    event ReserveAssetRemoved(address indexed _reserveAsset);\n    event LiquidityMinimumEdited(address indexed _resesrveAsset, uint256 _newMinLiquidityReserve);\n\n    event PriceOracleChanged(address indexed _priceOracle, address _oldPriceOracle);\n    event RewardsDistributorChanged(address indexed _rewardsDistributor, address _oldRewardsDistributor);\n    event TreasuryChanged(address _newTreasury, address _oldTreasury);\n    event IshtarGateChanged(address _newIshtarGate, address _oldIshtarGate);\n    event GardenValuerChanged(address indexed _gardenValuer, address _oldGardenValuer);\n    event GardenFactoryChanged(address indexed _gardenFactory, address _oldGardenFactory);\n    event UniswapFactoryChanged(address indexed _newUniswapFactory, address _oldUniswapFactory);\n    event GardenNFTChanged(address indexed _newGardenNFT, address _oldStrategyNFT);\n    event StrategyNFTChanged(address indexed _newStrategyNFT, address _oldStrategyNFT);\n\n    event StrategyFactoryEdited(address indexed _strategyFactory, address _oldStrategyFactory);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address _oldPauseGuardian, address _newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string _action, bool _pauseState);\n\n    /// @notice Emitted when an action is paused individually\n    event ActionPausedIndividually(string _action, address _address, bool _pauseState);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address private uniswapFactory; // do not use\n    address public override gardenValuer;\n    address public override priceOracle;\n    address public override gardenFactory;\n    address public override rewardsDistributor;\n    address public override ishtarGate;\n    address public override strategyFactory;\n    address public override gardenNFT;\n    address public override strategyNFT;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations;\n    // Address of the default trade integration used by the protocol\n    address public override defaultTradeIntegration;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public override enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public override isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) public assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Mapping of minimum liquidity per reserve asset\n    mapping(address => uint256) public override minLiquidityPerReserve;\n\n    // Recipient of protocol fees\n    address public override treasury;\n\n    // Strategy cooldown period\n    uint256 public constant MIN_COOLDOWN_PERIOD = 6 hours;\n    uint256 public constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    // Strategy Profit Sharing\n    uint256 public strategistProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsProfitPercentage; //\n\n    // Strategy BABL Rewards Sharing\n    uint256 public strategistBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsBABLPercentage; //\n\n    uint256 public gardenCreatorBonus;\n\n    // Assets\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public override gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public override bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public override allowPublicGardens;\n\n    uint256 public override protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public override protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    // Maximum number of contributors per garden\n    uint256 public override maxContributorsPerGarden;\n\n    // Enable garden creations to be fully open to the public (no need of Ishtar gate anymore)\n    bool public override gardenCreationIsOpen;\n\n    // Pause Guardian\n    address public guardian;\n    mapping(address => bool) public override guardianPaused;\n    bool public override guardianGlobalPaused;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        strategistProfitPercentage = 10e16;\n        stewardsProfitPercentage = 5e16;\n        lpsProfitPercentage = 80e16;\n\n        strategistBABLPercentage = 8e16;\n        stewardsBABLPercentage = 17e16;\n        lpsBABLPercentage = 75e16;\n\n        gardenCreatorBonus = 15e16;\n        maxContributorsPerGarden = 100;\n        gardenCreationIsOpen = false;\n    }\n\n    /* ============ External Functions ============ */\n\n    // ===========  Garden related Gov Functions ======\n    /**\n     * Creates a Garden smart contract and registers the Garden with the controller.\n     *\n     * If asset is not WETH, the creator needs to approve the controller\n     * @param _reserveAsset           Reserve asset of the Garden. Initially just weth\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _gardenParams           Array of numeric garden params\n     * @param _tokenURI               Garden NFT token URI\n     * @param _seed                   Seed to regenerate the garden NFT\n     * @param _initialContribution    Initial contribution by the gardener\n     */\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) external payable override returns (address) {\n        require(defaultTradeIntegration != address(0), 'Need a default trade integration');\n        require(enabledOperations.length > 0, 'Need operations enabled');\n        require(\n            IIshtarGate(ishtarGate).canCreate(msg.sender) || gardenCreationIsOpen,\n            'User does not have creation permissions'\n        );\n        address newGarden =\n            IGardenFactory(gardenFactory).createGarden(\n                _reserveAsset,\n                msg.sender,\n                _name,\n                _symbol,\n                _tokenURI,\n                _seed,\n                _gardenParams,\n                _initialContribution\n            );\n        if (_reserveAsset != WETH || msg.value == 0) {\n            IERC20(_reserveAsset).transferFrom(msg.sender, address(this), _initialContribution);\n            IERC20(_reserveAsset).approve(newGarden, _initialContribution);\n        }\n        require(!isGarden[newGarden], 'Garden already exists');\n        isGarden[newGarden] = true;\n        gardens.push(newGarden);\n        IGarden(newGarden).deposit{value: msg.value}(_initialContribution, _initialContribution, msg.sender, true);\n        emit GardenAdded(newGarden, msg.sender);\n        return newGarden;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a Garden\n     *\n     * @param _garden               Address of the Garden contract to remove\n     */\n    function removeGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        require(!IGarden(_garden).active(), 'The garden needs to be disabled.');\n        gardens = gardens.remove(_garden);\n\n        delete isGarden[_garden];\n\n        emit GardenRemoved(_garden);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to disable a garden\n     *\n     * @param _garden               Address of the garden\n     */\n    function disableGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.active(), 'The garden needs to be active.');\n        garden.setActive(false);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to enable a garden\n     *\n     * @param _garden               Address of the garden\n     */\n    function enableGarden(address _garden) external onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        IGarden garden = IGarden(_garden);\n        require(!garden.active(), 'The garden needs to be disabled.');\n        garden.setActive(true);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to enable public creation of gardens\n     *\n     */\n    function openPublicGardenCreation() external override onlyOwner {\n        require(!gardenCreationIsOpen, 'Garden creation is already open to the public');\n        gardenCreationIsOpen = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 gardenTokens\n     * Can only happen after 2021 is finished.\n     */\n    function enableGardenTokensTransfers() external override onlyOwner {\n        require(block.timestamp > 1641024000000, 'Transfers cannot be enabled yet');\n        gardenTokensTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows public gardens\n     */\n    function setAllowPublicGardens() external override onlyOwner {\n        allowPublicGardens = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Change the max number of contributors for new Gardens since the change\n     */\n    function setMaxContributorsPerGarden(uint256 _newMax) external override onlyOwner {\n        require(_newMax >= 1, 'Contributors cannot be less than 1 per garden');\n        maxContributorsPerGarden = _newMax;\n    }\n\n    // ===========  Protocol related Gov Functions ======\n\n    /**  PRIVILEGED GOVERNANCE FUNCTION. Enable and starts the BABL Mining program by the Rewards Distributor\n     * Can only happen after public launch of the protocol.\n     */\n    function enableBABLMiningProgram() external override onlyOwner {\n        if (bablMiningProgramEnabled == false) {\n            // Can only be activated once\n            bablMiningProgramEnabled = true;\n            IRewardsDistributor(rewardsDistributor).startBABLRewards(); // Sets the timestamp\n        }\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid keeper to the list\n     *\n     * @param _keeper Address of the keeper\n     */\n    function addKeeper(address _keeper) external override onlyOwner {\n        keeperList[_keeper] = true;\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Removes a keeper\n     *\n     * @param _keeper Address of the keeper\n     */\n    function removeKeeper(address _keeper) external override onlyOwner {\n        require(keeperList[_keeper], 'Keeper is whitelisted');\n        delete keeperList[_keeper];\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a list of assets to the whitelist\n     *\n     * @param _keepers List with keeprs of the assets to whitelist\n     */\n    function addKeepers(address[] memory _keepers) external override onlyOwner {\n        for (uint256 i = 0; i < _keepers.length; i++) {\n            keeperList[_keepers[i]] = true;\n        }\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid reserve asset for gardens\n     *\n     * @param _reserveAsset Address of the reserve assset\n     */\n    function addReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(!validReserveAsset[_reserveAsset], 'Reserve asset already added');\n        // TODO: check decimals reserve asset\n        validReserveAsset[_reserveAsset] = true;\n        reserveAssets.push(_reserveAsset);\n        emit ReserveAssetAdded(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a reserve asset\n     *\n     * @param _reserveAsset               Address of the reserve asset to remove\n     */\n    function removeReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(validReserveAsset[_reserveAsset], 'Reserve asset does not exist');\n\n        reserveAssets = reserveAssets.remove(_reserveAsset);\n\n        delete validReserveAsset[_reserveAsset];\n\n        emit ReserveAssetRemoved(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the price oracle\n     *\n     * @param _priceOracle               Address of the new price oracle\n     */\n    function editPriceOracle(address _priceOracle) external override onlyOwner {\n        require(_priceOracle != priceOracle, 'Price oracle already exists');\n\n        require(_priceOracle != address(0), 'Price oracle must exist');\n\n        address oldPriceOracle = priceOracle;\n        priceOracle = _priceOracle;\n\n        emit PriceOracleChanged(_priceOracle, oldPriceOracle);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the Ishtar Gate Address\n     *\n     * @param _ishtarGate               Address of the new Ishtar Gate\n     */\n    function editIshtarGate(address _ishtarGate) external override onlyOwner {\n        require(_ishtarGate != ishtarGate, 'Ishtar Gate already exists');\n\n        require(_ishtarGate != address(0), 'Ishtar Gate oracle must exist');\n\n        address oldIshtarGate = ishtarGate;\n        ishtarGate = _ishtarGate;\n\n        emit IshtarGateChanged(_ishtarGate, oldIshtarGate);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the garden valuer\n     *\n     * @param _gardenValuer Address of the new garden valuer\n     */\n    function editGardenValuer(address _gardenValuer) external override onlyOwner {\n        require(_gardenValuer != gardenValuer, 'Garden Valuer already exists');\n\n        require(_gardenValuer != address(0), 'Garden Valuer must exist');\n\n        address oldGardenValuer = gardenValuer;\n        gardenValuer = _gardenValuer;\n\n        emit GardenValuerChanged(_gardenValuer, oldGardenValuer);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol fee recipient\n     *\n     * @param _newTreasury      Address of the new protocol fee recipient\n     */\n    function editTreasury(address _newTreasury) external override onlyOwner {\n        require(_newTreasury != address(0), 'Address must not be 0');\n\n        address oldTreasury = treasury;\n        treasury = _newTreasury;\n\n        emit TreasuryChanged(_newTreasury, oldTreasury);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the rewards distributor\n     *\n     * @param _newRewardsDistributor      Address of the new rewards distributor\n     */\n    function editRewardsDistributor(address _newRewardsDistributor) external override onlyOwner {\n        require(_newRewardsDistributor != address(0), 'Address must not be 0');\n\n        address oldRewardsDistributor = rewardsDistributor;\n        rewardsDistributor = _newRewardsDistributor;\n\n        emit RewardsDistributorChanged(_newRewardsDistributor, oldRewardsDistributor);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden factory\n     *\n     * @param _newGardenFactory      Address of the new garden factory\n     */\n    function editGardenFactory(address _newGardenFactory) external override onlyOwner {\n        require(_newGardenFactory != address(0), 'Address must not be 0');\n\n        address oldGardenFactory = gardenFactory;\n        gardenFactory = _newGardenFactory;\n\n        emit GardenFactoryChanged(_newGardenFactory, oldGardenFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden NFT\n     *\n     * @param _newGardenNFT      Address of the new garden NFT\n     */\n    function editGardenNFT(address _newGardenNFT) external override onlyOwner {\n        require(_newGardenNFT != address(0), 'Address must not be 0');\n\n        address oldGardenNFT = gardenNFT;\n        gardenNFT = _newGardenNFT;\n\n        emit GardenNFTChanged(_newGardenNFT, oldGardenNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy NFT\n     *\n     * @param _newStrategyNFT      Address of the new strategy NFT\n     */\n    function editStrategyNFT(address _newStrategyNFT) external override onlyOwner {\n        require(_newStrategyNFT != address(0), 'Address must not be 0');\n\n        address oldStrategyNFT = strategyNFT;\n        strategyNFT = _newStrategyNFT;\n\n        emit StrategyNFTChanged(_newStrategyNFT, oldStrategyNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy factory\n     *\n     * @param _newStrategyFactory      Address of the new strategy factory\n     */\n    function editStrategyFactory(address _newStrategyFactory) external override onlyOwner {\n        require(_newStrategyFactory != address(0), 'Address must not be 0');\n\n        address oldStrategyFactory = strategyFactory;\n        strategyFactory = _newStrategyFactory;\n\n        emit StrategyFactoryEdited(_newStrategyFactory, oldStrategyFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol default trde integration\n     *\n     * @param _newDefaultTradeIntegation      Address of the new default trade integration\n     */\n    function setDefaultTradeIntegration(address _newDefaultTradeIntegation) external override onlyOwner {\n        require(_newDefaultTradeIntegation != address(0), 'Address must not be 0');\n        require(_newDefaultTradeIntegation != defaultTradeIntegration, 'Address must be different');\n        require(\n            enabledIntegrations[_nameHash(IIntegration(_newDefaultTradeIntegation).getName())] ==\n                _newDefaultTradeIntegation,\n            'Integration needs to be valid'\n        );\n        address oldDefaultTradeIntegration = defaultTradeIntegration;\n        defaultTradeIntegration = _newDefaultTradeIntegation;\n\n        emit DefaultTradeIntegrationChanged(_newDefaultTradeIntegation, oldDefaultTradeIntegration);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Add a new integration to the registry\n     *\n     * @param  _name             Human readable string identifying the integration\n     * @param  _integration      Address of the integration contract to add\n     */\n    function addIntegration(string memory _name, address _integration) public override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n        require(enabledIntegrations[hashedName] == address(0), 'Integration exists already.');\n        require(_integration != address(0), 'Integration address must exist.');\n\n        enabledIntegrations[hashedName] = _integration;\n\n        emit ControllerIntegrationAdded(_integration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing integration on the registry\n     *\n     * @param  _name         Human readable string identifying the integration\n     * @param  _integration      Address of the integration contract to edit\n     */\n    function editIntegration(string memory _name, address _integration) public override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n\n        require(enabledIntegrations[hashedName] != address(0), 'Integration does not exist.');\n        require(_integration != address(0), 'Integration address must exist.');\n\n        enabledIntegrations[hashedName] = _integration;\n\n        emit ControllerIntegrationEdited(_integration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Remove an existing integration on the registry\n     *\n     * @param  _name         Human readable string identifying the integration\n     */\n    function removeIntegration(string memory _name) external override onlyOwner {\n        bytes32 hashedName = _nameHash(_name);\n        require(enabledIntegrations[hashedName] != address(0), 'Integration does not exist.');\n\n        address oldIntegration = enabledIntegrations[hashedName];\n        delete enabledIntegrations[hashedName];\n\n        emit ControllerIntegrationRemoved(oldIntegration, _name);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing operation on the registry\n     *\n     * @param  _kind             Operation kind\n     * @param  _operation        Address of the operation contract to set\n     */\n    function setOperation(uint8 _kind, address _operation) public override onlyOwner {\n        require(_kind < MAX_OPERATIONS, 'Max operations reached');\n        require(enabledOperations[_kind] != _operation, 'Operation already set');\n        require(_operation != address(0), 'Operation address must exist.');\n        enabledOperations[_kind] = _operation;\n\n        emit ControllerOperationSet(_kind, _operation);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edits the minimum liquidity an asset must have on Uniswap\n     *\n     * @param  _reserve                         Address of the reserve to edit\n     * @param  _newMinLiquidityReserve          Absolute min liquidity of an asset to grab price\n     */\n    function editLiquidityReserve(address _reserve, uint256 _newMinLiquidityReserve) public override onlyOwner {\n        require(_newMinLiquidityReserve > 0, '_minRiskyPairLiquidityEth > 0');\n        require(validReserveAsset[_reserve], 'Needs to be a valid reserve');\n        minLiquidityPerReserve[_reserve] = _newMinLiquidityReserve;\n\n        emit LiquidityMinimumEdited(_reserve, _newMinLiquidityReserve);\n    }\n\n    // ===========  Protocol security related Gov Functions ======\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set-up a pause guardian\n     * @param _guardian               Address of the guardian\n     */\n    function setPauseGuardian(address _guardian) external override {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            'only pause guardian and owner can update pause guardian'\n        );\n        // Save current value for inclusion in log\n        address oldPauseGuardian = guardian;\n        // Store pauseGuardian with value newPauseGuardian\n        guardian = _guardian;\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, _guardian);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause the protocol globally in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _state               True to pause, false to unpause.\n     */\n    function setGlobalPause(bool _state) external override returns (bool) {\n        require(msg.sender == guardian || msg.sender == owner(), 'only pause guardian and owner can pause globally');\n        require(msg.sender == owner() || _state == true, 'only admin can unpause');\n\n        guardianGlobalPaused = _state;\n        emit ActionPaused('Guardian global pause', _state);\n        return _state;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause some smartcontracts in a batch process in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _address             Addresses of protocol smartcontract to be paused\n     * @param _state               Boolean pause state\n     */\n    function setSomePause(address[] memory _address, bool _state) external override returns (bool) {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            'only pause guardian and owner can pause individually'\n        );\n        require(msg.sender == owner() || _state == true, 'only admin can unpause');\n        for (uint256 i = 0; i < _address.length; i++) {\n            guardianPaused[_address[i]] = _state;\n            emit ActionPausedIndividually('Guardian individual pause', _address[i], _state);\n        }\n        return _state;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    function owner() public view override(IBabController, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    function getGardens() external view override returns (address[] memory) {\n        return gardens;\n    }\n\n    function getOperations() external view override returns (address[20] memory) {\n        return enabledOperations;\n    }\n\n    function getReserveAssets() external view returns (address[] memory) {\n        return reserveAssets;\n    }\n\n    function getMinCooldownPeriod() external pure override returns (uint256) {\n        return MIN_COOLDOWN_PERIOD;\n    }\n\n    function getMaxCooldownPeriod() external pure override returns (uint256) {\n        return MAX_COOLDOWN_PERIOD;\n    }\n\n    function isValidReserveAsset(address _reserveAsset) external view override returns (bool) {\n        return validReserveAsset[_reserveAsset];\n    }\n\n    function isValidKeeper(address _keeper) external view override returns (bool) {\n        return keeperList[_keeper];\n    }\n\n    /**\n     * Check whether or not there is a global pause or a specific pause of the provided contract address\n     * @param _contract               Smartcontract address to check for a global or specific pause\n     */\n    function isPaused(address _contract) external view override returns (bool) {\n        return guardianGlobalPaused || guardianPaused[_contract];\n    }\n\n    /**\n     * Returns the percentages of a strategy Profit Sharing\n     *\n     * @return            Strategist, Stewards, Lps, creator bonus\n     */\n    function getProfitSharing()\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (strategistProfitPercentage, stewardsProfitPercentage, lpsProfitPercentage);\n    }\n\n    /**\n     * Returns the percentages of BABL Profit Sharing\n     *\n     * @return            Strategist, Stewards, Lps, creator bonus\n     */\n    function getBABLSharing()\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (strategistBABLPercentage, stewardsBABLPercentage, lpsBABLPercentage, gardenCreatorBonus);\n    }\n\n    /**\n     * Get the integration address associated with passed human readable name\n     *\n     * @param  _name         Human readable integration name\n     *\n     * @return               Address of integration\n     */\n    function getIntegrationByName(string memory _name) external view override returns (address) {\n        return enabledIntegrations[_nameHash(_name)];\n    }\n\n    /**\n     * Get integration integration address associated with passed hashed name\n     *\n     * @param  _nameHashP     Hash of human readable integration name\n     *\n     * @return               Address of integration\n     */\n    function getIntegrationWithHash(bytes32 _nameHashP) external view override returns (address) {\n        return enabledIntegrations[_nameHashP];\n    }\n\n    /**\n     * Check if integration name is valid\n     *\n     * @param  _name         Human readable string identifying the integration\n     *\n     * @return               Boolean indicating if valid\n     */\n    function isValidIntegration(string memory _name, address _integration) external view override returns (bool) {\n        return enabledIntegrations[_nameHash(_name)] == _integration;\n    }\n\n    /**\n     * Check if a contract address is a garden or one of the system contracts\n     *\n     * @param  _contractAddress           The contract address to check\n     */\n    function isSystemContract(address _contractAddress) external view override returns (bool) {\n        return (isGarden[_contractAddress] ||\n            gardenValuer == _contractAddress ||\n            priceOracle == _contractAddress ||\n            gardenFactory == _contractAddress ||\n            defaultTradeIntegration == _contractAddress ||\n            strategyFactory == _contractAddress ||\n            rewardsDistributor == _contractAddress ||\n            owner() == _contractAddress ||\n            _contractAddress == address(this) ||\n            _isOperation(_contractAddress) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).strategyMapping(_contractAddress)));\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * Hashes the string and returns a bytes32 value\n     */\n    function _nameHash(string memory _name) private pure returns (bytes32) {\n        return keccak256(bytes(_name));\n    }\n\n    function _isOperation(address _address) private view returns (bool) {\n        for (uint8 i = 0; i < MAX_OPERATIONS; i++) {\n            if (_address == enabledOperations[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ncontract BabControllerV4 is BabController {}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title IRewardsDistributor\n * @author Babylon Finance\n *\n * Interface for the distribute rewards of the BABL Mining Program.\n */\n\ninterface IRewardsDistributor {\n    // Structs\n    struct PrincipalPerTimestamp {\n        uint256 principal;\n        uint256 time;\n        uint256 timeListPointer;\n    }\n\n    function protocolPrincipal() external view returns (uint256);\n\n    function pid() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function EPOCH_DURATION() external pure returns (uint256);\n\n    // solhint-disable-next-line\n    function START_TIME() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function Q1_REWARDS() external pure returns (uint256);\n\n    // solhint-disable-next-line\n    function DECAY_RATE() external pure returns (uint256);\n\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) external;\n\n    function getStrategyRewards(address _strategy) external view returns (uint96);\n\n    function sendTokensToContributor(address _to, uint256 _amount) external;\n\n    function startBABLRewards() external;\n\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view returns (uint256[] memory);\n\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) external view returns (uint256);\n\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw,\n        uint256 _pid\n    ) external;\n\n    function tokenSupplyPerQuarter(uint256 quarter) external view returns (uint96);\n\n    function checkProtocol(uint256 _time)\n        external\n        view\n        returns (\n            uint256 principal,\n            uint256 time,\n            uint256 quarterBelonging,\n            uint256 timeListPointer,\n            uint256 power\n        );\n\n    function checkQuarter(uint256 _num)\n        external\n        view\n        returns (\n            uint256 quarterPrincipal,\n            uint256 quarterNumber,\n            uint256 quarterPower,\n            uint96 supplyPerQuarter\n        );\n}\n"
    },
    "contracts/interfaces/IGarden.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IGarden\n * @author Babylon Finance\n *\n * Interface for operating with a Garden.\n */\ninterface IGarden {\n    /* ============ Functions ============ */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) external payable;\n\n    function makeGardenPublic() external;\n\n    function setActive(bool _val) external;\n\n    function active() external view returns (bool);\n\n    function guestListEnabled() external view returns (bool);\n\n    function controller() external view returns (address);\n\n    function creator() external view returns (address);\n\n    function isGardenStrategy(address _strategy) external view returns (bool);\n\n    function getContributor(address _contributor)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function reserveAsset() external view returns (address);\n\n    function totalContributors() external view returns (uint256);\n\n    function gardenInitializedAt() external view returns (uint256);\n\n    function minContribution() external view returns (uint256);\n\n    function maxContributors() external view returns (uint256);\n\n    function depositHardlock() external view returns (uint256);\n\n    function withdrawalsOpenUntil() external view returns (uint256);\n\n    function minLiquidityAsset() external view returns (uint256);\n\n    function minStrategyDuration() external view returns (uint256);\n\n    function maxStrategyDuration() external view returns (uint256);\n\n    function principal() external view returns (uint256);\n\n    function reserveAssetRewardsSetAside() external view returns (uint256);\n\n    function reserveAssetPrincipalWindow() external view returns (uint256);\n\n    function absoluteReturns() external view returns (int256);\n\n    function totalStake() external view returns (uint256);\n\n    function minVotesQuorum() external view returns (uint256);\n\n    function minVoters() external view returns (uint256);\n\n    function maxDepositLimit() external view returns (uint256);\n\n    function strategyCooldownPeriod() external view returns (uint256);\n\n    function getStrategies() external view returns (address[] memory);\n\n    function getFinalizedStrategies() external view returns (address[] memory);\n\n    function strategyMapping(address _strategy) external view returns (bool);\n\n    function startWithdrawalWindow(\n        uint256 _amount,\n        uint256 _profits,\n        int256 _returns,\n        address _strategy\n    ) external;\n\n    function allocateCapitalToStrategy(uint256 _capital) external;\n\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external;\n\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to,\n        bool mintNFT\n    ) external payable;\n\n    function withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external;\n\n    function claimReturns(address[] calldata _finalizedStrategies) external;\n\n    function getGardenTokenMintQuantity(uint256 _netReserveFlows, bool isDeposit) external view returns (uint256);\n\n    function getExpectedReserveWithdrawalQuantity(uint256 _gardenTokenQuantity) external view returns (uint256);\n\n    function getLockedBalance(address _contributor) external view returns (uint256);\n\n    function expireCandidateStrategy(address _strategy) external;\n\n    function burnStrategistStake(address _strategist, uint256 _amount) external;\n\n    function payKeeper(address payable _keeper, uint256 _fee) external;\n}\n"
    },
    "contracts/interfaces/IGardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IGardenFactory\n * @author Babylon Finance\n *\n * Interface for the garden factory\n */\ninterface IGardenFactory {\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title IStrategy\n * @author Babylon Finance\n *\n * Interface for strategy\n */\ninterface IStrategy {\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn\n    ) external;\n\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 fee\n    ) external;\n\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external;\n\n    function executeStrategy(uint256 _capital, uint256 fee) external;\n\n    function getNAV() external view returns (uint256);\n\n    function opDatas(uint256 _index) external view returns (address);\n\n    function opIntegrations(uint256 _index) external view returns (address);\n\n    function opTypes(uint256 _index) external view returns (uint8);\n\n    function getOperationsCount() external view returns (uint256);\n\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        returns (\n            uint8,\n            address,\n            address\n        );\n\n    function finalizeStrategy(uint256 fee, string memory _tokenURI) external;\n\n    function unwindStrategy(uint256 _amountToUnwind) external;\n\n    function changeStrategyDuration(uint256 _newDuration) external;\n\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory);\n\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external;\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external returns (uint256);\n\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external;\n\n    function getStrategyDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        );\n\n    function getStrategyState()\n        external\n        view\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function isStrategyActive() external view returns (bool);\n\n    function getUserVotes(address _address) external view returns (int256);\n\n    function strategist() external view returns (address);\n\n    function enteredAt() external view returns (uint256);\n\n    function enteredCooldownAt() external view returns (uint256);\n\n    function executedAt() external view returns (uint256);\n\n    function updatedAt() external view returns (uint256);\n\n    function exitedAt() external view returns (uint256);\n\n    function stake() external view returns (uint256);\n\n    function strategyRewards() external view returns (uint256);\n\n    function maxCapitalRequested() external view returns (uint256);\n\n    function expectedReturn() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function totalPositiveVotes() external view returns (uint256);\n\n    function totalVotes() external view returns (int256);\n\n    function totalNegativeVotes() external view returns (uint256);\n\n    function capitalReturned() external view returns (uint256);\n\n    function capitalAllocated() external view returns (uint256);\n\n    function finalized() external view returns (bool);\n\n    function active() external view returns (bool);\n\n    function garden() external view returns (IGarden);\n}\n"
    },
    "contracts/interfaces/IIshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IIshtarGate {\n    /* ============ Functions ============ */\n\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external returns (uint256);\n\n    function setCreatorPermissions(address _user, bool _canCreate) external returns (uint256);\n\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external returns (bool);\n\n    function maxNumberOfInvites() external view returns (uint256);\n\n    function tokenURI() external view returns (string memory);\n\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external;\n\n    function updateGardenURI(string memory _tokenURI) external;\n\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms) external returns (bool);\n\n    function canCreate(address _user) external view returns (bool);\n\n    function canJoinAGarden(address _garden, address _user) external view returns (bool);\n\n    function canVoteInAGarden(address _garden, address _user) external view returns (bool);\n\n    function canAddStrategiesInAGarden(address _garden, address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIntegration\n * @author Babylon Finance\n *\n * Interface for protocol integrations\n */\ninterface IIntegration {\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBabController\n * @author Babylon Finance\n *\n * Interface for interacting with BabController\n */\ninterface IBabController {\n    /* ============ Functions ============ */\n\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) external payable returns (address);\n\n    function removeGarden(address _garden) external;\n\n    function addReserveAsset(address _reserveAsset) external;\n\n    function removeReserveAsset(address _reserveAsset) external;\n\n    function disableGarden(address _garden) external;\n\n    function editPriceOracle(address _priceOracle) external;\n\n    function editIshtarGate(address _ishtarGate) external;\n\n    function editGardenValuer(address _gardenValuer) external;\n\n    function editRewardsDistributor(address _rewardsDistributor) external;\n\n    function editTreasury(address _newTreasury) external;\n\n    function editGardenFactory(address _newGardenFactory) external;\n\n    function editGardenNFT(address _newGardenNFT) external;\n\n    function editStrategyNFT(address _newStrategyNFT) external;\n\n    function editStrategyFactory(address _newStrategyFactory) external;\n\n    function addIntegration(string memory _name, address _integration) external;\n\n    function editIntegration(string memory _name, address _integration) external;\n\n    function removeIntegration(string memory _name) external;\n\n    function setOperation(uint8 _kind, address _operation) external;\n\n    function setDefaultTradeIntegration(address _newDefaultTradeIntegation) external;\n\n    function addKeeper(address _keeper) external;\n\n    function addKeepers(address[] memory _keepers) external;\n\n    function removeKeeper(address _keeper) external;\n\n    function enableGardenTokensTransfers() external;\n\n    function enableBABLMiningProgram() external;\n\n    function setAllowPublicGardens() external;\n\n    function editLiquidityReserve(address _reserve, uint256 _minRiskyPairLiquidityEth) external;\n\n    function maxContributorsPerGarden() external view returns (uint256);\n\n    function gardenCreationIsOpen() external view returns (bool);\n\n    function openPublicGardenCreation() external;\n\n    function setMaxContributorsPerGarden(uint256 _newMax) external;\n\n    function owner() external view returns (address);\n\n    function guardianGlobalPaused() external view returns (bool);\n\n    function guardianPaused(address _address) external view returns (bool);\n\n    function setPauseGuardian(address _guardian) external;\n\n    function setGlobalPause(bool _state) external returns (bool);\n\n    function setSomePause(address[] memory _address, bool _state) external returns (bool);\n\n    function isPaused(address _contract) external view returns (bool);\n\n    function priceOracle() external view returns (address);\n\n    function gardenValuer() external view returns (address);\n\n    function gardenNFT() external view returns (address);\n\n    function strategyNFT() external view returns (address);\n\n    function rewardsDistributor() external view returns (address);\n\n    function gardenFactory() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function ishtarGate() external view returns (address);\n\n    function strategyFactory() external view returns (address);\n\n    function defaultTradeIntegration() external view returns (address);\n\n    function gardenTokensTransfersEnabled() external view returns (bool);\n\n    function bablMiningProgramEnabled() external view returns (bool);\n\n    function allowPublicGardens() external view returns (bool);\n\n    function enabledOperations(uint256 _kind) external view returns (address);\n\n    function getProfitSharing()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getBABLSharing()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getGardens() external view returns (address[] memory);\n\n    function getOperations() external view returns (address[20] memory);\n\n    function isGarden(address _garden) external view returns (bool);\n\n    function getIntegrationByName(string memory _name) external view returns (address);\n\n    function getIntegrationWithHash(bytes32 _nameHashP) external view returns (address);\n\n    function isValidReserveAsset(address _reserveAsset) external view returns (bool);\n\n    function isValidKeeper(address _keeper) external view returns (bool);\n\n    function isSystemContract(address _contractAddress) external view returns (bool);\n\n    function isValidIntegration(string memory _name, address _integration) external view returns (bool);\n\n    function getMinCooldownPeriod() external view returns (uint256);\n\n    function getMaxCooldownPeriod() external view returns (uint256);\n\n    function protocolPerformanceFee() external view returns (uint256);\n\n    function protocolManagementFee() external view returns (uint256);\n\n    function minLiquidityPerReserve(address _reserve) external view returns (uint256);\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n */\nlibrary AddressArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Returns true if there are 2 elements that are the same in an array\n     * @param A The input array to search\n     * @return Returns boolean for the first occurrence of a duplicate\n     */\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n        require(A.length > 0, 'A is empty');\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a) internal pure returns (address[] memory) {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert('Address not in array.');\n        } else {\n            (address[] memory _A, ) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * Removes specified index from array\n     * @param A The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory A, uint256 index) internal pure returns (address[] memory, address) {\n        uint256 length = A.length;\n        require(index < A.length, 'Index must be < A length');\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n\n    /**\n     * Returns the combination of the two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        address[] memory newAddresses = new address[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = 0; j < bLength; j++) {\n            newAddresses[aLength + j] = B[j];\n        }\n        return newAddresses;\n    }\n}\n"
    },
    "contracts/lib/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SafeMath: division by zero');\n        return a / b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/token/RewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {TimeLockedToken} from './TimeLockedToken.sol';\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards of the BABL Mining Program\n * along the time reserved for executed strategies. It implements a supply curve to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared to the whole protocol usage.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses to specific profiles\n * which are actively contributing to the protocol growth and their communities (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributor is OwnableUpgradeable, IRewardsDistributor {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n    using Safe3296 for uint256;\n    using Safe3296 for int256;\n    using Safe3296 for uint96;\n    using Safe3296 for uint32;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the call is not from a valid strategy\n     */\n    modifier onlyStrategy {\n        _require(controller.isSystemContract(address(IStrategy(msg.sender).garden())), Errors.ONLY_STRATEGY);\n        _require(\n            IGarden(address(IStrategy(msg.sender).garden())).isGardenStrategy(msg.sender),\n            Errors.STRATEGY_GARDEN_MISMATCH\n        );\n        _;\n    }\n    /**\n     * Throws if the call is not from a valid active garden\n     */\n    modifier onlyActiveGarden(address _garden, uint256 _pid) {\n        if (_pid != 0 || gardenPid[address(_garden)] > 1) {\n            // Enable deploying flow with security restrictions\n            _require(IBabController(controller).isSystemContract(address(_garden)), Errors.NOT_A_SYSTEM_CONTRACT);\n            _require(IBabController(controller).isGarden(address(_garden)), Errors.ONLY_ACTIVE_GARDEN);\n        }\n        _require(msg.sender == address(_garden), Errors.ONLY_ACTIVE_GARDEN);\n        _require(IGarden(_garden).active(), Errors.ONLY_ACTIVE_GARDEN);\n        _;\n    }\n\n    /**\n     * Throws if the BABL Rewards mining program is not active\n     */\n    modifier onlyMiningActive() {\n        _require(IBabController(controller).bablMiningProgramEnabled(), Errors.ONLY_MINING_ACTIVE);\n        _;\n    }\n    /**\n     * Throws if the sender is not the controller\n     */\n    modifier onlyController() {\n        _require(IBabController(controller).isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        _require(address(controller) == msg.sender, Errors.ONLY_CONTROLLER);\n        _;\n    }\n    modifier onlyUnpaused() {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n        _;\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        _require(status != ENTERED, Errors.REENTRANT_CALL);\n        // Any calls to nonReentrant after this point will fail\n        status = ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        status = NOT_ENTERED;\n    }\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 public constant override Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 public constant override DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 public constant override EPOCH_DURATION = 90 days;\n\n    // solhint-disable-next-line\n    uint256 public override START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 private BABL_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 private BABL_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 private BABL_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_PROTOCOL_FEE;\n    // solhint-disable-next-line\n    uint256 private CREATOR_BONUS;\n\n    // DAI normalize asset\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Reentrancy guard countermeasure\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        // Protocol allocation checkpoints per timestamp along the time\n        uint256 principal; // Protocol principal allocation in normalized asset (DAI)\n        uint256 time; // Time of the checkpoint\n        uint256 quarterBelonging; // # Quarter checkpoint belonging since START_TIME\n        uint256 timeListPointer; // Pointer to the array of timestamps to enable the possibility of struct iteration\n        uint256 power; // Protocol power checkpoint (power is proportional to = principal * duration)\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // Checkpoint to keep track on accumulated protocol principal per quarter in normalized asset (DAI)\n        uint256 quarterNumber; // # Quarter since START_TIME\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // Supply per quarter\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 supply; // Checkpoint to keep track on garden supply\n        uint256 timestamp; // Checkpoint timestamps\n        uint256 power; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // Array of timestamps for each user in each garden\n        uint256 pid; // Garden contributor checkpoints counter to enable iteration\n        mapping(uint256 => TimestampContribution) tsContributions; // Sub-mapping all the contributor checkpoints\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 supply; // Garden token balance of user in each garden along the time\n        uint256 timestamp; // Checkpoint time\n        uint256 timePointer; // Pointer\n        uint256 power; // Contributor power per checkpoint\n    }\n    struct Checkpoints {\n        // Checkpoints for contributor power calculations where a certain window (from -> to) is queried\n        uint256 fromDepositAt; // First contributor checkpoint within the provided window\n        uint256 lastDepositAt; // Last contributor checkpoint within the provided window\n        uint256 gardenFromDepositAt; // First contributor checkpoint within the provided window\n        uint256 gardenLastDepositAt; // Last garden checkpoint within the provided window\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController public controller;\n\n    // BABL Token contract\n    TimeLockedToken public babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal) in all strategy pools.\n    uint256 public override protocolPrincipal;\n    mapping(uint256 => ProtocolPerTimestamp) public protocolPerTimestamp; // Mapping of all protocol checkpoints\n    uint256[] public timeList; // Array of all protocol checkpoints\n    uint256 public override pid; // Initialization of the ID assigning timeListPointer to the checkpoint number\n\n    mapping(uint256 => ProtocolPerQuarter) public protocolPerQuarter; // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => bool) public isProtocolPerQuarter; // Check if the protocol per quarter data has been initialized\n\n    // Strategy overhead control. Only used if each strategy has power overhead due to changes overtime\n    mapping(address => mapping(uint256 => uint256)) public rewardsPowerOverhead; // Overhead control to enable high level accuracy calculations for strategy rewards\n    // Contributor power control\n    mapping(address => mapping(address => ContributorPerGarden)) public contributorPerGarden; // Enable high level accuracy calculations\n    mapping(address => mapping(address => Checkpoints)) private checkpoints;\n    // Garden power control\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) public gardenPowerByTimestamp;\n    mapping(address => uint256[]) public gardenTimelist;\n    mapping(address => uint256) public gardenPid;\n\n    struct StrategyPerQuarter {\n        // Acumulated strategy power per each quarter along the time\n        uint256 quarterPrincipal;\n        uint256 quarterNumber; // # Quarter since START_TIME\n        uint256 quarterPower; //  Accumulated strategy power for each quarter\n        bool initialized;\n    }\n    struct StrategyPricePerTokenUnit {\n        // Take control over the price per token changes along the time when normalizing into DAI\n        uint256 preallocated; // Strategy capital preallocated before each checkpoint\n        uint256 pricePerTokenUnit; // Last average price per allocated tokens per strategy normalized into DAI\n    }\n    mapping(address => mapping(uint256 => StrategyPerQuarter)) public strategyPerQuarter; // Acumulated strategy power per each quarter along the time\n    mapping(address => StrategyPricePerTokenUnit) public strategyPricePerTokenUnit; // Pro-rata oracle price allowing re-allocations and unwinding of any capital value\n\n    // Reentrancy guard countermeasure\n    uint256 private status;\n\n    /* ============ Constructor ============ */\n\n    function initialize(TimeLockedToken _bablToken, IBabController _controller) public {\n        OwnableUpgradeable.__Ownable_init();\n        _require(address(_bablToken) != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        babltoken = _bablToken;\n        controller = _controller;\n\n        (BABL_STRATEGIST_SHARE, BABL_STEWARD_SHARE, BABL_LP_SHARE, CREATOR_BONUS) = controller.getBABLSharing();\n        (PROFIT_STRATEGIST_SHARE, PROFIT_STEWARD_SHARE, PROFIT_LP_SHARE) = controller.getProfitSharing();\n        PROFIT_PROTOCOL_FEE = controller.protocolPerformanceFee();\n\n        status = NOT_ENTERED;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Function that adds/substract the capital received to the total principal of the protocol per timestamp\n     * @param _capital                Amount of capital in any type of asset to be normalized into DAI\n     * @param _addOrSubstract         Whether we are adding or substracting capital\n     */\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract)\n        external\n        override\n        onlyStrategy\n        onlyMiningActive\n    {\n        IStrategy strategy = IStrategy(msg.sender);\n        if (strategy.enteredAt() >= START_TIME) {\n            // onlyMiningActive control, it does not create a checkpoint if the strategy is not part of the Mining Program\n            _updateProtocolPrincipal(address(strategy), _capital, _addOrSubstract);\n        }\n    }\n\n    /**\n     * Gets the total amount of rewards for a given strategy\n     * @param _strategy                Strategy to check\n     */\n    function getStrategyRewards(address _strategy) external view override returns (uint96) {\n        IStrategy strategy = IStrategy(_strategy);\n        _require(strategy.exitedAt() != 0, Errors.STRATEGY_IS_NOT_OVER_YET);\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 pricePerTokenUnit = oracle.getPrice(IGarden(strategy.garden()).reserveAsset(), DAI);\n        uint256 allocated = strategy.capitalAllocated().preciseMul(pricePerTokenUnit);\n        uint256 returned = strategy.capitalReturned().preciseMul(pricePerTokenUnit);\n        if ((strategy.enteredAt() >= START_TIME) && (START_TIME != 0)) {\n            // We avoid gas consuming once a strategy got its BABL rewards during its finalization\n            uint256 rewards = strategy.strategyRewards();\n            if (rewards != 0) {\n                return Safe3296.safe96(rewards, 'overflow 96 bits');\n            }\n            // If the calculation was not done earlier we go for it\n            (uint256 numQuarters, uint256 startingQuarter) =\n                _getRewardsWindow(strategy.executedAt(), strategy.exitedAt());\n            uint256 percentage = 1e18;\n\n            for (uint256 i = 0; i < numQuarters; i++) {\n                uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION)); // Initialization timestamp at the end of the first slot where the strategy starts its execution\n                // We calculate each epoch\n                uint256 strategyPower = strategyPerQuarter[_strategy][startingQuarter.add(i)].quarterPower;\n                uint256 protocolPower = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n                _require(strategyPower <= protocolPower, Errors.OVERFLOW_IN_POWER);\n                if (i.add(1) == numQuarters) {\n                    // last quarter - we take proportional supply for that timeframe\n                    percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                        slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                    );\n                }\n                uint256 powerRatioInQuarter =\n                    strategyPower\n                        .preciseDiv(protocolPower)\n                        .preciseMul(uint256(protocolPerQuarter[startingQuarter.add(i)].supplyPerQuarter))\n                        .preciseMul(percentage);\n                rewards = rewards.add(powerRatioInQuarter);\n            }\n            // Babl rewards will be proportional to the total return (profit) with a max cap of x2\n            uint256 percentageMul = returned.preciseDiv(allocated);\n            if (percentageMul > 2e18) percentageMul = 2e18;\n            rewards = rewards.preciseMul(percentageMul);\n            return Safe3296.safe96(rewards, 'overflow 96 bits');\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Sends BABL tokens rewards to a contributor after a claim is requested to the protocol.\n     * @param _to                Address to send the tokens to\n     * @param _amount            Amount of tokens to send the address to\n     */\n    function sendTokensToContributor(address _to, uint256 _amount)\n        external\n        override\n        nonReentrant\n        onlyMiningActive\n        onlyUnpaused\n    {\n        _require(controller.isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        uint96 amount = Safe3296.safe96(_amount, 'overflow 96 bits');\n        _safeBABLTransfer(_to, amount);\n    }\n\n    /**\n     * Starts BABL Rewards Mining Program from the controller.\n     */\n    function startBABLRewards() external override onlyController onlyUnpaused {\n        if (START_TIME == 0) {\n            // It can only be activated once to avoid overriding START_TIME\n            START_TIME = block.timestamp;\n        }\n    }\n\n    /**\n     * Function that set each contributor timestamp per garden\n     * @param _garden                Address of the garden the contributor belongs to\n     * @param _contributor           Address of the contributor\n     * @param _previousBalance       Previous balance of the contributor\n     * @param _depositOrWithdraw     If the timestamp is a deposit (true) or a withdraw (false)\n     * @param _pid                   The pid # of the Garden timestamps\n     */\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw,\n        uint256 _pid\n    ) external override nonReentrant onlyActiveGarden(_garden, _pid) {\n        _updateGardenPower(_garden);\n        _setContributorTimestampParams(_garden, _contributor, _previousBalance, _depositOrWithdraw);\n    }\n\n    /**\n     * Function that set the babl Token address as it is going to be released in a future date\n     * @param _bablToken BABLToken address\n     */\n    function setBablToken(TimeLockedToken _bablToken) external onlyOwner onlyUnpaused {\n        babltoken = _bablToken;\n    }\n\n    /* ========== View functions ========== */\n\n    /**\n     * Calculates the profits and BABL that a contributor should receive from a series of finalized strategies\n     * @param _garden                   Garden to which the strategies and the user must belong to\n     * @param _contributor              Address of the contributor to check\n     * @param _finalizedStrategies      List of addresses of the finalized strategies to check\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL , rewards[1]: Strategist Profit, rewards[2]: Steward BABL, rewards[3]: Steward Profit, rewards[4]: LP BABL, rewards[5]: total BABL, rewards[6]: total Profits\n     */\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view override returns (uint256[] memory) {\n        uint256[] memory totalRewards = new uint256[](7);\n        _require(IBabController(controller).isGarden(address(_garden)), Errors.ONLY_ACTIVE_GARDEN);\n        for (uint256 i = 0; i < _finalizedStrategies.length; i++) {\n            uint256[] memory tempRewards = new uint256[](7);\n            tempRewards = _getStrategyProfitsAndBABL(_garden, _finalizedStrategies[i], _contributor);\n            totalRewards[0] = totalRewards[0].add(tempRewards[0]);\n            totalRewards[1] = totalRewards[1].add(tempRewards[1]);\n            totalRewards[2] = totalRewards[2].add(tempRewards[2]);\n            totalRewards[3] = totalRewards[3].add(tempRewards[3]);\n            totalRewards[4] = totalRewards[4].add(tempRewards[4]);\n            totalRewards[5] = totalRewards[5].add(tempRewards[5]);\n            totalRewards[6] = totalRewards[6].add(tempRewards[6]);\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * Gets the contributor power from one timestamp to the other\n     * @param _garden      Address of the garden where the contributor belongs to\n     * @param _contributor Address if the contributor\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) external view override returns (uint256) {\n        return _getContributorPower(_garden, _contributor, _from, _to);\n    }\n\n    /**\n     * Calculates the BABL rewards supply for each quarter\n     * @param _quarter      Number of the epoch (quarter)\n     */\n    function tokenSupplyPerQuarter(uint256 _quarter) external view override returns (uint96) {\n        return _tokenSupplyPerQuarter(_quarter);\n    }\n\n    /**\n     * Check the protocol state in a certain timestamp\n     * @param time      Timestamp\n     */\n    function checkProtocol(uint256 _time)\n        external\n        view\n        override\n        returns (\n            uint256 principal,\n            uint256 time,\n            uint256 quarterBelonging,\n            uint256 timeListPointer,\n            uint256 power\n        )\n    {\n        ProtocolPerTimestamp storage protocolCheckpoint = protocolPerTimestamp[_time];\n\n        return (\n            protocolCheckpoint.principal,\n            protocolCheckpoint.time,\n            protocolCheckpoint.quarterBelonging,\n            protocolCheckpoint.timeListPointer,\n            protocolCheckpoint.power\n        );\n    }\n\n    /**\n     * Check the quarter state for a specific quarter\n     * @param _num     Number of quarter\n     */\n    function checkQuarter(uint256 _num)\n        external\n        view\n        override\n        returns (\n            uint256 quarterPrincipal,\n            uint256 quarterNumber,\n            uint256 quarterPower,\n            uint96 supplyPerQuarter\n        )\n    {\n        ProtocolPerQuarter storage protocolCheckpoint = protocolPerQuarter[_num];\n\n        return (\n            protocolCheckpoint.quarterPrincipal,\n            protocolCheckpoint.quarterNumber,\n            protocolCheckpoint.quarterPower,\n            protocolCheckpoint.supplyPerQuarter\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n    /**\n     * Update the protocol principal checkpoints\n     * @param _strategy         Strategy which is adding/removing principal\n     * @param _capital          Capital to update\n     * @param _addOrSubstract   Adding (true) or removing (false)\n     */\n\n    function _updateProtocolPrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) internal {\n        // Take control of getPrice fluctuations along the time - normalizing into DAI\n        uint256 pricePerTokenUnit = _getStrategyPricePerTokenUnit(_strategy, _capital, _addOrSubstract);\n        _capital = SafeDecimalMath.normalizeAmountTokens(\n            IGarden(IStrategy(_strategy).garden()).reserveAsset(),\n            DAI,\n            _capital.preciseMul(pricePerTokenUnit)\n        );\n        ProtocolPerTimestamp storage protocolCheckpoint = protocolPerTimestamp[block.timestamp];\n        if (_addOrSubstract == false) {\n            // Substracting capital\n            protocolPrincipal = protocolPrincipal.sub(_capital);\n        } else {\n            // Adding capital\n            protocolPrincipal = protocolPrincipal.add(_capital);\n        }\n        protocolCheckpoint.principal = protocolPrincipal;\n        protocolCheckpoint.time = block.timestamp;\n        protocolCheckpoint.quarterBelonging = _getQuarter(block.timestamp);\n        protocolCheckpoint.timeListPointer = pid;\n\n        if (pid == 0) {\n            // The very first strategy of all strategies in the mining program\n            protocolCheckpoint.power = 0;\n        } else {\n            // Any other strategy different from the very first one (will have an antecesor)\n            ProtocolPerTimestamp storage previousProtocolCheckpoint = protocolPerTimestamp[timeList[pid.sub(1)]];\n            protocolCheckpoint.power = previousProtocolCheckpoint.power.add(\n                protocolCheckpoint.time.sub(previousProtocolCheckpoint.time).mul(previousProtocolCheckpoint.principal)\n            );\n        }\n        timeList.push(block.timestamp); // Register of added strategies timestamps in the array for iteration\n        // Here we control the accumulated protocol power per each quarter\n        // Create or update the quarter checkpoint\n        _addProtocolPowerPerQuarter(block.timestamp);\n        // We update the strategy power per quarter normalized in DAI\n        _updateStrategyPowerPerQuarter(IStrategy(_strategy), _capital, _addOrSubstract);\n        pid++;\n    }\n\n    /**\n     * Get the price per token to be used in the adding or substraction normalized to DAI (supports multiple asset)\n     * @param _strategy         Strategy address\n     * @param _capital          Capital in reserve asset to add or substract\n     * @param _addOrSubstract   Whether or not we are adding or unwinding capital to the strategy\n     * @return pricePerToken value\n     */\n    function _getStrategyPricePerTokenUnit(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private returns (uint256) {\n        // Normalizing into DAI\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 pricePerTokenUnit = oracle.getPrice(IGarden(IStrategy(_strategy).garden()).reserveAsset(), DAI);\n        if (strategyPricePerTokenUnit[_strategy].preallocated == 0) {\n            // First adding checkpoint\n            strategyPricePerTokenUnit[_strategy].preallocated = _capital;\n            strategyPricePerTokenUnit[_strategy].pricePerTokenUnit = pricePerTokenUnit;\n            return pricePerTokenUnit;\n        } else {\n            // We are controlling pair reserveAsset-DAI fluctuations along the time\n            if (_addOrSubstract) {\n                strategyPricePerTokenUnit[_strategy].pricePerTokenUnit = (\n                    strategyPricePerTokenUnit[_strategy].pricePerTokenUnit.add(_capital.mul(pricePerTokenUnit))\n                )\n                    .preciseDiv(strategyPricePerTokenUnit[_strategy].preallocated.add(_capital))\n                    .div(1e18);\n                strategyPricePerTokenUnit[_strategy].preallocated = strategyPricePerTokenUnit[_strategy]\n                    .preallocated\n                    .add(_capital);\n            } else {\n                //We use the previous pricePerToken in a substract instead of a new price (as allocated capital used previous prices not the current one)\n                strategyPricePerTokenUnit[_strategy].preallocated = strategyPricePerTokenUnit[_strategy]\n                    .preallocated\n                    .sub(_capital);\n            }\n            return strategyPricePerTokenUnit[_strategy].pricePerTokenUnit;\n        }\n    }\n\n    /**\n     * Get the rewards for a specific contributor activately contributing in strategies of a specific garden\n     * @param _garden           Garden address responsible of the strategies to calculate rewards\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL , rewards[1]: Strategist Profit, rewards[2]: Steward BABL, rewards[3]: Steward Profit, rewards[4]: LP BABL, rewards[5]: total BABL, rewards[6]: total Profits\n     */\n    function _getStrategyProfitsAndBABL(\n        address _garden,\n        address _strategy,\n        address _contributor\n    ) private view returns (uint256[] memory) {\n        IStrategy strategy = IStrategy(_strategy);\n        _require(address(strategy.garden()) == _garden, Errors.STRATEGY_GARDEN_MISMATCH);\n        _require(IGarden(_garden).isGardenStrategy(_strategy), Errors.STRATEGY_GARDEN_MISMATCH);\n        // rewards[0]: Strategist BABL , rewards[1]: Strategist Profit, rewards[2]: Steward BABL, rewards[3]: Steward Profit, rewards[4]: LP BABL, rewards[5]: total BABL, rewards[6]: total Profits\n        uint256[] memory rewards = new uint256[](7);\n        uint256 contributorProfits;\n        uint256 contributorBABL;\n        // We get the state of the strategy in terms of profit and distance from expected to accurately calculate profits and rewards\n        (bool profit, uint256 profitValue, bool distance, uint256 distanceValue) =\n            _getStrategyRewardsContext(address(strategy));\n\n        (, uint256 initialDepositAt, uint256 claimedAt, , , , , , ) = IGarden(_garden).getContributor(_contributor);\n        // Positive strategies not yet claimed\n        if (\n            strategy.exitedAt() > claimedAt &&\n            strategy.executedAt() >= initialDepositAt &&\n            address(strategy.garden()) == _garden\n        ) {\n            // If strategy returned money we give out the profits\n            if (profit == true) {\n                // We reserve 5% of profits for performance fees\n                profitValue = profitValue.sub(profitValue.multiplyDecimal(PROFIT_PROTOCOL_FEE));\n            }\n            // Get strategist rewards in case the contributor is also the strategist of the strategy\n            rewards[0] = _getStrategyStrategistBabl(\n                address(strategy),\n                _contributor,\n                profit,\n                profitValue,\n                distance,\n                distanceValue\n            );\n            contributorBABL = contributorBABL.add(rewards[0]);\n            rewards[1] = _getStrategyStrategistProfits(address(strategy), _contributor, profit, profitValue);\n            contributorProfits = contributorProfits.add(rewards[1]);\n\n            // Get steward rewards\n            rewards[2] = _getStrategyStewardBabl(\n                address(strategy),\n                _contributor,\n                profit,\n                profitValue,\n                distance,\n                distanceValue\n            );\n            contributorBABL = contributorBABL.add(rewards[2]);\n            rewards[3] = _getStrategyStewardProfits(\n                address(strategy),\n                _contributor,\n                profit,\n                profitValue,\n                distance,\n                distanceValue\n            );\n            contributorProfits = contributorProfits.add(rewards[3]);\n\n            // Get LP rewards\n            rewards[4] = _getStrategyLPBabl(_garden, _strategy, _contributor);\n            contributorBABL = contributorBABL.add(rewards[4]);\n\n            // Get a multiplier bonus in case the contributor is the garden creator\n            if (_contributor == IGarden(_garden).creator()) {\n                contributorBABL = contributorBABL.add(contributorBABL.multiplyDecimal(CREATOR_BONUS));\n            }\n            rewards[5] = contributorBABL;\n            rewards[6] = contributorProfits;\n        }\n        return rewards;\n    }\n\n    /**\n     * Get the context of a specific address depending on their expected returns, capital allocated and capital returned\n     * @param _strategy         Strategy address\n     */\n    function _getStrategyRewardsContext(address _strategy)\n        private\n        view\n        returns (\n            bool,\n            uint256,\n            bool,\n            uint256\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 returned = strategy.capitalReturned();\n        uint256 expected =\n            strategy.capitalAllocated().add(strategy.capitalAllocated().preciseMul(strategy.expectedReturn()));\n        uint256 allocated = strategy.capitalAllocated();\n        bool profit;\n        bool distance;\n        uint256 profitValue;\n        uint256 distanceValue;\n        if (returned > allocated && returned >= expected) {\n            // The strategy went equal or above expectations\n            profit = true; // positive\n            distance = true; // positive\n            profitValue = returned.sub(allocated);\n            distanceValue = returned.sub(expected);\n        } else if (returned >= allocated && returned < expected) {\n            // The strategy went worse than expected but with some profits\n            profit = true; // positive or zero profits\n            distance = false; // negative vs expected return (got less than expected)\n            profitValue = returned.sub(allocated);\n            distanceValue = expected.sub(returned);\n        } else if (returned < allocated && returned < expected) {\n            // Negative profits - bad investments has penalties\n            profit = false; // negative - loosing capital\n            distance = false; // negative vs expected return (got less than expected)\n            profitValue = allocated.sub(returned); // Negative number, there were no profits at all\n            distanceValue = expected.sub(returned);\n        }\n\n        return (profit, profitValue, distance, distanceValue);\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Steward profile\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _profit           Whether or not the strategy had profits\n     * @param _distance         If true the results were above expected returns, false means opposite\n     * @param _distanceValue        The distance from/to expected returns for capital returned\n     */\n    function _getStrategyStewardBabl(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256, /* _profitValue */\n        bool _distance,\n        uint256 _distanceValue\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyRewards = strategy.strategyRewards();\n        int256 userVotes = strategy.getUserVotes(_contributor);\n        uint256 allocated = strategy.capitalAllocated();\n        uint256 totalPositiveVotes = strategy.totalPositiveVotes();\n        uint256 bablCap;\n        uint256 expected = allocated.add(allocated.preciseMul(strategy.expectedReturn()));\n\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 babl;\n        if (userVotes > 0 && _profit == true && _distance == true) {\n            // Voting in favor of the execution of the strategy with profits and positive distance\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(userVotes).preciseDiv(totalPositiveVotes)\n            );\n        } else if (userVotes > 0 && _profit == true && _distance == false) {\n            // Voting in favor positive profits but below expected return\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(userVotes).preciseDiv(totalPositiveVotes)\n            );\n            // We discount the error of expected return vs real returns\n            babl = babl.sub(babl.preciseMul(_distanceValue.preciseDiv(expected)));\n        } else if (userVotes > 0 && _profit == false) {\n            // Voting in favor of a non profitable strategy get nothing\n            babl = 0;\n        } else if (userVotes < 0 && _distance == false) {\n            // Voting against a strategy that got results below expected return provides rewards\n            // to the voter (helping the protocol to only have good strategies)\n            babl = strategyRewards.multiplyDecimal(BABL_STEWARD_SHARE).preciseMul(\n                uint256(Math.abs(userVotes)).preciseDiv(strategy.totalNegativeVotes())\n            );\n\n            bablCap = babl.mul(2); // Max cap\n            // We add a bonus inverse to the error of expected return vs real returns\n            babl = babl.add(babl.preciseMul(_distanceValue.preciseDiv(expected)));\n            if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n        } else if (userVotes < 0 && _distance == true) {\n            babl = 0;\n        }\n        return babl;\n    }\n\n    /**\n     * Get the rewards for a Steward profile\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _profit           Whether or not the strategy had profits\n     * @param _profitValue      The value of profits\n     * @param _distance         If true the results were above expected returns, false means opposite\n     */\n    function _getStrategyStewardProfits(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256 _profitValue,\n        bool _distance,\n        uint256 /* _distanceValue */\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 profits;\n        int256 userVotes = strategy.getUserVotes(_contributor);\n        if (_profit == true) {\n            if (userVotes > 0) {\n                profits = _profitValue.multiplyDecimal(PROFIT_STEWARD_SHARE).preciseMul(uint256(userVotes)).preciseDiv(\n                    strategy.totalPositiveVotes()\n                );\n            } else if ((userVotes < 0) && _distance == false) {\n                profits = _profitValue\n                    .multiplyDecimal(PROFIT_STEWARD_SHARE)\n                    .preciseMul(uint256(Math.abs(userVotes)))\n                    .preciseDiv(strategy.totalNegativeVotes());\n            } else if ((userVotes < 0) && _distance == true) {\n                // Voted against a very profit strategy above expected returns, get no profit at all\n                profits = 0;\n            }\n        } else profits = 0; // No profits at all\n\n        return profits;\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Strategist profile\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _profit           Whether or not the strategy had profits\n     * @param _distance         If true the results were above expected returns, false means opposite\n     */\n    function _getStrategyStrategistBabl(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256, /* _profitValue */\n        bool _distance,\n        uint256 /* _distanceValue */\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyRewards = strategy.strategyRewards();\n        uint256 babl;\n        uint256 allocated = strategy.capitalAllocated();\n        uint256 returned = strategy.capitalReturned();\n        uint256 bablCap;\n        uint256 expected = allocated.add(allocated.preciseMul(strategy.expectedReturn()));\n        if (strategy.strategist() == _contributor) {\n            babl = strategyRewards.multiplyDecimal(BABL_STRATEGIST_SHARE); // Standard calculation to be ponderated\n            if (_profit == true && _distance == true) {\n                // Strategy with equal or higher profits than expected\n                bablCap = babl.mul(2); // Max cap\n                // The more the results are close to the expected the more bonus will get (limited by a x2 cap)\n                babl = babl.add(babl.preciseMul(expected.preciseDiv(returned)));\n                if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n            } else if (_profit == true && _distance == false) {\n                //under expectations\n                // The more the results are close to the expected the less penalization it might have\n                babl = babl.sub(babl.sub(babl.preciseMul(returned.preciseDiv(expected))));\n            } else {\n                // No positive profit\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n        return babl;\n    }\n\n    /**\n     * Get the rewards for a Strategist profile\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _profit           Whether or not the strategy had profits\n     * @param _profitValue      The value of profits\n     */\n    function _getStrategyStrategistProfits(\n        address _strategy,\n        address _contributor,\n        bool _profit,\n        uint256 _profitValue\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 profits;\n        if (_profit == true) {\n            if (strategy.strategist() == _contributor) {\n                // If the contributor was the strategist of the strategy\n                profits = _profitValue.multiplyDecimal(PROFIT_STRATEGIST_SHARE);\n            }\n        } else profits = 0; // No profits at all\n\n        return profits;\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a LP profile\n     * @param _garden           Garden address\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     */\n    function _getStrategyLPBabl(\n        address _garden,\n        address _strategy,\n        address _contributor\n    ) private view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 strategyRewards = strategy.strategyRewards();\n        uint256 babl;\n        uint256 allocated =\n            SafeDecimalMath.normalizeAmountTokens(IGarden(_garden).reserveAsset(), DAI, strategy.capitalAllocated());\n        uint256 contributorPower =\n            _getContributorPower(_garden, _contributor, strategy.executedAt(), strategy.exitedAt());\n        // We take care of normalization into 18 decimals for capital allocated in less decimals than 18\n        babl = strategyRewards.multiplyDecimal(BABL_LP_SHARE).preciseMul(contributorPower.preciseDiv(allocated));\n        return babl;\n    }\n\n    /**\n     * Add protocol power timestamps for each quarter\n     * @param _time         Timestamp\n     */\n    function _addProtocolPowerPerQuarter(uint256 _time) private onlyMiningActive {\n        uint256 quarter = _getQuarter(_time);\n        ProtocolPerQuarter storage protocolCheckpoint = protocolPerQuarter[quarter];\n\n        if (!isProtocolPerQuarter[quarter.sub(1)]) {\n            // The quarter is not yet initialized then we create it\n            protocolCheckpoint.quarterNumber = quarter;\n            if (pid == 0) {\n                // The first strategy added in the first epoch\n                protocolCheckpoint.quarterPower = 0;\n                protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(quarter);\n            } else {\n                uint256 prevPid = pid.sub(1);\n                // Each time a new epoch starts with either a new strategy execution or finalization\n                // We just take the proportional power for this quarter from previous checkpoint\n                uint256 powerToSplit =\n                    protocolPerTimestamp[_time].power.sub(protocolPerTimestamp[timeList[prevPid]].power);\n                if (protocolPerTimestamp[timeList[prevPid]].quarterBelonging == quarter.sub(1)) {\n                    // There were no intermediate epochs without checkpoints\n                    // We re-initialize the protocol power counting for this new quarter\n                    protocolCheckpoint.quarterPower = powerToSplit\n                        .mul(_time.sub(START_TIME.add(quarter.mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                        .div(_time.sub(protocolPerTimestamp[timeList[prevPid]].time));\n                    protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(quarter);\n\n                    protocolPerQuarter[quarter.sub(1)].quarterPower = protocolPerQuarter[quarter.sub(1)]\n                        .quarterPower\n                        .add(powerToSplit.sub(protocolCheckpoint.quarterPower));\n                } else {\n                    // There were intermediate epochs without checkpoints - we need to create their protocolPerQuarter's and update the last one\n                    // We have to update all the quarters including where the previous checkpoint is and the one were we are now\n                    for (\n                        uint256 i = 0;\n                        i <= quarter.sub(protocolPerTimestamp[timeList[prevPid]].quarterBelonging);\n                        i++\n                    ) {\n                        ProtocolPerQuarter storage newCheckpoint =\n                            protocolPerQuarter[protocolPerTimestamp[timeList[prevPid]].quarterBelonging.add(i)];\n                        uint256 slotEnding =\n                            START_TIME.add(\n                                protocolPerTimestamp[timeList[prevPid]].quarterBelonging.add(i).mul(EPOCH_DURATION)\n                            );\n                        if (i == 0) {\n                            // We are in the first quarter to update, we add the corresponding part\n\n                            newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                                powerToSplit.mul(slotEnding.sub(protocolPerTimestamp[timeList[prevPid]].time)).div(\n                                    _time.sub(protocolPerTimestamp[timeList[prevPid]].time)\n                                )\n                            );\n                            newCheckpoint.quarterPrincipal = protocolPerTimestamp[timeList[prevPid]].principal;\n                        } else if (i < quarter.sub(protocolPerTimestamp[timeList[prevPid]].quarterBelonging)) {\n                            // We are in an intermediate quarter\n                            newCheckpoint.quarterPower = powerToSplit.mul(EPOCH_DURATION).div(\n                                _time.sub(protocolPerTimestamp[timeList[prevPid]].time)\n                            );\n                            newCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(\n                                protocolPerTimestamp[timeList[prevPid]].quarterBelonging.add(i)\n                            );\n                            newCheckpoint.quarterNumber = protocolPerTimestamp[timeList[prevPid]].quarterBelonging.add(\n                                i\n                            );\n                            newCheckpoint.quarterPrincipal = protocolPerTimestamp[timeList[prevPid]].principal;\n                        } else {\n                            // We are in the last quarter of the strategy\n                            protocolCheckpoint.quarterPower = powerToSplit\n                                .mul(_time.sub(START_TIME.add(quarter.mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                                .div(_time.sub(protocolPerTimestamp[timeList[prevPid]].time));\n                            protocolCheckpoint.supplyPerQuarter = _tokenSupplyPerQuarter(quarter);\n                            protocolCheckpoint.quarterNumber = quarter;\n                            protocolCheckpoint.quarterPrincipal = protocolPrincipal;\n                        }\n                    }\n                }\n            }\n            isProtocolPerQuarter[quarter.sub(1)] = true;\n        } else {\n            // Quarter checkpoint already created, it must have been filled with general info\n            // We update the power of the quarter by adding the new difference between last quarter checkpoint and this checkpoint\n            protocolCheckpoint.quarterPower = protocolCheckpoint.quarterPower.add(\n                protocolPerTimestamp[_time].power.sub(protocolPerTimestamp[timeList[pid.sub(1)]].power)\n            );\n        }\n        protocolCheckpoint.quarterPrincipal = protocolPrincipal;\n    }\n\n    /**\n     * Updates the strategy power per quarter for rewards calculations of each strategy out of the whole protocol\n     * @param _strategy      Strategy\n     * @param _capital       New capital normalized in DAI\n     */\n    function _updateStrategyPowerPerQuarter(\n        IStrategy _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private onlyMiningActive {\n        StrategyPerQuarter storage strategyCheckpoint =\n            strategyPerQuarter[address(_strategy)][_getQuarter(block.timestamp)];\n\n        if (!strategyCheckpoint.initialized) {\n            // The strategy quarter is not yet initialized then we create it\n            if (_getQuarter(block.timestamp) == _getQuarter(_strategy.executedAt())) {\n                // The first checkpoint in the first executing epoch\n                strategyCheckpoint.quarterPower = 0;\n                strategyCheckpoint.quarterNumber = _getQuarter(block.timestamp);\n            } else {\n                // Each time a new epoch starts with either a new strategy execution or finalization\n                // We just take the proportional power for this quarter from previous checkpoint\n                uint256 powerToSplit =\n                    strategyPerQuarter[address(_strategy)][_getQuarter(_strategy.updatedAt())].quarterPrincipal.mul(\n                        block.timestamp.sub(_strategy.updatedAt())\n                    );\n                // We need to iterate since last update of the strategy capital\n                (uint256 numQuarters, uint256 startingQuarter) =\n                    _getRewardsWindow(_strategy.updatedAt(), block.timestamp);\n\n                // There were intermediate epochs without checkpoints - we need to create their protocolPerQuarter's and update the last one\n                // We have to update all the quarters including where the previous checkpoint is and the one were we are now\n                for (uint256 i = 0; i < numQuarters; i++) {\n                    StrategyPerQuarter storage newCheckpoint =\n                        strategyPerQuarter[address(_strategy)][startingQuarter.add(i)];\n                    uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION));\n                    if (i == 0) {\n                        // We are in the first quarter to update, we add the corresponding part\n\n                        newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                            powerToSplit.mul(slotEnding.sub(_strategy.updatedAt())).div(\n                                block.timestamp.sub(_strategy.updatedAt())\n                            )\n                        );\n                    } else if (i > 0 && i.add(1) < numQuarters) {\n                        // We are in an intermediate quarter\n                        newCheckpoint.quarterPower = powerToSplit.mul(EPOCH_DURATION).div(\n                            block.timestamp.sub(_strategy.updatedAt())\n                        );\n                        newCheckpoint.quarterNumber = startingQuarter.add(i);\n                        newCheckpoint.quarterPrincipal = strategyPerQuarter[address(_strategy)][startingQuarter]\n                            .quarterPrincipal;\n                        newCheckpoint.initialized = true;\n                    } else {\n                        // We are in the last quarter of the strategy\n                        newCheckpoint.quarterPower = powerToSplit\n                            .mul(\n                            block.timestamp.sub(\n                                START_TIME.add(_getQuarter(block.timestamp).mul(EPOCH_DURATION).sub(EPOCH_DURATION))\n                            )\n                        )\n                            .div(block.timestamp.sub(_strategy.updatedAt()));\n                        newCheckpoint.quarterPrincipal = strategyPerQuarter[address(_strategy)][startingQuarter]\n                            .quarterPrincipal;\n                        newCheckpoint.quarterNumber = _getQuarter(block.timestamp);\n                    }\n                }\n            }\n            strategyCheckpoint.initialized = true;\n        } else {\n            // Quarter checkpoint already created, it must have been filled with general info\n            // We update the power of the quarter by adding the new difference between last quarter checkpoint and this checkpoint\n\n            strategyCheckpoint.quarterPower = strategyCheckpoint.quarterPower.add(\n                strategyCheckpoint.quarterPrincipal.mul(block.timestamp.sub(_strategy.updatedAt()))\n            );\n        }\n        if (_addOrSubstract == true) {\n            // Add\n            strategyCheckpoint.quarterPrincipal = strategyCheckpoint.quarterPrincipal.add(_capital);\n        } else {\n            // Sub\n            strategyCheckpoint.quarterPrincipal = strategyCheckpoint.quarterPrincipal.sub(_capital);\n        }\n    }\n\n    /**\n     * Safe BABL rewards (Mining program) token transfer.\n     * It handle cases when in case of rounding errors, RewardsDistributor might not have enough BABL.\n     * @param _to               The receiver address of the contributor to send\n     * @param _amount           The amount of BABL tokens to be rewarded during this claim\n     */\n    function _safeBABLTransfer(address _to, uint96 _amount) private onlyMiningActive {\n        uint256 bablBal = babltoken.balanceOf(address(this));\n        if (_amount > bablBal) {\n            SafeERC20.safeTransfer(babltoken, _to, bablBal);\n        } else {\n            SafeERC20.safeTransfer(babltoken, _to, _amount);\n        }\n    }\n\n    /**\n     * Gets the contributor power from a timestamp to a specific timestamp within a garden\n     * @param _garden      Address of the garden\n     * @param _contributor Address if the contributor\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n    function _getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256) {\n        // Out of bounds\n        _require(_to >= IGarden(_garden).gardenInitializedAt() && _to >= _from, Errors.CONTRIBUTOR_POWER_CHECK_WINDOW);\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][address(_contributor)];\n        Checkpoints memory powerCheckpoints = checkpoints[address(_garden)][address(_contributor)];\n\n        if (contributor.initialDepositAt == 0 || contributor.initialDepositAt > _to) {\n            return 0;\n        } else {\n            if (_from <= IGarden(_garden).gardenInitializedAt()) {\n                // Avoid division by zero in case of _from parameter is not passed\n                _from = IGarden(_garden).gardenInitializedAt();\n            }\n            // Find closest point to _from and _to either contributor and garden checkpoints at their left\n            (powerCheckpoints.fromDepositAt, powerCheckpoints.lastDepositAt) = _locateCheckpointsContributor(\n                _garden,\n                _contributor,\n                _from,\n                _to\n            );\n            (powerCheckpoints.gardenFromDepositAt, powerCheckpoints.gardenLastDepositAt) = _locateCheckpointsGarden(\n                _garden,\n                _from,\n                _to\n            );\n\n            // origin must be less than end window\n            _require(\n                powerCheckpoints.fromDepositAt <= powerCheckpoints.lastDepositAt &&\n                    powerCheckpoints.gardenFromDepositAt <= powerCheckpoints.gardenLastDepositAt,\n                Errors.CONTRIBUTOR_POWER_CHECK_DEPOSITS\n            );\n            uint256 contributorPower;\n            uint256 gardenPower;\n\n            // \"FROM power calculations\" PART\n            // Avoid underflows\n\n            if (_from < powerCheckpoints.fromDepositAt) {\n                // Contributor still has no power but _from is later than the start of the garden\n                contributorPower = 0;\n            } else if (_from > powerCheckpoints.fromDepositAt) {\n                contributorPower = contributor.tsContributions[powerCheckpoints.fromDepositAt].power.add(\n                    (_from.sub(powerCheckpoints.fromDepositAt)).mul(\n                        contributor.tsContributions[powerCheckpoints.fromDepositAt].supply\n                    )\n                );\n            } else {\n                // _from == fromDepositAt\n                contributorPower = contributor.tsContributions[powerCheckpoints.fromDepositAt].power;\n            }\n            gardenPower = gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenFromDepositAt].power.add(\n                (_from.sub(powerCheckpoints.gardenFromDepositAt)).mul(\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenFromDepositAt].supply\n                )\n            );\n            // \"TO power calculations\" PART\n            // We go for accurate power calculations avoiding overflows\n            // contributor power overflow\n            _require(contributorPower <= gardenPower, Errors.CONTRIBUTOR_POWER_OVERFLOW);\n            if (_from == _to) {\n                // Requested a specific checkpoint calculation (no slot)\n                if (gardenPower == 0) {\n                    return 0;\n                } else {\n                    return contributorPower.preciseDiv(gardenPower);\n                }\n                // Not a checkpoint anymore but a slot\n            } else if (_to < powerCheckpoints.lastDepositAt) {\n                // contributor has not deposited yet\n                return 0;\n            } else if (\n                _to == powerCheckpoints.lastDepositAt &&\n                powerCheckpoints.fromDepositAt == powerCheckpoints.lastDepositAt\n            ) {\n                // no more contributor checkpoints in the slot\n                gardenPower = (\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.gardenLastDepositAt)).mul(\n                            gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].supply\n                        )\n                    )\n                )\n                    .sub(gardenPower);\n                _require(contributorPower <= gardenPower, Errors.CONTRIBUTOR_POWER_OVERFLOW);\n                return contributorPower.preciseDiv(gardenPower);\n            } else {\n                contributorPower = (\n                    contributor.tsContributions[powerCheckpoints.lastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.lastDepositAt)).mul(\n                            contributor.tsContributions[powerCheckpoints.lastDepositAt].supply\n                        )\n                    )\n                )\n                    .sub(contributorPower);\n\n                gardenPower = (\n                    gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].power.add(\n                        (_to.sub(powerCheckpoints.gardenLastDepositAt)).mul(\n                            gardenPowerByTimestamp[address(_garden)][powerCheckpoints.gardenLastDepositAt].supply\n                        )\n                    )\n                )\n                    .sub(gardenPower);\n                _require(contributorPower <= gardenPower, Errors.CONTRIBUTOR_POWER_OVERFLOW);\n\n                return contributorPower.preciseDiv(gardenPower);\n            }\n        }\n    }\n\n    /**\n     * Gets the earlier and closest (deposit/withdrawal) checkpoints of a contributor in a specific range\n     * @param _garden      Address of the garden\n     * @param _contributor Address if the contributor\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n    function _locateCheckpointsContributor(\n        address _garden,\n        address _contributor,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256, uint256) {\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][address(_contributor)];\n\n        uint256 lastDepositAt = contributor.timeListPointer[contributor.timeListPointer.length.sub(1)]; // Initialized with lastDeposit\n        uint256 fromDepositAt = contributor.timeListPointer[0]; // Initialized with initialDeposit\n\n        if (lastDepositAt > _to || fromDepositAt < _from) {\n            // We go to find the closest deposits of the contributor to _from and _to\n            for (uint256 i = 0; i < contributor.timeListPointer.length; i++) {\n                if (contributor.timeListPointer[i] <= _to) {\n                    lastDepositAt = contributor.timeListPointer[i];\n                }\n                if (contributor.timeListPointer[i] <= _from) {\n                    fromDepositAt = contributor.timeListPointer[i];\n                }\n            }\n        }\n        return (fromDepositAt, lastDepositAt);\n    }\n\n    /**\n     * Gets the earlier and closest (deposit/withdrawal) checkpoints of a garden in a specific range\n     * @param _garden      Address of the garden\n     * @param _from        Initial timestamp\n     * @param _to          End timestamp\n     * @return uint256     Contributor power during that period\n     */\n    function _locateCheckpointsGarden(\n        address _garden,\n        uint256 _from,\n        uint256 _to\n    ) private view returns (uint256, uint256) {\n        uint256 gardenLastCheckpoint = gardenTimelist[address(_garden)].length.sub(1);\n        uint256 gardenLastDepositAt = gardenTimelist[address(_garden)][gardenLastCheckpoint]; // Initialized to the last garden checkpoint\n        uint256 gardenFromDepositAt = gardenTimelist[address(_garden)][0]; // Initialized to the first garden checkpoint\n\n        if (gardenLastDepositAt > _to || gardenFromDepositAt < _from) {\n            // We go for the closest timestamp of garden to _to and _from\n            for (uint256 i = 0; i <= gardenLastCheckpoint; i++) {\n                uint256 gardenTime = gardenTimelist[address(_garden)][i];\n                if (gardenTime <= _to) {\n                    gardenLastDepositAt = gardenTime;\n                }\n                if (gardenTime <= _from) {\n                    gardenFromDepositAt = gardenTime;\n                }\n            }\n        }\n        return (gardenFromDepositAt, gardenLastDepositAt);\n    }\n\n    /**\n     * Function that keeps checkpoints of the garden power (deposits and withdrawals) per timestamp\n     * @param _garden               Garden address\n     */\n    function _updateGardenPower(address _garden) private {\n        IGarden garden = IGarden(_garden);\n        GardenPowerByTimestamp storage gardenTimestamp = gardenPowerByTimestamp[address(garden)][block.timestamp];\n        gardenTimestamp.supply = IERC20(address(IGarden(_garden))).totalSupply();\n\n        gardenTimestamp.timestamp = block.timestamp;\n\n        if (gardenPid[address(_garden)] == 0) {\n            // The very first deposit of all contributors in the mining program\n            gardenTimestamp.power = 0;\n        } else {\n            // Any other deposit different from the very first one (will have an antecesor)\n            GardenPowerByTimestamp storage previousGardenTimestamp =\n                gardenPowerByTimestamp[address(garden)][\n                    gardenTimelist[address(garden)][gardenPid[address(garden)].sub(1)]\n                ];\n            gardenTimestamp.power = previousGardenTimestamp.power.add(\n                gardenTimestamp.timestamp.sub(previousGardenTimestamp.timestamp).mul(previousGardenTimestamp.supply)\n            );\n        }\n\n        gardenTimelist[address(garden)].push(block.timestamp); // Register of deposit timestamps in the array for iteration\n        gardenPid[address(garden)]++;\n    }\n\n    /**\n     * Updates contributor timestamps params\n     * @param _garden               Garden address\n     * @param _contributor          Contributor address\n     * @param _previousBalance      Previous balance\n     * @param _depositOrWithdraw    Whether it is a deposit or a withdraw\n     */\n    function _setContributorTimestampParams(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        bool _depositOrWithdraw\n    ) private {\n        // We make checkpoints around contributor deposits to avoid fast loans and give the right rewards afterwards\n        ContributorPerGarden storage contributor = contributorPerGarden[address(_garden)][_contributor];\n        TimestampContribution storage contributorDetail = contributor.tsContributions[block.timestamp];\n        contributorDetail.supply = IERC20(address(IGarden(_garden))).balanceOf(address(_contributor));\n\n        contributorDetail.timestamp = block.timestamp;\n\n        contributorDetail.timePointer = contributor.pid;\n\n        if (contributor.pid == 0) {\n            // The very first deposit\n            contributorDetail.power = 0;\n        } else {\n            // Any other deposits or withdrawals different from the very first one (will have an antecesor)\n            contributorDetail.power = contributor.tsContributions[contributor.lastDepositAt].power.add(\n                (block.timestamp.sub(contributor.lastDepositAt)).mul(\n                    contributor.tsContributions[contributor.lastDepositAt].supply\n                )\n            );\n        }\n        if (_depositOrWithdraw == true) {\n            // Deposit\n            if (_previousBalance == 0 || contributor.initialDepositAt == 0) {\n                contributor.initialDepositAt = block.timestamp;\n            }\n            contributor.lastDepositAt = block.timestamp;\n        } else {\n            // Withdrawals\n            if (contributorDetail.supply == 0) {\n                contributor.lastDepositAt = 0;\n                contributor.initialDepositAt = 0;\n                delete contributor.timeListPointer;\n            }\n        }\n\n        contributor.timeListPointer.push(block.timestamp);\n        contributor.pid++;\n    }\n\n    /**\n     * Calculates the BABL rewards supply for each quarter\n     * @param _quarter      Number of the epoch (quarter)\n     */\n    function _tokenSupplyPerQuarter(uint256 _quarter) internal view returns (uint96) {\n        _require(_quarter >= 1, Errors.QUARTERS_MIN_1);\n        if (_quarter >= 513) {\n            return 0; // Avoid math overflow\n        } else {\n            uint256 firstFactor = (SafeDecimalMath.unit().add(DECAY_RATE)).powDecimal(_quarter.sub(1));\n            uint256 supplyForQuarter = Q1_REWARDS.divideDecimal(firstFactor);\n            return Safe3296.safe96(supplyForQuarter, 'overflow 96 bits');\n        }\n    }\n\n    /**\n     * Calculates the quarter number for a specific time since START_TIME\n     * @param _now      Timestamp to calculate its quarter\n     */\n    function _getQuarter(uint256 _now) internal view returns (uint256) {\n        uint256 quarter = (_now.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        return quarter.add(1);\n    }\n\n    /**\n     * Calculates the range (starting quarter and ending quarter since START_TIME)\n     * @param _from   Starting timestamp\n     * @param _to     Ending timestamp\n     */\n    function _getRewardsWindow(uint256 _from, uint256 _to) internal view returns (uint256, uint256) {\n        uint256 quarters = (_to.sub(_from).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        uint256 startingQuarter = (_from.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        uint256 endingQuarter = (_to.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        if (\n            startingQuarter != endingQuarter &&\n            endingQuarter == startingQuarter.add(1) &&\n            _to.sub(_from) < EPOCH_DURATION\n        ) {\n            quarters = quarters.add(1);\n        }\n        return (quarters.add(1), startingQuarter.add(1));\n    }\n}\n\ncontract RewardsDistributorV3 is RewardsDistributor {}\n"
    },
    "contracts/token/TimeLockedToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {VoteToken} from './VoteToken.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title TimeLockedToken\n * @notice Time Locked ERC20 Token\n * @author Babylon Finance\n * @dev Contract which gives the ability to time-lock tokens specially for vesting purposes usage\n *\n * By overriding the balanceOf() and transfer() functions in ERC20,\n * an account can show its full, post-distribution balance and use it for voting power\n * but only transfer or spend up to an allowed amount\n *\n * A portion of previously non-spendable tokens are allowed to be transferred\n * along the time depending on each vesting conditions, and after all epochs have passed, the full\n * account balance is unlocked. In case on non-completion vesting period, only the Time Lock Registry can cancel\n * the delivery of the pending tokens and only can cancel the remaining locked ones.\n */\n\nabstract contract TimeLockedToken is VoteToken {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new lockout ocurr\n    event NewLockout(\n        address account,\n        uint256 tokenslocked,\n        bool isTeamOrAdvisor,\n        uint256 startingVesting,\n        uint256 endingVesting\n    );\n\n    /// @notice An event that emitted when a new Time Lock is registered\n    event NewTimeLockRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a new Rewards Distributor is registered\n    event NewRewardsDistributorRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a cancellation of Lock tokens is registered\n    event Cancel(address account, uint256 amount);\n\n    /// @notice An event that emitted when a claim of tokens are registered\n    event Claim(address _receiver, uint256 amount);\n\n    /// @notice An event that emitted when a lockedBalance query is done\n    event LockedBalance(address _account, uint256 amount);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyTimeLockRegistry() {\n        require(\n            msg.sender == address(timeLockRegistry),\n            'TimeLockedToken:: onlyTimeLockRegistry: can only be executed by TimeLockRegistry'\n        );\n        _;\n    }\n\n    modifier onlyTimeLockOwner() {\n        if (address(timeLockRegistry) != address(0)) {\n            require(\n                msg.sender == Ownable(timeLockRegistry).owner(),\n                'TimeLockedToken:: onlyTimeLockOwner: can only be executed by the owner of TimeLockRegistry'\n            );\n        }\n        _;\n    }\n    modifier onlyUnpaused() {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // represents total distribution for locked balances\n    mapping(address => uint256) distribution;\n\n    /// @notice The profile of each token owner under its particular vesting conditions\n    /**\n     * @param team Indicates whether or not is a Team member or Advisor (true = team member/advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct VestedToken {\n        bool teamOrAdvisor;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => VestedToken) public vestedToken;\n\n    // address of Time Lock Registry contract\n    IBabController public controller;\n\n    // address of Time Lock Registry contract\n    TimeLockRegistry public timeLockRegistry;\n\n    // address of Rewards Distriburor contract\n    IRewardsDistributor public rewardsDistributor;\n\n    // Enable Transfer of ERC20 BABL Tokens\n    // Only Minting or transfers from/to TimeLockRegistry and Rewards Distributor can transfer tokens until the protocol is fully decentralized\n    bool private tokenTransfersEnabled;\n    bool private tokenTransfersWereDisabled;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) VoteToken(_name, _symbol) {\n        tokenTransfersEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disables transfers of ERC20 BABL Tokens\n     */\n    function disableTokensTransfers() external onlyOwner {\n        require(!tokenTransfersWereDisabled, 'BABL must flow');\n        tokenTransfersEnabled = false;\n        tokenTransfersWereDisabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 BABL Tokens\n     * Can only happen after the protocol is fully decentralized.\n     */\n    function enableTokensTransfers() external onlyOwner {\n        tokenTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Time Lock Registry contract to control token vesting conditions\n     *\n     * @notice Set the Time Lock Registry contract to control token vesting conditions\n     * @param newTimeLockRegistry Address of TimeLockRegistry contract\n     */\n    function setTimeLockRegistry(TimeLockRegistry newTimeLockRegistry) external onlyTimeLockOwner returns (bool) {\n        require(address(newTimeLockRegistry) != address(0), 'cannot be zero address');\n        require(address(newTimeLockRegistry) != address(this), 'cannot be this contract');\n        require(address(newTimeLockRegistry) != address(timeLockRegistry), 'must be new TimeLockRegistry');\n        emit NewTimeLockRegistration(address(timeLockRegistry), address(newTimeLockRegistry));\n\n        timeLockRegistry = newTimeLockRegistry;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Rewards Distributor contract to control either BABL Mining or profit rewards\n     *\n     * @notice Set the Rewards Distriburor contract to control both types of rewards (profit and BABL Mining program)\n     * @param newRewardsDistributor Address of Rewards Distributor contract\n     */\n    function setRewardsDistributor(IRewardsDistributor newRewardsDistributor) external onlyOwner returns (bool) {\n        require(address(newRewardsDistributor) != address(0), 'cannot be zero address');\n        require(address(newRewardsDistributor) != address(this), 'cannot be this contract');\n        require(address(newRewardsDistributor) != address(rewardsDistributor), 'must be new Rewards Distributor');\n        emit NewRewardsDistributorRegistration(address(rewardsDistributor), address(newRewardsDistributor));\n\n        rewardsDistributor = newRewardsDistributor;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Register new token lockup conditions for vested tokens defined only by Time Lock Registry\n     *\n     * @notice Tokens are completely delivered during the registration however lockup conditions apply for vested tokens\n     * locking them according to the distribution epoch periods and the type of recipient (Team, Advisor, Investor)\n     * Emits a transfer event showing a transfer to the recipient\n     * Only the registry can call this function\n     * @param _receiver Address to receive the tokens\n     * @param _amount Tokens to be transferred\n     * @param _profile True if is a Team Member or Advisor\n     * @param _vestingBegin Unix Time when the vesting for that particular address\n     * @param _vestingEnd Unix Time when the vesting for that particular address\n     * @param _lastClaim Unix Time when the claim was done from that particular address\n     *\n     */\n    function registerLockup(\n        address _receiver,\n        uint256 _amount,\n        bool _profile,\n        uint256 _vestingBegin,\n        uint256 _vestingEnd,\n        uint256 _lastClaim\n    ) external onlyTimeLockRegistry returns (bool) {\n        require(balanceOf(msg.sender) >= _amount, 'insufficient balance');\n        require(_receiver != address(0), 'cannot be zero address');\n        require(_receiver != address(this), 'cannot be this contract');\n        require(_receiver != address(timeLockRegistry), 'cannot be the TimeLockRegistry contract itself');\n        require(_receiver != msg.sender, 'the owner cannot lockup itself');\n\n        // update amount of locked distribution\n        distribution[_receiver] = distribution[_receiver].add(_amount);\n\n        VestedToken storage newVestedToken = vestedToken[_receiver];\n\n        newVestedToken.teamOrAdvisor = _profile;\n        newVestedToken.vestingBegin = _vestingBegin;\n        newVestedToken.vestingEnd = _vestingEnd;\n        newVestedToken.lastClaim = _lastClaim;\n\n        // transfer tokens to the recipient\n        _transfer(msg.sender, _receiver, _amount);\n        emit NewLockout(_receiver, _amount, _profile, _vestingBegin, _vestingEnd);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors as it does not apply to investors.\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function cancelVestedTokens(address lockedAccount) external onlyTimeLockRegistry returns (uint256) {\n        return _cancelVestedTokensFromTimeLock(lockedAccount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Each token owner can claim its own specific tokens with its own specific vesting conditions from the Time Lock Registry\n     *\n     * @dev Claim msg.sender tokens (if any available in the registry)\n     */\n    function claimMyTokens() external {\n        // claim msg.sender tokens from timeLockRegistry\n        uint256 amount = timeLockRegistry.claim(msg.sender);\n        // After a proper claim, locked tokens of Team and Advisors profiles are under restricted special vesting conditions so they automatic grant\n        // rights to the Time Lock Registry to only retire locked tokens if non-compliance vesting conditions take places along the vesting periods.\n        // It does not apply to Investors under vesting (their locked tokens cannot be removed).\n        if (vestedToken[msg.sender].teamOrAdvisor == true) {\n            approve(address(timeLockRegistry), amount);\n        }\n        // emit claim event\n        emit Claim(msg.sender, amount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get unlocked balance for an account\n     *\n     * @notice Get unlocked balance for an account\n     * @param account Account to check\n     * @return Amount that is unlocked and available eg. to transfer\n     */\n    function unlockedBalance(address account) public returns (uint256) {\n        // totalBalance - lockedBalance\n        return balanceOf(account).sub(lockedBalance(account));\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. View the locked balance for an account\n     *\n     * @notice View locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n\n    function viewLockedBalance(address account) public view returns (uint256) {\n        // distribution of locked tokens\n        // get amount from distributions\n\n        uint256 amount = distribution[account];\n        uint256 lockedAmount = amount;\n\n        // Team and investors cannot transfer tokens in the first year\n        if (vestedToken[account].vestingBegin.add(365 days) > block.timestamp && amount != 0) {\n            return lockedAmount;\n        }\n\n        // in case of vesting has passed, all tokens are now available, if no vesting lock is 0 as well\n        if (block.timestamp >= vestedToken[account].vestingEnd || amount == 0) {\n            lockedAmount = 0;\n        } else if (amount != 0) {\n            // in case of still under vesting period, locked tokens are recalculated\n            lockedAmount = amount.mul(vestedToken[account].vestingEnd.sub(block.timestamp)).div(\n                vestedToken[account].vestingEnd.sub(vestedToken[account].vestingBegin)\n            );\n        }\n        return lockedAmount;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get locked balance for an account\n     *\n     * @notice Get locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n    function lockedBalance(address account) public returns (uint256) {\n        // get amount from distributions locked tokens (if any)\n        uint256 lockedAmount = viewLockedBalance(account);\n        // in case of vesting has passed, all tokens are now available so we set mapping to 0 only for accounts under vesting\n        if (\n            block.timestamp >= vestedToken[account].vestingEnd &&\n            msg.sender == account &&\n            lockedAmount == 0 &&\n            vestedToken[account].vestingEnd != 0\n        ) {\n            delete distribution[account];\n        }\n        emit LockedBalance(account, lockedAmount);\n        return lockedAmount;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the address of Time Lock Registry\n     *\n     * @notice Get the address of Time Lock Registry\n     * @return Address of the Time Lock Registry\n     */\n    function getTimeLockRegistry() external view returns (address) {\n        return address(timeLockRegistry);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Approval of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Override of \"Approve\" function to allow the `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender` except in the case of spender is Time Lock Registry\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::approve: spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::approve: spender cannot be the msg.sender');\n\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, 'TimeLockedToken::approve: amount exceeds 96 bits');\n        }\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        if ((spender == address(timeLockRegistry)) && (amount < allowance(msg.sender, address(timeLockRegistry)))) {\n            amount = safe96(\n                allowance(msg.sender, address(timeLockRegistry)),\n                'TimeLockedToken::approve: cannot decrease allowance to timelockregistry'\n            );\n        }\n        _approve(msg.sender, spender, amount);\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Increase of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an override with respect to the fulfillment of vesting conditions along the way\n     * However an user can increase allowance many times, it will never be able to transfer locked tokens during vesting period\n     * @return Whether or not the increaseAllowance succeeded\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public override nonReentrant returns (bool) {\n        require(\n            unlockedBalance(msg.sender) >= allowance(msg.sender, spender).add(addedValue) ||\n                spender == address(timeLockRegistry),\n            'TimeLockedToken::increaseAllowance:Not enough unlocked tokens'\n        );\n        require(spender != address(0), 'TimeLockedToken::increaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::increaseAllowance:Spender cannot be the msg.sender');\n        _approve(msg.sender, spender, allowance(msg.sender, spender).add(addedValue));\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the decrease of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically decrease the allowance granted to `spender` by the caller.\n     *\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an override with respect to the fulfillment of vesting conditions along the way\n     * An user cannot decrease the allowance to the Time Lock Registry who is in charge of vesting conditions\n     * @return Whether or not the decreaseAllowance succeeded\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::decreaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::decreaseAllowance:Spender cannot be the msg.sender');\n        require(\n            allowance(msg.sender, spender) >= subtractedValue,\n            'TimeLockedToken::decreaseAllowance:Underflow condition'\n        );\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        require(\n            address(spender) != address(timeLockRegistry),\n            'TimeLockedToken::decreaseAllowance:cannot decrease allowance to timeLockRegistry'\n        );\n\n        _approve(msg.sender, spender, allowance(msg.sender, spender).sub(subtractedValue));\n        return true;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the _transfer of ERC20 BABL tokens only allowing the transfer of unlocked tokens\n     *\n     * @dev Transfer function which includes only unlocked tokens\n     * Locked tokens can always be transfered back to the returns address\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal override onlyUnpaused {\n        require(_from != address(0), 'TimeLockedToken:: _transfer: cannot transfer from the zero address');\n        require(_to != address(0), 'TimeLockedToken:: _transfer: cannot transfer to the zero address');\n        require(\n            _to != address(this),\n            'TimeLockedToken:: _transfer: do not transfer tokens to the token contract itself'\n        );\n\n        require(balanceOf(_from) >= _value, 'TimeLockedToken:: _transfer: insufficient balance');\n\n        // check if enough unlocked balance to transfer\n        require(unlockedBalance(_from) >= _value, 'TimeLockedToken:: _transfer: attempting to transfer locked funds');\n        super._transfer(_from, _to, _value);\n        // voting power\n        _moveDelegates(\n            delegates[_from],\n            delegates[_to],\n            safe96(_value, 'TimeLockedToken:: _transfer: uint96 overflow')\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disable BABL token transfer until certain conditions are met\n     *\n     * @dev Override the _beforeTokenTransfer of ERC20 BABL tokens until certain conditions are met:\n     * Only allowing minting or transfers from Time Lock Registry and Rewards Distributor until transfers are allowed in the controller\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _value);\n        _require(\n            _from == address(0) ||\n                _from == address(timeLockRegistry) ||\n                _from == address(rewardsDistributor) ||\n                _to == address(timeLockRegistry) ||\n                tokenTransfersEnabled,\n            Errors.BABL_TRANSFERS_DISABLED\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of  vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function _cancelVestedTokensFromTimeLock(address lockedAccount) internal onlyTimeLockRegistry returns (uint256) {\n        require(distribution[lockedAccount] != 0, 'TimeLockedToken::cancelTokens:Not registered');\n\n        // get an update on locked amount from distributions at this precise moment\n        uint256 loosingAmount = lockedBalance(lockedAccount);\n\n        require(loosingAmount > 0, 'TimeLockedToken::cancelTokens:There are no more locked tokens');\n        require(\n            vestedToken[lockedAccount].teamOrAdvisor == true,\n            'TimeLockedToken::cancelTokens:cannot cancel locked tokens to Investors'\n        );\n\n        // set distribution mapping to 0\n        delete distribution[lockedAccount];\n\n        // set tokenVested mapping to 0\n        delete vestedToken[lockedAccount];\n\n        // transfer only locked tokens back to TimeLockRegistry Owner (msg.sender)\n        require(\n            transferFrom(lockedAccount, address(timeLockRegistry), loosingAmount),\n            'TimeLockedToken::cancelTokens:Transfer failed'\n        );\n\n        // emit cancel event\n        emit Cancel(lockedAccount, loosingAmount);\n\n        return loosingAmount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nlibrary SafeDecimalMath {\n    using LowGasSafeMath for uint256;\n\n    /* Number of decimal places in the representations. */\n    uint8 internal constant decimals = 18;\n\n    /* The number representing 1.0. */\n    uint256 internal constant UNIT = 10**uint256(decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() internal pure returns (uint256) {\n        return UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * Normalizing amount decimals between tokens\n     * @param assetFrom       ERC20 asset address\n     * @param assetTarget     ERC20 asset address\n     * @param quantity Value to normalize (e.g. capital)\n     */\n    function normalizeAmountTokens(\n        address assetFrom,\n        address assetTarget,\n        uint256 quantity\n    ) internal view returns (uint256) {\n        uint256 tokenDecimals = assetFrom == address(0) ? 18 : ERC20(assetFrom).decimals();\n        uint256 tokenDecimalsTarget = assetTarget == address(0) ? 18 : ERC20(assetTarget).decimals();\n        require(tokenDecimals <= 18 && tokenDecimalsTarget <= 18, 'Unsupported decimals');\n        if (tokenDecimals == tokenDecimalsTarget) {\n            return quantity;\n        }\n        if (tokenDecimalsTarget > tokenDecimals) {\n            return quantity.mul(10**(tokenDecimalsTarget.sub(tokenDecimals)));\n        }\n        return quantity.div(10**(tokenDecimals.sub(tokenDecimalsTarget)));\n    }\n}\n"
    },
    "contracts/lib/PreciseUnitMath.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {LowGasSafeMath} from './LowGasSafeMath.sol';\n\n/**\n * @title PreciseUnitMath\n * @author Set Protocol\n *\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n * dYdX's BaseMath library.\n *\n * CHANGELOG:\n * - 9/21/20: Added safePower function\n */\nlibrary PreciseUnitMath {\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // The number One in precise units.\n    uint256 internal constant PRECISE_UNIT = 10**18;\n    int256 internal constant PRECISE_UNIT_INT = 10**18;\n\n    // Max unsigned integer value\n    uint256 internal constant MAX_UINT_256 = type(uint256).max;\n    // Max and min signed integer value\n    int256 internal constant MAX_INT_256 = type(int256).max;\n    int256 internal constant MIN_INT_256 = type(int256).min;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function decimals() internal pure returns (uint256) {\n        return 18;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnitInt() internal pure returns (int256) {\n        return PRECISE_UNIT_INT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxUint256() internal pure returns (uint256) {\n        return MAX_UINT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxInt256() internal pure returns (int256) {\n        return MAX_INT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function minInt256() internal pure returns (int256) {\n        return MIN_INT_256;\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n     * significand of a number with 18 decimals precision.\n     */\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(b).div(PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down).\n     */\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISE_UNIT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded towards 0).\n     */\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(PRECISE_UNIT_INT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0).\n     */\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, 'Cant divide by 0');\n\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n     */\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'Cant divide by 0');\n        require(a != MIN_INT_256 || b != -1, 'Invalid input');\n\n        int256 result = a.div(b);\n        if (a ^ b < 0 && a % b != 0) {\n            result -= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Multiplies value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Divides value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\n    }\n\n    /**\n     * @dev Performs the power on a specified value, reverts on overflow.\n     */\n    function safePower(uint256 a, uint256 pow) internal pure returns (uint256) {\n        require(a > 0, 'Value must be positive');\n\n        uint256 result = 1;\n        for (uint256 i = 0; i < pow; i++) {\n            uint256 previousResult = result;\n\n            // Using safemath multiplication prevents overflows\n            result = previousResult.mul(a);\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/lib/Math.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// Libraries\nimport './SafeDecimalMath.sol';\n\n// https://docs.synthetix.io/contracts/source/libraries/math\nlibrary Math {\n    using LowGasSafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /**\n     * @dev Uses \"exponentiation by squaring\" algorithm where cost is 0(logN)\n     * vs 0(N) for naive repeated multiplication.\n     * Calculates x^n with x as fixed-point and n as regular unsigned int.\n     * Calculates to 18 digits of precision with SafeDecimalMath.unit()\n     */\n    function powDecimal(uint256 x, uint256 n) internal pure returns (uint256) {\n        // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n\n        uint256 result = SafeDecimalMath.unit();\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = result.multiplyDecimal(x);\n            }\n            x = x.multiplyDecimal(x);\n            n /= 2;\n        }\n        return result;\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n}\n"
    },
    "contracts/lib/Safe3296.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\nlibrary Safe3296 {\n    using LowGasSafeMath for uint256;\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"
    },
    "contracts/lib/BabylonErrors.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// solhint-disable\n\n/**\n * @notice Forked from https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/lib/helpers/BalancerErrors.sol\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAB#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAB#\" part is a known constant\n        // (0x42414223): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414223000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Max deposit limit needs to be under the limit\n    uint256 internal constant MAX_DEPOSIT_LIMIT = 0;\n    // Creator needs to deposit\n    uint256 internal constant MIN_CONTRIBUTION = 1;\n    // Min Garden token supply >= 0\n    uint256 internal constant MIN_TOKEN_SUPPLY = 2;\n    // Deposit hardlock needs to be at least 1 block\n    uint256 internal constant DEPOSIT_HARDLOCK = 3;\n    // Needs to be at least the minimum\n    uint256 internal constant MIN_LIQUIDITY = 4;\n    // _reserveAssetQuantity is not equal to msg.value\n    uint256 internal constant MSG_VALUE_DO_NOT_MATCH = 5;\n    // Withdrawal amount has to be equal or less than msg.sender balance\n    uint256 internal constant MSG_SENDER_TOKENS_DO_NOT_MATCH = 6;\n    // Tokens are staked\n    uint256 internal constant TOKENS_STAKED = 7;\n    // Balance too low\n    uint256 internal constant BALANCE_TOO_LOW = 8;\n    // msg.sender doesn't have enough tokens\n    uint256 internal constant MSG_SENDER_TOKENS_TOO_LOW = 9;\n    //  There is an open redemption window already\n    uint256 internal constant REDEMPTION_OPENED_ALREADY = 10;\n    // Cannot request twice in the same window\n    uint256 internal constant ALREADY_REQUESTED = 11;\n    // Rewards and profits already claimed\n    uint256 internal constant ALREADY_CLAIMED = 12;\n    // Value have to be greater than zero\n    uint256 internal constant GREATER_THAN_ZERO = 13;\n    // Must be reserve asset\n    uint256 internal constant MUST_BE_RESERVE_ASSET = 14;\n    // Only contributors allowed\n    uint256 internal constant ONLY_CONTRIBUTOR = 15;\n    // Only controller allowed\n    uint256 internal constant ONLY_CONTROLLER = 16;\n    // Only creator allowed\n    uint256 internal constant ONLY_CREATOR = 17;\n    // Only keeper allowed\n    uint256 internal constant ONLY_KEEPER = 18;\n    // Fee is too high\n    uint256 internal constant FEE_TOO_HIGH = 19;\n    // Only strategy allowed\n    uint256 internal constant ONLY_STRATEGY = 20;\n    // Only active allowed\n    uint256 internal constant ONLY_ACTIVE = 21;\n    // Only inactive allowed\n    uint256 internal constant ONLY_INACTIVE = 22;\n    // Address should be not zero address\n    uint256 internal constant ADDRESS_IS_ZERO = 23;\n    // Not within range\n    uint256 internal constant NOT_IN_RANGE = 24;\n    // Value is too low\n    uint256 internal constant VALUE_TOO_LOW = 25;\n    // Value is too high\n    uint256 internal constant VALUE_TOO_HIGH = 26;\n    // Only strategy or protocol allowed\n    uint256 internal constant ONLY_STRATEGY_OR_CONTROLLER = 27;\n    // Normal withdraw possible\n    uint256 internal constant NORMAL_WITHDRAWAL_POSSIBLE = 28;\n    // User does not have permissions to join garden\n    uint256 internal constant USER_CANNOT_JOIN = 29;\n    // User does not have permissions to add strategies in garden\n    uint256 internal constant USER_CANNOT_ADD_STRATEGIES = 30;\n    // Only Protocol or garden\n    uint256 internal constant ONLY_PROTOCOL_OR_GARDEN = 31;\n    // Only Strategist\n    uint256 internal constant ONLY_STRATEGIST = 32;\n    // Only Integration\n    uint256 internal constant ONLY_INTEGRATION = 33;\n    // Only garden and data not set\n    uint256 internal constant ONLY_GARDEN_AND_DATA_NOT_SET = 34;\n    // Only active garden\n    uint256 internal constant ONLY_ACTIVE_GARDEN = 35;\n    // Contract is not a garden\n    uint256 internal constant NOT_A_GARDEN = 36;\n    // Not enough tokens\n    uint256 internal constant STRATEGIST_TOKENS_TOO_LOW = 37;\n    // Stake is too low\n    uint256 internal constant STAKE_HAS_TO_AT_LEAST_ONE = 38;\n    // Duration must be in range\n    uint256 internal constant DURATION_MUST_BE_IN_RANGE = 39;\n    // Max Capital Requested\n    uint256 internal constant MAX_CAPITAL_REQUESTED = 41;\n    // Votes are already resolved\n    uint256 internal constant VOTES_ALREADY_RESOLVED = 42;\n    // Voting window is closed\n    uint256 internal constant VOTING_WINDOW_IS_OVER = 43;\n    // Strategy needs to be active\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_ACTIVE = 44;\n    // Max capital reached\n    uint256 internal constant MAX_CAPITAL_REACHED = 45;\n    // Capital is less then rebalance\n    uint256 internal constant CAPITAL_IS_LESS_THAN_REBALANCE = 46;\n    // Strategy is in cooldown period\n    uint256 internal constant STRATEGY_IN_COOLDOWN = 47;\n    // Strategy is not executed\n    uint256 internal constant STRATEGY_IS_NOT_EXECUTED = 48;\n    // Strategy is not over yet\n    uint256 internal constant STRATEGY_IS_NOT_OVER_YET = 49;\n    // Strategy is already finalized\n    uint256 internal constant STRATEGY_IS_ALREADY_FINALIZED = 50;\n    // No capital to unwind\n    uint256 internal constant STRATEGY_NO_CAPITAL_TO_UNWIND = 51;\n    // Strategy needs to be inactive\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_INACTIVE = 52;\n    // Duration needs to be less\n    uint256 internal constant DURATION_NEEDS_TO_BE_LESS = 53;\n    // Can't sweep reserve asset\n    uint256 internal constant CANNOT_SWEEP_RESERVE_ASSET = 54;\n    // Voting window is opened\n    uint256 internal constant VOTING_WINDOW_IS_OPENED = 55;\n    // Strategy is executed\n    uint256 internal constant STRATEGY_IS_EXECUTED = 56;\n    // Min Rebalance Capital\n    uint256 internal constant MIN_REBALANCE_CAPITAL = 57;\n    // Not a valid strategy NFT\n    uint256 internal constant NOT_STRATEGY_NFT = 58;\n    // Garden Transfers Disabled\n    uint256 internal constant GARDEN_TRANSFERS_DISABLED = 59;\n    // Tokens are hardlocked\n    uint256 internal constant TOKENS_HARDLOCKED = 60;\n    // Max contributors reached\n    uint256 internal constant MAX_CONTRIBUTORS = 61;\n    // BABL Transfers Disabled\n    uint256 internal constant BABL_TRANSFERS_DISABLED = 62;\n    // Strategy duration range error\n    uint256 internal constant DURATION_RANGE = 63;\n    // Checks the min amount of voters\n    uint256 internal constant MIN_VOTERS_CHECK = 64;\n    // Ge contributor power error\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_WINDOW = 65;\n    // Not enough reserve set aside\n    uint256 internal constant NOT_ENOUGH_RESERVE = 66;\n    // Garden is already public\n    uint256 internal constant GARDEN_ALREADY_PUBLIC = 67;\n    // Withdrawal with penalty\n    uint256 internal constant WITHDRAWAL_WITH_PENALTY = 68;\n    // Withdrawal with penalty\n    uint256 internal constant ONLY_MINING_ACTIVE = 69;\n    // Overflow in supply\n    uint256 internal constant OVERFLOW_IN_SUPPLY = 70;\n    // Overflow in power\n    uint256 internal constant OVERFLOW_IN_POWER = 71;\n    // Not a system contract\n    uint256 internal constant NOT_A_SYSTEM_CONTRACT = 72;\n    // Strategy vs Garden mismatch\n    uint256 internal constant STRATEGY_GARDEN_MISMATCH = 73;\n    // Minimum quarters is 1\n    uint256 internal constant QUARTERS_MIN_1 = 74;\n    // Too many strategy operations\n    uint256 internal constant TOO_MANY_OPS = 75;\n    // Only operations\n    uint256 internal constant ONLY_OPERATION = 76;\n    // Strat params wrong length\n    uint256 internal constant STRAT_PARAMS_LENGTH = 77;\n    // Garden params wrong length\n    uint256 internal constant GARDEN_PARAMS_LENGTH = 78;\n    // Token names too long\n    uint256 internal constant NAME_TOO_LONG = 79;\n    // Contributor power overflows over garden power\n    uint256 internal constant CONTRIBUTOR_POWER_OVERFLOW = 80;\n    // Contributor power window out of bounds\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_DEPOSITS = 81;\n    // Contributor power window out of bounds\n    uint256 internal constant NO_REWARDS_TO_CLAIM = 82;\n    // Pause guardian paused this operation\n    uint256 internal constant ONLY_UNPAUSED = 83;\n    // Reentrant intent\n    uint256 internal constant REENTRANT_CALL = 84;\n    // Reserve asset not supported\n    uint256 internal constant RESERVE_ASSET_NOT_SUPPORTED = 85;\n    // Withdrawal/Deposit check min amount received\n    uint256 internal constant RECEIVE_MIN_AMOUNT = 86;\n    // Total Votes has to be positive\n    uint256 internal constant TOTAL_VOTES_HAVE_TO_BE_POSITIVE = 87;\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol IPriceOracle)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPriceOracle\n * @author Babylon Finance\n *\n * Interface for interacting with PriceOracle\n */\ninterface IPriceOracle {\n    /* ============ Functions ============ */\n\n    function getPrice(address _assetOne, address _assetTwo) external view returns (uint256);\n}\n"
    },
    "contracts/token/TimeLockRegistry.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\n/**\n * @title TimeLockRegistry\n * @notice Register Lockups for TimeLocked ERC20 Token BABL (e.g. vesting)\n * @author Babylon Finance\n * @dev This contract allows owner to register distributions for a TimeLockedToken\n *\n * To register a distribution, register method should be called by the owner.\n * claim() should be called only by the BABL Token smartcontract (modifier onlyBABLToken)\n *  when any account registered to receive tokens make its own claim\n * If case of a mistake, owner can cancel registration before the claim is done by the account\n *\n * Note this contract address must be setup in the TimeLockedToken's contract pointing\n * to interact with (e.g. setTimeLockRegistry() function)\n */\n\ncontract TimeLockRegistry is Ownable {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n\n    event Register(address receiver, uint256 distribution);\n    event Cancel(address receiver, uint256 distribution);\n    event Claim(address account, uint256 distribution);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyBABLToken() {\n        require(msg.sender == address(token), 'only BABL Token');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // time locked token\n    TimeLockedToken public token;\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param receiver Account being registered\n     * @param investorType Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingStarting Date When the vesting begins for such token owner\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    struct Registration {\n        address receiver;\n        uint256 distribution;\n        bool investorType;\n        uint256 vestingStartingDate;\n    }\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param team Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct TokenVested {\n        bool team;\n        bool cliff;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => TokenVested) public tokenVested;\n\n    // mapping from token owners under vesting conditions to BABL due amount (e.g. SAFT addresses, team members, advisors)\n    mapping(address => uint256) public registeredDistributions;\n\n    // array of all registrations\n    address[] public registrations;\n\n    // total amount of tokens registered\n    uint256 public totalTokens;\n\n    // vesting for Team Members\n    uint256 private constant teamVesting = 365 days * 4;\n\n    // vesting for Investors and Advisors\n    uint256 private constant investorVesting = 365 days * 3;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new Time Lock Registry and gives ownership to sender\n     * @param _token TimeLockedToken contract to use in this registry\n     */\n    constructor(TimeLockedToken _token) {\n        token = _token;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets registrations\n     *\n     * @return  address[]        Returns list of registrations\n     */\n\n    function getRegistrations() external view returns (address[] memory) {\n        return registrations;\n    }\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register multiple investors/team in a batch\n     * @param _registrations Registrations to process\n     */\n    function registerBatch(Registration[] memory _registrations) external onlyOwner {\n        for (uint256 i = 0; i < _registrations.length; i++) {\n            register(\n                _registrations[i].receiver,\n                _registrations[i].distribution,\n                _registrations[i].investorType,\n                _registrations[i].vestingStartingDate\n            );\n        }\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register new account under vesting conditions (Team, Advisors, Investors e.g. SAFT purchaser)\n     * @param receiver Address belonging vesting conditions\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    function register(\n        address receiver,\n        uint256 distribution,\n        bool investorType,\n        uint256 vestingStartingDate\n    ) public onlyOwner {\n        require(receiver != address(0), 'TimeLockRegistry::register: cannot register the zero address');\n        require(\n            receiver != address(this),\n            'TimeLockRegistry::register: Time Lock Registry contract cannot be an investor'\n        );\n        require(distribution != 0, 'TimeLockRegistry::register: Distribution = 0');\n        require(\n            registeredDistributions[receiver] == 0,\n            'TimeLockRegistry::register:Distribution for this address is already registered'\n        );\n        require(block.timestamp >= 1614553200, 'Cannot register earlier than March 2021'); // 1614553200 is UNIX TIME of 2021 March the 1st\n        require(totalTokens.add(distribution) <= IERC20(token).balanceOf(address(this)), 'Not enough tokens');\n\n        totalTokens = totalTokens.add(distribution);\n        // register distribution\n        registeredDistributions[receiver] = distribution;\n        registrations.push(receiver);\n\n        // register token vested conditions\n        TokenVested storage newTokenVested = tokenVested[receiver];\n        newTokenVested.team = investorType;\n        newTokenVested.vestingBegin = vestingStartingDate;\n\n        if (newTokenVested.team == true) {\n            newTokenVested.vestingEnd = vestingStartingDate.add(teamVesting);\n        } else {\n            newTokenVested.vestingEnd = vestingStartingDate.add(investorVesting);\n        }\n        newTokenVested.lastClaim = vestingStartingDate;\n\n        tokenVested[receiver] = newTokenVested;\n\n        // emit register event\n        emit Register(receiver, distribution);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel distribution registration\n     * @dev A claim has not to be done earlier\n     * @param receiver Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelRegistration(address receiver) external onlyOwner returns (bool) {\n        require(registeredDistributions[receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[receiver];\n\n        // set distribution mapping to 0\n        delete registeredDistributions[receiver];\n\n        // set tokenVested mapping to 0\n        delete tokenVested[receiver];\n\n        // remove from the list of all registrations\n        registrations.remove(receiver);\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // emit cancel event\n        emit Cancel(receiver, amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel already delivered tokens. It might only apply when non-completion of vesting period of Team members or Advisors\n     * @dev An automatic override allowance is granted during the claim process\n     * @param account Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelDeliveredTokens(address account) external onlyOwner returns (bool) {\n        uint256 loosingAmount = token.cancelVestedTokens(account);\n\n        // emit cancel event\n        emit Cancel(account, loosingAmount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Recover tokens in Time Lock Registry smartcontract address by the owner\n     *\n     * @notice Send tokens from smartcontract address to the owner.\n     * It might only apply after a cancellation of vested tokens\n     * @param amount Amount to be recovered by the owner of the Time Lock Registry smartcontract from its balance\n     * @return Whether or not it succeeded\n     */\n    function transferToOwner(uint256 amount) external onlyOwner returns (bool) {\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Claim locked tokens by the registered account\n     *\n     * @notice Claim tokens due amount.\n     * @dev Claim is done by the user in the TimeLocked contract and the contract is the only allowed to call\n     * this function on behalf of the user to make the claim\n     * @return The amount of tokens registered and delivered after the claim\n     */\n    function claim(address _receiver) external onlyBABLToken returns (uint256) {\n        require(registeredDistributions[_receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[_receiver];\n        TokenVested storage claimTokenVested = tokenVested[_receiver];\n\n        claimTokenVested.lastClaim = block.timestamp;\n\n        // set distribution mapping to 0\n        delete registeredDistributions[_receiver];\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // register lockup in TimeLockedToken\n        // this will transfer funds from this contract and lock them for sender\n        token.registerLockup(\n            _receiver,\n            amount,\n            claimTokenVested.team,\n            claimTokenVested.vestingBegin,\n            claimTokenVested.vestingEnd,\n            claimTokenVested.lastClaim\n        );\n\n        // set tokenVested mapping to 0\n        delete tokenVested[_receiver];\n\n        // emit claim event\n        emit Claim(_receiver, amount);\n\n        return amount;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    function checkVesting(address address_)\n        external\n        view\n        returns (\n            bool team,\n            uint256 start,\n            uint256 end,\n            uint256 last\n        )\n    {\n        TokenVested storage checkTokenVested = tokenVested[address_];\n\n        return (\n            checkTokenVested.team,\n            checkTokenVested.vestingBegin,\n            checkTokenVested.vestingEnd,\n            checkTokenVested.lastClaim\n        );\n    }\n\n    function checkRegisteredDistribution(address address_) external view returns (uint256 amount) {\n        return registeredDistributions[address_];\n    }\n}\n"
    },
    "contracts/token/VoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title VoteToken\n * @notice Custom token which tracks voting power for governance\n * @dev This is an abstraction of a fork of the Compound governance contract\n * VoteToken is used by BABL to allow tracking voting power\n * Checkpoints are created every time state is changed which record voting power\n * Inherits standard ERC20 behavior\n */\n\nabstract contract VoteToken is Context, ERC20, Ownable, IVoteToken, ReentrancyGuard {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegating votes from msg.sender to delegatee\n     *\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n\n    function delegate(address delegatee) external override {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegate votes using signature to 'delegatee'\n     *\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external override {\n        address signatory;\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        if (prefix) {\n            bytes32 digestHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', digest));\n            signatory = ecrecover(digestHash, v, r, s);\n        } else {\n            signatory = ecrecover(digest, v, r, s);\n        }\n\n        require(balanceOf(signatory) > 0, 'VoteToken::delegateBySig: invalid delegator');\n        require(signatory != address(0), 'VoteToken::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory], 'VoteToken::delegateBySig: invalid nonce');\n        nonces[signatory]++;\n        require(block.timestamp <= expiry, 'VoteToken::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Check Delegate votes using signature to 'delegatee'\n     *\n     * @notice Get current voting power for an account\n     * @param account Account to get voting power for\n     * @return Voting power for an account\n     */\n    function getCurrentVotes(address account) external view virtual override returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get voting power at a specific block for an account\n     *\n     * @param account Account to get voting power for\n     * @param blockNumber Block to get voting power at\n     * @return Voting power for an account at specific block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view virtual override returns (uint96) {\n        require(blockNumber < block.number, 'BABLToken::getPriorVotes: not yet determined');\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function getMyDelegatee() external view override returns (address) {\n        return delegates[msg.sender];\n    }\n\n    function getDelegatee(address account) external view override returns (address) {\n        return delegates[account];\n    }\n\n    function getCheckpoints(address account, uint32 id)\n        external\n        view\n        override\n        returns (uint32 fromBlock, uint96 votes)\n    {\n        Checkpoint storage getCheckpoint = checkpoints[account][id];\n        return (getCheckpoint.fromBlock, getCheckpoint.votes);\n    }\n\n    function getNumberOfCheckpoints(address account) external view override returns (uint32) {\n        return numCheckpoints[account];\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Make a delegation\n     *\n     * @dev Internal function to delegate voting power to an account\n     * @param delegator The address of the account delegating votes from\n     * @param delegatee The address to delegate votes to\n     */\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = safe96(_balanceOf(delegator), 'VoteToken::_delegate: uint96 overflow');\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _balanceOf(address account) internal view virtual returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Move the delegates\n     *\n     * @dev Internal function to move delegates between accounts\n     * @param srcRep The address of the account delegating votes from\n     * @param dstRep The address of the account delegating votes to\n     * @param amount The voting power to move\n     */\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            // It must not revert but do nothing in cases of address(0) being part of the move\n            // Sub voting amount to source in case it is not the zero address (e.g. transfers)\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'VoteToken::_moveDelegates: vote amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n            if (dstRep != address(0)) {\n                // Add it to destination in case it is not the zero address (e.g. any transfer of tokens or delegations except a first mint to a specific address)\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'VoteToken::_moveDelegates: vote amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Internal function to write a checkpoint for voting power\n     *\n     * @dev internal function to write a checkpoint for voting power\n     * @param delegatee The address of the account delegating votes to\n     * @param nCheckpoints The num checkpoint\n     * @param oldVotes The previous voting power\n     * @param newVotes The new voting power\n     */\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, 'VoteToken::_writeCheckpoint: block number exceeds 32 bits');\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/IVoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IVoteToken {\n    function delegate(address delegatee) external;\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external;\n\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function getMyDelegatee() external view returns (address);\n\n    function getDelegatee(address account) external view returns (address);\n\n    function getCheckpoints(address account, uint32 id) external view returns (uint32 fromBlock, uint96 votes);\n\n    function getNumberOfCheckpoints(address account) external view returns (uint32);\n}\n\ninterface IVoteTokenWithERC20 is IVoteToken, IERC20 {}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../lib/UniversalERC20.sol';\n\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {ITradeIntegration} from '../interfaces/ITradeIntegration.sol';\nimport {IOperation} from '../interfaces/IOperation.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\n\n/**\n * @title Strategy\n * @author Babylon Finance\n *\n * Base Strategy contract. Belongs to a garden. Abstract.\n * Will be extended from specific strategy contracts.\n */\ncontract Strategy is ReentrancyGuard, IStrategy, Initializable {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for int256;\n    using SafeDecimalMath for uint256;\n    using Math for int256;\n    using Math for uint256;\n    using AddressArrayUtils for address[];\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event Invoked(address indexed _target, uint256 indexed _value, bytes _data, bytes _returnValue);\n    event StrategyVoted(\n        address indexed _garden,\n        uint256 totalPositiveVotes,\n        uint256 totalNegativeVotes,\n        uint256 _timestamp\n    );\n    event StrategyExecuted(address indexed _garden, uint256 _capital, uint256 _fee, uint256 timestamp);\n    event StrategyFinalized(address indexed _garden, uint256 _capitalReturned, uint256 _fee, uint256 timestamp);\n    event StrategyReduced(address indexed _garden, uint256 _amountReduced, uint256 timestamp);\n    event StrategyExpired(address indexed _garden, uint256 _timestamp);\n    event StrategyDeleted(address indexed _garden, uint256 _timestamp);\n    event StrategyDurationChanged(uint256 _newDuration, uint256 _oldDuration);\n\n    /* ============ Modifiers ============ */\n\n    function _onlyGovernorOrGarden() private view {\n        _require(\n            (msg.sender == address(garden) && IBabController(controller).isSystemContract(address(garden))) ||\n                msg.sender == controller.owner(),\n            Errors.ONLY_PROTOCOL_OR_GARDEN\n        );\n    }\n\n    function _onlyStrategist() private view {\n        _require(msg.sender == strategist, Errors.ONLY_STRATEGIST);\n    }\n\n    function _onlyStrategistOrGovernor() private view {\n        _require(msg.sender == strategist || msg.sender == controller.owner(), Errors.ONLY_STRATEGIST);\n    }\n\n    function _onlyContributor() private view {\n        _require(\n            IERC20(address(garden)).balanceOf(msg.sender) > 0 &&\n                IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_CONTRIBUTOR\n        );\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    function _onlyIntegration() private view {\n        // Internal function used to reduce bytecode size\n        _require(\n            controller.isValidIntegration(IIntegration(msg.sender).getName(), msg.sender),\n            Errors.ONLY_INTEGRATION\n        );\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    function _onlyOperation() private view {\n        bool found = false;\n        for (uint8 i = 0; i < opTypes.length; i++) {\n            found = found || msg.sender == controller.enabledOperations(opTypes[i]);\n        }\n        // Internal function used to reduce bytecode size\n        _require(found, Errors.ONLY_OPERATION);\n    }\n\n    /**\n     * Throws if the garden is not the caller or data is already set\n     */\n    function _onlyGardenAndNotSet() private view {\n        _require(\n            msg.sender == address(garden) && !dataSet && IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_GARDEN_AND_DATA_NOT_SET\n        );\n    }\n\n    /**\n     * Throws if the garden is not active\n     */\n    function _onlyActiveGarden() private view {\n        _require(\n            garden.active() == true && IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_ACTIVE_GARDEN\n        );\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     * @param _fee                     The fee paid to keeper to compensate the gas cost in the reserveAsset\n     */\n    function _onlyKeeper(uint256 _fee) private view {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n        // We assume that calling keeper functions should be less expensive than 1 million gas and the gas price should be lower than 1000 gwei.\n        address reserveAsset = garden.reserveAsset();\n        if (reserveAsset == WETH) {\n            // 1 ETH\n            _require(_fee <= (1e6 * 1e3 gwei), Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == DAI) {\n            // 2000 DAI\n            _require(_fee <= 2000 * 1e18, Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == USDC) {\n            // 2000 USDC\n            _require(_fee <= 2000 * 1e6, Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == WBTC) {\n            // 0.05 WBTC\n            _require(_fee <= 0.05 * 1e8, Errors.FEE_TOO_HIGH);\n        } else {\n            _revert(Errors.RESERVE_ASSET_NOT_SUPPORTED);\n        }\n    }\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(\n            !IBabController(controller).isPaused(address(this)) || msg.sender == controller.owner(),\n            Errors.ONLY_UNPAUSED\n        );\n    }\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 5e16; // 5%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    uint256 internal constant MAX_CANDIDATE_PERIOD = 7 days;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    // Max Operations\n    uint256 internal constant MAX_OPERATIONS = 6;\n\n    // Quadratic penalty for looses\n    uint256 internal constant STAKE_QUADRATIC_PENALTY_FOR_LOSSES = 175e16; // 1.75e18\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Babylon Controller Address\n    IBabController public controller;\n\n    // Type of operation.\n    // 0 = BuyOperation\n    // 1 = LiquidityOperation\n    // 2 = VaultOperation\n    // 3 = LendOperation\n    // 4 = BorrowOperation\n\n    // Asset Status\n    // 0 = Liquid\n    // 1 = Put as collateral\n    // 2 = Borrowed\n    // 3 = staked\n\n    // Types and data for the operations of this strategy\n    uint8[] public override opTypes;\n    address[] public override opIntegrations;\n    address[] public override opDatas;\n\n    // Garden that these strategies belong to\n    IGarden public override garden;\n\n    address public override strategist; // Address of the strategist that submitted the bet\n\n    uint256 public override enteredAt; // Timestamp when the strategy was submitted\n    uint256 public override enteredCooldownAt; // Timestamp when the strategy reached quorum\n    uint256 public override executedAt; // Timestamp when the strategy was executed\n    uint256 public override updatedAt; // Timestamp of last capital allocation update\n    uint256 public override exitedAt; // Timestamp when the strategy was submitted\n\n    address[] public voters; // Addresses with the voters\n    uint256 public override totalPositiveVotes; // Total positive votes endorsing the strategy execution\n    uint256 public override totalNegativeVotes; // Total negative votes against the strategy execution\n    bool public override finalized; // Flag that indicates whether we exited the strategy\n    bool public override active; // Whether the strategy has met the voting quorum\n    bool public dataSet;\n    bool public hasMiningStarted;\n\n    uint256 public override duration; // Duration of the bet\n    uint256 public override stake; // Amount of stake by the strategist (in reserve asset) needs to be positive\n    uint256 public override maxCapitalRequested; // Amount of max capital to allocate\n    uint256 public override capitalAllocated; // Current amount of capital allocated\n    uint256 public override expectedReturn; // Expect return by this strategy\n    uint256 public override capitalReturned; // Actual return by this strategy\n    uint256 private minRebalanceCapital; // DEPRECATED Min amount of capital so that it is worth to rebalance the capital here\n    address[] private tokensNeeded; // Not used anymore\n    uint256[] private tokenAmountsNeeded; // Not used anymore\n\n    uint256 public override strategyRewards; // Rewards allocated for this strategy updated on finalized\n    uint256 private rewardsTotalOverhead; // Potential extra amount we are giving in BABL rewards\n\n    // Voters mapped to their votes.\n    mapping(address => int256) public votes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the strategy for a garden\n     *\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _controller                    Address of the controller\n     * @param _maxCapitalRequested           Max Capital requested denominated in the reserve asset (0 to be unlimited)\n     * @param _stake                         Stake with garden participations absolute amounts 1e18\n     * @param _strategyDuration              Strategy duration in seconds\n     * @param _expectedReturn                Expected return\n     */\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn\n    ) external override initializer {\n        controller = IBabController(_controller);\n\n        _require(controller.isSystemContract(_garden), Errors.NOT_A_GARDEN);\n        garden = IGarden(_garden);\n        uint256 lockedBalance = garden.getLockedBalance(_strategist);\n        uint256 strategistUnlockedBalance = IERC20(address(garden)).balanceOf(_strategist).sub(lockedBalance);\n        _require(IERC20(address(garden)).balanceOf(_strategist) > 0, Errors.STRATEGIST_TOKENS_TOO_LOW);\n        _require(strategistUnlockedBalance >= _stake, Errors.TOKENS_STAKED);\n        // TODO: adjust this calc\n        _require(_stake > 0, Errors.STAKE_HAS_TO_AT_LEAST_ONE);\n        _require(\n            _strategyDuration >= garden.minStrategyDuration() && _strategyDuration <= garden.maxStrategyDuration(),\n            Errors.DURATION_MUST_BE_IN_RANGE\n        );\n\n        strategist = _strategist;\n        enteredAt = block.timestamp;\n        stake = _stake;\n        hasMiningStarted = _hasMiningStarted();\n        duration = _strategyDuration;\n        expectedReturn = _expectedReturn;\n        capitalAllocated = 0;\n        maxCapitalRequested = _maxCapitalRequested;\n\n        votes[_strategist] = _stake.toInt256();\n        totalPositiveVotes = _stake;\n\n        dataSet = false;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Sets the data for the operations of this strategy\n     * @param _opTypes                    An array with the op types\n     * @param _opIntegrations             Addresses with the integration for each op\n     * @param _opDatas                    Bytes with the params for the op in the same position in the opTypes array\n     */\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external override {\n        _onlyGardenAndNotSet();\n        _require(\n            (_opTypes.length == _opIntegrations.length) && (_opIntegrations.length == _opDatas.length),\n            Errors.TOO_MANY_OPS\n        );\n        _require(_opDatas.length < MAX_OPERATIONS && _opDatas.length > 0, Errors.TOO_MANY_OPS);\n        for (uint256 i = 0; i < _opTypes.length; i++) {\n            IOperation(controller.enabledOperations(_opTypes[i])).validateOperation(\n                _opDatas[i],\n                garden,\n                _opIntegrations[i],\n                i\n            );\n            _require(\n                controller.isValidIntegration(IIntegration(_opIntegrations[i]).getName(), _opIntegrations[i]),\n                Errors.ONLY_INTEGRATION\n            );\n        }\n\n        opTypes = _opTypes;\n        opIntegrations = _opIntegrations;\n        opDatas = _opDatas;\n        dataSet = true;\n    }\n\n    /**\n     * Adds off-chain voting results on-chain.\n     * @param _voters                  An array of garden member who voted on strategy.\n     * @param _votes                   An array of votes by on strategy by garden members.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     */\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 _fee\n    ) external override {\n        _onlyActiveGarden();\n        _onlyKeeper(_fee);\n        _require(_voters.length >= garden.minVoters(), Errors.MIN_VOTERS_CHECK);\n        _require(!active && !finalized, Errors.VOTES_ALREADY_RESOLVED);\n        _require(block.timestamp.sub(enteredAt) <= MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OVER);\n\n        active = true;\n\n        // set votes to zero expecting keeper to provide correct values\n        totalPositiveVotes = 0;\n        totalNegativeVotes = 0;\n\n        // Set votes data\n        for (uint256 i = 0; i < _voters.length; i++) {\n            votes[_voters[i]] = _votes[i];\n            if (_votes[i] > 0) {\n                totalPositiveVotes = totalPositiveVotes.add(uint256(Math.abs(_votes[i])));\n            } else {\n                totalNegativeVotes = totalNegativeVotes.add(uint256(Math.abs(_votes[i])));\n            }\n        }\n\n        _require(totalPositiveVotes.sub(totalNegativeVotes) > 0, Errors.TOTAL_VOTES_HAVE_TO_BE_POSITIVE);\n\n        // Keeper will account for strategist vote/stake\n        voters = _voters;\n\n        // Initializes cooldown\n        enteredCooldownAt = block.timestamp;\n        emit StrategyVoted(address(garden), totalPositiveVotes, totalNegativeVotes, block.timestamp);\n        garden.payKeeper(msg.sender, _fee);\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     */\n    function executeStrategy(uint256 _capital, uint256 _fee) external override nonReentrant {\n        _onlyActiveGarden();\n        _onlyKeeper(_fee);\n        _executesStrategy(_capital, _fee, msg.sender);\n    }\n\n    /**\n     * Exits from an executed strategy.\n     * Returns balance back to the garden and sets the capital aside for withdrawals in ETH.\n     * Pays the keeper.\n     * Updates the reserve asset position accordingly.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     * @param _tokenURI                URL with the JSON for the strategy\n     */\n    function finalizeStrategy(uint256 _fee, string memory _tokenURI) external override nonReentrant {\n        _onlyActiveGarden();\n        _onlyKeeper(_fee);\n        _require(executedAt > 0, Errors.STRATEGY_IS_NOT_EXECUTED);\n        _require(block.timestamp > executedAt.add(duration), Errors.STRATEGY_IS_NOT_OVER_YET);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n\n        uint256 reserveAssetReturns = IERC20(garden.reserveAsset()).balanceOf(address(this));\n        // Execute exit operations\n        _exitStrategy(HUNDRED_PERCENT);\n        capitalReturned = IERC20(garden.reserveAsset()).balanceOf(address(this)).sub(reserveAssetReturns);\n        // Mark as finalized\n        finalized = true;\n        active = false;\n        exitedAt = block.timestamp;\n        // Mint NFT\n        IStrategyNFT(IBabController(controller).strategyNFT()).grantStrategyNFT(strategist, _tokenURI);\n        // Pay Keeper Fee\n        garden.payKeeper(msg.sender, _fee);\n        // Transfer rewards\n        _transferStrategyPrincipal();\n        // Send rest to garden if any\n        _sendReserveAssetToGarden();\n        updatedAt = exitedAt;\n\n        emit StrategyFinalized(address(garden), capitalReturned, _fee, block.timestamp);\n    }\n\n    /**\n     * Partially unwinds an strategy.\n     * Triggered from an immediate withdraw in the Garden.\n     * @param _amountToUnwind              The amount of capital to unwind\n     */\n    function unwindStrategy(uint256 _amountToUnwind) external override nonReentrant {\n        _onlyGovernorOrGarden();\n        _onlyUnpaused();\n        _require(active && !finalized, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n\n        // Exits and enters the strategy\n        _exitStrategy(_amountToUnwind.preciseDiv(capitalAllocated));\n        capitalAllocated = capitalAllocated.sub(_amountToUnwind);\n\n        // Removes protocol principal for the calculation of rewards\n        if (hasMiningStarted) {\n            IRewardsDistributor rewardsDistributor =\n                IRewardsDistributor(IBabController(controller).rewardsDistributor());\n            // Only if the Mining program started on time for this strategy\n            rewardsDistributor.updateProtocolPrincipal(_amountToUnwind, false);\n        }\n        // Send the amount back to the warden for the immediate withdrawal\n        // TODO: Transfer the precise value; not entire balance\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n        updatedAt = block.timestamp;\n\n        emit StrategyReduced(address(garden), _amountToUnwind, block.timestamp);\n    }\n\n    /**\n     * Expires a candidate that has spent more than CANDIDATE_PERIOD without\n     * reaching quorum\n     * @param _fee              The keeper fee\n     */\n    function expireStrategy(uint256 _fee) external nonReentrant {\n        _onlyActiveGarden();\n        _onlyKeeper(_fee);\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n        _require(block.timestamp.sub(enteredAt) > MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OPENED);\n        // pay keeper before expiring strategy\n        garden.payKeeper(msg.sender, _fee);\n        _deleteCandidateStrategy();\n        emit StrategyExpired(address(garden), block.timestamp);\n    }\n\n    /**\n     * Delete a candidate strategy by the strategist\n     */\n    function deleteCandidateStrategy() external {\n        _onlyStrategistOrGovernor();\n        _deleteCandidateStrategy();\n        emit StrategyDeleted(address(garden), block.timestamp);\n    }\n\n    /**\n     * Lets the strategist change the duration of the strategy\n     * @param _newDuration            New duration of the strategy\n     */\n    function changeStrategyDuration(uint256 _newDuration) external override {\n        _onlyStrategistOrGovernor();\n        _onlyUnpaused();\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        _require(_newDuration < duration, Errors.DURATION_NEEDS_TO_BE_LESS);\n        emit StrategyDurationChanged(_newDuration, duration);\n        duration = _newDuration;\n    }\n\n    /**\n     * Any tokens (other than the target) that are sent here by mistake are recoverable by contributors\n     * Converts it to the reserve asset and sends it to the garden.\n     * @param _token             Address of the token to sweep\n     */\n    function sweep(address _token) external {\n        _onlyContributor();\n        _onlyUnpaused();\n        _require(_token != garden.reserveAsset(), Errors.CANNOT_SWEEP_RESERVE_ASSET);\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _require(balance > 0, Errors.BALANCE_TOO_LOW);\n\n        _trade(_token, balance, garden.reserveAsset());\n        // Send reserve asset to garden\n        _sendReserveAssetToGarden();\n    }\n\n    /**\n     * Helper to invoke Approve on ERC20 from integrations in the strategy context\n     */\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external override {\n        _onlyIntegration();\n        IERC20(_asset).safeApprove(_spender, _quantity);\n    }\n\n    /**\n     * Helper to invoke a call to an external contract from integrations in the strategy context\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external override returns (bytes memory) {\n        _onlyIntegration();\n        return _invoke(_target, _value, _data);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external override returns (uint256) {\n        _onlyOperation();\n        _onlyUnpaused();\n        return _trade(_sendToken, _sendQuantity, _receiveToken);\n    }\n\n    /**\n     * Deposits or withdraws weth from an operation in this context\n     * @param _isDeposit                    Whether is a deposit or withdraw\n     * @param _wethAmount                   Amount to deposit or withdraw\n     */\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external override {\n        _onlyOperation();\n        _onlyUnpaused();\n        if (_isDeposit) {\n            IWETH(WETH).deposit{value: _wethAmount}();\n            return;\n        }\n        IWETH(WETH).withdraw(_wethAmount);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Returns whether this strategy is currently active or not\n     */\n    function isStrategyActive() public view override returns (bool) {\n        return executedAt > 0 && exitedAt == 0;\n    }\n\n    /**\n     * Returns the number of operations in this strategy\n     */\n    function getOperationsCount() external view override returns (uint256) {\n        return opTypes.length;\n    }\n\n    /**\n     * Get the non-state related details of a Strategy\n     *\n     */\n    function getStrategyDetails()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            address(this),\n            strategist,\n            opIntegrations.length,\n            stake,\n            totalPositiveVotes,\n            totalNegativeVotes,\n            capitalAllocated,\n            capitalReturned,\n            duration,\n            expectedReturn,\n            maxCapitalRequested,\n            IBabController(controller).strategyNFT(),\n            enteredAt,\n            getNAV()\n        );\n    }\n\n    /**\n     * Get the state of a Strategy\n     *\n     */\n    function getStrategyState()\n        external\n        view\n        override\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (address(this), active, dataSet, finalized, executedAt, exitedAt, updatedAt);\n    }\n\n    /**\n     * Get the operation params by index\n     *\n     */\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        override\n        returns (\n            uint8,\n            address,\n            address\n        )\n    {\n        return (opTypes[_index], opIntegrations[_index], opDatas[_index]);\n    }\n\n    /**\n     * Gets the NAV of assets under management.\n     * It is the sum of the NAV of all the operations\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV() public view override returns (uint256) {\n        uint256 positiveNav = 0;\n        uint256 negativeNav = 0;\n        address reserveAsset = garden.reserveAsset();\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(uint256(opTypes[i])));\n            (uint256 strategyNav, bool positive) = operation.getNAV(opDatas[i], garden, opIntegrations[i]);\n            if (positive) {\n                positiveNav = positiveNav.add(strategyNav);\n            } else {\n                negativeNav = negativeNav.add(strategyNav);\n            }\n            // borrow op\n        }\n        uint256 lastOp = opTypes.length - 1;\n        if (opTypes[lastOp] == 4) {\n            uint256 borrowBalance = IERC20(opDatas[lastOp]).universalBalanceOf(address(this));\n            if (borrowBalance > 0) {\n                uint256 price = _getPrice(reserveAsset, opDatas[lastOp]);\n                positiveNav = positiveNav.add(\n                    SafeDecimalMath.normalizeAmountTokens(opDatas[lastOp], reserveAsset, borrowBalance).preciseDiv(\n                        price\n                    )\n                );\n            }\n        }\n        if (negativeNav > positiveNav) {\n            // Underwater, will display using operation NAV\n            return 0;\n        }\n        return positiveNav.sub(negativeNav);\n    }\n\n    /**\n     * Gets the votes casted by the contributor in this strategy\n     *\n     * @param _address           Address of the contributor\n     * @return _votes            Number of votes cast\n     */\n    function getUserVotes(address _address) external view override returns (int256) {\n        return votes[_address];\n    }\n\n    /**\n     * Gets the total votes casted for the strategy\n     *\n     * @return _totalVotes            Total amount of votes for the strategy\n     */\n    function totalVotes() external view override returns (int256) {\n        return totalPositiveVotes.toInt256().sub(totalNegativeVotes.toInt256());\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /*\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * Keeper will validate that quorum is reached, cacluates all the voting data and push it.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     * @param _keepers                  The address of the keeper to pay\n     */\n    function _executesStrategy(\n        uint256 _capital,\n        uint256 _fee,\n        address payable _keeper\n    ) internal {\n        _require(active, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(capitalAllocated.add(_capital) <= maxCapitalRequested, Errors.MAX_CAPITAL_REACHED);\n        _require(\n            block.timestamp.sub(enteredCooldownAt) >= garden.strategyCooldownPeriod(),\n            Errors.STRATEGY_IN_COOLDOWN\n        );\n\n        // Execute enter operation\n        garden.allocateCapitalToStrategy(_capital);\n        capitalAllocated = capitalAllocated.add(_capital);\n        _enterStrategy(_capital);\n\n        // Sets the executed timestamp on first execution\n        if (executedAt == 0) {\n            executedAt = block.timestamp;\n        }\n        if (hasMiningStarted) {\n            IRewardsDistributor rewardsDistributor =\n                IRewardsDistributor(IBabController(controller).rewardsDistributor());\n            // The Mining program has not started on time for this strategy\n            rewardsDistributor.updateProtocolPrincipal(_capital, true);\n        }\n        garden.payKeeper(_keeper, _fee);\n        updatedAt = block.timestamp;\n        emit StrategyExecuted(address(garden), _capital, _fee, block.timestamp);\n    }\n\n    /**\n     * Enters the strategy.\n     * Executes all the operations in order\n     * @param _capital  Amount of capital that the strategy receives\n     */\n    function _enterStrategy(uint256 _capital) internal {\n        uint256 capitalForNexOperation = _capital;\n        address assetAccumulated = garden.reserveAsset();\n        uint8 assetStatus = 0; // liquid\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i]));\n            (assetAccumulated, capitalForNexOperation, assetStatus) = operation.executeOperation(\n                assetAccumulated,\n                capitalForNexOperation,\n                assetStatus,\n                opDatas[i],\n                garden,\n                opIntegrations[i]\n            );\n        }\n    }\n\n    /**\n     * Exits the strategy.\n     * Exists all the operations starting by the end.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function _exitStrategy(uint256 _percentage) internal {\n        address assetFinalized = garden.reserveAsset();\n        uint256 capitalPending = 0;\n        uint8 assetStatus = 0;\n        for (uint256 i = opTypes.length; i > 0; i--) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i - 1]));\n            (assetFinalized, capitalPending, assetStatus) = operation.exitOperation(\n                assetFinalized,\n                capitalPending,\n                assetStatus,\n                _percentage,\n                opDatas[i - 1],\n                garden,\n                opIntegrations[i - 1]\n            );\n        }\n    }\n\n    /**\n     * Deletes this strategy and returns the stake to the strategist\n     */\n    function _deleteCandidateStrategy() internal {\n        _require(executedAt == 0, Errors.STRATEGY_IS_EXECUTED);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n\n        IGarden(garden).expireCandidateStrategy(address(this));\n        // TODO: Call selfdestruct??\n    }\n\n    /**\n     * Low level function that allows an integration to make an arbitrary function\n     * call to any contract from the garden (garden as msg.sender).\n     *\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function _invoke(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal returns (bytes memory _returnValue) {\n        _returnValue = _target.functionCallWithValue(_data, _value);\n        emit Invoked(_target, _value, _data, _returnValue);\n        return _returnValue;\n    }\n\n    function _sendReserveAssetToGarden() private {\n        uint256 remainingReserve = IERC20(garden.reserveAsset()).balanceOf(address(this));\n        // Sends the rest back if any\n        IERC20(garden.reserveAsset()).safeTransfer(address(garden), remainingReserve);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function _trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) internal returns (uint256) {\n        address tradeIntegration = IBabController(controller).defaultTradeIntegration();\n        // Uses on chain oracle for all internal strategy operations to avoid attacks\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 pricePerTokenUnit = oracle.getPrice(_sendToken, _receiveToken);\n        // minAmount must have receive token decimals\n        uint256 exactAmount =\n            SafeDecimalMath.normalizeAmountTokens(\n                _sendToken,\n                _receiveToken,\n                _sendQuantity.preciseMul(pricePerTokenUnit)\n            );\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ITradeIntegration(tradeIntegration).trade(\n            address(this),\n            _sendToken,\n            _sendQuantity,\n            _receiveToken,\n            minAmountExpected\n        );\n        return minAmountExpected;\n    }\n\n    function _transferStrategyPrincipal() internal {\n        address reserveAsset = garden.reserveAsset();\n        int256 strategyReturns = capitalReturned.toInt256().sub(capitalAllocated.toInt256());\n        uint256 protocolProfits;\n        // Strategy returns were positive\n        uint256 profits = capitalReturned > capitalAllocated ? capitalReturned.sub(capitalAllocated) : 0; // in reserve asset, e.g., WETH, USDC, DAI, WBTC\n        if (capitalReturned >= capitalAllocated) {\n            // Send weth performance fee to the protocol\n            protocolProfits = IBabController(controller).protocolPerformanceFee().preciseMul(profits);\n            IERC20(reserveAsset).safeTransfer(IBabController(controller).treasury(), protocolProfits);\n            strategyReturns = strategyReturns.sub(protocolProfits.toInt256());\n        } else {\n            // Returns were negative\n            // Burn strategist stake and add the amount to the garden\n            uint256 burningAmount =\n                (stake.sub(capitalReturned.preciseDiv(capitalAllocated).preciseMul(stake))).multiplyDecimal(\n                    STAKE_QUADRATIC_PENALTY_FOR_LOSSES\n                );\n            if (IERC20(address(garden)).balanceOf(strategist) < burningAmount) {\n                // Avoid underflow burning more than its balance\n                burningAmount = IERC20(address(garden)).balanceOf(strategist);\n            }\n\n            garden.burnStrategistStake(strategist, burningAmount);\n            strategyReturns = strategyReturns.add(int256(burningAmount));\n        }\n        // Return the balance back to the garden\n        IERC20(reserveAsset).safeTransfer(address(garden), capitalReturned.sub(protocolProfits));\n        // Start a redemption window in the garden with the capital plus the profits for the lps\n        (, , uint256 lpsProfitSharing) = IBabController(controller).getProfitSharing();\n        garden.startWithdrawalWindow(\n            capitalReturned.sub(profits).add((profits).preciseMul(lpsProfitSharing)),\n            profits.sub(profits.preciseMul(lpsProfitSharing)).sub(protocolProfits),\n            strategyReturns,\n            address(this)\n        );\n        // Substract the Principal in the Rewards Distributor to update the Protocol power value\n        if (hasMiningStarted) {\n            IRewardsDistributor rewardsDistributor =\n                IRewardsDistributor(IBabController(controller).rewardsDistributor());\n            // Only if the Mining program started on time for this strategy\n            rewardsDistributor.updateProtocolPrincipal(capitalAllocated, false);\n            strategyRewards = uint256(rewardsDistributor.getStrategyRewards(address(this))); // Must be zero in case the mining program didnt started on time\n        }\n    }\n\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return oracle.getPrice(_assetOne, _assetTwo);\n    }\n\n    function _hasMiningStarted() internal view returns (bool) {\n        IRewardsDistributor rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        uint256 rewardsStartTime = rewardsDistributor.START_TIME();\n        bool miningStarted = ((enteredAt > rewardsStartTime) && (rewardsStartTime != 0));\n        return miningStarted;\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract StrategyV4 is Strategy {}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/lib/UniversalERC20.sol": {
      "content": "pragma solidity 0.7.6;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n    function universalTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            address(uint160(to)).transfer(amount);\n        } else {\n            token.safeTransfer(to, amount);\n            return true;\n        }\n    }\n\n    function universalTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isETH(token)) {\n            require(from == msg.sender && msg.value >= amount, 'msg.value is zero');\n            if (to != address(this)) {\n                address(uint160(to)).transfer(amount);\n            }\n            if (msg.value > amount) {\n                msg.sender.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n\n    function universalApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (!isETH(token)) {\n            if (amount > 0 && token.allowance(address(this), to) > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, amount);\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function universalDecimals(IERC20 token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return 18;\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 5000}(abi.encodeWithSignature('decimals()'));\n\n        return success ? abi.decode(data, (uint256)) : 18;\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return address(token) == address(ZERO_ADDRESS);\n    }\n}\n"
    },
    "contracts/interfaces/external/weth/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/ITradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ITrade\n * @author Babylon Finance\n *\n * Interface for trading protocol integrations\n */\ninterface ITradeIntegration {\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external;\n\n    function getConversionRates(\n        address _sourceToken,\n        address _destinationToken,\n        uint256 _sourceQuantity\n    ) external returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IStrategy} from './IStrategy.sol';\n\n/**\n * @title IOperation\n * @author Babylon Finance\n *\n * Interface for an strategy operation\n */\ninterface IOperation {\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view returns (uint256, bool);\n\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IStrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IStrategyNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Strategy NFT.\n */\ninterface IStrategyNFT {\n    struct StratDetail {\n        string name;\n        string symbol;\n        uint256 tokenId;\n    }\n\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI) external returns (uint256);\n\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external;\n\n    function getStrategyTokenURI(address _stratgy) external view returns (string memory);\n\n    function getStrategyName(address _strategy) external view returns (string memory);\n}\n"
    },
    "contracts/mocks/StrategyV2Mock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {ITradeIntegration} from '../interfaces/ITradeIntegration.sol';\nimport {IOperation} from '../interfaces/IOperation.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\n\n/**\n * @title Strategy\n * @author Babylon Finance\n *\n * Base Strategy contract. Belongs to a garden. Abstract.\n * Will be extended from specific strategy contracts.\n */\ncontract StrategyV2Mock {\n    using SignedSafeMath for int256;\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for int256;\n    using SafeDecimalMath for uint256;\n    using Math for int256;\n    using Math for uint256;\n    using AddressArrayUtils for address[];\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 5e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    uint256 internal constant MAX_CANDIDATE_PERIOD = 7 days;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Max Operations\n    uint256 internal constant MAX_OPERATIONS = 6;\n\n    // Keeper max fee\n    // TODO: Given DAI, USDC, and WBTC can be a reseve asset, MAX_KEEPER_FEE should depend on reserve asset\n    uint256 internal constant MAX_KEEPER_FEE = (1e6 * 1e3 gwei);\n\n    // Quadratic penalty for looses\n    uint256 internal constant STAKE_QUADRATIC_PENALTY_FOR_LOSSES = 175e16; // 1.75e18\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Babylon Controller Address\n    IBabController public controller;\n\n    // Type of operation.\n    // 0 = BuyOperation\n    // 1 = LiquidityOperation\n    // 2 = VaultOperation\n    // 3 = LendOperation\n\n    // Asset Status\n    // 0 = Liquid\n    // 1 = Put as collateral\n    // 2 = Borrowed\n    // 3 = staked\n\n    // Types and data for the operations of this strategy\n    uint8[] public opTypes;\n    address[] public opIntegrations;\n    address[] public opDatas;\n\n    // Garden that these strategies belong to\n    IGarden public garden;\n\n    address public strategist; // Address of the strategist that submitted the bet\n\n    uint256 public enteredAt; // Timestamp when the strategy was submitted\n    uint256 public enteredCooldownAt; // Timestamp when the strategy reached quorum\n    uint256 public executedAt; // Timestamp when the strategy was executed\n    uint256 public updatedAt; // Timestamp of last capital allocation update\n    uint256 public exitedAt; // Timestamp when the strategy was submitted\n\n    address[] public voters; // Addresses with the voters\n    uint256 public totalPositiveVotes; // Total positive votes endorsing the strategy execution\n    uint256 public totalNegativeVotes; // Total negative votes against the strategy execution\n    bool public finalized; // Flag that indicates whether we exited the strategy\n    bool public active; // Whether the strategy has met the voting quorum\n    bool public dataSet;\n    bool public hasMiningStarted;\n\n    uint256 public duration; // Duration of the bet\n    uint256 public stake; // Amount of stake by the strategist (in reserve asset) needs to be positive\n    uint256 public maxCapitalRequested; // Amount of max capital to allocate\n    uint256 public capitalAllocated; // Current amount of capital allocated\n    uint256 public expectedReturn; // Expect return by this strategy\n    uint256 public capitalReturned; // Actual return by this strategy\n    uint256 private minRebalanceCapital; // Min amount of capital so that it is worth to rebalance the capital here\n    address[] private tokensNeeded; // Positions that need to be taken prior to enter the strategy\n    uint256[] private tokenAmountsNeeded; // Amount of these positions\n\n    uint256 public strategyRewards; // Rewards allocated for this strategy updated on finalized\n    uint256 private rewardsTotalOverhead; // Potential extra amount we are giving in BABL rewards\n\n    // Voters mapped to their votes.\n    mapping(address => int256) public votes;\n\n    uint256 public newVar;\n\n    uint256 internal absoluteMinRebalance; // 1e18 or 1e6 in case of USDC\n\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn\n    ) external {\n        newVar = 42;\n    }\n\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external {}\n\n    function newMethod() public view returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "contracts/strategies/StrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\n\n/**\n * @title StrategyNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Strategy\n */\ncontract StrategyNFT is ERC721, IStrategyNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event StrategyNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy {\n        IStrategy strategy = IStrategy(msg.sender);\n        require(\n            IGarden(strategy.garden()).strategyMapping(msg.sender) && controller.isSystemContract(msg.sender),\n            'Only the strategy can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    mapping(address => StratDetail) public stratDetails;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(bytes(_name).length < 50, 'Strategy Name is too long');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user                           Address of the user\n     * @param _strategyTokenURI               Strategy token URI\n     */\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI)\n        external\n        override\n        onlyStrategy\n        returns (uint256)\n    {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, _strategyTokenURI);\n        stratDetails[msg.sender].tokenId = newItemId;\n        emit StrategyNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the name an symbol for a new created strategy\n     *\n     * @param _strategy               Address of the strategy\n     * @param _name                   Strategy Name\n     * @param _symbol                 Strategy Symbol\n     */\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        StratDetail storage stratDetail = stratDetails[_strategy];\n        stratDetail.name = _name;\n        stratDetail.symbol = _symbol;\n    }\n\n    function getStrategyTokenURI(address _strategy) external view override returns (string memory) {\n        return tokenURI(stratDetails[_strategy].tokenId);\n    }\n\n    function getStrategyName(address _strategy) external view override returns (string memory) {\n        return stratDetails[_strategy].name;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/strategies/StrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\n\n/**\n * @title StrategyFactory\n * @author Babylon Finance\n *\n * Factory to create investment strategy contracts\n */\ncontract StrategyFactory is IStrategyFactory {\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a new investment strategy using minimal proxies\n     *\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _stratParams                   Strat Params\n     */\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external override returns (address) {\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IStrategy.initialize.selector,\n                        _strategist,\n                        _garden,\n                        controller,\n                        _stratParams[0],\n                        _stratParams[1],\n                        _stratParams[2],\n                        _stratParams[3]\n                    )\n                )\n            );\n        IStrategyNFT(controller.strategyNFT()).saveStrategyNameAndSymbol(proxy, _name, _symbol);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../access/Ownable.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) public {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "contracts/proxy/SafeBeaconProxy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/BeaconProxy.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to create garden contracts\n */\ncontract SafeBeaconProxy is BeaconProxy {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) public payable BeaconProxy(beacon, data) {}\n\n    /**\n     * @dev Accepts all ETH transfers but does not proxy calls to the implementation.\n     *\n     * Due to EIP-2929 the proxy overhead gas cost is higher than 2300 gas which is the stipend used by address.transfer.\n     * This results to a `out of gas` error for proxy calls initiated by code `address.transfer`.\n     * A notable example is WETH https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\n     * A downside of this approach is that a proxy implementation contract can not handle receiving pure ETH.\n     * In a scope of Babylon project this is acceptable but should be kept in mind at all times.\n     *\n     */\n    receive() external payable override {}\n}\n"
    },
    "contracts/interfaces/IStrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IStrategyFactory\n * @author Babylon Finance\n *\n * Interface for the strategy factory\n */\ninterface IStrategyFactory {\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\nimport \"./IBeacon.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) public payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).implementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/mocks/GardenV2Mock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IIshtarGate} from '../interfaces/IIshtarGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\n\n/**\n * @title BaseGarden\n * @author Babylon Finance\n *\n * Class that holds common garden-related state and functions\n */\ncontract GardenV2Mock is ERC20Upgradeable, ReentrancyGuard {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n\n    /* ============ State Constants ============ */\n\n    // Wrapped ETH address\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 private constant EARLY_WITHDRAWAL_PENALTY = 5e16;\n    uint256 private constant MAX_TOTAL_STRATEGIES = 20; // Max number of strategies\n    uint256 private constant TEN_PERCENT = 1e17;\n    // Window of time after an investment strategy finishes when the capital is available for withdrawals\n    uint256 private constant withdrawalWindowAfterStrategyCompletes = 7 days;\n\n    /* ============ Structs ============ */\n\n    struct Contributor {\n        uint256 lastDepositAt;\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        uint256 claimedBABL;\n        uint256 claimedRewards;\n        uint256 withdrawnSince;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address public reserveAsset;\n\n    // Address of the controller\n    address public controller;\n\n    // Address of the rewards distributor\n    IRewardsDistributor private rewardsDistributor;\n\n    // The person that creates the garden\n    address public creator;\n    // Whether the garden is currently active or not\n    bool public active;\n    bool public guestListEnabled;\n\n    // Keeps track of the reserve balance. In case we receive some through other means\n    uint256 public principal;\n    uint256 public reserveAssetRewardsSetAside;\n    uint256 public reserveAssetPrincipalWindow;\n    int256 public absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 public minLiquidityAsset;\n\n    uint256 public depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    uint256 public withdrawalsOpenUntil; // Indicates until when the withdrawals are open and the ETH is set aside\n\n    // Contributors\n    mapping(address => Contributor) private contributors;\n    uint256 public totalContributors;\n    uint256 public maxContributors;\n    uint256 public maxDepositLimit; // Limits the amount of deposits\n\n    uint256 public gardenInitializedAt; // Garden Initialized at timestamp\n    // Number of garden checkpoints used to control de garden power and each contributor power with accuracy avoiding flash loans and related attack vectors\n    uint256 private pid;\n\n    // Min contribution in the garden\n    uint256 public minContribution; //wei\n    uint256 private minGardenTokenSupply;\n\n    // Strategies variables\n    uint256 public totalStake;\n    uint256 public minVotesQuorum = TEN_PERCENT; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 public minVoters;\n    uint256 public minStrategyDuration; // Min duration for an strategy\n    uint256 public maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 public strategyCooldownPeriod;\n\n    address[] private strategies; // Strategies that are either in candidate or active state\n    address[] private finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) public strategyMapping;\n    mapping(address => bool) public isGardenStrategy; // Security control mapping\n\n    // Keeper debt in reserve asset if any, repaid upon every strategy finalization\n    uint256 public keeperDebt;\n\n    uint256 public newVar;\n\n    /* ============ External Functions ============ */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) public payable initializer {\n        newVar = 42;\n    }\n\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to,\n        bool mintNFT\n    ) external payable {}\n\n    function newMethod() public view returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/interfaces/IGardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\ninterface IGardenValuer {\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256);\n\n    function getLossesGarden(address _garden, uint256 _since) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IGardenNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Garden NFT.\n */\ninterface IGardenNFT {\n    function grantGardenNFT(address _user) external returns (uint256);\n\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external;\n\n    function gardenTokenURIs(address _garden) external view returns (string memory);\n\n    function gardenSeeds(address _garden) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/integrations/borrow/CompoundBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {ICEther} from '../../interfaces/external/compound/ICEther.sol';\nimport {ICompoundPriceOracle} from '../../interfaces/external/compound/ICompoundPriceOracle.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\n\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title CompoundBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses compound borring logic.\n */\ncontract CompoundBorrowIntegration is BorrowIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == controller.owner(), 'Only governance can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    address constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address constant CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     */\n    constructor(IBabController _controller, uint256 _maxCollateralFactor)\n        BorrowIntegration('compoundborrow', _controller, _maxCollateralFactor)\n    {\n        assetToCToken[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643; // DAI\n        assetToCToken[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984] = 0x35A18000230DA775CAc24873d00Ff85BccdeD550; // UNI\n        assetToCToken[address(0)] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // ETH\n        assetToCToken[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; // USDC\n        assetToCToken[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9; // USDT\n        assetToCToken[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; // WBTC\n        assetToCToken[0xc00e94Cb662C3520282E6f5717214004A7f26888] = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4; // COMP\n        assetToCToken[0x0D8775F648430679A709E98d2b0Cb6250d2887EF] = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E; // BAT\n        assetToCToken[0x514910771AF9Ca656af840dff83E8264EcF986CA] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7; // LINK\n        assetToCToken[0x1985365e9f78359a9B6AD760e32412f4a445E862] = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1; // REP\n        assetToCToken[0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359] = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC; // SAI\n        assetToCToken[0x0000000000085d4780B73119b644AE5ecd22b376] = 0x12392F67bdf24faE0AF363c24aC620a2f67DAd86; // TUSD\n        assetToCToken[0xE41d2489571d322189246DaFA5ebDe1F4699F498] = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407; // ZRX\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external onlyGovernance {\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            ,\n            // err\n            // cTokenBalance\n            uint256 borrowBalance,\n\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        return borrowBalance;\n    }\n\n    /**\n     * Get the amount of collateral depposited\n     * @param asset   The collateral to check\n     *\n     */\n    function getCollateralBalance(address _strategy, address asset) external view override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            // err\n            uint256 cTokenBalance, // borrow balance\n            ,\n            uint256 exchangeRateMantissa\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        uint256 decimals = IERC20(asset).universalDecimals();\n        // Source: balanceOfUnderlying from any ctoken\n        return cTokenBalance.mul(exchangeRateMantissa).div(10**decimals);\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        IComptroller comptroller = IComptroller(CompoundComptrollerAddress);\n        (\n            ,\n            /* error */\n            uint256 liquidity, /* shortfall */\n\n        ) = comptroller.getAccountLiquidity(_strategy);\n        return liquidity;\n    }\n\n    /* ============ Overriden Functions ============ */\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (CompoundComptrollerAddress, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('borrow(uint256)', _amount);\n\n        return (assetToCToken[_asset], 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (assetToCToken[_asset] == CEtherAddress) {\n            methodData = abi.encodeWithSignature('repayBorrow()');\n        } else {\n            methodData = abi.encodeWithSignature('repayBorrow(uint256)', _amount);\n        }\n        return (assetToCToken[_asset], assetToCToken[_asset] == CEtherAddress ? _amount : 0, methodData);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getCollateralAsset(\n        address _asset,\n        uint8 /* _borrowOp */\n    ) internal view override returns (address) {\n        // TODO: check this\n        return assetToCToken[_asset];\n    }\n\n    function _getSpender(address _asset) internal view override returns (address) {\n        return assetToCToken[_asset];\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function repayBorrowBehalf(address borrower, uint256 amount) external payable returns (uint256);\n\n    function borrowBalanceCurrent(address account) external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICEther {\n    function mint() external payable;\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function repayBorrow() external payable;\n\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/ICompoundPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICompoundPriceOracle {\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IComptroller {\n    /**\n     * @notice Marker function used for light validation when updating the comptroller of a market\n     * @dev Implementations should simply return true.\n     * @return true\n     */\n    function isComptroller() external view returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getAssetsIn(address account) external view returns (address[] memory);\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/integrations/borrow/BorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title BorrowIntetration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with lending protocols\n */\nabstract contract BorrowIntegration is BaseIntegration, ReentrancyGuard, IBorrowIntegration {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct DebtInfo {\n        IStrategy strategy; // Idea address\n        IGarden garden; // Garden address\n        address asset; // Asset involved in the operation\n        uint256 amount; // Amount involved in the operation\n        uint256 debt; // Amount of debt at the start of the operation\n        uint8 borrowOp; // Borrow operation type\n    }\n\n    uint8 constant BORROW_OPERATION_BORROW = 0;\n    uint8 constant BORROW_OPERATION_REPAY = 1;\n\n    /* ============ Events ============ */\n\n    event AmountBorrowed(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    event AmountRepaid(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    /* ============ State Variables ============ */\n    uint256 public override maxCollateralFactor;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     */\n    constructor(\n        string memory _name,\n        IBabController _controller,\n        uint256 _maxCollateralFactor\n    ) BaseIntegration(_name, _controller) {\n        maxCollateralFactor = _maxCollateralFactor;\n    }\n\n    /* ============ External Functions ============ */\n    // Governance function\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor) external override {\n        maxCollateralFactor = _newMaxCollateralFactor;\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * hparam asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(\n        address, /* strategy */\n        address /* asset */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address, /* strategy */\n        address /* asset */\n    ) external view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(\n        address /* strategy */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Borrows an asset\n     * @param asset The asset to be borrowed\n     * @param amount The amount to borrow\n     */\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_BORROW);\n\n        _validatePreBorrow(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_BORROW);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getBorrowCalldata(_strategy, asset, amount);\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostBorrow(debtInfo);\n        emit AmountBorrowed(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /**\n     * Repays a borrowed asset debt\n     * @param asset The asset to be repaid\n     * @param amount The amount to repay\n     */\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_REPAY);\n\n        _validatePreRepay(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_REPAY);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n        if (asset != address(0)) {\n            // Approves the repayment contract to take the tokens\n            debtInfo.strategy.invokeApprove(_getSpender(asset), asset, amount);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getRepayCalldata(_strategy, asset, amount);\n\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostRepay(debtInfo);\n\n        emit AmountRepaid(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return DebtInfo struct\n     *\n     * @param _strategy            The strategy executing this integration\n     * @param _asset               The asset involved in the op\n     * @param _amount              The amount involved in the op\n     * @param _borrowOp            Type of borrow operation\n     * return DebtInfo             Struct containing data for the debt position\n     */\n    function _createDebtInfo(\n        address _strategy,\n        address _asset,\n        uint256 _amount,\n        uint8 _borrowOp\n    ) internal view returns (DebtInfo memory) {\n        DebtInfo memory debtInfo;\n        debtInfo.strategy = IStrategy(_strategy);\n        debtInfo.garden = IGarden(debtInfo.strategy.garden());\n        debtInfo.asset = _asset;\n        debtInfo.debt = getBorrowBalance(_strategy, debtInfo.asset);\n        debtInfo.amount = _amount;\n        debtInfo.borrowOp = _borrowOp;\n\n        return debtInfo;\n    }\n\n    /**\n     * Validate pre borrow.\n     *\n     * hparam _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreBorrow(DebtInfo memory _debtInfo) internal view {\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate post borrow.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostBorrow(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'Did not receive the borrowed asset');\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate pre repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreRepay(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'We do not have enough to repay debt');\n        require(getBorrowBalance(address(_debtInfo.strategy), _debtInfo.asset) > 0, 'No debt to repay');\n    }\n\n    /**\n     * Validate post repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostRepay(DebtInfo memory _debtInfo) internal view {\n        // debt is paid\n        require(getBorrowBalance(address(_debtInfo.strategy), _debtInfo.asset) < _debtInfo.debt, 'Debt was not repaid');\n    }\n\n    /* ============ Virtual Functions ============ */\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getCollateralAsset(\n        address, /* _asset */\n        uint8 /* _borrowOp */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n\n    function _getSpender(\n        address /* asset */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n}\n"
    },
    "contracts/integrations/BaseIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\n\n/**\n * @title BaseIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses common Integration-related state and functions.\n */\nabstract contract BaseIntegration {\n    using SafeCast for int256;\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySystemContract() {\n        require(controller.isSystemContract(msg.sender), 'Only system can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the controller\n    IBabController public controller;\n    // Wrapped ETH address\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // Name of the integration\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n\n    constructor(string memory _name, IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the integration\n     */\n    function getName() external view returns (string memory) {\n        return name;\n    }\n}\n"
    },
    "contracts/interfaces/IBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBorrowIntegration\n * @author Babylon Finance\n *\n * Interface for borrow integrations\n */\ninterface IBorrowIntegration {\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 borrowAmount\n    ) external;\n\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external;\n\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor) external;\n\n    function maxCollateralFactor() external view returns (uint256);\n\n    function getBorrowBalance(address _strategy, address _asset) external view returns (uint256);\n\n    function getCollateralBalance(address _strategy, address asset) external view returns (uint256);\n\n    function getRemainingLiquidity(address _strategy) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/BorrowOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title LendOperatin\n * @author Babylon Finance\n *\n * Executes a borrow operation\n */\ncontract BorrowOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the borrow operation\n     *\n     * param _data                   Operation data\n     * param _garden                 Garden\n     * param _integration            Integration used\n     * @param _index                  Index of this operation\n     */\n    function validateOperation(\n        address, /* _data */\n        IGarden, /* _garden */\n        address, /* _integration */\n        uint256 _index\n    ) external view override onlyStrategy {\n        require(_index > 0, 'The operation cannot be the first. Needs to be a lend first');\n    }\n\n    /**\n     * Executes the borrow operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * @param _assetStatus        Status of the asset amount\n     * @param _borrowToken        Token to borrow\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        address _borrowToken,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(\n            _capital > 0 &&\n                _assetStatus == 1 &&\n                _asset != _borrowToken &&\n                IBorrowIntegration(_integration).getCollateralBalance(msg.sender, _asset) > 0,\n            'There is no collateral locked'\n        );\n        uint256 price = _getPrice(_asset, _borrowToken);\n        // % of the total collateral value in the borrow token\n        uint256 amountToBorrow =\n            _capital.preciseMul(price).preciseMul(IBorrowIntegration(_integration).maxCollateralFactor());\n        uint256 normalizedAmount = SafeDecimalMath.normalizeAmountTokens(_asset, _borrowToken, amountToBorrow);\n        IBorrowIntegration(_integration).borrow(msg.sender, _borrowToken, normalizedAmount);\n        _borrowToken = _borrowToken == address(0) ? WETH : _borrowToken;\n        return (_borrowToken, IERC20(_borrowToken).balanceOf(address(msg.sender)), 0); // borrowings are liquid\n    }\n\n    /**\n     * Exits the borrow operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        address _assetToken,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        IBorrowIntegration(_integration).repay(\n            msg.sender,\n            _assetToken,\n            address(0) == _assetToken ? address(msg.sender).balance : IERC20(_assetToken).balanceOf(address(msg.sender)) // We repay all that we can\n        );\n        return (_assetToken, IBorrowIntegration(_integration).getBorrowBalance(msg.sender, _assetToken), 2);\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _borrowToken        Asset borrowed\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        address _borrowToken,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 tokensOwed = IBorrowIntegration(_integration).getBorrowBalance(msg.sender, _borrowToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), _borrowToken);\n        uint256 NAV =\n            SafeDecimalMath.normalizeAmountTokens(_borrowToken, _garden.reserveAsset(), tokensOwed).preciseDiv(price);\n        return (NAV, false);\n    }\n}\n"
    },
    "contracts/strategies/operations/Operation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IOperation} from '../../interfaces/IOperation.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title LongStrategy\n * @author Babylon Finance\n *\n * Holds the data for a long strategy\n */\nabstract contract Operation is IOperation {\n    using SafeMath for uint256;\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy() {\n        IStrategy strategy = IStrategy(msg.sender);\n        IGarden garden = strategy.garden();\n        require(IBabController(controller).isSystemContract(address(garden)), 'Only a garden can call this');\n        require(garden.strategyMapping(msg.sender), 'Sender must be a strategy');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Address of the controller\n    address public controller;\n    // Name of the operation\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) {\n        require(_controller != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ Virtual External Functions ============ */\n\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view virtual override;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        address _data,\n        IGarden _garden,\n        address _integration\n    ) external view virtual override returns (uint256, bool);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the operation\n     */\n    function getName() external view override returns (string memory) {\n        return name;\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle\n     */\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return oracle.getPrice(_assetOne == address(0) ? WETH : _assetOne, _assetTwo == address(0) ? WETH : _assetTwo);\n    }\n}\n"
    },
    "contracts/strategies/operations/LendOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title LendOperatin\n * @author Babylon Finance\n *\n * Executes a lend operation\n */\ncontract LendOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the lend operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {}\n\n    /**\n     * Executes the lend operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _assetToken         Address of the asset to lend\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _assetToken,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        if (_assetToken != _asset) {\n            // Trade to WETH if is 0x0 (eth in compound)\n            if (_assetToken != address(0) || _asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, _capital, _assetToken == address(0) ? WETH : _assetToken);\n            }\n        }\n        uint256 numTokensToSupply;\n        if (_assetToken == address(0)) {\n            // change it to plain eth for compound\n            IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            numTokensToSupply = address(msg.sender).balance;\n        } else {\n            numTokensToSupply = IERC20(_assetToken).balanceOf(msg.sender);\n        }\n        uint256 exactAmount = ILendIntegration(_integration).getExpectedShares(_assetToken, numTokensToSupply);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ILendIntegration(_integration).supplyTokens(msg.sender, _assetToken, numTokensToSupply, minAmountExpected);\n        return (_assetToken, numTokensToSupply, 1); // put as collateral\n    }\n\n    /**\n     * Exits the lend operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address _borrowToken,\n        uint256 _remaining,\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        address _assetToken,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        // Normalize to underlying asset if any (ctokens for compound)\n        uint256 numTokensToRedeem = ILendIntegration(_integration).getInvestmentTokenAmount(msg.sender, _assetToken);\n        // Apply percentage\n        numTokensToRedeem = numTokensToRedeem.mul(_percentage.div(10**(18)));\n        uint256 remainingDebtInCollateralTokens = _getRemainingDebt(_borrowToken, _assetToken, _remaining);\n        remainingDebtInCollateralTokens = SafeDecimalMath.normalizeAmountTokens(\n            _borrowToken,\n            _assetToken,\n            remainingDebtInCollateralTokens\n        );\n\n        if (_remaining > 0) {\n            // Update amount so we can exit if there is debt\n            numTokensToRedeem = numTokensToRedeem.sub(remainingDebtInCollateralTokens.mul(130).div(100));\n        }\n        uint256 exchangeRate = ILendIntegration(_integration).getExchangeRatePerToken(_assetToken);\n        ILendIntegration(_integration).redeemTokens(\n            msg.sender,\n            _assetToken,\n            numTokensToRedeem,\n            exchangeRate.mul(numTokensToRedeem.sub(numTokensToRedeem.preciseMul(SLIPPAGE_ALLOWED)))\n        );\n        address tokenToTradeFrom = _assetToken;\n        // if eth, convert it to weth\n        if (_assetToken == address(0)) {\n            tokenToTradeFrom = WETH;\n            IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n        }\n        if (tokenToTradeFrom != _garden.reserveAsset()) {\n            IStrategy(msg.sender).trade(\n                tokenToTradeFrom,\n                IERC20(tokenToTradeFrom).balanceOf(msg.sender),\n                _garden.reserveAsset()\n            );\n        }\n        return (\n            _assetToken,\n            IERC20(ILendIntegration(_integration).getInvestmentToken(_assetToken)).balanceOf(msg.sender),\n            1\n        );\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _lendToken          Asset lent\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV(\n        address _lendToken,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 assetTokenAmount = ILendIntegration(_integration).getInvestmentTokenAmount(msg.sender, _lendToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), _lendToken);\n        uint256 NAV =\n            SafeDecimalMath.normalizeAmountTokens(_lendToken, _garden.reserveAsset(), assetTokenAmount).preciseDiv(\n                price\n            );\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    function _getRemainingDebt(\n        address _borrowToken,\n        address _assetToken,\n        uint256 _remaining\n    ) private view returns (uint256) {\n        if (_remaining == 0) {\n            return 0;\n        }\n        uint256 price = _getPrice(_borrowToken, _assetToken);\n        return _remaining.preciseMul(price);\n    }\n}\n"
    },
    "contracts/interfaces/ILendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ILendIntegration\n * @author Babylon Finance\n *\n * Interface for lending integrations such as Compound, Aave.\n */\ninterface ILendIntegration {\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external;\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external;\n\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply) external view returns (uint256);\n\n    function getExchangeRatePerToken(address _assetToken) external view returns (uint256);\n\n    function getInvestmentToken(address _assetToken) external view returns (address);\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/BuyOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\n\n/**\n * @title BuyOperation\n * @author Babylon Finance\n *\n * Executes a buy operation\n */\ncontract BuyOperation is Operation {\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the buy operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(_data != _garden.reserveAsset(), 'Receive token must be different');\n    }\n\n    /**\n     * Executes the buy operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _data               Address of the token to buy\n     * param _garden             Garden of the strategy\n     * param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _data,\n        IGarden, /* _garden */\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        IStrategy(msg.sender).trade(_asset, _capital, _data);\n        return (_data, IERC20(_data).balanceOf(address(msg.sender)), 0); // liquid\n    }\n\n    /**\n     * Exits the buy operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= 100e18, 'Unwind Percentage <= 100%');\n        IStrategy(msg.sender).trade(\n            _data,\n            IERC20(_data).balanceOf(address(msg.sender)).preciseMul(_percentage),\n            _garden.reserveAsset()\n        );\n    }\n\n    /**\n     * Gets the NAV of the buy op in the reserve asset\n     *\n     * @param _token               Asset bought\n     * @param _garden             Garden the strategy belongs to\n     * param _integration         Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        address _token,\n        IGarden _garden,\n        address /* _integration */\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 price = _getPrice(_garden.reserveAsset(), _token);\n        uint256 NAV =\n            SafeDecimalMath\n                .normalizeAmountTokens(_token, _garden.reserveAsset(), IERC20(_token).balanceOf(msg.sender))\n                .preciseDiv(price);\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n}\n"
    },
    "contracts/integrations/trade/TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport 'hardhat/console.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title BorrowIntetration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with trading protocols\n */\nabstract contract TradeIntegration is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct TradeInfo {\n        IGarden garden; // Garden\n        IStrategy strategy; // Strategy\n        string exchangeName; // Which exchange to use\n        address sendToken; // Address of token being sold\n        address receiveToken; // Address of token being bought\n        uint256 gardenTotalSupply; // Total supply of Garden in Precise Units (10^18)\n        uint256 totalSendQuantity; // Total quantity of sold tokens\n        uint256 totalMinReceiveQuantity; // Total minimum quantity of token to receive back\n        uint256 preTradeSendTokenBalance; // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance; // Total initial balance of token being bought\n    }\n\n    /* ============ Events ============ */\n\n    event ComponentExchanged(\n        IGarden indexed _garden,\n        IStrategy indexed _strategy,\n        address indexed _sendToken,\n        address _receiveToken,\n        string _exchangeName,\n        uint256 _totalSendAmount,\n        uint256 _totalReceiveAmount\n    );\n\n    /* ============ Constants ============ */\n\n    uint24 internal constant FEE_LOW = 500;\n    uint24 internal constant FEE_MEDIUM = 3000;\n    uint24 internal constant FEE_HIGH = 10000;\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external override nonReentrant onlySystemContract {\n        TradeInfo memory tradeInfo =\n            _createTradeInfo(_strategy, name, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity);\n        _validatePreTradeData(tradeInfo, _sendQuantity);\n        // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n        tradeInfo.strategy.invokeApprove(_getSpender(), tradeInfo.sendToken, tradeInfo.totalSendQuantity);\n        (address targetExchange, uint256 callValue, bytes memory methodData) =\n            _getTradeCallData(_strategy, tradeInfo.sendToken, tradeInfo.totalSendQuantity, tradeInfo.receiveToken);\n        tradeInfo.strategy.invokeFromIntegration(targetExchange, callValue, methodData);\n\n        uint256 exchangedQuantity = _validatePostTrade(tradeInfo);\n        uint256 newAmountSendTokens = tradeInfo.preTradeSendTokenBalance.sub(tradeInfo.totalSendQuantity);\n        uint256 newAmountReceiveTokens = tradeInfo.preTradeReceiveTokenBalance.add(exchangedQuantity);\n        emit ComponentExchanged(\n            tradeInfo.garden,\n            tradeInfo.strategy,\n            _sendToken,\n            _receiveToken,\n            tradeInfo.exchangeName,\n            newAmountSendTokens,\n            newAmountReceiveTokens\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return TradeInfo struct\n     *\n     * @param _strategy             Address of the strategy\n     * @param _exchangeName         Human readable name of the exchange in the integrations registry\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     * @param _minReceiveQuantity   Min units of token in SetToken to be received from the exchange\n     *\n     * return TradeInfo             Struct containing data for trade\n     */\n    function _createTradeInfo(\n        address _strategy,\n        string memory _exchangeName,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) internal view returns (TradeInfo memory) {\n        TradeInfo memory tradeInfo;\n\n        tradeInfo.strategy = IStrategy(_strategy);\n        tradeInfo.garden = tradeInfo.strategy.garden();\n\n        tradeInfo.exchangeName = _exchangeName;\n\n        tradeInfo.sendToken = _sendToken;\n        tradeInfo.receiveToken = _receiveToken;\n\n        tradeInfo.gardenTotalSupply = ERC20(address(tradeInfo.strategy.garden())).totalSupply();\n\n        tradeInfo.totalSendQuantity = _sendQuantity;\n\n        tradeInfo.totalMinReceiveQuantity = _minReceiveQuantity;\n\n        tradeInfo.preTradeSendTokenBalance = ERC20(_sendToken).balanceOf(_strategy);\n        tradeInfo.preTradeReceiveTokenBalance = ERC20(_receiveToken).balanceOf(_strategy);\n\n        return tradeInfo;\n    }\n\n    /**\n     * Validate pre trade data. Check exchange is valid, token quantity is valid.\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     */\n    function _validatePreTradeData(TradeInfo memory _tradeInfo, uint256 _sendQuantity) internal view {\n        require(_tradeInfo.totalSendQuantity > 0, 'Token to sell must be nonzero');\n\n        address reserveAsset = _tradeInfo.garden.reserveAsset();\n        uint256 liquidityInReserve = _getUniswapHighestLiquidity(_tradeInfo, reserveAsset);\n        uint256 minLiquidityReserveAsset = _tradeInfo.garden.minLiquidityAsset();\n        require(liquidityInReserve >= minLiquidityReserveAsset, 'Not enough liquidity');\n\n        require(\n            ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy)) >= _sendQuantity,\n            'Strategy needs to have enough liquid tokens'\n        );\n    }\n\n    function _getUniswapHighestLiquidity(TradeInfo memory _tradeInfo, address _reserveAsset)\n        internal\n        view\n        returns (uint256)\n    {\n        address sendToken = _getReserveAsWeth(_tradeInfo.sendToken, _reserveAsset);\n        address receiveToken = _getReserveAsWeth(_tradeInfo.receiveToken, _reserveAsset);\n        // Exit if going to weth from weth\n        if (sendToken == receiveToken) {\n            return _tradeInfo.garden.minLiquidityAsset();\n        }\n        (IUniswapV3Pool pool, ) = _getUniswapPoolWithHighestLiquidity(sendToken, receiveToken);\n        uint256 poolLiquidity = uint256(pool.liquidity());\n        uint256 liquidityInReserve;\n        if (pool.token0() == WETH) {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token1()).balanceOf(address(pool)));\n        }\n        if (pool.token1() == WETH) {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token0()).balanceOf(address(pool)));\n        }\n        // Normalize to reserve asset\n        if (WETH != _reserveAsset) {\n            IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n            uint256 price = oracle.getPrice(WETH, _reserveAsset);\n            liquidityInReserve = liquidityInReserve.preciseMul(price);\n        }\n        return liquidityInReserve;\n    }\n\n    /**\n     * Validate post trade data.\n     *\n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @return uint256                  Total quantity of receive token that was exchanged\n     */\n    function _validatePostTrade(TradeInfo memory _tradeInfo) internal view returns (uint256) {\n        uint256 exchangedQuantity =\n            ERC20(_tradeInfo.receiveToken).balanceOf(address(_tradeInfo.strategy)).sub(\n                _tradeInfo.preTradeReceiveTokenBalance\n            );\n        require(exchangedQuantity >= _tradeInfo.totalMinReceiveQuantity, 'Slippage greater than allowed');\n        return exchangedQuantity;\n    }\n\n    /**\n     * Return exchange calldata which is already generated from the exchange API\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the exchange\n     * hparam _sendQuantity         Units of reserve asset token sent to the exchange\n     * hparam _receiveToken         Address of the token that will be received from the exchange\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken */\n        uint256, /*_sendQuantity */\n        address /* _receiveToken */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address     Address of the contract to approve tokens to\n     */\n    function _getSpender() internal view virtual returns (address);\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        internal\n        view\n        returns (IUniswapV3Pool pool, uint24 fee)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow > liquidityMedium && liquidityLow >= liquidityHigh) {\n            return (poolLow, FEE_LOW);\n        }\n        if (liquidityMedium > liquidityLow && liquidityMedium >= liquidityHigh) {\n            return (poolMedium, FEE_MEDIUM);\n        }\n        return (poolHigh, FEE_HIGH);\n    }\n\n    function _getReserveAsWeth(address _token, address _reserveAsset) private view returns (address) {\n        return _reserveAsset == _token ? WETH : _token;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/trade/UniswapV3TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport 'hardhat/console.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ISwapRouter} from '../../interfaces/external/uniswap-v3/ISwapRouter.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title UniswapV3TradeIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapV3 trade integration\n */\ncontract UniswapV3TradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    // Address of Uniswap V3 SwapRouter contract\n    address private constant swapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('univ3', _controller) {}\n\n    /* ============ External Functions ============ */\n    /**\n     * Returns the conversion rate between the source token and the destination token\n     * in 18 decimals, regardless of component token's decimals\n     *\n     * hparam  _sourceToken        Address of source token to be sold\n     * hparam  _destinationToken   Address of destination token to buy\n     * hparam  _sourceQuantity     Amount of source token to sell\n     *\n     * @return uint256             Conversion rate in wei\n     * @return uint256             Slippage rate in wei\n     */\n    function getConversionRates(\n        address,\n        address,\n        uint256\n    ) external pure override returns (uint256, uint256) {\n        revert('not implemented');\n        return (0, 0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through UniswapV3.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        bytes memory path;\n        if (_sendToken == WETH || _receiveToken == WETH) {\n            (, uint24 fee) = _getUniswapPoolWithHighestLiquidity(_sendToken, _receiveToken);\n            path = abi.encodePacked(_sendToken, fee, _receiveToken);\n        } else {\n            (, uint24 fee0) = _getUniswapPoolWithHighestLiquidity(_sendToken, WETH);\n            (, uint24 fee1) = _getUniswapPoolWithHighestLiquidity(_sendToken, WETH);\n            path = abi.encodePacked(_sendToken, fee0, WETH, fee1, _receiveToken);\n        }\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(\n                path,\n                _strategy,\n                block.timestamp,\n                _sendQuantity,\n                1 // we check for amountOutMinimum in the post trade check\n            );\n\n        bytes memory callData = abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n        return (swapRouter, 0, callData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender() internal view override returns (address) {\n        return address(swapRouter);\n    }\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol SetValuer)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\n/**\n * @title Treasury\n * @author Babylon Finance\n *\n * Contract that will receive the fees earned by the protocol.\n * Governance will be able to send funds from the treasury.\n */\ncontract Treasury is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    /* ============ Events ============ */\n\n    event TreasuryFundsSent(address _asset, uint256 _amount, address _to);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     */\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION: Send an asset amount to an address\n     *\n     * @param _asset            Address of the asset to send\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryFunds(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external onlyOwner nonReentrant {\n        require(_asset != address(0), 'Asset must exist');\n        require(_to != address(0), 'Target address must exist');\n        IERC20(_asset).safeTransferFrom(address(this), _to, _amount);\n        emit TreasuryFundsSent(_asset, _amount, _to);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Send an ETH amount to an address\n     *\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryETH(uint256 _amount, address payable _to) external onlyOwner nonReentrant {\n        require(_to != address(0), 'Target address must exist');\n        require(address(this).balance >= _amount, 'Not enough funds in treasury');\n        Address.sendValue(_to, _amount);\n        emit TreasuryFundsSent(address(0), _amount, _to);\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n"
    },
    "contracts/token/BABLToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title BABL Token\n * @dev The BABLToken contract is ERC20 using 18 decimals as a standard\n * Is Ownable to transfer ownership to Governor Alpha for Decentralized Governance\n * It overrides the mint and maximum supply to control the timing and maximum cap allowed along the time.\n */\n\ncontract BABLToken is TimeLockedToken {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new mint ocurr\n    event MintedNewTokens(address account, uint256 tokensminted);\n\n    /// @notice An event thats emitted when maxSupplyAllowed changes\n    event MaxSupplyChanged(uint256 previousMaxValue, uint256 newMaxValue);\n\n    /// @notice An event that emitted when maxSupplyAllowedAfter changes\n    event MaxSupplyAllowedAfterChanged(uint256 previousAllowedAfterValue, uint256 newAllowedAfterValue);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @dev EIP-20 token name for this token\n    string private constant NAME = 'Babylon.Finance';\n\n    /// @dev EIP-20 token symbol for this token\n    string private constant SYMBOL = 'BABL';\n\n    /// @dev Maximum number of tokens in circulation of 1 million for the first 8 years (using 18 decimals as ERC20 standard)\n    uint256 public maxSupplyAllowed = 1_000_000e18; //\n\n    /// @notice The timestamp after which a change on maxSupplyAllowed may occur\n    uint256 public maxSupplyAllowedAfter;\n\n    /// @notice Cap on the percentage of maxSupplyAllowed that can be increased per year after maxSupplyAllowedAfter\n    uint8 public constant MAX_SUPPLY_CAP = 5;\n\n    /// @notice Cap on the percentage of totalSupply that can be minted at each mint after the initial 1 Million BABL\n    uint8 public constant MINT_CAP = 2;\n\n    /// @notice The timestamp after which minting may occur after FIRST_EPOCH_MINT (8 years)\n    uint256 public mintingAllowedAfter;\n\n    /// @notice The timestamp of BABL Token deployment\n    uint256 public BABLTokenDeploymentTimestamp;\n\n    /// @dev First Epoch Mint where no more than 1 Million BABL can be minted (>= 8 Years)\n    uint32 private constant FIRST_EPOCH_MINT = 365 days * 8;\n\n    /// @dev Minimum time between mints after\n    uint32 private constant MIN_TIME_BETWEEN_MINTS = 365 days;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new BABL token and gives ownership to sender\n     */\n    constructor(TimeLockRegistry newTimeLockRegistry, IBabController newController) TimeLockedToken(NAME, SYMBOL) {\n        // Timestamp of contract deployment\n        BABLTokenDeploymentTimestamp = block.timestamp;\n\n        // Set-up the minimum time of 8 years to wait until the maxSupplyAllowed can be changed (it will also include a max cap)\n        maxSupplyAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        //Starting with a maxSupplyAllowed of 1 million for the first 8 years\n        _mint(msg.sender, 1_000_000e18);\n\n        //Set-up the minimum time of 8 years for additional mints\n        mintingAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        // Set the Time Lock Registry\n        timeLockRegistry = newTimeLockRegistry;\n\n        // Set the Babylon Controller\n        controller = newController;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows to mint new tokens\n     *\n     * @notice Mint new BABL tokens. Initial 1 Million BABL. After 8 years new BABL could be minted by governance decision\n     * @dev MINT_CAP The new maximum limit, limited by a 2% cap of totalSupply for each new mint and always limited by maxSupplyAllowed.\n     * mintingAllowedAfter Defines the next time allowed for a new mint\n     * @param _to The address of the destination account that will receive the new BABL tokens\n     * @param _amount The number of tokens to be minted\n     * @return Whether or not the mint succeeded\n     */\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        require(totalSupply().add(_amount) <= maxSupplyAllowed, 'BABLToken::mint: max supply exceeded');\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::mint: minting not allowed after the FIRST_EPOCH_MINT has passed >= 8 years'\n        );\n        require(_amount > 0, 'BABLToken::mint: mint should be higher than zero');\n        require(\n            block.timestamp >= mintingAllowedAfter,\n            'BABLToken::mint: minting not allowed yet because mintingAllowedAfter'\n        );\n        require(_to != address(0), 'BABLToken::mint: cannot transfer to the zero address');\n        require(_to != address(this), 'BABLToken::mint: cannot mint to the address of this contract');\n\n        // set-up the new time where a new (the next) mint can be allowed\n        mintingAllowedAfter = block.timestamp.add(MIN_TIME_BETWEEN_MINTS);\n\n        // mint the amount\n        uint96 amount = safe96(_amount, 'BABLToken::mint: amount exceeds 96 bits');\n\n        // After FIRST_EPOCH_MINT (8 years) a MINT_CAP applies\n        require(\n            amount <= totalSupply().mul(MINT_CAP).div(100),\n            'BABLToken::mint: exceeded mint cap of 2% of total supply'\n        );\n        _mint(_to, amount);\n\n        emit MintedNewTokens(_to, amount);\n\n        // move delegates to add voting power to the destination\n        _moveDelegates(address(0), delegates[_to], amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change maxSupplyAllowed\n     *\n     * @notice Set-up a greater maxSupplyAllowed value to allow more tokens to be minted\n     * @param newMaxSupply The new maximum limit, limited by a maximum of 5% cap per year\n     * @param newMaxSupplyAllowedAfter The new waiting period to change the maxSupplyAllowed limited for a minimum of 1 year\n     * @return Whether or not the changeMaxSupply succeeded\n     */\n    function changeMaxSupply(uint256 newMaxSupply, uint256 newMaxSupplyAllowedAfter) external onlyOwner returns (bool) {\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed until 8 years after deployment'\n        );\n        require(\n            block.timestamp >= maxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed yet'\n        );\n\n        // update the amount\n        require(\n            newMaxSupply > maxSupplyAllowed,\n            'BABLToken::changeMaxSupply: changeMaxSupply should be higher than previous value'\n        );\n        uint256 limitedNewSupply = maxSupplyAllowed.add(maxSupplyAllowed.mul(MAX_SUPPLY_CAP).div(100));\n        require(newMaxSupply <= limitedNewSupply, 'BABLToken::changeMaxSupply: exceeded of allowed 5% cap');\n        emit MaxSupplyChanged(maxSupplyAllowed, newMaxSupply);\n        maxSupplyAllowed = safe96(newMaxSupply, 'BABLToken::changeMaxSupply: potential max amount exceeds 96 bits');\n\n        // update the new waiting time until a new change could be done >= 1 year since this change\n        uint256 futureTime = block.timestamp.add(365 days);\n        require(\n            newMaxSupplyAllowedAfter >= futureTime,\n            'BABLToken::changeMaxSupply: the newMaxSupplyAllowedAfter should be at least 1 year in the future'\n        );\n        emit MaxSupplyAllowedAfterChanged(maxSupplyAllowedAfter, newMaxSupplyAllowedAfter);\n        maxSupplyAllowedAfter = safe96(\n            newMaxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: new newMaxSupplyAllowedAfter exceeds 96 bits'\n        );\n\n        return true;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the value of maxSupplyAllowed\n     *\n     * @return Returns the value of maxSupplyAllowed at the time\n     */\n    function maxSupply() external view returns (uint96, uint256) {\n        uint96 safeMaxSupply =\n            safe96(maxSupplyAllowed, 'BABLToken::maxSupplyAllowed: maxSupplyAllowed exceeds 96 bits'); // Overflow check\n        return (safeMaxSupply, maxSupplyAllowedAfter);\n    }\n}\n"
    },
    "contracts/mocks/BabControllerV2Mock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabControllerV2Mock is OwnableUpgradeable {\n    using AddressArrayUtils for address[];\n    using AddressUpgradeable for address;\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address public uniswapFactory;\n    address public gardenValuer;\n    address public priceOracle;\n    address public gardenFactory;\n    address public rewardsDistributor;\n    address public ishtarGate;\n    address public strategyFactory;\n    address public gardenNFT;\n    address public strategyNFT;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations;\n    // Address of the default trade integration used by the protocol\n    address public defaultTradeIntegration;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) public assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Mapping of minimum liquidity per reserve asset\n    mapping(address => uint256) public minLiquidityPerReserve;\n\n    // Recipient of protocol fees\n    address public treasury;\n\n    // Strategy cooldown period\n    uint256 public constant MIN_COOLDOWN_PERIOD = 6 hours;\n    uint256 public constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    // Strategy Profit Sharing\n    uint256 public strategistProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsProfitPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsProfitPercentage; //\n\n    // Strategy BABL Rewards Sharing\n    uint256 public strategistBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public stewardsBABLPercentage; // (0.01% = 1e14, 1% = 1e16)\n    uint256 public lpsBABLPercentage; //\n\n    uint256 public gardenCreatorBonus;\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public allowPublicGardens;\n\n    uint256 public protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    // Maximum number of contributors per garden\n    uint256 public maxContributorsPerGarden;\n\n    // Enable garden creations to be fully open to the public (no need of Ishtar gate anymore)\n    bool public gardenCreationIsOpen;\n\n    // Pause Guardian\n    address public guardian;\n    mapping(address => bool) public guardianPaused;\n    bool public guardianGlobalPaused;\n\n    bool public newVar;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        gardenTokensTransfersEnabled = false;\n        bablMiningProgramEnabled = false;\n        guardianGlobalPaused = false;\n\n        uniswapFactory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n        strategistProfitPercentage = 10e16;\n        stewardsProfitPercentage = 5e16;\n        lpsProfitPercentage = 80e16;\n\n        strategistBABLPercentage = 8e16;\n        stewardsBABLPercentage = 17e16;\n        lpsBABLPercentage = 75e16;\n\n        gardenCreatorBonus = 15e16;\n        maxContributorsPerGarden = 100;\n        gardenCreationIsOpen = false;\n    }\n\n    /* ============ External Functions ============ */\n\n    function newMethod() public view returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "contracts/integrations/pool/PoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title PoolIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with pool protocols\n */\nabstract contract PoolIntegration is BaseIntegration, ReentrancyGuard, IPoolIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct PoolInfo {\n        IGarden garden; // Garden address\n        IStrategy strategy; // Strategy address\n        address pool; // Pool address\n        uint256 totalSupply; // Total Supply of the pool\n        uint256 poolTokensInTransaction; // Pool tokens affected by this transaction\n        uint256 poolTokensInStrategy; // Pool tokens strategy balance\n        uint256[] limitPoolTokenQuantities;\n    }\n\n    /* ============ Events ============ */\n\n    event PoolEntered(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensOut);\n\n    event PoolExited(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensIn);\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 5e16; // 5%\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Joins a pool\n     *\n     * @param _strategy             Address of the strategy\n     * @param _poolAddress          Address of the pool token to join\n     * @param _poolTokensOut        Min amount of pool tokens to receive\n     * @param _tokensIn             Array of token addresses to deposit\n     * @param _maxAmountsIn         Array of max token quantities to pull out from the garden\n     */\n    function joinPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _poolAddress, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        _validatePreJoinPoolData(poolInfo);\n        // Approve spending of the tokens\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            // No need to approve ETH\n            if (_tokensIn[i] != address(0)) {\n                poolInfo.strategy.invokeApprove(_getSpender(_poolAddress), _tokensIn[i], _maxAmountsIn[i]);\n            }\n        }\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getJoinPoolCalldata(_strategy, _poolAddress, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        poolInfo.poolTokensInTransaction = IERC20(poolInfo.pool).balanceOf(address(poolInfo.strategy)).sub(\n            poolInfo.poolTokensInStrategy\n        );\n        _validatePostJoinPoolData(poolInfo);\n        emit PoolEntered(address(poolInfo.strategy), address(poolInfo.garden), poolInfo.pool, _poolTokensOut);\n    }\n\n    /**\n     * Exits a liquidity pool. Accrue protocol fee (if any)\n     *\n     * @param _strategy               Address of the strategy\n     * @param _poolAddress            Address of the pool token to join\n     * @param _poolTokensIn           Pool tokens to exchange for the underlying tokens\n     * @param _tokensOut              Array of token addresses to withdraw\n     * @param _minAmountsOut          Array of min token quantities to receive from the pool\n     */\n    function exitPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _poolAddress, _poolTokensIn, _tokensOut, _minAmountsOut);\n        _validatePreExitPoolData(poolInfo);\n        // Approve spending of the pool token\n        poolInfo.strategy.invokeApprove(_getSpender(_poolAddress), _poolAddress, _poolTokensIn);\n\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getExitPoolCalldata(_strategy, _poolAddress, _poolTokensIn, _tokensOut, _minAmountsOut);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        _validatePostExitPoolData(poolInfo);\n\n        emit PoolExited(address(poolInfo.strategy), address(poolInfo.garden), poolInfo.pool, _poolTokensIn);\n    }\n\n    /**\n     * Checks whether a pool address is valid\n     *\n     * @param _poolAddress                 Pool address to check\n     * @return bool                        True if the address is a pool\n     */\n    function isPool(address _poolAddress) external view override returns (bool) {\n        return _isPool(_poolAddress);\n    }\n\n    function getPoolTokens(\n        address /* _poolAddress */\n    ) external view virtual override returns (address[] memory);\n\n    function getPoolWeights(\n        address /*_poolAddress */\n    ) external view virtual override returns (uint256[] memory);\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return PoolInfo struct\n     *\n     * @param _strategy                      Address of the strategy\n     * @param _pool                          Address of the pool\n     * @param _poolTokensInTransaction       Number of pool tokens involved\n     * hparam _poolTokens                    Addresseses of the pool tokens\n     * @param _limitPoolTokenQuantities      Limit quantity of the pool tokens\n     *\n     * return PoolInfo             Struct containing data for pool\n     */\n    function _createPoolInfo(\n        address _strategy,\n        address _pool,\n        uint256 _poolTokensInTransaction,\n        address[] calldata, /* _poolTokens */\n        uint256[] calldata _limitPoolTokenQuantities\n    ) internal view returns (PoolInfo memory) {\n        PoolInfo memory poolInfo;\n        poolInfo.strategy = IStrategy(_strategy);\n        poolInfo.garden = IGarden(poolInfo.strategy.garden());\n        poolInfo.pool = _pool;\n        poolInfo.totalSupply = IERC20(_pool).totalSupply();\n        poolInfo.poolTokensInStrategy = IERC20(_pool).balanceOf(_strategy);\n        poolInfo.poolTokensInTransaction = _poolTokensInTransaction;\n        poolInfo.limitPoolTokenQuantities = _limitPoolTokenQuantities;\n\n        return poolInfo;\n    }\n\n    /**\n     * Validate pre pool join data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Min pool tokens to receive must be greater than 0');\n    }\n\n    /**\n     * Validate pre pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Pool tokens to exchange must be greater than 0');\n        require(\n            _poolInfo.poolTokensInStrategy >= _poolInfo.poolTokensInTransaction,\n            'The strategy does not have enough pool tokens'\n        );\n    }\n\n    /**\n     * Validate post join pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            (IERC20(_poolInfo.pool).balanceOf(address(_poolInfo.strategy)) > _poolInfo.poolTokensInStrategy),\n            'The strategy did not receive the pool tokens'\n        );\n    }\n\n    /**\n     * Validate post exit pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            IERC20(_poolInfo.pool).balanceOf(address(_poolInfo.strategy)) ==\n                _poolInfo.poolTokensInStrategy - _poolInfo.poolTokensInTransaction,\n            'The strategy did not return the pool tokens'\n        );\n        // TODO: validate individual tokens received\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * hparam  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address, /* _poolAddress */\n        uint256, /* _poolTokensOut */\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata /* _maxAmountsIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * hparam  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address, /* _poolAddress */\n        uint256, /* _poolTokensIn */\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata /* _minAmountsOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _isPool(\n        address /* _poolAddress */\n    ) internal view virtual returns (bool);\n\n    function _getSpender(\n        address /* _poolAddress */\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/interfaces/IPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPoolIntegration\n * @author Babylon Finance\n *\n * Interface for liquiditypool protocol integrations\n */\ninterface IPoolIntegration {\n    function joinPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] memory _poolTokens,\n        uint256[] memory _maxAmountsIn\n    ) external;\n\n    function exitPool(\n        address _strategy,\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] memory _poolTokens,\n        uint256[] memory _minAmountsOut\n    ) external;\n\n    function getPoolTokens(address _poolAddress) external view returns (address[] memory);\n\n    function getPoolWeights(address _poolAddress) external view returns (uint256[] memory);\n\n    function getPoolTokensOut(\n        address _poolAdress,\n        address _tokenAddress,\n        uint256 _maxAmountsIn\n    ) external view returns (uint256);\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _poolTokenAmount)\n        external\n        view\n        returns (uint256[] memory _minAmountsOut);\n\n    function isPool(address _poolAddress) external view returns (bool);\n}\n"
    },
    "contracts/integrations/pool/UniswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {IUniswapV2Router} from '../../interfaces/external/uniswap/IUniswapV2Router.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapPoolIntegration protocol integration\n */\ncontract UniswapPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IUniswapV2Router public uniRouter;\n\n    /* ============ Constants ============ */\n\n    uint8 public immutable MAX_DELTA_BLOCKS = 5;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _uniswapRouterAddress         Address of Uniswap router\n     */\n    constructor(IBabController _controller, address _uniswapRouterAddress)\n        PoolIntegration('uniswap_pool', _controller)\n    {\n        uniRouter = IUniswapV2Router(_uniswapRouterAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        address[] memory result = new address[](2);\n        result[0] = IUniswapV2Pair(_poolAddress).token0();\n        result[1] = IUniswapV2Pair(_poolAddress).token1();\n        return result;\n    }\n\n    function getPoolWeights(\n        address /* _poolAddress */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address, /* _poolAddress */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        uint256 totalSupply = IUniswapV2Pair(_poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        result[0] = IERC20(IUniswapV2Pair(_poolAddress).token0())\n            .balanceOf(_poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = IERC20(IUniswapV2Pair(_poolAddress).token1())\n            .balanceOf(_poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal pure override returns (bool) {\n        return IUniswapV2Pair(_poolAddress).MINIMUM_LIQUIDITY() > 0;\n    }\n\n    function _getSpender(\n        address //_poolAddress\n    ) internal view override returns (address) {\n        return address(uniRouter);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address _strategy,\n        address, /* _poolAddress */\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        return (address(uniRouter), 0, _getMethodData(_strategy, _tokensIn, _maxAmountsIn));\n    }\n\n    function _getMethodData(\n        address _strategy,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) private view returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                'addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)',\n                _tokensIn[0],\n                _tokensIn[1],\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED)),\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address _strategy,\n        address, /* _poolAddress */\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)',\n                _tokensOut[0],\n                _tokensOut[1],\n                _poolTokensIn,\n                _minAmountsOut[0],\n                _minAmountsOut[1],\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n\n        return (address(uniRouter), 0, methodData);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV2Router.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/strategies/operations/DepositVaultOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title DepositVaultOperation\n * @author Babylon Finance\n *\n * Executes a deposit vault operation\n */\ncontract DepositVaultOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the deposit vault operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {}\n\n    /**\n     * Executes the deposit vault operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _data               Address of the vault to enter\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address yieldVault = _data;\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        if (vaultAsset != _asset) {\n            IStrategy(msg.sender).trade(_asset, _capital, vaultAsset);\n        }\n        uint256 exactAmount = IPassiveIntegration(_integration).getExpectedShares(yieldVault, _capital);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        IPassiveIntegration(_integration).enterInvestment(\n            msg.sender,\n            yieldVault,\n            minAmountExpected,\n            vaultAsset,\n            IERC20(vaultAsset).balanceOf(msg.sender)\n        );\n        return (yieldVault, IERC20(yieldVault).balanceOf(msg.sender), 0); // liquid\n    }\n\n    /**\n     * Exits the deposit vault operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        address _yieldVault,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(_yieldVault);\n        uint256 amountVault = IERC20(_yieldVault).balanceOf(msg.sender).preciseMul(_percentage);\n        uint256 minAmount =\n            IPassiveIntegration(_integration).getPricePerShare(_yieldVault).mul(\n                amountVault.sub(amountVault.preciseMul(SLIPPAGE_ALLOWED))\n            );\n        IPassiveIntegration(_integration).exitInvestment(msg.sender, _yieldVault, amountVault, vaultAsset, minAmount);\n        if (vaultAsset != _garden.reserveAsset()) {\n            IStrategy(msg.sender).trade(vaultAsset, IERC20(vaultAsset).balanceOf(msg.sender), _garden.reserveAsset());\n        }\n        return (_yieldVault, 0, 0);\n    }\n\n    /**\n     * Gets the NAV of the deposit vault op in the reserve asset\n     *\n     * @param _vault              Vault\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        address _vault,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(_vault);\n        uint256 price = _getPrice(_garden.reserveAsset(), vaultAsset);\n        uint256 NAV =\n            IPassiveIntegration(_integration).getPricePerShare(_vault).mul(IERC20(_vault).balanceOf(msg.sender)).div(\n                price\n            );\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n}\n"
    },
    "contracts/interfaces/IPassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPassiveIntegration\n * @author Babylon Finance\n *\n * Interface for passive investments protocol integrations\n */\ninterface IPassiveIntegration {\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external;\n\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external;\n\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount) external view returns (uint256);\n\n    function getPricePerShare(address _investmentAddress) external view returns (uint256);\n\n    function getInvestmentAsset(address _investmentAddress) external view returns (address);\n}\n"
    },
    "contracts/integrations/passive/PassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title PassiveIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract PassiveIntegration is BaseIntegration, ReentrancyGuard, IPassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address investment; // Investment address\n        uint256 totalSupply; // Total Supply of the investment\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event InvestmentEntered(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        address tokenIn,\n        uint256 investmentTokensOut\n    );\n\n    event InvestmentExited(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        uint256 investmentTokensOut\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits tokens into an investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokensOut        Min amount of investment tokens to receive\n     * @param _tokenIn                    Token aaddress to deposit\n     * @param _maxAmountIn                Max amount of the token to deposit\n     */\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        _validatePreJoinInvestmentData(investmentInfo);\n        // Approve spending of the token\n        investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress), _tokenIn, _maxAmountIn);\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getEnterInvestmentCalldata(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit InvestmentEntered(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _investmentAddress,\n            _tokenIn,\n            _investmentTokensOut\n        );\n    }\n\n    /**\n     * Exits an outside passive investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokenIn          Quantity of investment tokens to return\n     * @param _tokenOut                   Token address to withdraw\n     * @param _minAmountOut               Min token quantities to receive from the investment\n     */\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        _validatePreExitInvestmentData(investmentInfo);\n        // Approve spending of the investment token\n        investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress), _investmentAddress, _investmentTokenIn);\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getExitInvestmentCalldata(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit InvestmentExited(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            investmentInfo.investment,\n            _investmentTokenIn\n        );\n    }\n\n    /**\n     * Gets the amount of shares expected to get after depositing _ethAmount\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @param _ethAmount                         Amount of eth to invest\n     * @return uint256                           Amount of investment shares to receive\n     */\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_investmentAddress, _ethAmount);\n    }\n\n    /**\n     * Gets how much eth one unit of the investment is worth\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return uint256                           Returns the price in ETH of an investment share\n     */\n    function getPricePerShare(address _investmentAddress) external view override returns (uint256) {\n        return _getPricePerShare(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset needed to enter the investment\n     *\n     * @return address                           Returns the asset that this investment needs\n     */\n    function getInvestmentAsset(address _investmentAddress) external view override returns (address) {\n        return _getInvestmentAsset(_investmentAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * @param _strategy                                 Address of the strategy\n     * @param _investment                               Address of the investment\n     * @param _investmentTokensInTransaction            Number of investment tokens involved\n     * hparam _tokenIn                                  Addresseses of the deposit token\n     * @param _limitDepositToken                        Limit quantity of the deposit/withdrawal token\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _investment,\n        uint256 _investmentTokensInTransaction,\n        address, /*_tokenIn*/\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.investment = _investment;\n        investmentInfo.totalSupply = IERC20(_investment).totalSupply();\n        investmentInfo.investmentTokensInGarden = IERC20(_investment).balanceOf(_strategy);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) ==\n                _investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction,\n            'The garden did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                       Addresses of tokens to send to the investment\n     * hparam  _maxAmountIn                   Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _investmentAddress */\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 /* _maxAmountIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of token to receive\n     * hparam  _minAmountOut                   Amount of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /*_strategy */\n        address, /*_investmentAddress */\n        uint256, /*_investmentTokensIn */\n        address, /*_tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getExpectedShares(\n        address, //_investmentAddress\n        uint256 // _ethAmount\n    ) internal view virtual returns (uint256);\n\n    function _getPricePerShare(\n        address //_investmentAddress\n    ) internal view virtual returns (uint256);\n\n    function _getInvestmentAsset(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/passive/YearnVaultIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IYearnRegistry} from '../../interfaces/external/yearn/IYearnRegistry.sol';\nimport {IYearnVault} from '../../interfaces/external/yearn/IYearnVault.sol';\n\n/**\n * @title YearnIntegration\n * @author Babylon Finance Protocol\n *\n * Yearn v2 Vault Integration\n */\ncontract YearnVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IYearnRegistry private constant registry = IYearnRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('yearnvaultsv2', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(address _asset) internal pure override returns (address) {\n        return _asset;\n    }\n\n    function _getExpectedShares(address _asset, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Yearn\n        return\n            _amount.preciseDiv(IYearnVault(_asset).pricePerShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_asset).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _asset) internal view override returns (uint256) {\n        return IYearnVault(_asset).pricePerShare();\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address) {\n        return IYearnVault(_asset).token();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.deposit.selector, _maxAmountIn);\n\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.withdraw.selector, _investmentTokensIn);\n\n        return (_asset, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnRegistry {\n    function latestVault(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function token() external view returns (address);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 shares) external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\n\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance Protocol\n *\n * Uses Uniswap V3 to get a price of a token pair\n */\ncontract PriceOracle is Ownable, IPriceOracle {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n\n    // Address of Uniswap factory\n    IUniswapV3Factory internal constant factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // the desired seconds agos array passed to the observe method\n    uint32 private constant SECONDS_GRANULARITY = 30;\n\n    uint24 private constant FEE_LOW = 500;\n    uint24 private constant FEE_MEDIUM = 3000;\n    uint24 private constant FEE_HIGH = 10000;\n    int24 private constant maxTwapDeviation = 100;\n    uint160 private constant maxLiquidityDeviationFactor = 50;\n    int24 private constant baseThreshold = 1000;\n\n    /* ============ Constructor ============ */\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return price                Price of the pair\n     */\n    function getPrice(address _tokenIn, address _tokenOut) public view override returns (uint256 price) {\n        bool found;\n        uint256 price;\n        int24 tick;\n        IUniswapV3Pool pool;\n\n        // Same asset. Returns base unit\n        if (_tokenIn == _tokenOut) {\n            return 10**18;\n        }\n\n        if (_tokenIn != WETH && _tokenOut != WETH) {\n            return getPrice(_tokenIn, WETH).preciseDiv(getPrice(_tokenOut, WETH));\n        }\n        // We try the low pool first\n        (found, pool, tick) = checkPool(_tokenIn, _tokenOut, FEE_LOW);\n        if (!found) {\n            (found, pool, tick) = checkPool(_tokenIn, _tokenOut, FEE_MEDIUM);\n        }\n        if (!found) {\n            (found, pool, tick) = checkPool(_tokenIn, _tokenOut, FEE_HIGH);\n        }\n        // No valid price\n        require(found, 'Price not found');\n\n        price = OracleLibrary\n            .getQuoteAtTick(\n            tick,\n            // because we use 1e18 as a precision unit\n            uint128(uint256(1e18).mul(10**(uint256(18).sub(ERC20(_tokenOut).decimals())))),\n            _tokenIn,\n            _tokenOut\n        )\n            .div(10**(uint256(18).sub(ERC20(_tokenIn).decimals())));\n        return price;\n    }\n\n    function checkPool(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 fee\n    )\n        internal\n        view\n        returns (\n            bool,\n            IUniswapV3Pool,\n            int24\n        )\n    {\n        int24 tick;\n        IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(_tokenIn, _tokenOut, fee));\n        if (address(pool) != address(0)) {\n            (, tick, , , , , ) = pool.slot0();\n            return (_checkPrice(tick, pool), pool, tick);\n        }\n        return (false, IUniswapV3Pool(0), 0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /// @dev Revert if current price is too close to min or max ticks allowed\n    /// by Uniswap, or if it deviates too much from the TWAP. Should be called\n    /// whenever base and limit ranges are updated. In practice, prices should\n    /// only become this extreme if there's no liquidity in the Uniswap pool.\n    function _checkPrice(int24 mid, IUniswapV3Pool _pool) internal view returns (bool) {\n        int24 tickSpacing = _pool.tickSpacing();\n        // TODO: Add the other param from charm\n        if (mid < TickMath.MIN_TICK + baseThreshold + tickSpacing) {\n            // \"price too low\"\n            return false;\n        }\n        if (mid > TickMath.MAX_TICK - baseThreshold - tickSpacing) {\n            // \"price too high\"\n            return false;\n        }\n\n        // Check TWAP deviation. This check prevents price manipulation before\n        // the rebalance and also avoids rebalancing when price has just spiked.\n        int56 twap = _getTwap(_pool);\n\n        int56 deviation = mid > twap ? mid - twap : twap - mid;\n        // Fail twap check\n        return deviation < maxTwapDeviation;\n    }\n\n    // given the cumulative prices of the start and end of a period, and the length of the period, compute the average\n    function _getTwap(IUniswapV3Pool _pool) private view returns (int56 twap) {\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = SECONDS_GRANULARITY;\n        secondsAgo[1] = 0;\n        // observe fails if the pair has no observations\n        try _pool.observe(secondsAgo) returns (\n            int56[] memory tickCumulatives,\n            uint160[] memory secondsPerLiquidityCumulativeX128s\n        ) {\n            return (tickCumulatives[1] - tickCumulatives[0]) / SECONDS_GRANULARITY;\n        } catch {\n            return 0;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / period);\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % period != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/integrations/lend/CompoundLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\n\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title CompoundLendIntegration\n * @author Babylon Finance Protocol\n *\n * Compound lend integration.\n */\ncontract CompoundLendIntegration is LendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == controller.owner(), 'Only governance can call this');\n        _;\n    }\n\n    /* ============ Constant ============ */\n\n    address internal constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address internal constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     */\n    constructor(IBabController _controller) LendIntegration('compoundlend', _controller) {\n        assetToCToken[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643; // DAI\n        assetToCToken[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984] = 0x35A18000230DA775CAc24873d00Ff85BccdeD550; // UNI\n        assetToCToken[address(0)] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // ETH\n        assetToCToken[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; // USDC\n        assetToCToken[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9; // USDT\n        assetToCToken[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; // WBTC\n        assetToCToken[0xc00e94Cb662C3520282E6f5717214004A7f26888] = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4; // COMP\n        assetToCToken[0x0D8775F648430679A709E98d2b0Cb6250d2887EF] = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E; // BAT\n        assetToCToken[0x514910771AF9Ca656af840dff83E8264EcF986CA] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7; // LINK\n        assetToCToken[0x1985365e9f78359a9B6AD760e32412f4a445E862] = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1; // REP\n        assetToCToken[0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359] = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC; // SAI\n        assetToCToken[0x0000000000085d4780B73119b644AE5ecd22b376] = 0x12392F67bdf24faE0AF363c24aC620a2f67DAd86; // TUSD\n        assetToCToken[0xE41d2489571d322189246DaFA5ebDe1F4699F498] = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407; // ZRX\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external onlyGovernance {\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        ICToken ctoken = ICToken(_getInvestmentToken(_assetToken));\n        return ctoken.balanceOf(_address).mul(ctoken.exchangeRateStored()).div(10**18);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        return assetToCToken[_assetToken] != address(0);\n    }\n\n    function _getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 oneCTokenInUderlying = _getExchangeRatePerToken(_assetToken);\n        return oneCTokenInUderlying.mul(_numTokensToSupply).div(10**18);\n    }\n\n    // TODO: Test this\n    function _getExchangeRatePerToken(address _assetToken) internal view override returns (uint256) {\n        address cToken = assetToCToken[_assetToken];\n        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateStored();\n        uint256 assetDecimals = IERC20(_assetToken).universalDecimals();\n        // cTokens always have 8 decimals.\n        if (assetDecimals < 8) {\n            uint256 mantissa = 8 - assetDecimals;\n            return exchangeRateCurrent.mul(10**mantissa);\n        } else {\n            uint256 mantissa = assetDecimals - 8;\n            return exchangeRateCurrent.div(10**mantissa);\n        }\n    }\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('redeemUnderlying(uint256)', _numTokensToSupply);\n\n        return (assetToCToken[_assetToken], 0, methodData);\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (assetToCToken[_assetToken] == cETH) {\n            methodData = abi.encodeWithSignature('mint()');\n        } else {\n            methodData = abi.encodeWithSignature('mint(uint256)', _numTokensToSupply);\n        }\n        // If it is ETH, send the value\n        return (assetToCToken[_assetToken], assetToCToken[_assetToken] == cETH ? _numTokensToSupply : 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (CompoundComptrollerAddress, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getSpender(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n}\n"
    },
    "contracts/integrations/lend/LendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title LendIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract LendIntegration is BaseIntegration, ReentrancyGuard, ILendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address assetToken;\n        address investment; // Investment address\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event TokensSupplied(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToSupply\n    );\n\n    event TokensRedeemed(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToRedeem,\n        uint256 protocolFee\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n    function getInvestmentToken(address _assetToken) external view override returns (address) {\n        return _getInvestmentToken(_assetToken);\n    }\n\n    /**\n     * Checks whether an investment address is valid\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return bool                              True if the address is a investment\n     */\n    function isInvestment(address _investmentAddress) external view returns (bool) {\n        return _isInvestment(_investmentAddress);\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken)\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToSupply,\n                _minAmountExpected\n            );\n\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToSupply, 0);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        // not needed for eth\n        if (_assetToken != address(0)) {\n            investmentInfo.strategy.invokeApprove(_getSpender(_assetToken), _assetToken, _numTokensToSupply);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getSupplyCalldata(_strategy, _assetToken, _numTokensToSupply);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToSupply\n        );\n    }\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToRedeem,\n                _minAmountExpected\n            );\n\n        _validatePreExitInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToRedeem, 1);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getRedeemCalldata(_strategy, _assetToken, _numTokensToRedeem);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToRedeem\n        );\n    }\n\n    function getExchangeRatePerToken(address _assetToken) external view override returns (uint256) {\n        return _getExchangeRatePerToken(_assetToken);\n    }\n\n    /**\n     * Gets the amount of cTokens expected to get after depositing ERC20 asset.\n     *\n     * @param _numTokensToSupply                 Amount of ERC20 tokens to supply\n     * @return uint256                           Amount of supply tokens to receive\n     */\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_assetToken, _numTokensToSupply);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        uint256 balance =\n            _investmentInfo.assetToken == address(0)\n                ? address(_investmentInfo.strategy).balance\n                : IERC20(_investmentInfo.assetToken).balanceOf(address(_investmentInfo.strategy));\n        require(\n            balance >= _investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction,\n            'The garden did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    function _isInvestment(\n        address //_investmentAddress\n    ) internal view virtual returns (bool);\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _assetToken,\n        address _investmentToken,\n        uint256 _investmentTokensInTransaction,\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.assetToken = _assetToken;\n        investmentInfo.investment = _investmentToken;\n        investmentInfo.investmentTokensInGarden = getInvestmentTokenAmount(_strategy, _assetToken);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    function _getExpectedShares(address, uint256) internal view virtual returns (uint256);\n\n    function _getExchangeRatePerToken(address) internal view virtual returns (uint256);\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * hparam  _strategy                Address of the strat\n     * hparam  _assetToken              Address of the token\n     * hparam  _numTokensToSupply       Number of tokens\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getInvestmentToken(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/strategies/operations/AddLiquidityOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport 'hardhat/console.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title AddLiquidityOperation\n * @author Babylon Finance\n *\n * Executes a add liquidity operation\n */\ncontract AddLiquidityOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the add liquidity operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        address _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(IPoolIntegration(_integration).isPool(_data), 'Not a valid pool');\n    }\n\n    /**\n     * Executes the add liquidity operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _pool               Address of the pool to enter\n     * @param _garden             Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        address _pool,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_pool);\n        uint256[] memory _maxAmountsIn = new uint256[](poolTokens.length);\n        uint256[] memory _poolWeights = IPoolIntegration(_integration).getPoolWeights(_pool);\n        // Get the tokens needed to enter the pool\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            _maxAmountsIn[i] = _getMaxAmountTokenPool(_asset, _capital, _garden, _poolWeights[i], poolTokens[i]);\n        }\n        uint256 poolTokensOut = IPoolIntegration(_integration).getPoolTokensOut(_pool, poolTokens[0], _maxAmountsIn[0]);\n        IPoolIntegration(_integration).joinPool(\n            msg.sender,\n            _pool,\n            poolTokensOut.sub(poolTokensOut.preciseMul(SLIPPAGE_ALLOWED)),\n            poolTokens,\n            _maxAmountsIn\n        );\n        return (_pool, IERC20(_pool).balanceOf(msg.sender), 0); // liquid\n    }\n\n    /**\n     * Exits the add liquidity operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        address _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= 100e18, 'Unwind Percentage <= 100%');\n        address pool = _data;\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(pool);\n        uint256 lpTokens = IERC20(pool).balanceOf(msg.sender).preciseMul(_percentage); // Sell all pool tokens\n        uint256[] memory _minAmountsOut = IPoolIntegration(_integration).getPoolMinAmountsOut(pool, lpTokens);\n        IPoolIntegration(_integration).exitPool(\n            msg.sender,\n            pool,\n            lpTokens, // Sell all pool tokens\n            poolTokens,\n            _minAmountsOut\n        );\n        // Exit Pool tokens\n        address reserveAsset = _garden.reserveAsset();\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] != reserveAsset) {\n                if (poolTokens[i] == address(0)) {\n                    IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n                    poolTokens[i] = WETH;\n                }\n                if (poolTokens[i] != reserveAsset) {\n                    IStrategy(msg.sender).trade(\n                        poolTokens[i],\n                        IERC20(poolTokens[i]).balanceOf(msg.sender),\n                        reserveAsset\n                    );\n                }\n            }\n        }\n        return (_data, 0, 0);\n    }\n\n    /**\n     * Gets the NAV of the add liquidity op in the reserve asset\n     *\n     * @param _pool               Pool address\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        address _pool,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_pool);\n        uint256 NAV;\n        uint256 totalSupply = IERC20(_pool).totalSupply();\n        uint256 lpTokens = IERC20(_pool).balanceOf(msg.sender);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            uint256 price = _getPrice(_garden.reserveAsset(), poolTokens[i] != address(0) ? poolTokens[i] : WETH);\n            uint256 balance = poolTokens[i] != address(0) ? IERC20(poolTokens[i]).balanceOf(_pool) : _pool.balance;\n            NAV += balance.mul(lpTokens).div(totalSupply).preciseDiv(price);\n        }\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getMaxAmountTokenPool(\n        address _asset,\n        uint256 _capital,\n        IGarden, /* _garden */\n        uint256 _poolWeight,\n        address _poolToken\n    ) private returns (uint256) {\n        uint256 normalizedAssetAmount = _capital.preciseMul(_poolWeight);\n        uint256 price = _getPrice(_asset, _poolToken != address(0) ? _poolToken : WETH);\n        uint256 normalizedTokenAmount =\n            SafeDecimalMath.normalizeAmountTokens(_asset, _poolToken, normalizedAssetAmount.preciseMul(price));\n\n        if (_poolToken != _asset && _poolToken != address(0)) {\n            IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, _poolToken);\n            return IERC20(_poolToken).balanceOf(msg.sender);\n        }\n        if (_poolToken == address(0)) {\n            if (_asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, WETH); // normalized amount in original asset decimals\n            }\n            // Convert WETH to ETH\n            // We consider the slippage in the trade\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(WETH).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(WETH).balanceOf(msg.sender);\n            IStrategy(msg.sender).handleWeth(false, normalizedTokenAmount); // normalized WETH/ETH amount with 18 decimals\n        }\n        return normalizedTokenAmount;\n    }\n}\n"
    },
    "contracts/mocks/RewardsDistributorV2Mock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport 'hardhat/console.sol';\nimport {TimeLockedToken} from '../token/TimeLockedToken.sol';\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards of the BABL Mining Program\n * along the time reserved for executed strategies. It implements a supply curve to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared to the whole protocol usage.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses to specific profiles\n * which are actively contributing to the protocol growth and their communities (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributorV2Mock is OwnableUpgradeable {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n    using Safe3296 for uint256;\n    using Safe3296 for int256;\n    using Safe3296 for uint96;\n    using Safe3296 for uint32;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 public constant Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 public constant DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 public constant EPOCH_DURATION = 90 days;\n\n    // solhint-disable-next-line\n    uint256 public START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 private BABL_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 private BABL_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 private BABL_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_STRATEGIST_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_STEWARD_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_LP_SHARE;\n    // solhint-disable-next-line\n    uint256 private PROFIT_PROTOCOL_FEE;\n    // solhint-disable-next-line\n    uint256 private CREATOR_BONUS;\n\n    // DAI normalize asset\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Reentrancy guard countermeasure\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        // Protocol allocation checkpoints per timestamp along the time\n        uint256 principal; // Protocol principal allocation in normalized asset (DAI)\n        uint256 time; // Time of the checkpoint\n        uint256 quarterBelonging; // # Quarter checkpoint belonging since START_TIME\n        uint256 timeListPointer; // Pointer to the array of timestamps to enable the possibility of struct iteration\n        uint256 power; // Protocol power checkpoint (power is proportional to = principal * duration)\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // Checkpoint to keep track on accumulated protocol principal per quarter in normalized asset (DAI)\n        uint256 quarterNumber; // # Quarter since START_TIME\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // Supply per quarter\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 supply; // Checkpoint to keep track on garden supply\n        uint256 timestamp; // Checkpoint timestamps\n        uint256 power; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // Array of timestamps for each user in each garden\n        uint256 pid; // Garden contributor checkpoints counter to enable iteration\n        mapping(uint256 => TimestampContribution) tsContributions; // Sub-mapping all the contributor checkpoints\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 supply; // Garden token balance of user in each garden along the time\n        uint256 timestamp; // Checkpoint time\n        uint256 timePointer; // Pointer\n        uint256 power; // Contributor power per checkpoint\n    }\n    struct Checkpoints {\n        // Checkpoints for contributor power calculations where a certain window (from -> to) is queried\n        uint256 fromDepositAt; // First contributor checkpoint within the provided window\n        uint256 lastDepositAt; // Last contributor checkpoint within the provided window\n        uint256 gardenFromDepositAt; // First contributor checkpoint within the provided window\n        uint256 gardenLastDepositAt; // Last garden checkpoint within the provided window\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController public controller;\n\n    // BABL Token contract\n    TimeLockedToken public babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal) in all strategy pools.\n    uint256 public protocolPrincipal;\n    mapping(uint256 => ProtocolPerTimestamp) public protocolPerTimestamp; // Mapping of all protocol checkpoints\n    uint256[] public timeList; // Array of all protocol checkpoints\n    uint256 public pid; // Initialization of the ID assigning timeListPointer to the checkpoint number\n\n    mapping(uint256 => ProtocolPerQuarter) public protocolPerQuarter; // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => bool) public isProtocolPerQuarter; // Check if the protocol per quarter data has been initialized\n\n    // Strategy overhead control. Only used if each strategy has power overhead due to changes overtime\n    mapping(address => mapping(uint256 => uint256)) public rewardsPowerOverhead; // Overhead control to enable high level accuracy calculations for strategy rewards\n    // Contributor power control\n    mapping(address => mapping(address => ContributorPerGarden)) public contributorPerGarden; // Enable high level accuracy calculations\n    mapping(address => mapping(address => Checkpoints)) private checkpoints;\n    // Garden power control\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) public gardenPowerByTimestamp;\n    mapping(address => uint256[]) public gardenTimelist;\n    mapping(address => uint256) public gardenPid;\n\n    struct StrategyPerQuarter {\n        // Acumulated strategy power per each quarter along the time\n        uint256 quarterPrincipal;\n        uint256 quarterNumber; // # Quarter since START_TIME\n        uint256 quarterPower; //  Accumulated strategy power for each quarter\n        bool initialized;\n    }\n    struct StrategyPricePerTokenUnit {\n        // Take control over the price per token changes along the time when normalizing into DAI\n        uint256 preallocated; // Strategy capital preallocated before each checkpoint\n        uint256 pricePerTokenUnit; // Last average price per allocated tokens per strategy normalized into DAI\n    }\n    mapping(address => mapping(uint256 => StrategyPerQuarter)) public strategyPerQuarter; // Acumulated strategy power per each quarter along the time\n    mapping(address => StrategyPricePerTokenUnit) public strategyPricePerTokenUnit; // Pro-rata oracle price allowing re-allocations and unwinding of any capital value\n\n    // Reentrancy guard countermeasure\n    uint256 private status;\n\n    /* ============ Constructor ============ */\n\n    function initialize(TimeLockedToken _bablToken, IBabController _controller) public {\n        OwnableUpgradeable.__Ownable_init();\n\n        _require(address(_bablToken) != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        babltoken = _bablToken;\n        controller = _controller;\n\n        (BABL_STRATEGIST_SHARE, BABL_STEWARD_SHARE, BABL_LP_SHARE, CREATOR_BONUS) = controller.getBABLSharing();\n        (PROFIT_STRATEGIST_SHARE, PROFIT_STEWARD_SHARE, PROFIT_LP_SHARE) = controller.getProfitSharing();\n        PROFIT_PROTOCOL_FEE = controller.protocolPerformanceFee();\n\n        status = NOT_ENTERED;\n    }\n\n    /* ============ External Functions ============ */\n\n    function newMethod() public view returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "contracts/IshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title IshtarGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists for Babylon Finance using an NFT\n */\ncontract IshtarGate is ERC721, IIshtarGate, Ownable {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event IshtarGateAwarded(address indexed _member, uint256 indexed _newItemId);\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission, uint256 _tokenId);\n    event GardenCreationPower(address indexed _member, bool _creation, uint256 _tokenId);\n    event GateURIUpdated(string indexed _newURI, string indexed _oldURI);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    // Address of the Ishtar Gate JSON (Shared JSON)\n    string public override tokenURI;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => uint256) public gardenAccessCount;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == address(controller), 'Controller must match');\n        require(msg.sender == garden.creator(), 'Only creator can give access to garden');\n        require(IBabController(controller).isSystemContract(address(_garden)));\n        require(IBabController(controller).isGarden(address(_garden)));\n        require(gardenAccessCount[_garden] <= maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _tokenURI           URL of the Ishtar Gate JSON metadata\n     */\n    constructor(IBabController _controller, string memory _tokenURI) ERC721('IshtarGate', 'ISHT') {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n        tokenURI = _tokenURI;\n        maxNumberOfInvites = 10;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Updates the token URI of the gate NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateGardenURI(string memory _tokenURI) external override onlyOwner {\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit GateURIUpdated(tokenURI, oldURI);\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override onlyGardenCreator(_garden) returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= JUST_LP || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STEWARD || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STRATEGIST || IGarden(_garden).creator() == _user);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new gate to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetGateNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit IshtarGateAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        require(_permission <= 3, 'Permission out of bounds');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            require(gardenAccessCount[_garden] < maxNumberOfInvites, 'Max Number of invites reached');\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        emit GardenAccess(_user, _garden, _permission, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate, newItemId);\n        return newItemId;\n    }\n}\n"
    },
    "contracts/gardens/Garden.sol": {
      "content": "/*\n Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IIshtarGate} from '../interfaces/IIshtarGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\n\n/**\n * @title BaseGarden\n * @author Babylon Finance\n *\n * Class that holds common garden-related state and functions\n */\ncontract Garden is ERC20Upgradeable, ReentrancyGuard, IGarden {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event GardenDeposit(address indexed _to, uint256 reserveToken, uint256 reserveTokenQuantity, uint256 timestamp);\n    event GardenWithdrawal(\n        address indexed _from,\n        address indexed _to,\n        uint256 reserveToken,\n        uint256 reserveTokenQuantity,\n        uint256 timestamp\n    );\n    event AddStrategy(address indexed _strategy, string _name, uint256 _expectedReturn);\n\n    event RewardsForContributor(address indexed _contributor, uint256 indexed _amount);\n    event BABLRewardsForContributor(address indexed _contributor, uint256 _rewards);\n\n    /* ============ State Constants ============ */\n\n    // Wrapped ETH address\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint256 private constant EARLY_WITHDRAWAL_PENALTY = 5e16;\n    uint256 private constant MAX_TOTAL_STRATEGIES = 20; // Max number of strategies\n    uint256 private constant TEN_PERCENT = 1e17;\n    // Window of time after an investment strategy finishes when the capital is available for withdrawals\n    uint256 private constant withdrawalWindowAfterStrategyCompletes = 7 days;\n\n    /* ============ Structs ============ */\n\n    struct Contributor {\n        uint256 lastDepositAt;\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        uint256 claimedBABL;\n        uint256 claimedRewards;\n        uint256 withdrawnSince;\n        uint256 totalDeposits;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address public override reserveAsset;\n\n    // Address of the controller\n    address public override controller;\n\n    // Address of the rewards distributor\n    IRewardsDistributor private rewardsDistributor;\n\n    // The person that creates the garden\n    address public override creator;\n    // Whether the garden is currently active or not\n    bool public override active;\n    bool public override guestListEnabled;\n\n    // Keeps track of the reserve balance. In case we receive some through other means\n    uint256 public override principal;\n    uint256 public override reserveAssetRewardsSetAside;\n    uint256 public override reserveAssetPrincipalWindow;\n    int256 public override absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 public override minLiquidityAsset;\n\n    uint256 public override depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    uint256 public override withdrawalsOpenUntil; // Indicates until when the withdrawals are open and the ETH is set aside\n\n    // Contributors\n    mapping(address => Contributor) private contributors;\n    uint256 public override totalContributors;\n    uint256 public override maxContributors;\n    uint256 public override maxDepositLimit; // Limits the amount of deposits\n\n    uint256 public override gardenInitializedAt; // Garden Initialized at timestamp\n    // Number of garden checkpoints used to control de garden power and each contributor power with accuracy avoiding flash loans and related attack vectors\n    uint256 private pid;\n\n    // Min contribution in the garden\n    uint256 public override minContribution; //wei\n    uint256 private minGardenTokenSupply; // DEPRECATED\n\n    // Strategies variables\n    uint256 public override totalStake;\n    uint256 public override minVotesQuorum = TEN_PERCENT; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 public override minVoters;\n    uint256 public override minStrategyDuration; // Min duration for an strategy\n    uint256 public override maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 public override strategyCooldownPeriod;\n\n    address[] private strategies; // Strategies that are either in candidate or active state\n    address[] private finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) public override strategyMapping;\n    mapping(address => bool) public override isGardenStrategy; // Security control mapping\n\n    // Keeper debt in reserve asset if any, repaid upon every strategy finalization\n    uint256 public keeperDebt;\n\n    /* ============ Modifiers ============ */\n\n    function _onlyContributor() private view {\n        _onlyUnpaused();\n        _require(balanceOf(msg.sender) > 0, Errors.ONLY_CONTRIBUTOR);\n    }\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Throws if the sender is not an strategy of this garden\n     */\n    function _onlyStrategy() private view {\n        _onlyUnpaused();\n        _require(strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n    }\n\n    /**\n     * Throws if the garden is not active\n     */\n    function _onlyActive() private view {\n        _onlyUnpaused();\n        _require(active, Errors.ONLY_ACTIVE);\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * When a new Garden is created.\n     * All parameter validations are on the BabController contract. Validations are performed already on the\n     * BabController.\n     * WARN: If the reserve Asset is different than WETH the gardener needs to have approved the controller.\n     *\n     * @param _reserveAsset           Address of the reserve asset ERC20\n     * @param _controller             Address of the controller\n     * @param _creator                Address of the creator\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _gardenParams           Array of numeric garden params\n     * @param _initialContribution    Initial Contribution by the Gardener\n     */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) public payable override initializer {\n        _require(bytes(_name).length < 50, Errors.NAME_TOO_LONG);\n        _require(\n            _creator != address(0) && _controller != address(0) && ERC20Upgradeable(_reserveAsset).decimals() > 0,\n            Errors.ADDRESS_IS_ZERO\n        );\n        _require(_gardenParams.length == 9, Errors.GARDEN_PARAMS_LENGTH);\n        _require(IBabController(_controller).isValidReserveAsset(_reserveAsset), Errors.MUST_BE_RESERVE_ASSET);\n        __ERC20_init(_name, _symbol);\n\n        controller = _controller;\n        reserveAsset = _reserveAsset;\n        creator = _creator;\n        maxContributors = IBabController(_controller).maxContributorsPerGarden();\n        rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        _require(address(rewardsDistributor) != address(0), Errors.ADDRESS_IS_ZERO);\n        guestListEnabled = true;\n\n        _start(\n            _initialContribution,\n            _gardenParams[0],\n            _gardenParams[1],\n            _gardenParams[2],\n            _gardenParams[3],\n            _gardenParams[4],\n            _gardenParams[5],\n            _gardenParams[6],\n            _gardenParams[7],\n            _gardenParams[8]\n        );\n        active = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * FUND LEAD ONLY.  Starts the Garden with allowed reserve assets,\n     * fees and issuance premium. Only callable by the Garden's creator\n     *\n     * @param _creatorDeposit                       Deposit by the creator\n     * @param _maxDepositLimit                      Max deposit limit\n     * @param _minLiquidityAsset                    Number that represents min amount of liquidity denominated in ETH\n     * @param _depositHardlock                      Number that represents the time deposits are locked for an user after he deposits\n     * @param _minContribution                      Min contribution to the garden\n     * @param _strategyCooldownPeriod               How long after the strategy has been activated, will it be ready to be executed\n     * @param _minVotesQuorum                       Percentage of votes needed to activate an strategy (0.01% = 1e14, 1% = 1e16)\n     * @param _minStrategyDuration                  Min duration of an strategy\n     * @param _maxStrategyDuration                  Max duration of an strategy\n     * @param _minVoters                            The minimum amount of voters needed for quorum\n     */\n    function _start(\n        uint256 _creatorDeposit,\n        uint256 _maxDepositLimit,\n        uint256 _minLiquidityAsset,\n        uint256 _depositHardlock,\n        uint256 _minContribution,\n        uint256 _strategyCooldownPeriod,\n        uint256 _minVotesQuorum,\n        uint256 _minStrategyDuration,\n        uint256 _maxStrategyDuration,\n        uint256 _minVoters\n    ) private {\n        _require(_minContribution > 0 && _creatorDeposit >= _minContribution, Errors.MIN_CONTRIBUTION);\n        _require(\n            _minLiquidityAsset >= IBabController(controller).minLiquidityPerReserve(reserveAsset),\n            Errors.MIN_LIQUIDITY\n        );\n        _require(\n            _creatorDeposit <= _maxDepositLimit && _maxDepositLimit <= (reserveAsset == WETH ? 1e22 : 1e25),\n            Errors.MAX_DEPOSIT_LIMIT\n        );\n        _require(_depositHardlock > 0, Errors.DEPOSIT_HARDLOCK);\n        _require(\n            _strategyCooldownPeriod <= IBabController(controller).getMaxCooldownPeriod() &&\n                _strategyCooldownPeriod >= IBabController(controller).getMinCooldownPeriod(),\n            Errors.NOT_IN_RANGE\n        );\n        _require(_minVotesQuorum >= TEN_PERCENT && _minVotesQuorum <= TEN_PERCENT.mul(5), Errors.VALUE_TOO_LOW);\n        _require(\n            _maxStrategyDuration >= _minStrategyDuration &&\n                _minStrategyDuration >= 1 days &&\n                _maxStrategyDuration <= 500 days,\n            Errors.DURATION_RANGE\n        );\n        _require(_minVoters >= 1 && _minVoters < 10, Errors.MIN_VOTERS_CHECK);\n        minContribution = _minContribution;\n        strategyCooldownPeriod = _strategyCooldownPeriod;\n        minVotesQuorum = _minVotesQuorum;\n        minVoters = _minVoters;\n        minStrategyDuration = _minStrategyDuration;\n        maxStrategyDuration = _maxStrategyDuration;\n        maxDepositLimit = _maxDepositLimit;\n        gardenInitializedAt = block.timestamp;\n        minLiquidityAsset = _minLiquidityAsset;\n        depositHardlock = _depositHardlock;\n    }\n\n    /**\n     * Deposits the reserve asset into the garden and mints the Garden token of the given quantity\n     * to the specified _to address.\n     * WARN: If the reserve Asset is different than WETH the sender needs to have approved the garden.\n     *\n     * @param _reserveAssetQuantity  Quantity of the reserve asset that are received\n     * @param _minGardenTokenReceiveQuantity   Min quantity of Garden token to receive after issuance\n     * @param _to                   Address to mint Garden tokens to\n     * @param _mintNft              Whether to mint NFT or not\n     */\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to,\n        bool _mintNft\n    ) external payable override nonReentrant {\n        _onlyActive();\n        _require(\n            !guestListEnabled ||\n                IIshtarGate(IBabController(controller).ishtarGate()).canJoinAGarden(address(this), msg.sender) ||\n                creator == _to,\n            Errors.USER_CANNOT_JOIN\n        );\n        // if deposit limit is 0, then there is no deposit limit\n        if (maxDepositLimit > 0) {\n            _require(principal.add(_reserveAssetQuantity) <= maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);\n        }\n\n        _require(totalContributors <= maxContributors, Errors.MAX_CONTRIBUTORS);\n        _require(_reserveAssetQuantity >= minContribution, Errors.MIN_CONTRIBUTION);\n\n        // If reserve asset is WETH wrap it\n        uint256 reserveAssetBalance = IERC20(reserveAsset).balanceOf(address(this));\n\n        if (reserveAsset == WETH && msg.value > 0) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            // Transfer ERC20 to the garden\n            IERC20(reserveAsset).safeTransferFrom(msg.sender, address(this), _reserveAssetQuantity);\n        }\n        // Make sure we received the reserve asset\n        _require(\n            IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetBalance) == _reserveAssetQuantity,\n            Errors.MSG_VALUE_DO_NOT_MATCH\n        );\n\n        // gardenTokenQuantity has to be at least _minGardenTokenReceiveQuantity\n        _require(_reserveAssetQuantity >= _minGardenTokenReceiveQuantity, Errors.RECEIVE_MIN_AMOUNT);\n\n        uint256 previousBalance = balanceOf(_to);\n\n        _mint(_to, getGardenTokenMintQuantity(_reserveAssetQuantity, true));\n        _updateContributorDepositInfo(_to, previousBalance, _reserveAssetQuantity);\n        principal = principal.add(_reserveAssetQuantity);\n\n        // Mint the garden NFT\n        if (_mintNft) {\n            IGardenNFT(IBabController(controller).gardenNFT()).grantGardenNFT(_to);\n        }\n\n        emit GardenDeposit(_to, msg.value, _reserveAssetQuantity, block.timestamp);\n    }\n\n    /**\n     * Withdraws the ETH relative to the token participation in the garden and sends it back to the sender.\n     * ATTENTION. Do not call withPenalty unless certain. If penalty is set, it will be applied regardless of the garden state.\n     * It is advised to first try to withdraw with no penalty and it this reverts then try to with penalty.\n     *\n     * @param _gardenTokenQuantity           Quantity of the garden token to withdrawal\n     * @param _minReserveReceiveQuantity     Min quantity of reserve asset to receive\n     * @param _to                            Address to send component assets to\n     * @param _withPenalty                   Whether or not this is an immediate withdrawal\n     * @param _unwindStrategy                Strategy to unwind\n     */\n    function withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external override nonReentrant {\n        _onlyContributor();\n        // Flashloan protection\n        _require(\n            block.timestamp.sub(contributors[msg.sender].lastDepositAt) >= depositHardlock,\n            Errors.DEPOSIT_HARDLOCK\n        );\n        // Withdrawal amount has to be equal or less than msg.sender balance minus the locked balance\n        uint256 lockedAmount = getLockedBalance(msg.sender);\n        _require(_gardenTokenQuantity <= balanceOf(msg.sender).sub(lockedAmount), Errors.TOKENS_STAKED); // Strategists cannot withdraw locked stake while in active strategies\n\n        uint256 outflow = _getWithdrawalReserveQuantity(reserveAsset, _gardenTokenQuantity);\n\n        // if withPenaltiy then unwind strategy\n        if (_withPenalty) {\n            outflow = outflow.sub(outflow.preciseMul(EARLY_WITHDRAWAL_PENALTY));\n            // When unwinding a strategy, a slippage on integrations will result in receiving less tokens\n            // than desired so we have have to account for this with a 5% slippage.\n            IStrategy(_unwindStrategy).unwindStrategy(outflow.add(outflow.preciseMul(5e16)));\n        }\n\n        _require(outflow >= _minReserveReceiveQuantity, Errors.RECEIVE_MIN_AMOUNT);\n\n        _require(_canWithdrawReserveAmount(msg.sender, outflow), Errors.MIN_LIQUIDITY);\n\n        _reenableReserveForStrategies();\n\n        _burn(msg.sender, _gardenTokenQuantity);\n        _safeSendReserveAsset(msg.sender, outflow);\n        _updateContributorWithdrawalInfo(outflow);\n\n        // Required withdrawable quantity is greater than existing collateral\n        _require(principal >= outflow, Errors.BALANCE_TOO_LOW);\n        principal = principal.sub(outflow);\n\n        emit GardenWithdrawal(msg.sender, _to, outflow, _gardenTokenQuantity, block.timestamp);\n    }\n\n    /**\n     * User can claim the rewards from the strategies that his principal\n     * was invested in.\n     */\n    function claimReturns(address[] calldata _finalizedStrategies) external override nonReentrant {\n        _onlyContributor();\n        Contributor storage contributor = contributors[msg.sender];\n        _require(block.timestamp > contributor.claimedAt, Errors.ALREADY_CLAIMED); // race condition check\n        uint256[] memory rewards = new uint256[](7);\n\n        rewards = rewardsDistributor.getRewards(address(this), msg.sender, _finalizedStrategies);\n        _require(rewards[5] > 0 || rewards[6] > 0, Errors.NO_REWARDS_TO_CLAIM);\n\n        if (rewards[6] > 0) {\n            contributor.claimedRewards = contributor.claimedRewards.add(rewards[6]); // Rewards claimed properly\n            reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.sub(rewards[6]);\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n            _safeSendReserveAsset(msg.sender, rewards[6]);\n            emit RewardsForContributor(msg.sender, rewards[6]);\n        }\n        if (rewards[5] > 0) {\n            contributor.claimedBABL = contributor.claimedBABL.add(rewards[5]); // BABL Rewards claimed properly\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n            // Send BABL rewards\n            rewardsDistributor.sendTokensToContributor(msg.sender, rewards[5]);\n            emit BABLRewardsForContributor(msg.sender, rewards[5]);\n        }\n    }\n\n    /**\n     * When an strategy finishes execution, we want to make that eth available for withdrawals\n     * from members of the garden.\n     *\n     * @param _amount                        Amount of Reserve Asset to set aside until the window ends\n     * @param _rewards                       Amount of Reserve Asset to set aside forever\n     * @param _returns                       Profits or losses that the strategy received\n     */\n    function startWithdrawalWindow(\n        uint256 _amount,\n        uint256 _rewards,\n        int256 _returns,\n        address _strategy\n    ) external override {\n        _onlyUnpaused();\n        _require(\n            (strategyMapping[msg.sender] && address(IStrategy(msg.sender).garden()) == address(this)),\n            Errors.ONLY_STRATEGY\n        );\n        // Updates reserve asset\n        if (withdrawalsOpenUntil > block.timestamp) {\n            withdrawalsOpenUntil = block.timestamp.add(\n                withdrawalWindowAfterStrategyCompletes.sub(withdrawalsOpenUntil.sub(block.timestamp))\n            );\n        } else {\n            withdrawalsOpenUntil = block.timestamp.add(withdrawalWindowAfterStrategyCompletes);\n        }\n        reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.add(_rewards);\n        reserveAssetPrincipalWindow = reserveAssetPrincipalWindow.add(_amount);\n        // Mark strategy as finalized\n        absoluteReturns = absoluteReturns.add(_returns);\n        strategies = strategies.remove(_strategy);\n        finalizedStrategies.push(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /**\n     * Pays gas costs back to the keeper from executing transactions including the past debt\n     * @param _keeper             Keeper that executed the transaction\n     * @param _fee                The fee paid to keeper to compensate the gas cost\n     */\n    function payKeeper(address payable _keeper, uint256 _fee) external override {\n        _require(IBabController(controller).isValidKeeper(_keeper), Errors.ONLY_KEEPER);\n        _onlyStrategy();\n        keeperDebt = keeperDebt.add(_fee);\n        // Pay Keeper in Reserve Asset\n        if (keeperDebt > 0 && _liquidReserve() >= keeperDebt) {\n            IERC20(reserveAsset).safeTransfer(_keeper, keeperDebt);\n            keeperDebt = 0;\n        }\n    }\n\n    /**\n     * Makes a previously private garden public\n     */\n    function makeGardenPublic() external override {\n        _require(msg.sender == creator, Errors.ONLY_CREATOR);\n        _require(guestListEnabled && IBabController(controller).allowPublicGardens(), Errors.GARDEN_ALREADY_PUBLIC);\n        guestListEnabled = false;\n    }\n\n    /**\n     * PRIVILEGED Manager, protocol FUNCTION. When a Garden is active, deposits are enabled.\n     */\n    function setActive(bool _newValue) external override {\n        _require(msg.sender == controller, Errors.ONLY_CONTROLLER);\n        _require(active != _newValue, Errors.ONLY_INACTIVE);\n        active = _newValue;\n    }\n\n    /* ============ Strategy Functions ============ */\n    /**\n     * Creates a new strategy calling the factory and adds it to the array\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _stratParams                   Num params for the strategy\n     * @param _opTypes                      Type for every operation in the strategy\n     * @param _opIntegrations               Integration to use for every operation\n     * @param _opDatas                      Param for every operation in the strategy\n     */\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        address[] calldata _opDatas\n    ) external override {\n        _onlyActive();\n        _onlyContributor();\n        _require(\n            IIshtarGate(IBabController(controller).ishtarGate()).canAddStrategiesInAGarden(address(this), msg.sender),\n            Errors.USER_CANNOT_ADD_STRATEGIES\n        );\n        _require(strategies.length < MAX_TOTAL_STRATEGIES, Errors.VALUE_TOO_HIGH);\n        _require(_stratParams.length == 4, Errors.STRAT_PARAMS_LENGTH);\n        address strategy =\n            IStrategyFactory(IBabController(controller).strategyFactory()).createStrategy(\n                _name,\n                _symbol,\n                msg.sender,\n                address(this),\n                _stratParams\n            );\n        strategyMapping[strategy] = true;\n        totalStake = totalStake.add(_stratParams[1]);\n        strategies.push(strategy);\n        IStrategy(strategy).setData(_opTypes, _opIntegrations, _opDatas);\n        isGardenStrategy[strategy] = true;\n        emit AddStrategy(strategy, _name, _stratParams[3]);\n    }\n\n    /**\n     * Allocates garden capital to an strategy\n     *\n     * @param _capital        Amount of capital to allocate to the strategy\n     */\n    function allocateCapitalToStrategy(uint256 _capital) external override {\n        _onlyStrategy();\n        _onlyActive();\n        _reenableReserveForStrategies();\n\n        uint256 protocolMgmtFee = IBabController(controller).protocolManagementFee().preciseMul(_capital);\n        _require(_capital.add(protocolMgmtFee) <= _liquidReserve(), Errors.MIN_LIQUIDITY);\n\n        // Take protocol mgmt fee\n        _payProtocolFeeFromGarden(reserveAsset, protocolMgmtFee);\n\n        // Send Capital to strategy\n        IERC20(reserveAsset).safeTransfer(msg.sender, _capital);\n    }\n\n    /*\n     * Remove an expire candidate from the strategy Array\n     * @param _strategy      Strategy to remove\n     */\n    function expireCandidateStrategy(address _strategy) external override {\n        _onlyStrategy();\n        strategies = strategies.remove(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /*\n     * Burns the stake of the strategist of a given strategy\n     * @param _strategy      Strategy\n     */\n    function burnStrategistStake(address _strategist, uint256 _amount) external override {\n        _onlyStrategy();\n        if (_amount >= balanceOf(_strategist)) {\n            // Avoid underflow condition\n            _amount = balanceOf(_strategist);\n        }\n        _burn(_strategist, _amount);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets current strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getStrategies() external view override returns (address[] memory) {\n        return strategies;\n    }\n\n    /**\n     * Gets finalized strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getFinalizedStrategies() external view override returns (address[] memory) {\n        return finalizedStrategies;\n    }\n\n    function getContributor(address _contributor)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Contributor storage contributor = contributors[_contributor];\n        uint256 contributorPower =\n            rewardsDistributor.getContributorPower(\n                address(this),\n                _contributor,\n                contributor.initialDepositAt,\n                block.timestamp\n            );\n        uint256 balance = balanceOf(_contributor);\n        uint256 lockedBalance = getLockedBalance(_contributor);\n        return (\n            contributor.lastDepositAt,\n            contributor.initialDepositAt,\n            contributor.claimedAt,\n            contributor.claimedBABL,\n            contributor.claimedRewards,\n            contributor.totalDeposits > contributor.withdrawnSince\n                ? contributor.totalDeposits.sub(contributor.withdrawnSince)\n                : 0,\n            balance,\n            lockedBalance,\n            contributorPower\n        );\n    }\n\n    /**\n     * Get the expected reserve asset to be withdrawaled\n     *\n     * @param _gardenTokenQuantity             Quantity of Garden tokens to withdrawal\n     *\n     * @return  uint256                     Expected reserve asset quantity withdrawaled\n     */\n    function getExpectedReserveWithdrawalQuantity(uint256 _gardenTokenQuantity)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getWithdrawalReserveQuantity(reserveAsset, _gardenTokenQuantity);\n    }\n\n    /**\n     * Checks balance locked for strategists in active strategies\n     *\n     * @param _contributor                 Address of the account\n     *\n     * @return  uint256                    Returns the amount of locked garden tokens for the account\n     */\n    function getLockedBalance(address _contributor) public view override returns (uint256) {\n        uint256 lockedAmount;\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            if (_contributor == strategy.strategist()) {\n                lockedAmount = lockedAmount.add(strategy.stake());\n            }\n        }\n        // Avoid overflows if off-chain voting system fails\n        if (balanceOf(_contributor) < lockedAmount) lockedAmount = balanceOf(_contributor);\n        return lockedAmount;\n    }\n\n    function getGardenTokenMintQuantity(\n        uint256 _reserveAssetQuantity,\n        bool isDeposit // Value of reserve asset net of fees\n    ) public view override returns (uint256) {\n        // Get valuation of the Garden with the quote asset as the reserve asset.\n        // Reverts if price is not found\n        uint256 baseUnits = uint256(10)**ERC20Upgradeable(reserveAsset).decimals();\n        uint256 normalizedReserveQuantity = _reserveAssetQuantity.preciseDiv(baseUnits);\n        // First deposit\n        if (totalSupply() == 0) {\n            return normalizedReserveQuantity;\n        }\n        uint256 gardenValuationPerToken =\n            IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                reserveAsset\n            );\n        if (isDeposit) {\n            gardenValuationPerToken = gardenValuationPerToken.sub(normalizedReserveQuantity.preciseDiv(totalSupply()));\n        }\n        return normalizedReserveQuantity.preciseDiv(gardenValuationPerToken);\n    }\n\n    /* ============ Internal Functions ============ */\n    /**\n     * Gets liquid reserve available for to Garden.\n     */\n    function _liquidReserve() private view returns (uint256) {\n        return\n            IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetPrincipalWindow).sub(\n                reserveAssetRewardsSetAside\n            );\n    }\n\n    /**\n     * When the window of withdrawals finishes, we need to make the capital available again for investments\n     * We still keep the profits aside.\n     */\n    function _reenableReserveForStrategies() private {\n        if (block.timestamp >= withdrawalsOpenUntil) {\n            withdrawalsOpenUntil = 0;\n            reserveAssetPrincipalWindow = 0;\n        }\n    }\n\n    /**\n     * Check if the fund has reserve amount available for withdrawals.\n     * If it returns false, reserve pool would be available.\n     * @param _contributor                   Address of the contributors\n     * @param _amount                        Amount of ETH to withdraw\n     */\n    function _canWithdrawReserveAmount(address _contributor, uint256 _amount) private view returns (bool) {\n        // Reserve rewards cannot be withdrawn. Only claimed\n        uint256 liquidReserve = IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetRewardsSetAside);\n\n        // Withdrawal open\n        if (block.timestamp <= withdrawalsOpenUntil) {\n            // There is a window but there is more than needed\n            if (liquidReserve.sub(reserveAssetPrincipalWindow) > _amount) {\n                return true;\n            }\n            // Pro rata withdrawals\n            uint256 contributorPower =\n                rewardsDistributor.getContributorPower(\n                    address(this),\n                    _contributor,\n                    contributors[_contributor].initialDepositAt,\n                    block.timestamp\n                );\n            return\n                reserveAssetPrincipalWindow.preciseMul(contributorPower).add(\n                    liquidReserve.sub(reserveAssetPrincipalWindow)\n                ) >= _amount;\n        }\n        return liquidReserve.sub(reserveAssetPrincipalWindow) >= _amount;\n    }\n\n    /**\n     * Gets the total active capital currently invested in strategies\n     *\n     * @return uint256       Total amount active\n     * @return uint256       Total amount active in the largest strategy\n     * @return address       Address of the largest strategy\n     */\n    function _getActiveCapital()\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            address\n        )\n    {\n        uint256 totalActiveCapital;\n        uint256 maxAllocation;\n        address maxStrategy = address(0);\n        for (uint8 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            if (strategy.isStrategyActive()) {\n                uint256 allocation = strategy.capitalAllocated();\n                totalActiveCapital = totalActiveCapital.add(allocation);\n                if (allocation > maxAllocation) {\n                    maxAllocation = allocation;\n                    maxStrategy = strategies[i];\n                }\n            }\n        }\n        return (totalActiveCapital, maxAllocation, maxStrategy);\n    }\n\n    /**\n     * Pays the _feeQuantity from the _garden denominated in _token to the protocol fee recipient\n     * @param _token                   Address of the token to pay with\n     * @param _feeQuantity             Fee to transfer\n     */\n    function _payProtocolFeeFromGarden(address _token, uint256 _feeQuantity) private {\n        IERC20(_token).safeTransfer(IBabController(controller).treasury(), _feeQuantity);\n    }\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 _amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, _amount);\n        _require(\n            from == address(0) ||\n                to == address(0) ||\n                (IBabController(controller).gardenTokensTransfersEnabled() && !guestListEnabled),\n            Errors.GARDEN_TRANSFERS_DISABLED\n        );\n    }\n\n    function _safeSendReserveAsset(address payable _to, uint256 _amount) private {\n        if (reserveAsset == WETH) {\n            // Check that the withdrawal is possible\n            // Unwrap WETH if ETH balance lower than netFlowQuantity\n            if (address(this).balance < _amount) {\n                IWETH(WETH).withdraw(_amount.sub(address(this).balance));\n            }\n            // Send ETH\n            Address.sendValue(_to, _amount);\n        } else {\n            // Send reserve asset\n            IERC20(reserveAsset).safeTransfer(_to, _amount);\n        }\n    }\n\n    function _getWithdrawalReserveQuantity(address _reserveAsset, uint256 _gardenTokenQuantity)\n        private\n        view\n        returns (uint256)\n    {\n        // Get valuation of the Garden with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 gardenValuationPerToken =\n            IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                _reserveAsset\n            );\n\n        uint256 totalWithdrawalValueInPreciseUnits = _gardenTokenQuantity.preciseMul(gardenValuationPerToken);\n        return totalWithdrawalValueInPreciseUnits.preciseMul(10**ERC20Upgradeable(_reserveAsset).decimals());\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorDepositInfo(\n        address _contributor,\n        uint256 previousBalance,\n        uint256 _reserveAssetQuantity\n    ) private {\n        Contributor storage contributor = contributors[_contributor];\n        // If new contributor, create one, increment count, and set the current TS\n        if (previousBalance == 0 || contributor.initialDepositAt == 0) {\n            _require(totalContributors < maxContributors, Errors.MAX_CONTRIBUTORS);\n            totalContributors = totalContributors.add(1);\n            contributor.initialDepositAt = block.timestamp;\n        }\n        // We make checkpoints around contributor deposits to avoid fast loans and give the right rewards afterwards\n        contributor.totalDeposits = contributor.totalDeposits.add(_reserveAssetQuantity);\n        contributor.lastDepositAt = block.timestamp;\n        rewardsDistributor.updateGardenPowerAndContributor(address(this), _contributor, previousBalance, true, pid);\n        pid++;\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorWithdrawalInfo(uint256 _netflowQuantity) private {\n        Contributor storage contributor = contributors[msg.sender];\n        // If sold everything\n        if (balanceOf(msg.sender) == 0) {\n            contributor.lastDepositAt = 0;\n            contributor.initialDepositAt = 0;\n            contributor.withdrawnSince = 0;\n            contributor.totalDeposits = 0;\n            totalContributors = totalContributors.sub(1);\n        } else {\n            contributor.withdrawnSince = contributor.withdrawnSince.add(_netflowQuantity);\n        }\n        rewardsDistributor.updateGardenPowerAndContributor(address(this), msg.sender, 0, false, pid);\n        pid++;\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract GardenV3 is Garden {}\n"
    },
    "contracts/gardens/GardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n//\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Garden\n */\ncontract GardenNFT is ERC721, IGardenNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event GardenNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGarden {\n        require(\n            controller.isSystemContract(msg.sender) && IGarden(msg.sender).controller() == address(controller),\n            'Only the garden can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    Counters.Counter private _tokenIds;\n    mapping(address => string) public override gardenTokenURIs;\n    mapping(address => uint256) public override gardenSeeds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     */\n    function grantGardenNFT(address _user) external override onlyGarden returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, gardenTokenURIs[msg.sender]);\n        emit GardenNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the Garden URI and seed\n     *\n     * @param _garden               Address of the garden\n     * @param _gardenTokenURI     Garden Token URI\n     */\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        gardenTokenURIs[_garden] = _gardenTokenURI;\n        gardenSeeds[_garden] = _seed;\n    }\n}\n"
    },
    "contracts/integrations/borrow/AaveBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title AaveBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses aave borring/lending logic.\n */\ncontract AaveBorrowIntegration is BorrowIntegration {\n    using SafeERC20 for IERC20;\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n    uint256 constant interestRateMode = 1; // Stable Interest\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed (from 0 to a 100)\n     */\n    constructor(IBabController _controller, uint256 _maxCollateralFactor)\n        BorrowIntegration('aaveborrow', _controller, _maxCollateralFactor)\n    {}\n\n    /* ============ External Functions ============ */\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view override returns (uint256) {\n        (, uint256 stableDebt, , , , , , , ) = dataProvider.getUserReserveData(asset, _strategy);\n        return stableDebt;\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address _strategy,\n        address /* asset */\n    ) external view override returns (uint256) {\n        (\n            uint256 totalCollateral, // uint256 totalDebt, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n            ,\n            ,\n\n        ) =\n            // uint256 healthFactor\n            lendingPool.getUserAccountData(_strategy);\n        return totalCollateral;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        (\n            ,\n            ,\n            // uint256 totalCollateral,\n            // uint256 totalDebt,\n            uint256 borrowingPower, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n\n        ) =\n            // uint256 healthFactor\n            lendingPool.getUserAccountData(_strategy);\n        return borrowingPower;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * @param  _strategy                 Address of the strategy executing\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'borrow(address,uint256,uint256,uint16,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                0,\n                _strategy\n            );\n\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * @param  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'repay(address,uint256,uint256,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                _strategy\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getCollateralAsset(\n        address asset,\n        uint8 /* _borrowOp */\n    ) internal pure override returns (address) {\n        return asset;\n    }\n\n    function _getSpender(\n        address /* asset */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getDebtToken(address asset) internal view returns (address) {\n        // Get the relevant debt token address\n        (, address stableDebtTokenAddress, ) = dataProvider.getReserveTokensAddresses(asset);\n        return stableDebtTokenAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the gardens on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the gardens\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the gardens, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if gardens can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/interfaces/external/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/integrations/lend/AaveLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {AaveToken} from '../../interfaces/external/aave/AaveToken.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/external/aave/ILendingPoolAddressesProvider.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title AaveLendIntegration\n * @author Babylon Finance Protocol\n *\n * Aave lend integration.\n */\ncontract AaveLendIntegration is LendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Constant ============ */\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     */\n    constructor(IBabController _controller) LendIntegration('aavelend', _controller) {}\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        return IERC20(_getInvestmentToken(_assetToken)).balanceOf(_address);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress != address(0);\n    }\n\n    function _getExpectedShares(\n        address, /* _assetToken */\n        uint256 _numTokensToSupply\n    ) internal pure override returns (uint256) {\n        // love it \n        return _numTokensToSupply;\n    }\n\n    function _getExchangeRatePerToken(\n        address /* _assetToken */\n    ) internal pure override returns (uint256) {\n        // love it \n        return 1;\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(address,uint256,address,uint16)',\n                _assetToken,\n                _numTokensToSupply,\n                _strategy,\n                0\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Returns calldata for redeeming the collateral\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getRedeemCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('withdraw(address,uint256,address)', _assetToken, _numTokensToSupply, _strategy);\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getSpender(\n        address /* _investmentAddress */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/AaveToken.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n"
    },
    "contracts/BabylonViewer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGardenValuer} from './interfaces/IGardenValuer.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGardenNFT} from './interfaces/IGardenNFT.sol';\nimport {IStrategyNFT} from './interfaces/IStrategyNFT.sol';\nimport {Math} from './lib/Math.sol';\n\n/**\n * @title BabylonViewer\n * @author Babylon Finance\n *\n * Class that holds common view functions to retrieve garden information effectively\n */\ncontract BabylonViewer {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using Math for int256;\n\n    IBabController public controller;\n\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets garden details\n     *\n     * @param _garden            Address of the garden to fetch\n     * @return                   Garden complete details\n     */\n    function getGardenDetails(address _garden)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            address,\n            address,\n            bool[2] memory,\n            address[] memory,\n            address[] memory,\n            uint256[11] memory,\n            uint256[10] memory\n        )\n    {\n        IGarden garden = IGarden(_garden);\n        IGardenValuer valuer = IGardenValuer(controller.gardenValuer());\n        uint256 valuationPerToken = valuer.calculateGardenValuation(_garden, garden.reserveAsset());\n        uint256 totalSupply = IERC20(_garden).totalSupply();\n        uint256 seed = _getGardenSeed(_garden);\n\n        return (\n            ERC20(_garden).name(),\n            ERC20(_garden).symbol(),\n            garden.creator(),\n            garden.reserveAsset(),\n            [garden.active(), garden.guestListEnabled()],\n            garden.getStrategies(),\n            garden.getFinalizedStrategies(),\n            [\n                garden.depositHardlock(),\n                garden.withdrawalsOpenUntil(),\n                garden.minVotesQuorum(),\n                garden.maxContributors(),\n                garden.maxDepositLimit(),\n                garden.minVoters(),\n                garden.minStrategyDuration(),\n                garden.maxStrategyDuration(),\n                garden.strategyCooldownPeriod(),\n                garden.minContribution(),\n                garden.minLiquidityAsset()\n            ],\n            [\n                garden.principal(),\n                garden.reserveAssetRewardsSetAside(),\n                garden.reserveAssetPrincipalWindow(),\n                uint256(garden.absoluteReturns()),\n                garden.gardenInitializedAt(),\n                garden.totalContributors(),\n                garden.totalStake(),\n                totalSupply.preciseMul(valuationPerToken),\n                totalSupply,\n                seed\n            ]\n        );\n    }\n\n    /**\n     * Gets complete strategy details\n     *\n     * @param _strategy            Address of the strategy to fetch\n     * @return                     All strategy details\n     */\n    function getCompleteStrategy(address _strategy)\n        external\n        view\n        returns (\n            address,\n            string memory,\n            uint256[12] memory,\n            bool[] memory,\n            uint256[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        bool[] memory status = new bool[](3);\n        uint256[] memory ts = new uint256[](4);\n        (, status[0], status[1], status[2], ts[0], ts[1], ts[2]) = strategy.getStrategyState();\n        uint256 rewards =\n            strategy.exitedAt() != 0\n                ? IRewardsDistributor(controller.rewardsDistributor()).getStrategyRewards(_strategy)\n                : 0;\n        ts[3] = strategy.enteredCooldownAt();\n        return (\n            strategy.strategist(),\n            IStrategyNFT(controller.strategyNFT()).getStrategyName(_strategy),\n            [\n                strategy.getOperationsCount(),\n                strategy.stake(),\n                strategy.totalPositiveVotes(),\n                strategy.totalNegativeVotes(),\n                strategy.capitalAllocated(),\n                strategy.capitalReturned(),\n                strategy.duration(),\n                strategy.expectedReturn(),\n                strategy.maxCapitalRequested(),\n                strategy.enteredAt(),\n                strategy.getNAV(),\n                rewards\n            ],\n            status,\n            ts\n        );\n    }\n\n    function getOperationsStrategy(address _strategy)\n        public\n        view\n        returns (\n            uint8[] memory,\n            address[] memory,\n            address[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 count = strategy.getOperationsCount();\n        uint8[] memory types = new uint8[](count);\n        address[] memory integrations = new address[](count);\n        address[] memory datas = new address[](count);\n\n        for (uint8 i = 0; i < count; i++) {\n            (types[i], integrations[i], datas[i]) = strategy.getOperationByIndex(i);\n        }\n        return (types, integrations, datas);\n    }\n\n    function getPermissions(address _user) external view returns (bool, bool) {\n        IIshtarGate gate = IIshtarGate(controller.ishtarGate());\n        return (IERC721(address(gate)).balanceOf(_user) > 0, gate.canCreate(_user));\n    }\n\n    function getGardenPermissions(address _garden, address _user)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        IIshtarGate gate = IIshtarGate(controller.ishtarGate());\n        return (\n            gate.canJoinAGarden(_garden, _user),\n            gate.canVoteInAGarden(_garden, _user),\n            gate.canAddStrategiesInAGarden(_garden, _user)\n        );\n    }\n\n    function getGardensUser(address _user, uint256 _offset) external view returns (address[] memory, bool[] memory) {\n        address[] memory gardens = controller.getGardens();\n        address[] memory userGardens = new address[](25);\n        bool[] memory hasUserDeposited = new bool[](25);\n        uint8 resultIndex;\n        IIshtarGate gate = IIshtarGate(controller.ishtarGate());\n        for (uint256 i = _offset; i < gardens.length; i++) {\n            IGarden garden = IGarden(gardens[i]);\n            if (garden.active() && (!garden.guestListEnabled() || gate.canJoinAGarden(gardens[i], _user))) {\n                userGardens[resultIndex] = gardens[i];\n                hasUserDeposited[resultIndex] = IERC20(gardens[i]).balanceOf(_user) > 0;\n                resultIndex = resultIndex + 1;\n            }\n        }\n        return (userGardens, hasUserDeposited);\n    }\n\n    function getUserStrategyActions(address[] memory _strategies, address _user)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 strategiesCreated;\n        uint256 totalVotes;\n        for (uint8 i = 0; i < _strategies.length; i++) {\n            IStrategy strategy = IStrategy(_strategies[i]);\n            if (strategy.strategist() == _user) {\n                strategiesCreated = strategiesCreated.add(1);\n            }\n            int256 votes = strategy.getUserVotes(_user);\n            if (votes != 0) {\n                totalVotes = totalVotes.add(uint256(Math.abs(votes)));\n            }\n        }\n        return (strategiesCreated, totalVotes);\n    }\n\n    function getContributionAndRewards(address _garden, address _user)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        IGarden garden = IGarden(_garden);\n        uint256[] memory contribution = new uint256[](9);\n        (\n            contribution[0],\n            contribution[1],\n            contribution[2],\n            contribution[3],\n            contribution[4],\n            contribution[5],\n            ,\n            ,\n            contribution[8]\n        ) = garden.getContributor(_user);\n        contribution[6] = IERC20(_garden).balanceOf(_user);\n        contribution[7] = garden.getLockedBalance(_user);\n        uint256[] memory totalRewards =\n            IRewardsDistributor(controller.rewardsDistributor()).getRewards(\n                _garden,\n                _user,\n                garden.getFinalizedStrategies()\n            );\n        return (contribution, totalRewards);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getGardenSeed(address _garden) private view returns (uint256) {\n        return IGardenNFT(controller.gardenNFT()).gardenSeeds(_garden);\n    }\n}\n"
    },
    "contracts/gardens/GardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to create garden contracts\n */\ncontract GardenFactory is IGardenFactory {\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a garden using minimal proxies\n     * @param _reserveAsset           Address of the reserve asset ERC20\n     * @param _creator                Address of the creator\n     * @param _name                   Name of the Garden\n     * @param _symbol                 Symbol of the Garden\n     * @param _tokenURI               URL of the garden NFT JSON\n     * @param _seed                   Seed to regenerate the garden NFT\n     * @param _gardenParams           Array of numeric params in the garden\n     * @param _initialContribution    Initial Contribution by the Gardener\n     */\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution\n    ) external override returns (address) {\n        require(msg.sender == address(controller), 'Only the controller can create gardens');\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IGarden.initialize.selector,\n                        _reserveAsset,\n                        controller,\n                        _creator,\n                        _name,\n                        _symbol,\n                        _gardenParams,\n                        _initialContribution\n                    )\n                )\n            );\n        IGardenNFT(controller.gardenNFT()).saveGardenURIAndSeed(proxy, _tokenURI, _seed);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "contracts/GardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title GardenValuer\n * @author Babylon Finance\n *\n * Contract that returns the valuation of a Garden using price oracle data used in contracts\n * that are external to the system.\n *\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract GardenValuer {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    address public controller;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _controller             Address of controller contract\n     */\n    constructor(address _controller) {\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Gets the valuation of a Garden using data from the price oracle.\n     * Adds all the active strategies plus the reserve asset and ETH.\n     * Note: this works for external\n     * positions and negative (debt) positions.\n     *\n     * Note: There is a risk that the valuation is off if airdrops aren't retrieved\n     *\n     * @param _garden               Garden instance to get valuation\n     * @param _quoteAsset           Quote asset for the valuation\n     *\n     * @return                 Token valuation in terms of quote asset in precise units 1e18\n     */\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256) {\n        IPriceOracle priceOracle = IPriceOracle(IBabController(controller).priceOracle());\n        address reserveAsset = IGarden(_garden).reserveAsset();\n\n        // uint8 reserveAssetDecimals = ERC20(reserveAsset).decimals();\n        uint8 quoteAssetDecimals = ERC20(_quoteAsset).decimals();\n\n        uint256 reservePrice;\n        // Get price of the reserveAsset in _quoteAsset\n        if (reserveAsset == _quoteAsset) {\n            // meaning 1 reserveAsset equals to 1 _quoteAsset\n            reservePrice = 1 ether;\n        } else {\n            reservePrice = priceOracle.getPrice(reserveAsset, _quoteAsset);\n        }\n\n        uint256 wethPrice;\n        // Get price of the WETH in _quoteAsset\n        if (_quoteAsset == WETH) {\n            // meaning 1 WETH equals to 1 _quoteAsset\n            // this line looks ironic. 10/10.\n            wethPrice = 1 ether;\n        } else {\n            wethPrice = priceOracle.getPrice(WETH, _quoteAsset);\n        }\n\n        address[] memory strategies = IGarden(_garden).getStrategies();\n        uint256 valuation;\n        for (uint256 j = 0; j < strategies.length; j++) {\n            IStrategy strategy = IStrategy(strategies[j]);\n            // strategies return their valuation in garden's reserveAsset\n            valuation = valuation.add(strategy.getNAV());\n        }\n\n        // Add garden reserve assets and garden's reserve asset\n        valuation = valuation.add(ERC20(reserveAsset).balanceOf(address(_garden)));\n\n        // Get the valuation in terms of the quote asset\n        valuation = valuation.preciseMul(reservePrice);\n\n        // Adds ETH of garden in _quoteAsset prices\n        valuation = valuation.add(address(_garden).balance.preciseMul(wethPrice));\n\n        if (quoteAssetDecimals < 18) {\n            valuation = valuation.mul(10**(18 - quoteAssetDecimals));\n        }\n\n        return valuation.preciseDiv(ERC20(_garden).totalSupply());\n    }\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ITimelock} from '../interfaces/ITimelock.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\n\ncontract GovernorAlpha is Ownable {\n    /* ============ Events ============ */\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The name of this contract\n    string public constant name = 'BABL Governor Alpha';\n\n    /// @notice The address of the BABL Protocol Timelock\n    ITimelock public timelock;\n\n    /// @notice The address of the BABL governance token\n    IVoteToken public babl;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint256) {\n        return 40_000e18;\n    } // 4% of BABL\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint256) {\n        return 10_000e18;\n    } // 1% of BABL\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10;\n    } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint256) {\n        return 1;\n    } // 1 block TODO - CHECK DELAY TO PROPOSE\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint256) {\n        return 7 days;\n    } // TODO - CHECK AND AGREE ON THE VOTING PERIOD\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // @notice Unique id for looking up a proposal\n        uint256 id;\n        // @notice Creator of the proposal\n        address proposer;\n        // @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        // @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        // @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        // @notice The ordered list of function signatures to be called\n        string[] signatures;\n        // @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        // @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        // @notice Flag marking whether the proposal has been executed\n        bool executed;\n        // @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // @notice Whether or not a vote has been cast\n        bool hasVoted;\n        // @notice Whether or not the voter supports the proposal\n        bool support;\n        // @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,bool support)');\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a GovernorAlpha and gives ownership to sender\n     * @param timelock_ is the address of the timelock instance\n     * @param babl_ is the instance of the BABL Token instance\n     * @param guardian_ the Pause Guardian address capable of disabling protocol functionality. Used only in the event\n     * of an unforeseen vulnerability.\n     */\n\n    constructor(\n        address timelock_,\n        address babl_,\n        address guardian_\n    ) {\n        timelock = ITimelock(timelock_);\n        babl = IVoteToken(babl_);\n        guardian = guardian_;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to propose governance actions\n     *\n     * @notice Propose new governance actions. Depends on power voting capacity of idea proposer\n     * @param targets The array of addresses as destination targets\n     * @param values The array of values\n     * @param signatures The array of signatures\n     * @param calldatas The array of calldatas to be executed as part of the proposals\n     * @param description The description of the proposal\n     * @return The proposal id created if it was successfully created\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256) {\n        require(\n            babl.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(),\n            'GovernorAlpha::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'GovernorAlpha::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'GovernorAlpha::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations(), 'GovernorAlpha::propose: too many actions');\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'GovernorAlpha::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to queue a specific proposal\n     *\n     * @notice Allows to queue a specific proposal in state = Succeeded\n     * @param proposalId The ID of the proposal\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'GovernorAlpha::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to queue or revert a transaction part of a proposal within the timelock\n     *\n     * @notice Allows to queue or revert a transaction part of a proposal (not queued earlier) within the timelock\n     * @param target The addresses of the target\n     * @param value The uint values\n     * @param signature The signature\n     * @param data The data\n     * @param eta The timestamp of allowed execution\n     */\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'GovernorAlpha::_queueOrRevert: proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows to execute a queued (state = queued) proposal\n     *\n     * @notice Allows to queue or revert a transaction part of a proposal (not queued earlier) within the timelock\n     * @param proposalId The ID of the proposal\n     */\n    function execute(uint256 proposalId) external payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'GovernorAlpha::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: (proposal.values[i])}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the msg.sender to cast a vote\n     *\n     * @notice Allows the msg.sender to cast a vote\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     */\n    function castVote(uint256 proposalId, bool support) external {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the cast of a vote by signature\n     *\n     * @notice Allows the cast of a vote by signature\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'GovernorAlpha::castVoteBySig: invalid signature');\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to cancel a proposal if state != executed\n     *\n     * @notice Allows the Pause Guardian to cancel a proposal if state != executed\n     * @param proposalId The ID of the proposal\n     */\n    function cancel(uint256 proposalId) external {\n        ProposalState _state = state(proposalId);\n        require(_state != ProposalState.Executed, 'GovernorAlpha::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n        // A Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(\n            msg.sender == guardian ||\n                babl.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(),\n            'GovernorAlpha::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to execute acceptAdmin in the timelock instance\n     *\n     * @notice Allows the Pause Guardian to execute acceptAdmin in the timelock instance\n     */\n    function __acceptAdmin() external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__acceptAdmin: sender must be gov guardian');\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to abdicate as Guardian\n     *\n     * @notice Allows the Pause Guardian to abdicate as Guardian\n     */\n    function __abdicate() external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__abdicate: sender must be gov guardian');\n        guardian = address(0);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to queue a set of timelock pending admin\n     *\n     * @notice Allows the Pause Guardian to queue a set of timelock pending admin\n     */\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian');\n        timelock.queueTransaction(address(timelock), 0, 'setPendingAdmin(address)', abi.encode(newPendingAdmin), eta);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows the Pause Guardian to execute the set of timelock pending admin\n     *\n     * @notice Allows the Pause Guardian to execute the set of timelock pending admin\n     */\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) external {\n        // The Pause Guardian is capable of disabling protocol functionality. Used only in the event of an unforeseen vulnerability and just for specific operations.\n        require(msg.sender == guardian, 'GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian');\n        timelock.executeTransaction(address(timelock), 0, 'setPendingAdmin(address)', abi.encode(newPendingAdmin), eta);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to  check the list of actions of a proposal\n     *\n     * @notice Allows the caller to check the list of actions of a proposal\n     * @param proposalId The ID of the proposal\n     * @return targets of the proposalId\n     * @return values of the proposalId\n     * @return signatures of the proposalId\n     * @return calldatas of the proposalId\n     *\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to get the receipt of the voter for a specific proposalId\n     *\n     * @notice Allows the caller to get the receipt of the voter for a specific proposalId\n     * @param proposalId The ID of the proposal\n     * @param voter The ID of the proposal\n     * @return The receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the caller to get the state a specific proposalId\n     *\n     * @notice Allows the caller to get the state a specific proposalId\n     * @return The proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, 'GovernorAlpha::state: invalid proposal id');\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Allows the voter to cast a vote\n     *\n     * @dev Allows the voter to cast a vote\n     * @param voter The address of the voter\n     * @param proposalId The ID of the proposal\n     * @param support Boolean whether it supports or not the proposal\n     */\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(state(proposalId) == ProposalState.Active, 'GovernorAlpha::_castVote: voting is closed');\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'GovernorAlpha::_castVote: voter already voted');\n        uint96 votes = babl.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    /**\n     * INTERNAL SAFE MATH FUNCTION. Safe add two uint256 values checking overflow returning uint\n     *\n     * @dev Safe add two uint256 values checking overflow\n     */\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'addition overflow');\n        return c;\n    }\n\n    /**\n     * INTERNAL SAFE MATH FUNCTION. Safe sub two uint256 values checking underflow returning uint\n     *\n     * @dev Safe sub two uint256 values checking overflow\n     */\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, 'subtraction underflow');\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\ninterface ITimelock {\n    function delay() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {ITimelock} from '../interfaces/ITimelock.sol';\n\n// TODO: Do a diff to check for changes\ncontract Timelock is ITimelock {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    uint256 public constant override GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public override delay;\n\n    mapping(bytes32 => bool) public override queuedTransactions;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY, 'Timelock::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'Timelock::setDelay: Delay must not exceed maximum delay.');\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    /* ============ Fallback ============ */\n\n    fallback() external payable {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    function setDelay(uint256 delay_) external {\n        require(msg.sender == address(this), 'Timelock::setDelay: Call must come from Timelock.');\n        require(delay_ >= MINIMUM_DELAY, 'Timelock::setDelay: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'Timelock::setDelay: Delay must not exceed maximum delay.');\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() external override {\n        require(msg.sender == pendingAdmin, 'Timelock::acceptAdmin: Call must come from pendingAdmin.');\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) external {\n        require(msg.sender == address(this), 'Timelock::setPendingAdmin: Call must come from Timelock.');\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external override returns (bytes32) {\n        require(msg.sender == admin, 'Timelock::queueTransaction: Call must come from admin.');\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            'Timelock::queueTransaction: Estimated execution block must satisfy delay.'\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external override {\n        require(msg.sender == admin, 'Timelock::cancelTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external payable override returns (bytes memory) {\n        require(msg.sender == admin, 'Timelock::executeTransaction: Call must come from admin.');\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], 'Transaction is not queued');\n        require(getBlockTimestamp() >= eta, 'Transaction is too young');\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), 'Transaction is stale');\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, 'Timelock::executeTransaction: Transaction execution reverted.');\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IMooniswap is IERC20 {\n    function getTokens() external view returns (address[] memory _tokens);\n\n    function tokens(uint256 i) external view returns (IERC20);\n\n    function getBalanceForAddition(IERC20 token) external view returns (uint256);\n\n    function getBalanceForRemoval(IERC20 token) external view returns (uint256);\n\n    function getReturn(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts)\n        external\n        payable\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function depositFor(\n        uint256[2] memory maxAmounts,\n        uint256[2] memory minAmounts,\n        address target\n    ) external payable returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function withdraw(uint256 amount, uint256[] memory minReturns)\n        external\n        returns (uint256[2] memory withdrawnAmounts);\n\n    function withdrawFor(\n        uint256 amount,\n        uint256[] memory minReturns,\n        address payable target\n    ) external returns (uint256[2] memory withdrawnAmounts);\n\n    function swap(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    ) external payable returns (uint256 result);\n\n    function swapFor(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral,\n        address payable receiver\n    ) external payable returns (uint256 result);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './IMooniswap.sol';\nimport './IMooniswapFactoryGovernance.sol';\n\ninterface IMooniswapFactory is IMooniswapFactoryGovernance {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n\n    function isPool(IMooniswap mooniswap) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactoryGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IMooniswapFactoryGovernance {\n    function shareParameters()\n        external\n        view\n        returns (\n            uint256 _referralShare,\n            uint256 _governanceShare,\n            address _governanceWallet,\n            address _referralFeeReceiver\n        );\n\n    function defaults()\n        external\n        view\n        returns (\n            uint256 _defaultFee,\n            uint256 _defaultSlippageFee,\n            uint256 _defaultDecayPeriod\n        );\n\n    function defaultFee() external view returns (uint256);\n\n    function defaultSlippageFee() external view returns (uint256);\n\n    function defaultDecayPeriod() external view returns (uint256);\n\n    function virtualDefaultFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultSlippageFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultDecayPeriod()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function referralShare() external view returns (uint256);\n\n    function governanceShare() external view returns (uint256);\n\n    function governanceWallet() external view returns (address);\n\n    function feeCollector() external view returns (address);\n\n    function isFeeCollector(address) external view returns (bool);\n\n    function isActive() external view returns (bool);\n}\n"
    },
    "contracts/integrations/pool/OneInchPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {IMooniswapFactory} from '../../interfaces/external/1inch/IMooniswapFactory.sol';\nimport {IMooniswap} from '../../interfaces/external/1inch/IMooniswap.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * OneInchPoolIntegration protocol trade integration\n */\ncontract OneInchPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IMooniswapFactory public mooniswapFactory;\n\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _mooniswapFactoryAddress         Address of the Mooniswap factory\n     */\n    constructor(IBabController _controller, address _mooniswapFactoryAddress)\n        PoolIntegration('oneinch_pool', _controller)\n    {\n        mooniswapFactory = IMooniswapFactory(_mooniswapFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        return IMooniswap(_poolAddress).getTokens();\n    }\n\n    function getPoolWeights(\n        address /* _poolAddress */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address, /* _poolAddress */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address[] memory tokens = IMooniswap(_poolAddress).getTokens();\n        uint256 totalSupply = IMooniswap(_poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        uint256 token0Balance =\n            (tokens[0] != address(0) ? IERC20(tokens[0]).balanceOf(_poolAddress) : _poolAddress.balance);\n        uint256 token1Balance =\n            (tokens[1] != address(0) ? IERC20(tokens[1]).balanceOf(_poolAddress) : _poolAddress.balance);\n        result[0] = token0Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = token1Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal view override returns (bool) {\n        return IMooniswapFactory(mooniswapFactory).isPool(IMooniswap(_poolAddress));\n    }\n\n    function _getSpender(address _poolAddress) internal pure override returns (address) {\n        return _poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(uint256[2],uint256[2])',\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED * 2)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED * 2))\n            );\n        uint256 value = 0;\n        // Add ETH if one of the tokens\n        if (_tokensIn[0] == address(0)) {\n            value = _maxAmountsIn[0];\n        }\n        if (_tokensIn[1] == address(0)) {\n            value = _maxAmountsIn[1];\n        }\n\n        return (address(_poolAddress), value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (address(_poolAddress), 0, methodData);\n    }\n}\n"
    },
    "contracts/integrations/pool/BalancerIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {IBFactory} from '../../interfaces/external/balancer/IBFactory.sol';\nimport {IBPool} from '../../interfaces/external/balancer/IBPool.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Balancer protocol trade integration\n */\ncontract BalancerIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IBFactory public coreFactory;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _coreFactoryAddress           Address of Balancer core factory address\n     */\n    constructor(IBabController _controller, address _coreFactoryAddress) PoolIntegration('balancer', _controller) {\n        coreFactory = IBFactory(_coreFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(address _poolAddress) external view override returns (address[] memory) {\n        return IBPool(_poolAddress).getCurrentTokens();\n    }\n\n    function getPoolWeights(address _poolAddress) external view override returns (uint256[] memory) {\n        address[] memory poolTokens = IBPool(_poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint8 i = 0; i < poolTokens.length; i++) {\n            result[i] = IBPool(_poolAddress).getNormalizedWeight(poolTokens[i]);\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        address _poolAddress,\n        address _poolToken,\n        uint256 _maxAmountsIn\n    ) external view override returns (uint256) {\n        uint256 tokenBalance = IBPool(_poolAddress).getBalance(_poolToken);\n        return IBPool(_poolAddress).totalSupply().preciseMul(_maxAmountsIn.preciseDiv(tokenBalance));\n    }\n\n    function getPoolMinAmountsOut(address _poolAddress, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        uint256 lpTokensTotalSupply = IBPool(_poolAddress).totalSupply();\n        address[] memory poolTokens = IBPool(_poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            result[i] = IERC20(poolTokens[i])\n                .balanceOf(_poolAddress)\n                .mul(_liquidity)\n                .div(lpTokensTotalSupply)\n                .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        }\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(address _poolAddress) internal view override returns (bool) {\n        return coreFactory.isBPool(_poolAddress);\n    }\n\n    function _getSpender(address _poolAddress) internal pure override returns (address) {\n        return _poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _poolAddress              Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensOut,\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('joinPool(uint256,uint256[])', _poolTokensOut, _maxAmountsIn);\n\n        return (_poolAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _poolAddress              Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        address _poolAddress,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('exitPool(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (_poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/balancer/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IBPool} from './IBPool.sol';\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n\n    function newBPool() external returns (IBPool);\n}\n"
    },
    "contracts/interfaces/external/balancer/IBPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IBPool {\n    function isPublicSwap() external view returns (bool);\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address t) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getCurrentTokens() external view returns (address[] memory tokens);\n\n    function getFinalTokens() external view returns (address[] memory tokens);\n\n    function getDenormalizedWeight(address token) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getNormalizedWeight(address token) external view returns (uint256);\n\n    function getBalance(address token) external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function getController() external view returns (address);\n\n    function setSwapFee(uint256 swapFee) external;\n\n    function setController(address manager) external;\n\n    function setPublicSwap(bool external_) external;\n\n    function finalize() external;\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function unbind(address token) external;\n\n    function gulp(address token) external;\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut);\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external returns (uint256 tokenAmountIn);\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 tokenAmountOut);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) external pure returns (uint256 spotPrice);\n\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/integrations/passive/HarvestVaultIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\n\nimport {IHarvestVault} from '../../interfaces/external/harvest/IVault.sol';\n\n/**\n * @title HarvestIntegration\n * @author Babylon Finance Protocol\n *\n * Harvest v2 Vault Integration\n */\ncontract HarvestVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('harvestvaults', _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(address _vault) internal pure override returns (address) {\n        return _vault;\n    }\n\n    function _getExpectedShares(address _vault, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Harvest\n        return\n            _amount.preciseDiv(IHarvestVault(_vault).getPricePerFullShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_vault).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _vault) internal view override returns (uint256) {\n        return IHarvestVault(_vault).getPricePerFullShare();\n    }\n\n    function _getInvestmentAsset(address _vault) internal view override returns (address) {\n        return IHarvestVault(_vault).underlying();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.deposit.selector, _maxAmountIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.withdraw.selector, _investmentTokensIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/harvest/IVault.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\n\ninterface IHarvestVault {\n    function underlyingBalanceInVault() external view returns (uint256);\n\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    function governance() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n    function deposit(uint256 amountWei) external;\n\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256 numberOfShares) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/pool/SushiswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {UniswapPoolIntegration} from './UniswapPoolIntegration.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\n/**\n * @title SushiswapPoolIntegration\n * @author Babylon Finance Protocol\n *\n * Sushiswap Protocol pool integration\n */\ncontract SushiswapPoolIntegration is UniswapPoolIntegration {\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _sushiswapRouterAddress         Address of Sushiswap router\n     */\n    constructor(IBabController _controller, address _sushiswapRouterAddress)\n        UniswapPoolIntegration(_controller, _sushiswapRouterAddress)\n    {\n        name = 'sushiswap_pool';\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}