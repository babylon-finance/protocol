{
  "language": "Solidity",
  "sources": {
    "contracts/BabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IGardenFactory} from './interfaces/IGardenFactory.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IIntegration} from './interfaces/IIntegration.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\nimport {LowGasSafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabController is OwnableUpgradeable, IBabController {\n    using AddressArrayUtils for address[];\n    using AddressUpgradeable for address;\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event GardenAdded(address indexed _garden, address indexed _factory);\n    event GardenRemoved(address indexed _garden);\n\n    event ControllerIntegrationAdded(address _integration, string indexed _integrationName);\n    event ControllerIntegrationRemoved(address _integration, string indexed _integrationName);\n    event ControllerIntegrationEdited(address _newIntegration, string indexed _integrationName);\n    event ControllerOperationSet(uint8 indexed _kind, address _address);\n    event MasterSwapperChanged(address indexed _newTradeIntegration, address _oldTradeIntegration);\n\n    event ReserveAssetAdded(address indexed _reserveAsset);\n    event ReserveAssetRemoved(address indexed _reserveAsset);\n    event LiquidityMinimumEdited(address indexed _resesrveAsset, uint256 _newMinLiquidityReserve);\n\n    event PriceOracleChanged(address indexed _priceOracle, address _oldPriceOracle);\n    event RewardsDistributorChanged(address indexed _rewardsDistributor, address _oldRewardsDistributor);\n    event TreasuryChanged(address _newTreasury, address _oldTreasury);\n    event IshtarGateChanged(address _newIshtarGate, address _oldIshtarGate);\n    event MardukGateChanged(address _newMardukGate, address _oldMardukGate);\n    event GardenValuerChanged(address indexed _gardenValuer, address _oldGardenValuer);\n    event GardenFactoryChanged(address indexed _gardenFactory, address _oldGardenFactory);\n    event UniswapFactoryChanged(address indexed _newUniswapFactory, address _oldUniswapFactory);\n    event GardenNFTChanged(address indexed _newGardenNFT, address _oldStrategyNFT);\n    event StrategyNFTChanged(address indexed _newStrategyNFT, address _oldStrategyNFT);\n\n    event StrategyFactoryEdited(address indexed _strategyFactory, address _oldStrategyFactory);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address _oldPauseGuardian, address _newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string _action, bool _pauseState);\n\n    /// @notice Emitted when an action is paused individually\n    event ActionPausedIndividually(string _action, address _address, bool _pauseState);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGovernanceOrEmergency {\n        require(msg.sender == owner() || msg.sender == EMERGENCY_OWNER, 'Not enough privileges');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address private uniswapFactory; // do not use\n    address public override gardenValuer;\n    address public override priceOracle;\n    address public override gardenFactory;\n    address public override rewardsDistributor;\n    address public override ishtarGate;\n    address public override strategyFactory;\n    address public override gardenNFT;\n    address public override strategyNFT;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations; // DEPRECATED\n    // Address of the master swapper used by the protocol\n    address public override masterSwapper;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public override enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public override isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) public assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Mapping of minimum liquidity per reserve asset\n    mapping(address => uint256) public override minLiquidityPerReserve;\n\n    // Recipient of protocol fees\n    address public override treasury;\n\n    // Strategy Profit Sharing\n    uint256 private strategistProfitPercentage; // DEPRECATED\n    uint256 private stewardsProfitPercentage; // DEPRECATED\n    uint256 private lpsProfitPercentage; // DEPRECATED\n\n    // Strategy BABL Rewards Sharing\n    uint256 private strategistBABLPercentage; // DEPRECATED\n    uint256 private stewardsBABLPercentage; // DEPRECATED\n    uint256 private lpsBABLPercentage; // DEPRECATED\n\n    uint256 private gardenCreatorBonus; // DEPRECATED\n\n    // Assets\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public override gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public override bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public override allowPublicGardens;\n\n    uint256 public override protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public override protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    // Maximum number of contributors per garden\n    uint256 private maxContributorsPerGarden; // DEPRECATED\n\n    // Enable garden creations to be fully open to the public (no need of Ishtar gate anymore)\n    bool public override gardenCreationIsOpen;\n\n    // Pause Guardian\n    address public guardian;\n    mapping(address => bool) public override guardianPaused;\n    bool public override guardianGlobalPaused;\n    address public override mardukGate;\n\n    /* ============ Constants ============ */\n\n    address public constant EMERGENCY_OWNER = 0x0B892EbC6a4bF484CDDb7253c6BD5261490163b9;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IERC20 public constant BABL = IERC20(0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74);\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n\n        maxContributorsPerGarden = 100;\n        gardenCreationIsOpen = false;\n        allowPublicGardens = true;\n        bablMiningProgramEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    // ===========  Garden related Gov Functions ======\n    /**\n     * Creates a Garden smart contract and registers the Garden with the controller.\n     *\n     * If asset is not WETH, the creator needs to approve the controller\n     * @param _reserveAsset                     Reserve asset of the Garden. Initially just weth\n     * @param _name                             Name of the Garden\n     * @param _symbol                           Symbol of the Garden\n     * @param _gardenParams                     Array of numeric garden params\n     * @param _tokenURI                         Garden NFT token URI\n     * @param _seed                             Seed to regenerate the garden NFT\n     * @param _initialContribution              Initial contribution by the gardener\n     * @param _publicGardenStrategistsStewards  Public garden, public strategist rights and public stewards rights\n     * @param _profitSharing                    Custom profit sharing (if any)\n     */\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards,\n        uint256[] memory _profitSharing\n    ) external payable override returns (address) {\n        require(masterSwapper != address(0), 'Need a default trade integration');\n        require(enabledOperations.length > 0, 'Need operations enabled');\n        require(\n            mardukGate != address(0) &&\n                gardenNFT != address(0) &&\n                strategyFactory != address(0) &&\n                gardenValuer != address(0) &&\n                treasury != address(0),\n            'Parameters not initialized'\n        );\n        require(\n            IIshtarGate(mardukGate).canCreate(msg.sender) || gardenCreationIsOpen,\n            'User does not have creation permissions'\n        );\n        address newGarden =\n            IGardenFactory(gardenFactory).createGarden(\n                _reserveAsset,\n                msg.sender,\n                _name,\n                _symbol,\n                _tokenURI,\n                _seed,\n                _gardenParams,\n                _initialContribution,\n                _publicGardenStrategistsStewards\n            );\n        if (_reserveAsset != WETH || msg.value == 0) {\n            IERC20(_reserveAsset).safeTransferFrom(msg.sender, address(this), _initialContribution);\n            IERC20(_reserveAsset).safeApprove(newGarden, _initialContribution);\n        }\n        require(!isGarden[newGarden], 'Garden already exists');\n        isGarden[newGarden] = true;\n        gardens.push(newGarden);\n        IGarden(newGarden).deposit{value: msg.value}(_initialContribution, _initialContribution, msg.sender, true);\n        // Avoid gas cost if default sharing values are provided (0,0,0)\n        if (_profitSharing[0] != 0 || _profitSharing[1] != 0 || _profitSharing[2] != 0) {\n            IRewardsDistributor(rewardsDistributor).setProfitRewards(\n                newGarden,\n                _profitSharing[0],\n                _profitSharing[1],\n                _profitSharing[2]\n            );\n        }\n        emit GardenAdded(newGarden, msg.sender);\n        return newGarden;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a Garden\n     *\n     * @param _garden               Address of the Garden contract to remove\n     */\n    function removeGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        require(IGarden(_garden).getStrategies().length == 0, 'Garden has active strategies!');\n        gardens = gardens.remove(_garden);\n        delete isGarden[_garden];\n\n        emit GardenRemoved(_garden);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 gardenTokens\n     * Can only happen after 2021 is finished.\n     */\n    function enableGardenTokensTransfers() external override onlyOwner {\n        require(block.timestamp > 1641024000, 'Transfers cannot be enabled yet');\n        gardenTokensTransfersEnabled = true;\n    }\n\n    // ===========  Protocol related Gov Functions ======\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid keeper to the list\n     *\n     * @param _keeper Address of the keeper\n     */\n    function addKeeper(address _keeper) external override onlyOwner {\n        require(!keeperList[_keeper] && _keeper != address(0), 'Incorrect address');\n        keeperList[_keeper] = true;\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Removes a keeper\n     *\n     * @param _keeper Address of the keeper\n     */\n    function removeKeeper(address _keeper) external override onlyOwner {\n        require(keeperList[_keeper], 'Keeper is whitelisted');\n        delete keeperList[_keeper];\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a list of assets to the whitelist\n     *\n     * @param _keepers List with keeprs of the assets to whitelist\n     */\n    function addKeepers(address[] memory _keepers) external override onlyOwner {\n        for (uint256 i = 0; i < _keepers.length; i++) {\n            keeperList[_keepers[i]] = true;\n        }\n    }\n\n    /**\n     * PRIVILEGED FACTORY FUNCTION. Adds a new valid reserve asset for gardens\n     *\n     * @param _reserveAsset Address of the reserve assset\n     */\n    function addReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(_reserveAsset != address(0) && ERC20(_reserveAsset).decimals() <= 18, 'Incorrect address');\n        require(!validReserveAsset[_reserveAsset], 'Reserve asset already added');\n        validReserveAsset[_reserveAsset] = true;\n        reserveAssets.push(_reserveAsset);\n        emit ReserveAssetAdded(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a reserve asset\n     *\n     * @param _reserveAsset               Address of the reserve asset to remove\n     */\n    function removeReserveAsset(address _reserveAsset) external override onlyOwner {\n        require(validReserveAsset[_reserveAsset], 'Reserve asset does not exist');\n\n        reserveAssets = reserveAssets.remove(_reserveAsset);\n\n        delete validReserveAsset[_reserveAsset];\n\n        emit ReserveAssetRemoved(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the Marduk Gate Address\n     *\n     * @param _mardukGate               Address of the new Marduk Gate\n     */\n    function editMardukGate(address _mardukGate) external override onlyOwner {\n        require(_mardukGate != mardukGate, 'Marduk Gate already exists');\n\n        require(_mardukGate != address(0), 'Marduk Gate oracle must exist');\n\n        address oldMardukGate = mardukGate;\n        mardukGate = _mardukGate;\n\n        emit MardukGateChanged(_mardukGate, oldMardukGate);\n    }\n\n    function editRewardsDistributor(address _newRewardsDistributor) external override onlyOwner {\n        require(_newRewardsDistributor != address(0), 'Address must not be 0');\n\n        address oldRewardsDistributor = rewardsDistributor;\n        rewardsDistributor = _newRewardsDistributor;\n\n        emit RewardsDistributorChanged(_newRewardsDistributor, oldRewardsDistributor);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol fee recipient\n     *\n     * @param _newTreasury      Address of the new protocol fee recipient\n     */\n    function editTreasury(address _newTreasury) external override onlyOwner {\n        require(_newTreasury != address(0), 'Address must not be 0');\n\n        address oldTreasury = treasury;\n        treasury = _newTreasury;\n\n        emit TreasuryChanged(_newTreasury, oldTreasury);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edits the minimum liquidity an asset must have on Uniswap\n     *\n     * @param  _reserve                         Address of the reserve to edit\n     * @param  _newMinLiquidityReserve          Absolute min liquidity of an asset to grab price\n     */\n    function editLiquidityReserve(address _reserve, uint256 _newMinLiquidityReserve) public override onlyOwner {\n        require(_newMinLiquidityReserve > 0, '_minRiskyPairLiquidityEth > 0');\n        require(validReserveAsset[_reserve], 'Needs to be a valid reserve');\n        minLiquidityPerReserve[_reserve] = _newMinLiquidityReserve;\n\n        emit LiquidityMinimumEdited(_reserve, _newMinLiquidityReserve);\n    }\n\n    // Setter that can be changed by the team in case of an emergency\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the price oracle\n     *\n     * @param _priceOracle               Address of the new price oracle\n     */\n    function editPriceOracle(address _priceOracle) external override onlyGovernanceOrEmergency {\n        require(_priceOracle != priceOracle, 'Price oracle already exists');\n\n        require(_priceOracle != address(0), 'Price oracle must exist');\n\n        address oldPriceOracle = priceOracle;\n        priceOracle = _priceOracle;\n\n        emit PriceOracleChanged(_priceOracle, oldPriceOracle);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the garden valuer\n     *\n     * @param _gardenValuer Address of the new garden valuer\n     */\n    function editGardenValuer(address _gardenValuer) external override onlyGovernanceOrEmergency {\n        require(_gardenValuer != gardenValuer, 'Garden Valuer already exists');\n\n        require(_gardenValuer != address(0), 'Garden Valuer must exist');\n\n        address oldGardenValuer = gardenValuer;\n        gardenValuer = _gardenValuer;\n\n        emit GardenValuerChanged(_gardenValuer, oldGardenValuer);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden factory\n     *\n     * @param _newGardenFactory      Address of the new garden factory\n     */\n    function editGardenFactory(address _newGardenFactory) external override onlyGovernanceOrEmergency {\n        require(_newGardenFactory != address(0), 'Address must not be 0');\n\n        address oldGardenFactory = gardenFactory;\n        gardenFactory = _newGardenFactory;\n\n        emit GardenFactoryChanged(_newGardenFactory, oldGardenFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden NFT\n     *\n     * @param _newGardenNFT      Address of the new garden NFT\n     */\n    function editGardenNFT(address _newGardenNFT) external override onlyGovernanceOrEmergency {\n        require(_newGardenNFT != address(0), 'Address must not be 0');\n\n        address oldGardenNFT = gardenNFT;\n        gardenNFT = _newGardenNFT;\n\n        emit GardenNFTChanged(_newGardenNFT, oldGardenNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy NFT\n     *\n     * @param _newStrategyNFT      Address of the new strategy NFT\n     */\n    function editStrategyNFT(address _newStrategyNFT) external override onlyGovernanceOrEmergency {\n        require(_newStrategyNFT != address(0), 'Address must not be 0');\n\n        address oldStrategyNFT = strategyNFT;\n        strategyNFT = _newStrategyNFT;\n\n        emit StrategyNFTChanged(_newStrategyNFT, oldStrategyNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy factory\n     *\n     * @param _newStrategyFactory      Address of the new strategy factory\n     */\n    function editStrategyFactory(address _newStrategyFactory) external override onlyGovernanceOrEmergency {\n        require(_newStrategyFactory != address(0), 'Address must not be 0');\n\n        address oldStrategyFactory = strategyFactory;\n        strategyFactory = _newStrategyFactory;\n\n        emit StrategyFactoryEdited(_newStrategyFactory, oldStrategyFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol default trde integration\n     *\n     * @param _newDefaultMasterSwapper     Address of the new default trade integration\n     */\n    function setMasterSwapper(address _newDefaultMasterSwapper) external override onlyGovernanceOrEmergency {\n        require(_newDefaultMasterSwapper != address(0), 'Address must not be 0');\n        require(_newDefaultMasterSwapper != masterSwapper, 'Address must be different');\n        address oldMasterSwapper = masterSwapper;\n        masterSwapper = _newDefaultMasterSwapper;\n\n        emit MasterSwapperChanged(_newDefaultMasterSwapper, oldMasterSwapper);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing operation on the registry\n     *\n     * @param  _kind             Operation kind\n     * @param  _operation        Address of the operation contract to set\n     */\n    function setOperation(uint8 _kind, address _operation) public override onlyGovernanceOrEmergency {\n        require(_kind < MAX_OPERATIONS, 'Max operations reached');\n        require(enabledOperations[_kind] != _operation, 'Operation already set');\n        require(_operation != address(0), 'Operation address must exist.');\n        enabledOperations[_kind] = _operation;\n\n        emit ControllerOperationSet(_kind, _operation);\n    }\n\n    // ===========  Protocol security related Gov Functions ======\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set-up a pause guardian\n     * @param _guardian               Address of the guardian\n     */\n    function setPauseGuardian(address _guardian) external override {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            'only pause guardian and owner can update pause guardian'\n        );\n        require(msg.sender == owner() || _guardian != address(0), 'Guardian cannot remove himself');\n        // Save current value for inclusion in log\n        address oldPauseGuardian = guardian;\n        // Store pauseGuardian with value newPauseGuardian\n        guardian = _guardian;\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, _guardian);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause the protocol globally in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _state               True to pause, false to unpause.\n     */\n    function setGlobalPause(bool _state) external override returns (bool) {\n        require(msg.sender == guardian || msg.sender == owner(), 'only pause guardian and owner can pause globally');\n        require(msg.sender == owner() || _state == true, 'only admin can unpause');\n\n        guardianGlobalPaused = _state;\n        emit ActionPaused('Guardian global pause', _state);\n        return _state;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause some smartcontracts in a batch process in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _address             Addresses of protocol smartcontract to be paused\n     * @param _state               Boolean pause state\n     */\n    function setSomePause(address[] memory _address, bool _state) external override returns (bool) {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            'only pause guardian and owner can pause individually'\n        );\n        require(msg.sender == owner() || _state == true, 'only admin can unpause');\n        for (uint256 i = 0; i < _address.length; i++) {\n            guardianPaused[_address[i]] = _state;\n            emit ActionPausedIndividually('Guardian individual pause', _address[i], _state);\n        }\n        return _state;\n    }\n\n    function completeArrival() external override onlyOwner {\n        BABL.safeTransfer(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43, 15_404e18);\n        BABL.safeTransfer(treasury, 70_000e18 - 15_404e18);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    function owner() public view override(IBabController, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    function getGardens() external view override returns (address[] memory) {\n        return gardens;\n    }\n\n    function getOperations() external view override returns (address[20] memory) {\n        return enabledOperations;\n    }\n\n    function getReserveAssets() external view returns (address[] memory) {\n        return reserveAssets;\n    }\n\n    function isValidReserveAsset(address _reserveAsset) external view override returns (bool) {\n        return validReserveAsset[_reserveAsset];\n    }\n\n    function isValidKeeper(address _keeper) external view override returns (bool) {\n        return keeperList[_keeper];\n    }\n\n    /**\n     * Check whether or not there is a global pause or a specific pause of the provided contract address\n     * @param _contract               Smartcontract address to check for a global or specific pause\n     */\n    function isPaused(address _contract) external view override returns (bool) {\n        return guardianGlobalPaused || guardianPaused[_contract];\n    }\n\n    /**\n     * Check whether or not the strategies are beta protocol strategies deserving rewards\n     * @param _strategies              Smartcontract address to check for a global or specific pause\n     */\n    function isBetaStrategy(address[] memory _strategies)\n        external\n        view\n        override\n        returns (bool[] memory, uint256[] memory)\n    {\n        uint256[] memory capitalAllocated = new uint256[](_strategies.length);\n        bool[] memory isABetaStrategy = new bool[](_strategies.length);\n        uint256 startTime = IRewardsDistributor(rewardsDistributor).START_TIME();\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            require(_strategies[i] != address(0), 'not a valid address');\n            address garden = address(IStrategy(_strategies[i]).garden());\n            // Only protocol strategies security cross-check\n            require(isGarden[garden] && IGarden(garden).isGardenStrategy(_strategies[i]), 'not a protocol strategy');\n            // ts[0]: executedAt, ts[1]: updatedAt\n            // isStrategyActive implies exitedAt == 0 (not finished yet)\n            uint256[] memory ts = new uint256[](2);\n            (, , , , ts[0], , ts[1]) = IStrategy(_strategies[i]).getStrategyState();\n            isABetaStrategy[i] =\n                ts[0] < startTime &&\n                ts[1] < startTime &&\n                IStrategy(_strategies[i]).isStrategyActive() &&\n                startTime != 0;\n            capitalAllocated[i] = IStrategy(_strategies[i]).capitalAllocated();\n        }\n        return (isABetaStrategy, capitalAllocated);\n    }\n\n    function getLiveStrategies(uint256 _size) external view override returns (address[] memory) {\n        uint256 pid;\n        address[] memory liveStrategies = new address[](_size);\n        // Get all protocol gardens at initialization of mining program\n        for (uint256 i = 0; i < gardens.length; i++) {\n            // get all strategies at each garden and check whether or not are active strategies\n            address[] memory strategies = IGarden(gardens[i]).getStrategies();\n            if (strategies.length == 0) {\n                continue;\n            }\n            for (uint256 j = 0; j < strategies.length; j++) {\n                if (IStrategy(strategies[j]).isStrategyActive()) {\n                    // We pre-select eligible strategies to call rewards distributor\n                    liveStrategies[pid] = address(strategies[j]);\n                    pid++;\n                }\n                if (pid == _size) break;\n            }\n            if (pid == _size) break;\n        }\n        return liveStrategies;\n    }\n\n    /**\n     * Check if a contract address is a garden or one of the system contracts\n     *\n     * @param  _contractAddress           The contract address to check\n     */\n    function isSystemContract(address _contractAddress) external view override returns (bool) {\n        if (_contractAddress == address(0)) {\n            return false;\n        }\n        return (isGarden[_contractAddress] ||\n            gardenValuer == _contractAddress ||\n            priceOracle == _contractAddress ||\n            gardenFactory == _contractAddress ||\n            masterSwapper == _contractAddress ||\n            strategyFactory == _contractAddress ||\n            rewardsDistributor == _contractAddress ||\n            owner() == _contractAddress ||\n            _contractAddress == address(this) ||\n            _isOperation(_contractAddress) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).strategyMapping(_contractAddress)) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).isGardenStrategy(_contractAddress)));\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * Hashes the string and returns a bytes32 value\n     */\n    function _nameHash(string memory _name) private pure returns (bytes32) {\n        return keccak256(bytes(_name));\n    }\n\n    function _isOperation(address _address) private view returns (bool) {\n        for (uint8 i = 0; i < MAX_OPERATIONS; i++) {\n            if (_address == enabledOperations[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract BabControllerV10 is BabController {}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title IRewardsDistributor\n * @author Babylon Finance\n *\n * Interface for the rewards distributor in charge of the BABL Mining Program.\n */\n\ninterface IRewardsDistributor {\n    /* ========== View functions ========== */\n\n    // solhint-disable-next-line\n    function START_TIME() external view returns (uint256);\n\n    function getStrategyRewards(address _strategy) external view returns (uint96);\n\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view returns (uint256[] memory);\n\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _time\n    ) external view returns (uint256);\n\n    function getGardenProfitsSharing(address _garden) external view returns (uint256[3] memory);\n\n    function getBABLMiningParameters()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function checkMining(uint256 _quarterNum, address _strategy)\n        external\n        view\n        returns (uint256[] memory, bool[] memory);\n\n    function getContributorPerGarden(address _garden, address _contributor)\n        external\n        view\n        returns (uint256[] memory, bool[] memory);\n\n    function estimateUserRewards(address _strategy, address _contributor) external view returns (uint256[] memory);\n\n    function estimateStrategyRewards(address _strategy) external view returns (uint256);\n\n    /* ============ External Functions ============ */\n\n    function updateStrategyCheckpoint(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) external;\n\n    function sendTokensToContributor(address _to, uint256 _amount) external returns (uint256);\n\n    function setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) external;\n\n    function setBABLMiningParameters(\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare,\n        uint256 _creatorBonus,\n        uint256 _profitWeight,\n        uint256 _principalWeight\n    ) external;\n\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) external;\n\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _previousSupply,\n        uint256 _tokenDiff,\n        bool _addOrSubstract\n    ) external;\n}\n"
    },
    "contracts/interfaces/IGarden.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IGarden\n * @author Babylon Finance\n *\n * Interface for operating with a Garden.\n */\ninterface IGarden {\n    /* ============ Functions ============ */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external payable;\n\n    function makeGardenPublic() external;\n\n    function transferCreatorRights(address _newCreator, uint8 _index) external;\n\n    function addExtraCreators(address[4] memory _newCreators) external;\n\n    function setPublicRights(bool _publicStrategist, bool _publicStewards) external;\n\n    function privateGarden() external view returns (bool);\n\n    function publicStrategists() external view returns (bool);\n\n    function publicStewards() external view returns (bool);\n\n    function controller() external view returns (address);\n\n    function creator() external view returns (address);\n\n    function isGardenStrategy(address _strategy) external view returns (bool);\n\n    function getContributor(address _contributor)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function reserveAsset() external view returns (address);\n\n    function totalContributors() external view returns (uint256);\n\n    function gardenInitializedAt() external view returns (uint256);\n\n    function minContribution() external view returns (uint256);\n\n    function depositHardlock() external view returns (uint256);\n\n    function minLiquidityAsset() external view returns (uint256);\n\n    function minStrategyDuration() external view returns (uint256);\n\n    function maxStrategyDuration() external view returns (uint256);\n\n    function reserveAssetRewardsSetAside() external view returns (uint256);\n\n    function absoluteReturns() external view returns (int256);\n\n    function totalStake() external view returns (uint256);\n\n    function minVotesQuorum() external view returns (uint256);\n\n    function minVoters() external view returns (uint256);\n\n    function maxDepositLimit() external view returns (uint256);\n\n    function strategyCooldownPeriod() external view returns (uint256);\n\n    function getStrategies() external view returns (address[] memory);\n\n    function extraCreators(uint256 index) external view returns (address);\n\n    function getFinalizedStrategies() external view returns (address[] memory);\n\n    function strategyMapping(address _strategy) external view returns (bool);\n\n    function finalizeStrategy(\n        uint256 _profits,\n        int256 _returns,\n        uint256 _burningAmount\n    ) external;\n\n    function allocateCapitalToStrategy(uint256 _capital) external;\n\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes calldata _opEncodedDatas\n    ) external;\n\n    function deposit(\n        uint256 _reserveAssetQuantity,\n        uint256 _minGardenTokenReceiveQuantity,\n        address _to,\n        bool mintNFT\n    ) external payable;\n\n    function depositBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        bool _mintNft,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function withdraw(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external;\n\n    function withdrawBySig(\n        uint256 _gardenTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        uint256 _nonce,\n        uint256 _maxFee,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function claimReturns(address[] calldata _finalizedStrategies) external;\n\n    function getLockedBalance(address _contributor) external view returns (uint256);\n\n    function updateGardenParams(uint256[9] memory _newParams) external;\n\n    function expireCandidateStrategy(address _strategy) external;\n\n    function payKeeper(address payable _keeper, uint256 _fee) external;\n\n    function keeperDebt() external view returns (uint256);\n\n    function totalKeeperFees() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IGardenFactory\n * @author Babylon Finance\n *\n * Interface for the garden factory\n */\ninterface IGardenFactory {\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title IStrategy\n * @author Babylon Finance\n *\n * Interface for strategy\n */\ninterface IStrategy {\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _maxAllocationPercentage,\n        uint256 _maxGasFeePercentage,\n        uint256 _maxTradeSlippagePercentage\n    ) external;\n\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 fee\n    ) external;\n\n    function updateParams(uint256[4] calldata _params) external;\n\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes memory _opEncodedData\n    ) external;\n\n    function executeStrategy(uint256 _capital, uint256 fee) external;\n\n    function getNAV() external view returns (uint256);\n\n    function opEncodedData() external view returns (bytes memory);\n\n    function getOperationsCount() external view returns (uint256);\n\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        returns (\n            uint8,\n            address,\n            bytes memory\n        );\n\n    function finalizeStrategy(uint256 fee, string memory _tokenURI) external;\n\n    function unwindStrategy(uint256 _amountToUnwind, uint256 _strategyNAV) external;\n\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory);\n\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external;\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external returns (uint256);\n\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external;\n\n    function getStrategyDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        );\n\n    function getStrategyState()\n        external\n        view\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getStrategyRewardsContext()\n        external\n        view\n        returns (\n            address,\n            uint256[] memory,\n            bool[] memory\n        );\n\n    function isStrategyActive() external view returns (bool);\n\n    function getUserVotes(address _address) external view returns (int256);\n\n    function strategist() external view returns (address);\n\n    function enteredAt() external view returns (uint256);\n\n    function enteredCooldownAt() external view returns (uint256);\n\n    function stake() external view returns (uint256);\n\n    function strategyRewards() external view returns (uint256);\n\n    function maxCapitalRequested() external view returns (uint256);\n\n    function maxAllocationPercentage() external view returns (uint256);\n\n    function maxTradeSlippagePercentage() external view returns (uint256);\n\n    function maxGasFeePercentage() external view returns (uint256);\n\n    function expectedReturn() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function totalPositiveVotes() external view returns (uint256);\n\n    function totalNegativeVotes() external view returns (uint256);\n\n    function capitalReturned() external view returns (uint256);\n\n    function capitalAllocated() external view returns (uint256);\n\n    function garden() external view returns (IGarden);\n}\n"
    },
    "contracts/interfaces/IIshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IBabylonGate} from './IBabylonGate.sol';\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IIshtarGate is IBabylonGate {\n    /* ============ Functions ============ */\n\n    function tokenURI() external view returns (string memory);\n\n    function updateGardenURI(string memory _tokenURI) external;\n}\n"
    },
    "contracts/interfaces/IIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIntegration\n * @author Babylon Finance\n *\n * Interface for protocol integrations\n */\ninterface IIntegration {\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBabController.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBabController\n * @author Babylon Finance\n *\n * Interface for interacting with BabController\n */\ninterface IBabController {\n    /* ============ Functions ============ */\n\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards,\n        uint256[] memory _profitSharing\n    ) external payable returns (address);\n\n    function removeGarden(address _garden) external;\n\n    function addReserveAsset(address _reserveAsset) external;\n\n    function removeReserveAsset(address _reserveAsset) external;\n\n    function editPriceOracle(address _priceOracle) external;\n\n    function editMardukGate(address _mardukGate) external;\n\n    function editGardenValuer(address _gardenValuer) external;\n\n    function editTreasury(address _newTreasury) external;\n\n    function editRewardsDistributor(address _rewardsDistributor) external;\n\n    function editGardenFactory(address _newGardenFactory) external;\n\n    function editGardenNFT(address _newGardenNFT) external;\n\n    function editStrategyNFT(address _newStrategyNFT) external;\n\n    function editStrategyFactory(address _newStrategyFactory) external;\n\n    function setOperation(uint8 _kind, address _operation) external;\n\n    function setMasterSwapper(address _newMasterSwapper) external;\n\n    function addKeeper(address _keeper) external;\n\n    function addKeepers(address[] memory _keepers) external;\n\n    function removeKeeper(address _keeper) external;\n\n    function enableGardenTokensTransfers() external;\n\n    function editLiquidityReserve(address _reserve, uint256 _minRiskyPairLiquidityEth) external;\n\n    function gardenCreationIsOpen() external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function guardianGlobalPaused() external view returns (bool);\n\n    function guardianPaused(address _address) external view returns (bool);\n\n    function setPauseGuardian(address _guardian) external;\n\n    function setGlobalPause(bool _state) external returns (bool);\n\n    function setSomePause(address[] memory _address, bool _state) external returns (bool);\n\n    function isPaused(address _contract) external view returns (bool);\n\n    function priceOracle() external view returns (address);\n\n    function gardenValuer() external view returns (address);\n\n    function gardenNFT() external view returns (address);\n\n    function strategyNFT() external view returns (address);\n\n    function rewardsDistributor() external view returns (address);\n\n    function gardenFactory() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function ishtarGate() external view returns (address);\n\n    function mardukGate() external view returns (address);\n\n    function strategyFactory() external view returns (address);\n\n    function masterSwapper() external view returns (address);\n\n    function gardenTokensTransfersEnabled() external view returns (bool);\n\n    function bablMiningProgramEnabled() external view returns (bool);\n\n    function allowPublicGardens() external view returns (bool);\n\n    function enabledOperations(uint256 _kind) external view returns (address);\n\n    function getGardens() external view returns (address[] memory);\n\n    function getOperations() external view returns (address[20] memory);\n\n    function getLiveStrategies(uint256 _size) external view returns (address[] memory);\n\n    function isGarden(address _garden) external view returns (bool);\n\n    function isValidReserveAsset(address _reserveAsset) external view returns (bool);\n\n    function isValidKeeper(address _keeper) external view returns (bool);\n\n    function isSystemContract(address _contractAddress) external view returns (bool);\n\n    function isBetaStrategy(address[] memory _strategies) external view returns (bool[] memory, uint256[] memory);\n\n    function protocolPerformanceFee() external view returns (uint256);\n\n    function protocolManagementFee() external view returns (uint256);\n\n    function minLiquidityPerReserve(address _reserve) external view returns (uint256);\n\n    function completeArrival() external;\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n */\nlibrary AddressArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Returns true if there are 2 elements that are the same in an array\n     * @param A The input array to search\n     * @return Returns boolean for the first occurrence of a duplicate\n     */\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n        require(A.length > 0, 'A is empty');\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a) internal pure returns (address[] memory) {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert('Address not in array.');\n        } else {\n            (address[] memory _A, ) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * Removes specified index from array\n     * @param A The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory A, uint256 index) internal pure returns (address[] memory, address) {\n        uint256 length = A.length;\n        require(index < A.length, 'Index must be < A length');\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n\n    /**\n     * Returns the combination of the two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        address[] memory newAddresses = new address[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = 0; j < bLength; j++) {\n            newAddresses[aLength + j] = B[j];\n        }\n        return newAddresses;\n    }\n}\n"
    },
    "contracts/lib/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SafeMath: division by zero');\n        return a / b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IBabylonGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributedx under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBabylonGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Guestlists\n */\ninterface IBabylonGate {\n    /* ============ Functions ============ */\n\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external returns (uint256);\n\n    function setCreatorPermissions(address _user, bool _canCreate) external returns (uint256);\n\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external returns (bool);\n\n    function maxNumberOfInvites() external view returns (uint256);\n\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external;\n\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms) external returns (bool);\n\n    function canCreate(address _user) external view returns (bool);\n\n    function canJoinAGarden(address _garden, address _user) external view returns (bool);\n\n    function canVoteInAGarden(address _garden, address _user) external view returns (bool);\n\n    function canAddStrategiesInAGarden(address _garden, address _user) external view returns (bool);\n}\n"
    },
    "contracts/token/RewardsDistributor.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {TimeLockedToken} from './TimeLockedToken.sol';\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards\n * of the BABL Mining Program along the time reserved for executed strategies. It implements a supply curve\n * to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared\n * to the whole protocol usage as well as profits of each strategy counts.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses\n * to specific profiles, which are actively contributing to the protocol growth and their communities\n * (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributor is OwnableUpgradeable, IRewardsDistributor {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n    using Safe3296 for uint256;\n    using Safe3296 for int256;\n    using Safe3296 for uint96;\n    using Safe3296 for uint32;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the call is not from a valid strategy\n     */\n    function _onlyStrategy(address _strategy) private view {\n        address garden = address(IStrategy(_strategy).garden());\n        _require(IBabController(controller).isGarden(garden), Errors.ONLY_ACTIVE_GARDEN);\n        _require(IGarden(garden).isGardenStrategy(_strategy), Errors.STRATEGY_GARDEN_MISMATCH);\n    }\n\n    /**\n     * Throws if the sender is not the controller\n     */\n    function _onlyController() private view {\n        _require(IBabController(controller).isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        _require(address(controller) == msg.sender, Errors.ONLY_CONTROLLER);\n    }\n\n    /**\n     * Throws if Rewards Distributor is paused\n     */\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Throws if a malicious reentrant call is detected\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        _require(status != ENTERED, Errors.REENTRANT_CALL);\n        // Any calls to nonReentrant after this point will fail\n        status = ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        status = NOT_ENTERED;\n    }\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 private constant Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 private constant DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 private constant EPOCH_DURATION = 90 days;\n\n    // solhint-disable-next-line\n    uint256 public override START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 private strategistBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private strategistProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private profitProtocolFee;\n    // solhint-disable-next-line\n    uint256 private gardenCreatorBonus;\n\n    // DAI normalize asset\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Reentrancy guard countermeasure\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        uint256 principal; // DEPRECATED\n        uint256 time; // DEPRECATED\n        uint256 quarterBelonging; // DEPRECATED\n        uint256 timeListPointer; // DEPRECATED\n        uint256 power; // DEPRECATED\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 quarterNumber; // DEPRECATED\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // DEPRECATED\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 avgGardenBalance; // Checkpoint to keep track on garden supply\n        uint256 lastDepositAt; // Checkpoint timestamps\n        uint256 accGardenPower; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // DEPRECATED, but still needed during beta gardens migration\n        uint256 pid; // DEPRECATED, but still needed during beta gardens migration\n        // Sub-mapping of contributor details, updated info after beta will be only at position [0]\n        mapping(uint256 => TimestampContribution) tsContributions;\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 avgBalance; // User avg balance in each garden along the time\n        uint256 timestamp; // DEPRECATED\n        uint256 timePointer; // DEPRECATED\n        uint256 power; // Contributor power\n    }\n    struct Checkpoints {\n        uint256 fromDepositAt; // DEPRECATED\n        uint256 lastDepositAt; // DEPRECATED\n        uint256 gardenFromDepositAt; // DEPRECATED\n        uint256 gardenLastDepositAt; // DEPRECATED\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController private controller;\n\n    // BABL Token contract\n    TimeLockedToken private babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal)\n    // in all ongoing strategies during mining program.\n    uint256 private miningProtocolPrincipal; // Protocol principal (only related to mining program)\n    mapping(uint256 => ProtocolPerTimestamp) private protocolPerTimestamp; // DEPRECATED\n    uint256[] private timeList; // DEPRECATED\n    uint256 private miningProtocolPower; // Mining protocol power along the time\n\n    // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => ProtocolPerQuarter) private protocolPerQuarter;\n    // Check if the protocol per quarter data has been initialized\n    mapping(uint256 => bool) private isProtocolPerQuarter;\n\n    mapping(address => mapping(uint256 => uint256)) private rewardsPowerOverhead; // DEPRECATED\n    // Contributor power control\n    // Contributor details per garden\n    mapping(address => mapping(address => ContributorPerGarden)) private contributorPerGarden;\n    mapping(address => mapping(address => Checkpoints)) private checkpoints; // DEPRECATED\n    // Garden power control\n    // Garden power details per garden. Updated info after beta will be only at position [0]\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) private gardenPowerByTimestamp;\n    mapping(address => uint256[]) private gardenTimelist; // DEPRECATED, but still needed during beta gardens migration\n    mapping(address => uint256) private gardenPid; // DEPRECATED, but still needed during beta gardens migration\n\n    struct StrategyPerQuarter {\n        // Acumulated strategy power per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 betaInitializedAt; // Only used for beta strategies\n        uint256 quarterPower; //  Accumulated strategy power for each quarter\n        bool initialized; // True if the strategy has checkpoints in that quarter already\n    }\n    struct StrategyPricePerTokenUnit {\n        // Take control over the price per token changes along the time when normalizing into DAI\n        uint256 preallocated; // Strategy capital preallocated before each checkpoint\n        uint256 pricePerTokenUnit; // Last average price per allocated tokens per strategy normalized into DAI\n    }\n    // Acumulated strategy power per each quarter along the time\n    mapping(address => mapping(uint256 => StrategyPerQuarter)) private strategyPerQuarter;\n    // Pro-rata oracle price allowing re-allocations and unwinding of any capital value\n    mapping(address => StrategyPricePerTokenUnit) private strategyPricePerTokenUnit;\n\n    // Reentrancy guard countermeasure\n    uint256 private status;\n\n    // Customized profit sharing (if any)\n    // [0]: _strategistProfit , [1]: _stewardsProfit, [2]: _lpProfit\n    mapping(address => uint256[3]) private gardenProfitSharing;\n    mapping(address => bool) private gardenCustomProfitSharing;\n\n    uint256 private miningUpdatedAt; // Timestamp of last strategy capital update\n    mapping(address => uint256) private strategyPrincipal; // Last known strategy principal normalized into DAI\n\n    // Only for beta gardens and users as they need migration into new gas-optimized data structure\n    // Boolean check to control users and garden migration into to new mapping architecture without checkpoints\n    mapping(address => mapping(address => bool)) private betaUserMigrated; // DEPRECATED\n    mapping(address => bool) private betaGardenMigrated; // DEPRECATED\n\n    uint256 private bablProfitWeight;\n    uint256 private bablPrincipalWeight;\n\n    /* ============ Constructor ============ */\n\n    function initialize(TimeLockedToken _bablToken, IBabController _controller) public {\n        OwnableUpgradeable.__Ownable_init();\n        _require(address(_bablToken) != address(0) && address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        babltoken = _bablToken;\n        controller = _controller;\n\n        profitProtocolFee = controller.protocolPerformanceFee();\n\n        strategistProfitPercentage = 10e16; // 10%\n        stewardsProfitPercentage = 5e16; // 5%\n        lpsProfitPercentage = 80e16; // 80%\n\n        strategistBABLPercentage = 10e16; // 10%\n        stewardsBABLPercentage = 10e16; // 10%\n        lpsBABLPercentage = 80e16; // 80%\n        gardenCreatorBonus = 10e16; // 10%\n\n        bablProfitWeight = 65e16; // 65%\n        bablPrincipalWeight = 35e16; // 35%\n\n        status = NOT_ENTERED;\n        // We start BABL rewards as they were started by bip#1\n        START_TIME = block.timestamp;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Function that adds/substract the capital received to the total principal of the protocol per timestamp\n     * @param _capital                Amount of capital in any type of asset to be normalized into DAI\n     * @param _addOrSubstract         Whether we are adding or substracting capital\n     */\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) external override {\n        _onlyStrategy(msg.sender);\n        // All strategies are now part of the Mining Program\n        _updateProtocolPrincipal(msg.sender, _capital, _addOrSubstract);\n    }\n\n    /**\n     * PRIVILEGE FUNCTION to update strategy data\n     * @param _strategy               Address of the strategy\n     * @param _capital                Amount of capital in any type of asset to be normalized into DAI\n     * @param _addOrSubstract         Whether we are adding or substracting capital\n     */\n    function updateStrategyCheckpoint(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) external override onlyOwner {\n        _onlyUnpaused();\n        _onlyStrategy(_strategy);\n        _updateProtocolPrincipal(_strategy, _capital, _addOrSubstract);\n    }\n\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _previousSupply,\n        uint256 _tokenDiff,\n        bool _addOrSubstract\n    ) external override nonReentrant {\n        _require(IBabController(controller).isGarden(msg.sender), Errors.ONLY_ACTIVE_GARDEN);\n        uint256 newSupply = _addOrSubstract ? _previousSupply.add(_tokenDiff) : _previousSupply.sub(_tokenDiff);\n        uint256 newBalance = _addOrSubstract ? _previousBalance.add(_tokenDiff) : _previousBalance.sub(_tokenDiff);\n        // End of temporal beta migrations for users and gardens\n        _updateGardenPower(_garden, _previousSupply, newSupply);\n        _updateContributorPower(_garden, _contributor, _previousBalance, newBalance);\n    }\n\n    /**\n     * Sends BABL tokens rewards to a contributor after a claim is requested to the protocol.\n     * @param _to                Address to send the tokens to\n     * @param _amount            Amount of tokens to send the address to\n     * returns the amount of tokens transferred\n     */\n    function sendTokensToContributor(address _to, uint256 _amount) external override nonReentrant returns (uint256) {\n        _onlyUnpaused();\n        // Restrictive only to gardens when claiming BABL\n        _require(IBabController(controller).isGarden(msg.sender), Errors.ONLY_ACTIVE_GARDEN);\n        uint96 amount = Safe3296.safe96(_amount, 'overflow 96 bits');\n        return _safeBABLTransfer(_to, amount);\n    }\n\n    /**\n     * Set customized profit shares for a specific garden by the gardener\n     * @param _garden               Address of the garden\n     * @param _strategistShare      New % of strategistShare\n     * @param _stewardsShare        New % of stewardsShare\n     * @param _lpShare              New % of lpShare\n     */\n    function setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) external override {\n        _onlyController();\n        _require(IBabController(controller).isGarden(_garden), Errors.ONLY_ACTIVE_GARDEN);\n        _setProfitRewards(_garden, _strategistShare, _stewardsShare, _lpShare);\n    }\n\n    /**\n     * Change default BABL shares % by the governance\n     * @param _strategistShare      New % of BABL strategist share\n     * @param _stewardsShare        New % of BABL stewards share\n     * @param _lpShare              New % of BABL lp share\n     * @param _creatorBonus         New % of creator bonus\n     * @param _profitWeight         New % of profit weigth for strategy rewards\n     * @param _principalWeight      New % of principal weigth for strategy rewards\n     */\n    function setBABLMiningParameters(\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare,\n        uint256 _creatorBonus,\n        uint256 _profitWeight,\n        uint256 _principalWeight\n    ) external override onlyOwner {\n        _require(\n            _strategistShare.add(_stewardsShare).add(_lpShare) == 1e18 &&\n                _creatorBonus <= 1e18 &&\n                _profitWeight.add(_principalWeight) == 1e18,\n            Errors.INVALID_MINING_VALUES\n        );\n        strategistBABLPercentage = _strategistShare;\n        stewardsBABLPercentage = _stewardsShare;\n        lpsBABLPercentage = _lpShare;\n        gardenCreatorBonus = _creatorBonus;\n        bablProfitWeight = _profitWeight;\n        bablPrincipalWeight = _principalWeight;\n    }\n\n    /* ========== View functions ========== */\n\n    /**\n     * Calculates the profits and BABL that a contributor should receive from a series of finalized strategies\n     * @param _garden                   Garden to which the strategies and the user must belong to\n     * @param _contributor              Address of the contributor to check\n     * @param _finalizedStrategies      List of addresses of the finalized strategies to check\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view override returns (uint256[] memory) {\n        _require(IBabController(controller).isGarden(address(_garden)), Errors.ONLY_ACTIVE_GARDEN);\n        uint256[] memory totalRewards = new uint256[](8);\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        (, initialDepositAt, claimedAt, , , , , , , ) = IGarden(_garden).getContributor(_contributor);\n        for (uint256 i = 0; i < _finalizedStrategies.length; i++) {\n            // Security check\n            _require(IGarden(_garden).isGardenStrategy(_finalizedStrategies[i]), Errors.STRATEGY_GARDEN_MISMATCH);\n\n            uint256[] memory tempRewards = new uint256[](8);\n\n            tempRewards = _getStrategyProfitsAndBABL(\n                _garden,\n                _finalizedStrategies[i],\n                _contributor,\n                initialDepositAt,\n                claimedAt\n            );\n            totalRewards[0] = totalRewards[0].add(tempRewards[0]);\n            totalRewards[1] = totalRewards[1].add(tempRewards[1]);\n            totalRewards[2] = totalRewards[2].add(tempRewards[2]);\n            totalRewards[3] = totalRewards[3].add(tempRewards[3]);\n            totalRewards[4] = totalRewards[4].add(tempRewards[4]);\n            totalRewards[5] = totalRewards[5].add(tempRewards[5]);\n            totalRewards[6] = totalRewards[6].add(tempRewards[6]);\n            totalRewards[7] = totalRewards[7].add(tempRewards[7]);\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * Gets the total amount of rewards for a given strategy\n     * @param _strategy                Strategy to check\n     */\n    function getStrategyRewards(address _strategy) external view override returns (uint96) {\n        IStrategy strategy = IStrategy(_strategy);\n        // ts[0]: executedAt, ts[1]: exitedAt, ts[2]: updatedAt\n        uint256[] memory ts = new uint256[](3);\n        (, , , , ts[0], ts[1], ts[2]) = strategy.getStrategyState();\n        _require(ts[1] != 0, Errors.STRATEGY_IS_NOT_OVER_YET);\n        if ((strategy.enteredAt() >= START_TIME || ts[1] >= START_TIME) && START_TIME != 0) {\n            // We avoid gas consuming once a strategy got its BABL rewards during its finalization\n            uint256 rewards = strategy.strategyRewards();\n            if (rewards != 0) {\n                return Safe3296.safe96(rewards, 'overflow 96 bits');\n            }\n            // str[0]: capitalAllocated, str[1]: capitalReturned\n            uint256[] memory str = new uint256[](2);\n            (, , , , , , str[0], str[1], , , , , , ) = strategy.getStrategyDetails();\n            // If the calculation was not done earlier we go for it\n            (uint256 numQuarters, uint256 startingQuarter) = _getRewardsWindow(ts[0], ts[1]);\n            uint256 percentage = 1e18;\n\n            for (uint256 i = 0; i < numQuarters; i++) {\n                // Initialization timestamp at the end of the first slot where the strategy starts its execution\n                uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION));\n                // We calculate each epoch\n                uint256 strategyPower = strategyPerQuarter[_strategy][startingQuarter.add(i)].quarterPower;\n                uint256 protocolPower = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n                _require(strategyPower <= protocolPower, Errors.OVERFLOW_IN_POWER);\n                if (i.add(1) == numQuarters) {\n                    // last quarter - we need to take proportional supply for that timeframe despite\n                    // the epoch has not finished yet\n                    percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                        slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                    );\n                }\n                uint256 rewardsPerQuarter =\n                    strategyPower\n                        .preciseDiv(protocolPower)\n                        .preciseMul(uint256(_tokenSupplyPerQuarter(startingQuarter.add(i))))\n                        .preciseMul(percentage);\n                rewards = rewards.add(rewardsPerQuarter);\n            }\n            // Governance has decided to have different weights for principal and profit\n            // Profit weight must be higher than principal\n            // profitWeight + principalWeight must always sum 1e18 (100%)\n            // PercentageProfit must always have 18 decimals (capital returned by capital allocated)\n            uint256 percentageProfit = str[1].preciseDiv(str[0]);\n            // Set the max cap bonus x2\n            uint256 maxRewards = rewards.preciseMul(2e18);\n            // Apply rewards weight related to principal and profit\n            rewards = rewards.preciseMul(bablPrincipalWeight).add(\n                rewards.preciseMul(bablProfitWeight).preciseMul(percentageProfit)\n            );\n            // Check max cap\n            if (rewards >= maxRewards) {\n                rewards = maxRewards;\n            }\n            return Safe3296.safe96(rewards, 'overflow 96 bits');\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Gets the contributor power from one timestamp to the other\n     * @param _garden      Address of the garden where the contributor belongs to\n     * @param _contributor Address of the contributor\n     * @param _time        Timestamp to check power\n     * @return uint256     Contributor power during that period\n     */\n    function getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _time\n    ) public view override returns (uint256) {\n        // Check to avoid out of bounds\n        _require(_time >= IGarden(_garden).gardenInitializedAt(), Errors.CONTRIBUTOR_POWER_CHECK_WINDOW);\n        uint256[] memory powerData = new uint256[](9);\n        // powerData[0]: lastDepositAt (contributor)\n        // powerData[1]: initialDepositAt (contributor)\n        // powerData[2]: balance (contributor)\n        // powerData[3]: power (contributor)\n        // powerData[4]: avgBalance (contributor)\n        // powerData[5]: lastDepositAt (garden)\n        // powerData[6]: accGardenPower (garden)\n        // powerData[7]: avgGardenBalance (garden)\n        // powerData[8]: totalSupply (garden)\n        powerData = _getGardenAndContributor(_garden, _contributor);\n        if (powerData[1] == 0 || powerData[1] > _time || powerData[2] == 0) {\n            return 0;\n        } else {\n            // Safe check to avoid underflow, time travel only works for a past date\n            if (_time > block.timestamp) {\n                _time = block.timestamp;\n            }\n            // First we need to get an updatedValue of user and garden power since lastDeposits as of block.timestamp\n            uint256 updatedPower = powerData[3].add((block.timestamp.sub(powerData[0])).mul(powerData[2]));\n            uint256 updatedGardenPower = powerData[6].add((block.timestamp.sub(powerData[5])).mul(powerData[8]));\n            // We then time travel back to when the strategy exitedAt\n            // Calculate the power at \"_to\" timestamp\n            uint256 timeDiff = block.timestamp.sub(_time);\n            uint256 userPowerDiff = powerData[4].mul(timeDiff);\n            uint256 gardenPowerDiff = powerData[7].mul(timeDiff);\n            // Avoid underflow conditions 0 at user, 1 at garden\n            updatedPower = updatedPower > userPowerDiff ? updatedPower.sub(userPowerDiff) : 0;\n            updatedGardenPower = updatedGardenPower > gardenPowerDiff ? updatedGardenPower.sub(gardenPowerDiff) : 1;\n            uint256 virtualPower = updatedPower.preciseDiv(updatedGardenPower);\n            if (virtualPower > 1e18) {\n                virtualPower = 1e18; // Overflow limit\n            }\n            return virtualPower;\n        }\n    }\n\n    /**\n     * Check the mining program state for a specific quarter and strategy\n     * @param _quarterNum      Number of quarter\n     * @param _strategy        Address of strategy\n     */\n\n    function checkMining(uint256 _quarterNum, address _strategy)\n        external\n        view\n        override\n        returns (uint256[] memory, bool[] memory)\n    {\n        uint256[] memory miningData = new uint256[](10);\n        bool[] memory miningBool = new bool[](2);\n        miningData[0] = START_TIME;\n        miningData[1] = miningUpdatedAt;\n        miningData[2] = miningProtocolPrincipal;\n        miningData[3] = miningProtocolPower;\n        miningData[4] = protocolPerQuarter[_quarterNum].quarterPower;\n        miningData[5] = strategyPrincipal[_strategy];\n        miningData[6] = strategyPricePerTokenUnit[_strategy].preallocated;\n        miningData[7] = strategyPricePerTokenUnit[_strategy].pricePerTokenUnit;\n        miningData[8] = strategyPerQuarter[_strategy][_quarterNum].quarterPower;\n        miningData[9] = _tokenSupplyPerQuarter(_quarterNum);\n        miningBool[0] = isProtocolPerQuarter[_quarterNum];\n        miningBool[1] = strategyPerQuarter[_strategy][_quarterNum].initialized;\n        return (miningData, miningBool);\n    }\n\n    /**\n     * Get contributor data per garden\n     * @param _garden       Address of the garden\n     * @param _contributor  Address of contributor\n     */\n\n    function getContributorPerGarden(address _garden, address _contributor)\n        external\n        view\n        override\n        returns (uint256[] memory, bool[] memory)\n    {\n        uint256[] memory contributorData = new uint256[](12);\n        bool[] memory contributorBool = new bool[](2);\n        ContributorPerGarden storage contributor = contributorPerGarden[_garden][_contributor];\n        TimestampContribution storage contributorDetail = contributor.tsContributions[0];\n        GardenPowerByTimestamp storage garden = gardenPowerByTimestamp[_garden][0];\n\n        contributorData[0] = contributor.lastDepositAt;\n        contributorData[1] = contributor.initialDepositAt;\n        contributorData[2] = contributor.pid;\n        contributorData[3] = contributorDetail.avgBalance;\n        contributorData[4] = ERC20(_garden).balanceOf(_contributor);\n        contributorData[5] = contributorDetail.power;\n        contributorData[6] = contributorDetail.timestamp;\n        contributorData[7] = contributorDetail.timePointer;\n        contributorData[8] = gardenPid[_garden];\n        contributorData[9] = garden.avgGardenBalance;\n        contributorData[10] = garden.lastDepositAt;\n        contributorData[11] = garden.accGardenPower;\n        contributorBool[0] = betaGardenMigrated[_garden];\n        contributorBool[1] = betaUserMigrated[_garden][_contributor];\n\n        return (contributorData, contributorBool);\n    }\n\n    /**\n     * Check the garden profit sharing % if different from default\n     * @param _garden     Address of the garden\n     */\n    function getGardenProfitsSharing(address _garden) external view override returns (uint256[3] memory) {\n        if (gardenCustomProfitSharing[_garden]) {\n            // It has customized values\n            return gardenProfitSharing[_garden];\n        } else {\n            return [strategistProfitPercentage, stewardsProfitPercentage, lpsProfitPercentage];\n        }\n    }\n\n    /**\n     * Returns the percentages of BABL Mining program\n     *\n     * @return   Strategist, Stewards, Lps, creator bonus, bablProfit weight, babl principal weigth\n     *\n     */\n    function getBABLMiningParameters()\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            strategistBABLPercentage,\n            stewardsBABLPercentage,\n            lpsBABLPercentage,\n            gardenCreatorBonus,\n            bablProfitWeight,\n            bablPrincipalWeight\n        );\n    }\n\n    /**\n     * Get an estimation of user rewards for active strategies\n     * @param _strategy        Address of the strategy to estimate BABL rewards\n     * @param _contributor     Address of the garden contributor\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function estimateUserRewards(address _strategy, address _contributor)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        uint256[] memory rewards = new uint256[](8);\n        if (IStrategy(_strategy).isStrategyActive()) {\n            address garden = address(IStrategy(_strategy).garden());\n            (address strategist, uint256[] memory strategyDetails, bool[] memory profitData) =\n                _estimateStrategyRewards(_strategy);\n            // Get the contributor power until the the strategy exit timestamp\n            uint256 contributorPower =\n                getContributorPower(\n                    garden,\n                    _contributor,\n                    strategyDetails[1] == 0 ? block.timestamp : strategyDetails[1]\n                );\n            rewards = _getRewardsPerRole(\n                garden,\n                _strategy,\n                strategist,\n                _contributor,\n                contributorPower,\n                strategyDetails,\n                profitData\n            );\n        }\n        return rewards;\n    }\n\n    /**\n     * Get an estimation of strategy BABL rewards for active strategies in the mining program\n     * @param _strategy        Address of the strategy to estimate BABL rewards\n     * @return the estimated BABL rewards\n     */\n    function estimateStrategyRewards(address _strategy) external view override returns (uint256) {\n        if (IStrategy(_strategy).isStrategyActive()) {\n            (, uint256[] memory strategyDetails, ) = _estimateStrategyRewards(_strategy);\n            return strategyDetails[9];\n        } else {\n            return 0;\n        }\n    }\n\n    /* ============ Internal Functions ============ */\n    /**\n     * Update the protocol principal checkpoints\n     * @param _strategy         Strategy which is adding/removing principal\n     * @param _capital          Capital to update\n     * @param _addOrSubstract   Adding (true) or removing (false)\n     */\n    function _updateProtocolPrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) internal {\n        address reserveAsset = IGarden(IStrategy(_strategy).garden()).reserveAsset();\n        // To compare strategy power between all strategies we normalize their capital into DAI\n        // Then, we need to take control of getPrice fluctuations along the time\n        uint256 pricePerTokenUnit = _getStrategyPricePerTokenUnit(reserveAsset, _strategy, _capital, _addOrSubstract);\n        _capital = _capital.preciseMul(pricePerTokenUnit).mul(10**uint256(18).sub(ERC20(reserveAsset).decimals()));\n        // Create or/and update the protocol quarter checkpoints if mining program is activated\n        _updateProtocolPowerPerQuarter();\n        // We update the strategy power per quarter normalized in DAI if mining program is activated\n        _updateStrategyPowerPerQuarter(_strategy);\n        // The following function call _updatePrincipal must be always executed\n        // after _updateProtocolPowerPerQuarter and _updateStrategyPowerPerQuarter\n        _updatePrincipal(_strategy, _capital, _addOrSubstract);\n        // The following time set should always be executed at the end\n        miningUpdatedAt = block.timestamp;\n    }\n\n    /**\n     * Update the principal considered part of the mining program either Protocol or Strategies\n     * @param _strategy         Strategy address\n     * @param _capital          Capital normalized into DAI to add or substract for accurate\n     * comparisons between strategies\n     * @param _addOrSubstract   Whether or not we are adding or unwinding capital to the strategy under mining\n     */\n    function _updatePrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private {\n        if (_addOrSubstract == false) {\n            // Substracting capital\n            // Failsafe condition\n            uint256 amount = _capital > strategyPrincipal[_strategy] ? strategyPrincipal[_strategy] : _capital;\n            miningProtocolPrincipal = miningProtocolPrincipal.sub(amount);\n            strategyPrincipal[_strategy] = strategyPrincipal[_strategy].sub(amount);\n        } else {\n            // Adding capital\n            miningProtocolPrincipal = miningProtocolPrincipal.add(_capital);\n            strategyPrincipal[_strategy] = strategyPrincipal[_strategy].add(_capital);\n        }\n    }\n\n    /**\n     * Update the garden power whenever there is a deposit or withdraw\n     * @param _garden           Address of the garden\n     * @param _previousSupply   Previous garden token supply before minting or burning new user tokens\n     */\n    function _updateGardenPower(\n        address _garden,\n        uint256 _previousSupply,\n        uint256 _newSupply\n    ) internal {\n        // We select timestamp [0] to persist the garden power data as we deprecated checkpoints\n        GardenPowerByTimestamp storage gardenPower = gardenPowerByTimestamp[_garden][0];\n        // The very first deposit takes 0 of power in a garden as power is principal x time and time is 0\n        // Power is updated by usign previous totalSupply (before the new mint or burn which is just done\n        // as part of deposit/withdraw op)\n        gardenPower.accGardenPower = gardenPower.lastDepositAt == 0\n            ? 0\n            : gardenPower.accGardenPower.add((block.timestamp.sub(gardenPower.lastDepositAt)).mul(_previousSupply));\n        // The following call should always go after minting new tokens\n        // The reason is that we need an updated totalSupply to update avg garden balance\n        gardenPower.avgGardenBalance = gardenPower.lastDepositAt == 0\n            ? _newSupply\n            : (\n                gardenPower.avgGardenBalance.mul(block.timestamp.sub(IGarden(_garden).gardenInitializedAt())).add(\n                    _newSupply\n                )\n            )\n                .div(block.timestamp.sub(IGarden(_garden).gardenInitializedAt()));\n\n        gardenPower.lastDepositAt = block.timestamp;\n\n        if (_newSupply == 0) {\n            // reset Garden power if all funds are removed\n            gardenPower.lastDepositAt = 0;\n            gardenPower.avgGardenBalance = 0;\n            gardenPower.accGardenPower = 0;\n        }\n    }\n\n    /**\n     * Update the contributor power whenever there is a deposit or withdraw\n     * @param _garden           Address of the garden\n     * @param _contributor      Address of the contributor\n     * @param _previousBalance  Previous balance the user had before minting or burning new tokens\n     */\n\n    function _updateContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _newBalance\n    ) internal {\n        ContributorPerGarden storage contributor = contributorPerGarden[_garden][_contributor];\n        // We select timestamp [0] to persist the contributor power data as we deprecated checkpoints\n        TimestampContribution storage contributorDetail = contributor.tsContributions[0];\n        // The very first deposit takes 0 of power\n        // Power is updated by usign previous balance (before the new mint or burn which is\n        // just done as part of this deposit/withdraw op)\n        // Its power is proportional to the time passed by the previous supply during that time\n        contributorDetail.power = contributor.lastDepositAt == 0\n            ? 0\n            : contributorDetail.power.add((block.timestamp.sub(contributor.lastDepositAt)).mul(_previousBalance));\n        // The following call should always go after minting new tokens\n        // The reason is that we need an updated user balance to update avg contributor balance\n        // The new balance of the user takes care of the sharePrice so we use garden tokens count for power\n        contributorDetail.avgBalance = contributor.lastDepositAt == 0\n            ? _newBalance\n            : (contributorDetail.avgBalance.mul(block.timestamp.sub(contributor.initialDepositAt)).add(_newBalance))\n                .div(block.timestamp.sub(contributor.initialDepositAt));\n        // Initial Deposit\n        if (_previousBalance == 0 || contributor.initialDepositAt == 0) {\n            contributor.initialDepositAt = block.timestamp;\n        }\n        contributor.lastDepositAt = block.timestamp;\n\n        // Check for withdrawals of full capital\n        if (_newBalance == 0) {\n            contributor.lastDepositAt = 0;\n            contributor.initialDepositAt = 0;\n            contributorDetail.avgBalance = 0;\n            contributorDetail.power = 0;\n            delete contributor.timeListPointer; // Backward compatible\n        }\n    }\n\n    /**\n     * Get the price per token to be used in the adding or substraction normalized to DAI (supports multiple asset)\n     * @param _reserveAsset     Garden reserve asset address\n     * @param _strategy         Strategy address\n     * @param _capital          Capital in reserve asset to add or substract\n     * @param _addOrSubstract   Whether or not we are adding or unwinding capital to the strategy\n     * @return pricePerToken value\n     */\n    function _getStrategyPricePerTokenUnit(\n        address _reserveAsset,\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private returns (uint256) {\n        // Normalizing into DAI\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 pricePerTokenUnit = oracle.getPrice(_reserveAsset, DAI);\n        StrategyPricePerTokenUnit storage strPpt = strategyPricePerTokenUnit[_strategy];\n        if (strPpt.preallocated == 0) {\n            // First adding checkpoint\n            strPpt.preallocated = _capital;\n            strPpt.pricePerTokenUnit = pricePerTokenUnit;\n            return pricePerTokenUnit;\n        } else {\n            // We are controlling pair reserveAsset-DAI fluctuations along the time\n            if (_addOrSubstract) {\n                strPpt.pricePerTokenUnit = (\n                    ((strPpt.pricePerTokenUnit.mul(strPpt.preallocated)).add(_capital.mul(pricePerTokenUnit))).div(1e18)\n                )\n                    .preciseDiv(strPpt.preallocated.add(_capital));\n                strPpt.preallocated = strPpt.preallocated.add(_capital);\n            } else {\n                // We use the previous pricePerToken in a substract instead of a new price\n                // (as allocated capital used previous prices not the current one)\n                // Failsafe condition\n                uint256 amount = _capital > strPpt.preallocated ? strPpt.preallocated : _capital;\n                strPpt.preallocated = strPpt.preallocated.sub(amount);\n            }\n            return strPpt.pricePerTokenUnit;\n        }\n    }\n\n    /**\n     * Add protocol power timestamps for each quarter\n     */\n    function _updateProtocolPowerPerQuarter() private {\n        uint256[] memory data = new uint256[](4);\n        // data[0]: previous quarter, data[1]: current quarter, data[2]: timeDifference, data[3]: debtPower\n        data[0] = miningUpdatedAt == 0 ? 1 : _getQuarter(miningUpdatedAt);\n        data[1] = _getQuarter(block.timestamp);\n        data[2] = block.timestamp.sub(miningUpdatedAt);\n        ProtocolPerQuarter storage protocolCheckpoint = protocolPerQuarter[data[1]];\n        data[3] = miningUpdatedAt == 0 ? 0 : miningProtocolPrincipal.mul(data[2]);\n        if (!isProtocolPerQuarter[data[1]]) {\n            // The quarter is not initialized yet, we then create it\n            if (miningUpdatedAt > 0) {\n                // A new epoch has started with either a new strategy execution or finalization checkpoint\n                if (data[0] == data[1].sub(1)) {\n                    // There were no intermediate epoch without checkpoints, we are in the next epoch\n                    // We need to divide the debtPower between previous epoch and current epoch\n                    // We re-initialize the protocol power in the new epoch adding only the corresponding\n                    // to its duration\n                    protocolCheckpoint.quarterPower = data[3]\n                        .mul(block.timestamp.sub(START_TIME.add(data[1].mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                        .div(data[2]);\n                    // We now update the previous quarter with its proportional pending debtPower\n                    protocolPerQuarter[data[1].sub(1)].quarterPower = protocolPerQuarter[data[1].sub(1)]\n                        .quarterPower\n                        .add(data[3].sub(protocolCheckpoint.quarterPower));\n                } else {\n                    // There were some intermediate epochs without checkpoints - we need to create\n                    // missing checkpoints and update the last (current) one.\n                    // We have to update all the quarters since last update\n                    for (uint256 i = 0; i <= data[1].sub(data[0]); i++) {\n                        ProtocolPerQuarter storage newCheckpoint = protocolPerQuarter[data[0].add(i)];\n                        uint256 slotEnding = START_TIME.add(data[0].add(i).mul(EPOCH_DURATION));\n                        if (i == 0) {\n                            // We are in the first quarter to update (corresponding to miningUpdatedAt timestamp)\n                            // We add the corresponding proportional part\n                            newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                                data[3].mul(slotEnding.sub(miningUpdatedAt)).div(data[2])\n                            );\n                        } else if (i < data[1].sub(data[0])) {\n                            // We are in an intermediate quarter without checkpoints - need to create and update it\n                            newCheckpoint.quarterPower = data[3].mul(EPOCH_DURATION).div(data[2]);\n                        } else {\n                            // We are in the last (current) quarter\n                            // We update its proportional remaining debt power\n                            protocolCheckpoint.quarterPower = data[3]\n                                .mul(\n                                block.timestamp.sub(START_TIME.add(data[1].mul(EPOCH_DURATION).sub(EPOCH_DURATION)))\n                            )\n                                .div(data[2]);\n                        }\n                    }\n                }\n            }\n            isProtocolPerQuarter[data[1]] = true;\n        } else {\n            // Quarter checkpoint already created\n            // We update the power of the quarter by adding the new difference between last quarter\n            // checkpoint and this checkpoint\n            protocolCheckpoint.quarterPower = protocolCheckpoint.quarterPower.add(data[3]);\n            miningProtocolPower = miningProtocolPower.add(data[3]);\n        }\n    }\n\n    /**\n     * Updates the strategy power per quarter for rewards calculations of each strategy out of the whole protocol\n     * @param _strategy    Strategy address\n     */\n    function _updateStrategyPowerPerQuarter(address _strategy) private {\n        uint256[] memory data = new uint256[](5);\n        // data[0]: executedAt, data[1]: updatedAt, data[2]: time difference, data[3]: quarter, data[4]: debtPower\n        (, , , , data[0], , data[1]) = IStrategy(_strategy).getStrategyState();\n        if (data[1] < START_TIME) {\n            // We check the initialization only for beta gardens, quarter = 1\n            StrategyPerQuarter storage betaStrategyCheckpoint = strategyPerQuarter[_strategy][1];\n            if (betaStrategyCheckpoint.betaInitializedAt == 0) {\n                betaStrategyCheckpoint.betaInitializedAt = block.timestamp;\n            }\n            // Only for strategies starting before mining and still executing, get proportional\n            // Exited strategies before the mining starts, are not eligible of this standard setup\n            data[1] = betaStrategyCheckpoint.betaInitializedAt;\n        }\n        data[2] = block.timestamp.sub(data[1]);\n        data[3] = _getQuarter(block.timestamp);\n        StrategyPerQuarter storage strategyCheckpoint = strategyPerQuarter[_strategy][data[3]];\n        // We calculate the debt Power since last checkpoint (if any)\n        data[4] = strategyPrincipal[_strategy].mul(data[2]);\n        if (!strategyCheckpoint.initialized) {\n            // The strategy quarter is not yet initialized then we create it\n            // If it the first checkpoint in the first executing epoch - keep power 0\n            if (data[3] > _getQuarter(data[0])) {\n                // Each time a running strategy has a new checkpoint on a new (different) epoch than\n                // previous checkpoints.\n                // debtPower is the proportional power of the strategy for this quarter from previous checkpoint\n                // We need to iterate since last checkpoint\n                (uint256 numQuarters, uint256 startingQuarter) = _getRewardsWindow(data[1], block.timestamp);\n\n                // There were intermediate epochs without checkpoints - we need to create their corresponding\n                //  checkpoints and update the last one\n                // We have to update all the quarters including where the previous checkpoint is and\n                // the one where we are now\n                for (uint256 i = 0; i < numQuarters; i++) {\n                    StrategyPerQuarter storage newCheckpoint = strategyPerQuarter[_strategy][startingQuarter.add(i)];\n                    uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION));\n                    if (i == 0) {\n                        // We are in the first quarter to update, we add the proportional pending part\n                        newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                            data[4].mul(slotEnding.sub(data[1])).div(data[2])\n                        );\n                    } else if (i > 0 && i.add(1) < numQuarters) {\n                        // We are updating an intermediate quarter\n                        newCheckpoint.quarterPower = data[4].mul(EPOCH_DURATION).div(data[2]);\n                        newCheckpoint.initialized = true;\n                    } else {\n                        // We are updating the current quarter of this strategy checkpoint\n                        newCheckpoint.quarterPower = data[4]\n                            .mul(block.timestamp.sub(START_TIME.add(data[3].mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                            .div(data[2]);\n                    }\n                }\n            }\n            strategyCheckpoint.initialized = true;\n        } else {\n            // We are in the same quarter than previous checkpoints for this strategy\n            // We update the power of the quarter by adding the new difference between\n            // last quarter checkpoint and this checkpoint\n            strategyCheckpoint.quarterPower = strategyCheckpoint.quarterPower.add(data[4]);\n        }\n    }\n\n    /**\n     * Safe BABL rewards (Mining program) token transfer.\n     * It handle cases when in case of rounding errors, RewardsDistributor might not have enough BABL.\n     * @param _to               The receiver address of the contributor to send\n     * @param _amount           The amount of BABL tokens to be rewarded during this claim\n     * returns the amount of tokens transferred\n     */\n    function _safeBABLTransfer(address _to, uint96 _amount) private returns (uint256) {\n        uint256 bablBal = babltoken.balanceOf(address(this));\n        uint256 amountToSend = _amount > bablBal ? bablBal : _amount;\n        SafeERC20.safeTransfer(babltoken, _to, amountToSend);\n        return amountToSend;\n    }\n\n    /**\n     * Set a customized profit rewards\n     * @param _garden           Address of the garden\n     * @param _strategistShare  New sharing profit % for strategist\n     * @param _stewardsShare    New sharing profit % for stewards\n     * @param _lpShare          New sharing profit % for lp\n     */\n    function _setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) internal {\n        _require(_strategistShare.add(_stewardsShare).add(_lpShare) == 95e16, Errors.PROFIT_SHARING_MISMATCH);\n        // [0]: _strategistProfit , [1]: _stewardsProfit, [2]: _lpProfit\n        if (\n            _strategistShare != strategistProfitPercentage ||\n            _stewardsShare != stewardsProfitPercentage ||\n            _lpShare != lpsProfitPercentage\n        ) {\n            // Different from standard %\n            gardenCustomProfitSharing[_garden] = true;\n            gardenProfitSharing[_garden][0] = _strategistShare;\n            gardenProfitSharing[_garden][1] = _stewardsShare;\n            gardenProfitSharing[_garden][2] = _lpShare;\n        }\n    }\n\n    /**\n     * Get an estimation of user rewards for active strategies\n     * @param _garden               Address of the garden\n     * @param _strategy             Address of the strategy to estimate rewards\n     * @param _strategist           Address of the strategist\n     * @param _contributor          Address of the garden contributor\n     * @param _contributorPower     Contributor power in a specific time\n     * @param _strategyDetails      Details of the strategy in that specific moment\n     * @param _profitData           Array of profit Data (if profit as well distance)\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function _getRewardsPerRole(\n        address _garden,\n        address _strategy,\n        address _strategist,\n        address _contributor,\n        uint256 _contributorPower,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) internal view returns (uint256[] memory) {\n        uint256[] memory rewards = new uint256[](8);\n        // Get strategist BABL rewards in case the contributor is also the strategist of the strategy\n        rewards[0] = _strategist == _contributor ? _getStrategyStrategistBabl(_strategyDetails, _profitData) : 0;\n        // Get strategist profit\n        rewards[1] = (_strategist == _contributor && _profitData[0] == true)\n            ? _getStrategyStrategistProfits(_garden, _strategyDetails[10])\n            : 0;\n        // Get steward rewards\n        rewards[2] = _getStrategyStewardBabl(_strategy, _contributor, _strategyDetails, _profitData);\n        // If not profits _getStrategyStewardsProfits should not execute\n        rewards[3] = _profitData[0] == true\n            ? _getStrategyStewardProfits(_garden, _strategy, _contributor, _strategyDetails, _profitData)\n            : 0;\n        // Get LP rewards\n        // Contributor power is fluctuating along the way for each new deposit\n        rewards[4] = _getStrategyLPBabl(_strategyDetails[9], _contributorPower);\n        // Total BABL including creator bonus (if any)\n        rewards[5] = _getCreatorBonus(_garden, _contributor, rewards[0].add(rewards[2]).add(rewards[4]));\n        // Total profit\n        rewards[6] = rewards[1].add(rewards[3]);\n        // Creator bonus\n        rewards[7] = rewards[5] > (rewards[0].add(rewards[2]).add(rewards[4]))\n            ? rewards[5].sub(rewards[0].add(rewards[2]).add(rewards[4]))\n            : 0;\n        return rewards;\n    }\n\n    /* ========== Internal View functions ========== */\n\n    /**\n     * Get the rewards for a specific contributor activately contributing in strategies of a specific garden\n     * @param _garden               Garden address responsible of the strategies to calculate rewards\n     * @param _strategy             Strategy address\n     * @param _contributor          Contributor address\n     * @param _initialDepositAt     User initial deposit timestamp\n     * @param _claimedAt            User last claim timestamp\n\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL \n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     */\n    function _getStrategyProfitsAndBABL(\n        address _garden,\n        address _strategy,\n        address _contributor,\n        uint256 _initialDepositAt,\n        uint256 _claimedAt\n    ) private view returns (uint256[] memory) {\n        _require(address(IStrategy(_strategy).garden()) == _garden, Errors.STRATEGY_GARDEN_MISMATCH);\n        uint256[] memory rewards = new uint256[](8);\n\n        (address strategist, uint256[] memory strategyDetails, bool[] memory profitData) =\n            IStrategy(_strategy).getStrategyRewardsContext();\n\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        // Positive strategies not yet claimed\n        // Users might get BABL rewards if they join the garden before the strategy ends\n        // Contributor power will check their exact contribution (avoiding flashloans)\n        if (strategyDetails[1] > _claimedAt && strategyDetails[1] > _initialDepositAt && _initialDepositAt != 0) {\n            // Get the contributor power until the the strategy exit timestamp\n            uint256 contributorPower = getContributorPower(_garden, _contributor, strategyDetails[1]);\n            rewards = _getRewardsPerRole(\n                _garden,\n                _strategy,\n                strategist,\n                _contributor,\n                contributorPower,\n                strategyDetails,\n                profitData\n            );\n        }\n\n        return rewards;\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Steward profile\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _strategyDetails  Strategy details data\n     * @param _profitData       Strategy profit data\n     */\n    function _getStrategyStewardBabl(\n        address _strategy,\n        address _contributor,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) private view returns (uint256) {\n        // Assumptions:\n        // It executes in all cases as non profited strategies can also give BABL rewards to those who voted against\n\n        int256 userVotes = IStrategy(_strategy).getUserVotes(_contributor);\n        uint256 totalVotes = _strategyDetails[4].add(_strategyDetails[5]);\n\n        uint256 bablCap;\n\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 babl;\n        if (userVotes > 0 && _profitData[0] == true && _profitData[1] == true) {\n            // Voting in favor of the execution of the strategy with profits and positive distance\n            // Negative votes in this case will not receive BABL so we divide only by positive votes\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(userVotes).preciseDiv(_strategyDetails[4])\n            );\n        } else if (userVotes > 0 && _profitData[0] == true && _profitData[1] == false) {\n            // Voting in favor positive profits but below expected return\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(userVotes).preciseDiv(totalVotes)\n            );\n            // We discount the error of expected return vs real returns\n            babl = babl.sub(babl.preciseMul(_strategyDetails[11].preciseDiv(_strategyDetails[8])));\n        } else if (userVotes > 0 && _profitData[0] == false) {\n            // Voting in favor of a non profitable strategy get nothing\n            babl = 0;\n        } else if (userVotes < 0 && _profitData[1] == false) {\n            // Voting against a strategy that got results below expected return provides rewards\n            // to the voter (helping the protocol to only have good strategies)\n            // If no profit at all, the whole steward benefit goes to those voting against\n            uint256 votesAccounting = _profitData[0] ? totalVotes : _strategyDetails[5];\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(Math.abs(userVotes)).preciseDiv(votesAccounting)\n            );\n\n            bablCap = babl.mul(2); // Max cap\n            // We add a bonus inverse to the error of expected return vs real returns\n            babl = babl.add(babl.preciseMul(_strategyDetails[11].preciseDiv(_strategyDetails[8])));\n            if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n        } else if (userVotes < 0 && _profitData[1] == true) {\n            babl = 0;\n        }\n        return babl;\n    }\n\n    /**\n     * Get the rewards for a Steward profile\n     * @param _garden           Garden address\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _strategyDetails  Strategy details data\n     * @param _profitData       Strategy profit data\n     */\n    function _getStrategyStewardProfits(\n        address _garden,\n        address _strategy,\n        address _contributor,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) private view returns (uint256 stewardBabl) {\n        // Assumptions:\n        // Assumption that the strategy got profits. Should not execute otherwise.\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        int256 userVotes = IStrategy(_strategy).getUserVotes(_contributor);\n        uint256 totalVotes = _strategyDetails[4].add(_strategyDetails[5]);\n\n        uint256 profitShare =\n            gardenCustomProfitSharing[_garden] ? gardenProfitSharing[_garden][1] : stewardsProfitPercentage;\n        if (userVotes > 0) {\n            // If the strategy got profits equal or above expected return only positive votes counts,\n            // so we divide by only positive\n            // Otherwise, we divide by all total votes as also voters against will get some profits\n            // if the strategy returned less than expected\n            uint256 accountingVotes = _profitData[1] ? _strategyDetails[4] : totalVotes;\n            stewardBabl = _strategyDetails[10].multiplyDecimal(profitShare).preciseMul(uint256(userVotes)).preciseDiv(\n                accountingVotes\n            );\n        } else if ((userVotes < 0) && _profitData[1] == false) {\n            stewardBabl = _strategyDetails[10]\n                .multiplyDecimal(profitShare)\n                .preciseMul(uint256(Math.abs(userVotes)))\n                .preciseDiv(totalVotes);\n        } else if ((userVotes < 0) && _profitData[1] == true) {\n            // Voted against a very profit strategy above expected returns, get no profit at all\n            stewardBabl = 0;\n        }\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Strategist profile\n     * @param _strategyDetails     Strategy details data\n     * @param _profitData          Strategy details data\n     */\n    function _getStrategyStrategistBabl(uint256[] memory _strategyDetails, bool[] memory _profitData)\n        private\n        view\n        returns (uint256)\n    {\n        // Assumptions:\n        // We assume that the contributor is the strategist. Should not execute this function otherwise.\n        uint256 babl;\n        uint256 bablCap;\n        babl = _strategyDetails[9].multiplyDecimal(strategistBABLPercentage); // Standard calculation to be ponderated\n        if (_profitData[0] == true && _profitData[1] == true) {\n            // Strategy with equal or higher profits than expected\n            bablCap = babl.mul(2); // Max cap\n            // The more the results are close to the expected the more bonus will get (limited by a x2 cap)\n            babl = babl.add(babl.preciseMul(_strategyDetails[8].preciseDiv(_strategyDetails[7])));\n            if (babl > bablCap) babl = bablCap; // We limit 2x by a Cap\n        } else if (_profitData[0] == true && _profitData[1] == false) {\n            //under expectations\n            // The more the results are close to the expected the less penalization it might have\n            babl = babl.sub(babl.sub(babl.preciseMul(_strategyDetails[7].preciseDiv(_strategyDetails[8]))));\n        } else {\n            // No positive profit, no BABL assigned to the strategist role\n            return 0;\n        }\n        return babl;\n    }\n\n    /**\n     * Get the rewards for a Strategist profile\n     * @param _garden           Garden address\n     * @param _profitValue      Strategy profit value\n     */\n    function _getStrategyStrategistProfits(address _garden, uint256 _profitValue) private view returns (uint256) {\n        // Assumptions:\n        // Only executes if the contributor was the strategist of the strategy\n        // AND the strategy had profits\n        uint256 profitShare =\n            gardenCustomProfitSharing[_garden] ? gardenProfitSharing[_garden][0] : strategistProfitPercentage;\n        return _profitValue.multiplyDecimal(profitShare);\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a LP profile\n     * @param _strategyRewards      Strategy rewards\n     * @param _contributorPower     Contributor power\n     */\n    function _getStrategyLPBabl(uint256 _strategyRewards, uint256 _contributorPower) private view returns (uint256) {\n        uint256 babl;\n        // All params must have 18 decimals precision\n        babl = _strategyRewards.multiplyDecimal(lpsBABLPercentage).preciseMul(_contributorPower);\n        return babl;\n    }\n\n    function _getGardenAndContributor(address _garden, address _contributor) private view returns (uint256[] memory) {\n        uint256[] memory powerData = new uint256[](9);\n        ContributorPerGarden storage contributor = contributorPerGarden[_garden][_contributor];\n        GardenPowerByTimestamp storage garden = gardenPowerByTimestamp[_garden][0];\n\n        // powerData[0]: lastDepositAt (contributor)\n        // powerData[1]: initialDepositAt (contributor)\n        // powerData[2]: balance (contributor)\n        // powerData[3]: power (contributor)\n        // powerData[4]: avgBalance (contributor)\n        // powerData[5]: lastDepositAt (garden)\n        // powerData[6]: accGardenPower (garden)\n        // powerData[7]: avgGardenBalance (garden)\n        // powerData[8]: totalSupply (garden)\n        powerData[0] = contributor.lastDepositAt;\n        powerData[1] = contributor.initialDepositAt;\n        powerData[2] = ERC20(_garden).balanceOf(_contributor);\n        powerData[3] = contributor.tsContributions[0].power;\n        powerData[4] = contributor.tsContributions[0].avgBalance;\n        powerData[5] = garden.lastDepositAt;\n        powerData[6] = garden.accGardenPower;\n        powerData[7] = garden.avgGardenBalance;\n        powerData[8] = ERC20(_garden).totalSupply();\n        return powerData;\n    }\n\n    /**\n     * Calculates the BABL rewards supply for each quarter\n     * @param _quarter      Number of the epoch (quarter)\n     */\n    function _tokenSupplyPerQuarter(uint256 _quarter) internal pure returns (uint96) {\n        _require(_quarter >= 1, Errors.QUARTERS_MIN_1);\n        if (_quarter >= 513) {\n            return 0; // Avoid math overflow\n        } else {\n            uint256 firstFactor = (SafeDecimalMath.unit().add(DECAY_RATE)).powDecimal(_quarter.sub(1));\n            uint256 supplyForQuarter = Q1_REWARDS.divideDecimal(firstFactor);\n            return Safe3296.safe96(supplyForQuarter, 'overflow 96 bits');\n        }\n    }\n\n    /**\n     * Calculates the quarter number for a specific time since START_TIME\n     * @param _now      Timestamp to calculate its quarter\n     */\n    function _getQuarter(uint256 _now) internal view returns (uint256) {\n        // Avoid underflow for active strategies during mining activation\n        uint256 quarter = _now >= START_TIME ? (_now.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18) : 0;\n        return quarter.add(1);\n    }\n\n    /**\n     * Calculates the range (starting quarter and ending quarter since START_TIME)\n     * @param _from   Starting timestamp\n     * @param _to     Ending timestamp\n     */\n    function _getRewardsWindow(uint256 _from, uint256 _to) internal view returns (uint256, uint256) {\n        // Avoid underflow for active strategies during mining activation\n        if (_from < START_TIME) {\n            _from = START_TIME;\n        }\n        uint256 quarters = (_to.sub(_from).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        uint256 startingQuarter = (_from.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        uint256 endingQuarter = (_to.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        if (\n            startingQuarter != endingQuarter &&\n            endingQuarter == startingQuarter.add(1) &&\n            _to.sub(_from) < EPOCH_DURATION\n        ) {\n            quarters = quarters.add(1);\n        }\n        return (quarters.add(1), startingQuarter.add(1));\n    }\n\n    /**\n     * Gives creator bonus to the user and returns original + bonus\n     * @param _garden           Address of the garden\n     * @param _contributor      Address of the contributor\n     * @param _contributorBABL  BABL obtained in the strategy\n     */\n    function _getCreatorBonus(\n        address _garden,\n        address _contributor,\n        uint256 _contributorBABL\n    ) private view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        bool isCreator = garden.creator() == _contributor;\n        uint8 creatorCount = garden.creator() != address(0) ? 1 : 0;\n        for (uint8 i = 0; i < 4; i++) {\n            address _extraCreator = garden.extraCreators(i);\n            if (_extraCreator != address(0)) {\n                creatorCount++;\n                isCreator = isCreator || _extraCreator == _contributor;\n            }\n        }\n        // Get a multiplier bonus in case the contributor is the garden creator\n        if (creatorCount == 0) {\n            // If there is no creator divide the creator bonus across al members\n            return\n                _contributorBABL.add(\n                    _contributorBABL.multiplyDecimal(gardenCreatorBonus).div(IGarden(_garden).totalContributors())\n                );\n        } else {\n            if (isCreator) {\n                // Check other creators and divide by number of creators or members if creator address is 0\n                return _contributorBABL.add(_contributorBABL.multiplyDecimal(gardenCreatorBonus).div(creatorCount));\n            }\n        }\n        return _contributorBABL;\n    }\n\n    function _estimateStrategyRewards(address _strategy)\n        internal\n        view\n        returns (\n            address strategist,\n            uint256[] memory strategyDetails,\n            bool[] memory profitData\n        )\n    {\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        (strategist, strategyDetails, profitData) = IStrategy(_strategy).getStrategyRewardsContext();\n        if (strategyDetails[9] != 0 || strategyDetails[0] == 0) {\n            // Already finished and got rewards or not executed yet (not active)\n            return (strategist, strategyDetails, profitData);\n        }\n        // Strategy has not finished yet, lets try to estimate its mining rewards\n        // As the strategy has not ended we replace the capital returned value by the NAV\n        strategyDetails[7] = IStrategy(_strategy).getNAV();\n        // We apply a 0.25% rounding error margin at NAV\n        strategyDetails[7] = strategyDetails[7].sub(strategyDetails[7].multiplyDecimal(25e14));\n        // Failsafe mode in case of wrong NAV (above 300%)\n        strategyDetails[7] = strategyDetails[7].preciseDiv(strategyDetails[6]) > 3e18\n            ? strategyDetails[6]\n            : strategyDetails[7];\n        profitData[0] = strategyDetails[7] >= strategyDetails[6] ? true : false;\n        profitData[1] = strategyDetails[7] >= strategyDetails[8] ? true : false;\n        strategyDetails[10] = profitData[0] ? strategyDetails[7].sub(strategyDetails[6]) : 0; // no profit\n        // We consider that it potentially will have profits so the protocol will take profitFee\n        // If 0 it does nothing\n        strategyDetails[11] = profitData[1]\n            ? strategyDetails[7].sub(strategyDetails[8])\n            : strategyDetails[8].sub(strategyDetails[7]);\n        // We take care about beta live strategies as they have a different start mining time != executedAt\n        (uint256 numQuarters, uint256 startingQuarter) =\n            _getRewardsWindow(\n                (\n                    (strategyDetails[0] > START_TIME && START_TIME != 0)\n                        ? strategyDetails[0]\n                        : strategyPerQuarter[_strategy][1].betaInitializedAt\n                ),\n                block.timestamp\n            );\n        // We create an array of quarters since the begining of the strategy\n        // We then fill with known + unknown data that has to be figured out\n        uint256[] memory strategyPower = new uint256[](numQuarters);\n        uint256[] memory protocolPower = new uint256[](numQuarters);\n        for (uint256 i = 0; i < numQuarters; i++) {\n            // We take the info of each epoch from current checkpoints\n            // array[0] for the first quarter power checkpoint of the strategy\n            strategyPower[i] = strategyPerQuarter[_strategy][startingQuarter.add(i)].quarterPower;\n            protocolPower[i] = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n            _require(strategyPower[i] <= protocolPower[i], Errors.OVERFLOW_IN_POWER);\n        }\n        strategyPower = _updatePendingPower(\n            strategyPower,\n            numQuarters,\n            startingQuarter,\n            strategyDetails[2],\n            strategyPrincipal[_strategy]\n        );\n        protocolPower = _updatePendingPower(\n            protocolPower,\n            numQuarters,\n            startingQuarter,\n            miningUpdatedAt,\n            miningProtocolPrincipal\n        );\n        strategyDetails[9] = _harvestStrategyRewards(\n            strategyPower,\n            protocolPower,\n            startingQuarter,\n            numQuarters,\n            strategyDetails[7].preciseDiv(strategyDetails[6])\n        );\n    }\n\n    function _harvestStrategyRewards(\n        uint256[] memory _strategyPower,\n        uint256[] memory _protocolPower,\n        uint256 _startingQuarter,\n        uint256 _numQuarters,\n        uint256 _percentageProfit\n    ) internal view returns (uint256) {\n        uint256 strategyRewards;\n        uint256 percentage = 1e18;\n        for (uint256 i = 0; i < _numQuarters; i++) {\n            if (i.add(1) == _numQuarters) {\n                // last quarter - we need to take proportional supply for that timeframe despite\n                // the epoch has not finished yet\n                uint256 slotEnding = START_TIME.add(_startingQuarter.add(i).mul(EPOCH_DURATION));\n                percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                    slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                );\n            }\n            uint256 rewardsPerQuarter =\n                _strategyPower[i]\n                    .preciseDiv(_protocolPower[i] == 0 ? 1 : _protocolPower[i])\n                    .preciseMul(uint256(_tokenSupplyPerQuarter(_startingQuarter.add(i))))\n                    .preciseMul(percentage);\n            strategyRewards = strategyRewards.add(rewardsPerQuarter);\n        }\n        // Set the max cap bonus x2\n        uint256 maxRewards = strategyRewards.preciseMul(2e18);\n        // Apply rewards weight related to principal and profit\n        strategyRewards = strategyRewards.preciseMul(bablPrincipalWeight).add(\n            strategyRewards.preciseMul(bablProfitWeight).preciseMul(_percentageProfit)\n        );\n        // Check max cap\n        if (strategyRewards >= maxRewards) {\n            strategyRewards = maxRewards;\n        }\n        return strategyRewards;\n    }\n\n    function _updatePendingPower(\n        uint256[] memory _powerToUpdate,\n        uint256 _numQuarters,\n        uint256 _startingQuarter,\n        uint256 _updatedAt,\n        uint256 _principal\n    ) internal view returns (uint256[] memory) {\n        uint256 lastQuarter = _getQuarter(_updatedAt); // quarter of last update\n        uint256 currentQuarter = _getQuarter(block.timestamp); // current quarter\n        uint256 timeDiff = block.timestamp.sub(_updatedAt); // 1sec to avoid division by zero\n        // We check the pending power to be accounted until now, since last update for protocol and strategy\n        uint256 powerDebt = _principal.mul(timeDiff);\n        if (powerDebt > 0) {\n            for (uint256 i = 0; i < _numQuarters; i++) {\n                uint256 slotEnding = START_TIME.add(_startingQuarter.add(i).mul(EPOCH_DURATION));\n                if (i == 0 && lastQuarter == _startingQuarter && lastQuarter < currentQuarter) {\n                    // We are in the first quarter to update, we add the proportional pending part\n                    _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt.mul(slotEnding.sub(_updatedAt)).div(timeDiff));\n                } else if (i > 0 && i.add(1) < _numQuarters && lastQuarter <= _startingQuarter.add(i)) {\n                    // We are updating an intermediate quarter\n                    // Should have 0 inside before updating\n                    _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt.mul(EPOCH_DURATION).div(timeDiff));\n                } else if (_startingQuarter.add(i) == currentQuarter) {\n                    // We are updating the current quarter of this strategy checkpoint or the last to update\n                    // It can be a multiple quarter strategy or the only one that need proportional time\n                    if (lastQuarter == currentQuarter) {\n                        // Just add the powerDebt being in the same epoch, no need to get proportional\n                        _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt);\n                    } else {\n                        // should have 0 inside before updating in case of different epoch since last update\n                        _powerToUpdate[i] = _powerToUpdate[i].add(\n                            powerDebt.mul(block.timestamp.sub(slotEnding.sub(EPOCH_DURATION))).div(timeDiff)\n                        );\n                    }\n                }\n            }\n        }\n        return _powerToUpdate;\n    }\n}\n\ncontract RewardsDistributorV10 is RewardsDistributor {}\n"
    },
    "contracts/token/TimeLockedToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {VoteToken} from './VoteToken.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title TimeLockedToken\n * @notice Time Locked ERC20 Token\n * @author Babylon Finance\n * @dev Contract which gives the ability to time-lock tokens specially for vesting purposes usage\n *\n * By overriding the balanceOf() and transfer() functions in ERC20,\n * an account can show its full, post-distribution balance and use it for voting power\n * but only transfer or spend up to an allowed amount\n *\n * A portion of previously non-spendable tokens are allowed to be transferred\n * along the time depending on each vesting conditions, and after all epochs have passed, the full\n * account balance is unlocked. In case on non-completion vesting period, only the Time Lock Registry can cancel\n * the delivery of the pending tokens and only can cancel the remaining locked ones.\n */\n\nabstract contract TimeLockedToken is VoteToken {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new lockout ocurr\n    event NewLockout(\n        address account,\n        uint256 tokenslocked,\n        bool isTeamOrAdvisor,\n        uint256 startingVesting,\n        uint256 endingVesting\n    );\n\n    /// @notice An event that emitted when a new Time Lock is registered\n    event NewTimeLockRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a new Rewards Distributor is registered\n    event NewRewardsDistributorRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a cancellation of Lock tokens is registered\n    event Cancel(address account, uint256 amount);\n\n    /// @notice An event that emitted when a claim of tokens are registered\n    event Claim(address _receiver, uint256 amount);\n\n    /// @notice An event that emitted when a lockedBalance query is done\n    event LockedBalance(address _account, uint256 amount);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyTimeLockRegistry() {\n        require(\n            msg.sender == address(timeLockRegistry),\n            'TimeLockedToken:: onlyTimeLockRegistry: can only be executed by TimeLockRegistry'\n        );\n        _;\n    }\n\n    modifier onlyTimeLockOwner() {\n        if (address(timeLockRegistry) != address(0)) {\n            require(\n                msg.sender == Ownable(timeLockRegistry).owner(),\n                'TimeLockedToken:: onlyTimeLockOwner: can only be executed by the owner of TimeLockRegistry'\n            );\n        }\n        _;\n    }\n    modifier onlyUnpaused() {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // represents total distribution for locked balances\n    mapping(address => uint256) distribution;\n\n    /// @notice The profile of each token owner under its particular vesting conditions\n    /**\n     * @param team Indicates whether or not is a Team member or Advisor (true = team member/advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct VestedToken {\n        bool teamOrAdvisor;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => VestedToken) public vestedToken;\n\n    // address of Time Lock Registry contract\n    IBabController public controller;\n\n    // address of Time Lock Registry contract\n    TimeLockRegistry public timeLockRegistry;\n\n    // address of Rewards Distriburor contract\n    IRewardsDistributor public rewardsDistributor;\n\n    // Enable Transfer of ERC20 BABL Tokens\n    // Only Minting or transfers from/to TimeLockRegistry and Rewards Distributor can transfer tokens until the protocol is fully decentralized\n    bool private tokenTransfersEnabled;\n    bool private tokenTransfersWereDisabled;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) VoteToken(_name, _symbol) {\n        tokenTransfersEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disables transfers of ERC20 BABL Tokens\n     */\n    function disableTokensTransfers() external onlyOwner {\n        require(!tokenTransfersWereDisabled, 'BABL must flow');\n        tokenTransfersEnabled = false;\n        tokenTransfersWereDisabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 BABL Tokens\n     * Can only happen after the protocol is fully decentralized.\n     */\n    function enableTokensTransfers() external onlyOwner {\n        tokenTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Time Lock Registry contract to control token vesting conditions\n     *\n     * @notice Set the Time Lock Registry contract to control token vesting conditions\n     * @param newTimeLockRegistry Address of TimeLockRegistry contract\n     */\n    function setTimeLockRegistry(TimeLockRegistry newTimeLockRegistry) external onlyTimeLockOwner returns (bool) {\n        require(address(newTimeLockRegistry) != address(0), 'cannot be zero address');\n        require(address(newTimeLockRegistry) != address(this), 'cannot be this contract');\n        require(address(newTimeLockRegistry) != address(timeLockRegistry), 'must be new TimeLockRegistry');\n        emit NewTimeLockRegistration(address(timeLockRegistry), address(newTimeLockRegistry));\n\n        timeLockRegistry = newTimeLockRegistry;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Rewards Distributor contract to control either BABL Mining or profit rewards\n     *\n     * @notice Set the Rewards Distriburor contract to control both types of rewards (profit and BABL Mining program)\n     * @param newRewardsDistributor Address of Rewards Distributor contract\n     */\n    function setRewardsDistributor(IRewardsDistributor newRewardsDistributor) external onlyOwner returns (bool) {\n        require(address(newRewardsDistributor) != address(0), 'cannot be zero address');\n        require(address(newRewardsDistributor) != address(this), 'cannot be this contract');\n        require(address(newRewardsDistributor) != address(rewardsDistributor), 'must be new Rewards Distributor');\n        emit NewRewardsDistributorRegistration(address(rewardsDistributor), address(newRewardsDistributor));\n\n        rewardsDistributor = newRewardsDistributor;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Register new token lockup conditions for vested tokens defined only by Time Lock Registry\n     *\n     * @notice Tokens are completely delivered during the registration however lockup conditions apply for vested tokens\n     * locking them according to the distribution epoch periods and the type of recipient (Team, Advisor, Investor)\n     * Emits a transfer event showing a transfer to the recipient\n     * Only the registry can call this function\n     * @param _receiver Address to receive the tokens\n     * @param _amount Tokens to be transferred\n     * @param _profile True if is a Team Member or Advisor\n     * @param _vestingBegin Unix Time when the vesting for that particular address\n     * @param _vestingEnd Unix Time when the vesting for that particular address\n     * @param _lastClaim Unix Time when the claim was done from that particular address\n     *\n     */\n    function registerLockup(\n        address _receiver,\n        uint256 _amount,\n        bool _profile,\n        uint256 _vestingBegin,\n        uint256 _vestingEnd,\n        uint256 _lastClaim\n    ) external onlyTimeLockRegistry returns (bool) {\n        require(balanceOf(msg.sender) >= _amount, 'insufficient balance');\n        require(_receiver != address(0), 'cannot be zero address');\n        require(_receiver != address(this), 'cannot be this contract');\n        require(_receiver != address(timeLockRegistry), 'cannot be the TimeLockRegistry contract itself');\n        require(_receiver != msg.sender, 'the owner cannot lockup itself');\n\n        // update amount of locked distribution\n        distribution[_receiver] = distribution[_receiver].add(_amount);\n\n        VestedToken storage newVestedToken = vestedToken[_receiver];\n\n        newVestedToken.teamOrAdvisor = _profile;\n        newVestedToken.vestingBegin = _vestingBegin;\n        newVestedToken.vestingEnd = _vestingEnd;\n        newVestedToken.lastClaim = _lastClaim;\n\n        // transfer tokens to the recipient\n        _transfer(msg.sender, _receiver, _amount);\n        emit NewLockout(_receiver, _amount, _profile, _vestingBegin, _vestingEnd);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors as it does not apply to investors.\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function cancelVestedTokens(address lockedAccount) external onlyTimeLockRegistry returns (uint256) {\n        return _cancelVestedTokensFromTimeLock(lockedAccount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Each token owner can claim its own specific tokens with its own specific vesting conditions from the Time Lock Registry\n     *\n     * @dev Claim msg.sender tokens (if any available in the registry)\n     */\n    function claimMyTokens() external {\n        // claim msg.sender tokens from timeLockRegistry\n        uint256 amount = timeLockRegistry.claim(msg.sender);\n        // After a proper claim, locked tokens of Team and Advisors profiles are under restricted special vesting conditions so they automatic grant\n        // rights to the Time Lock Registry to only retire locked tokens if non-compliance vesting conditions take places along the vesting periods.\n        // It does not apply to Investors under vesting (their locked tokens cannot be removed).\n        if (vestedToken[msg.sender].teamOrAdvisor == true) {\n            approve(address(timeLockRegistry), amount);\n        }\n        // emit claim event\n        emit Claim(msg.sender, amount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get unlocked balance for an account\n     *\n     * @notice Get unlocked balance for an account\n     * @param account Account to check\n     * @return Amount that is unlocked and available eg. to transfer\n     */\n    function unlockedBalance(address account) public returns (uint256) {\n        // totalBalance - lockedBalance\n        return balanceOf(account).sub(lockedBalance(account));\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. View the locked balance for an account\n     *\n     * @notice View locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n\n    function viewLockedBalance(address account) public view returns (uint256) {\n        // distribution of locked tokens\n        // get amount from distributions\n\n        uint256 amount = distribution[account];\n        uint256 lockedAmount = amount;\n\n        // Team and investors cannot transfer tokens in the first year\n        if (vestedToken[account].vestingBegin.add(365 days) > block.timestamp && amount != 0) {\n            return lockedAmount;\n        }\n\n        // in case of vesting has passed, all tokens are now available, if no vesting lock is 0 as well\n        if (block.timestamp >= vestedToken[account].vestingEnd || amount == 0) {\n            lockedAmount = 0;\n        } else if (amount != 0) {\n            // in case of still under vesting period, locked tokens are recalculated\n            lockedAmount = amount.mul(vestedToken[account].vestingEnd.sub(block.timestamp)).div(\n                vestedToken[account].vestingEnd.sub(vestedToken[account].vestingBegin)\n            );\n        }\n        return lockedAmount;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get locked balance for an account\n     *\n     * @notice Get locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n    function lockedBalance(address account) public returns (uint256) {\n        // get amount from distributions locked tokens (if any)\n        uint256 lockedAmount = viewLockedBalance(account);\n        // in case of vesting has passed, all tokens are now available so we set mapping to 0 only for accounts under vesting\n        if (\n            block.timestamp >= vestedToken[account].vestingEnd &&\n            msg.sender == account &&\n            lockedAmount == 0 &&\n            vestedToken[account].vestingEnd != 0\n        ) {\n            delete distribution[account];\n        }\n        emit LockedBalance(account, lockedAmount);\n        return lockedAmount;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the address of Time Lock Registry\n     *\n     * @notice Get the address of Time Lock Registry\n     * @return Address of the Time Lock Registry\n     */\n    function getTimeLockRegistry() external view returns (address) {\n        return address(timeLockRegistry);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Approval of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Override of \"Approve\" function to allow the `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender` except in the case of spender is Time Lock Registry\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::approve: spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::approve: spender cannot be the msg.sender');\n\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, 'TimeLockedToken::approve: amount exceeds 96 bits');\n        }\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        if ((spender == address(timeLockRegistry)) && (amount < allowance(msg.sender, address(timeLockRegistry)))) {\n            amount = safe96(\n                allowance(msg.sender, address(timeLockRegistry)),\n                'TimeLockedToken::approve: cannot decrease allowance to timelockregistry'\n            );\n        }\n        _approve(msg.sender, spender, amount);\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Increase of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an override with respect to the fulfillment of vesting conditions along the way\n     * However an user can increase allowance many times, it will never be able to transfer locked tokens during vesting period\n     * @return Whether or not the increaseAllowance succeeded\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public override nonReentrant returns (bool) {\n        require(\n            unlockedBalance(msg.sender) >= allowance(msg.sender, spender).add(addedValue) ||\n                spender == address(timeLockRegistry),\n            'TimeLockedToken::increaseAllowance:Not enough unlocked tokens'\n        );\n        require(spender != address(0), 'TimeLockedToken::increaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::increaseAllowance:Spender cannot be the msg.sender');\n        _approve(msg.sender, spender, allowance(msg.sender, spender).add(addedValue));\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the decrease of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically decrease the allowance granted to `spender` by the caller.\n     *\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an override with respect to the fulfillment of vesting conditions along the way\n     * An user cannot decrease the allowance to the Time Lock Registry who is in charge of vesting conditions\n     * @return Whether or not the decreaseAllowance succeeded\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::decreaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::decreaseAllowance:Spender cannot be the msg.sender');\n        require(\n            allowance(msg.sender, spender) >= subtractedValue,\n            'TimeLockedToken::decreaseAllowance:Underflow condition'\n        );\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        require(\n            address(spender) != address(timeLockRegistry),\n            'TimeLockedToken::decreaseAllowance:cannot decrease allowance to timeLockRegistry'\n        );\n\n        _approve(msg.sender, spender, allowance(msg.sender, spender).sub(subtractedValue));\n        return true;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the _transfer of ERC20 BABL tokens only allowing the transfer of unlocked tokens\n     *\n     * @dev Transfer function which includes only unlocked tokens\n     * Locked tokens can always be transfered back to the returns address\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal override onlyUnpaused {\n        require(_from != address(0), 'TimeLockedToken:: _transfer: cannot transfer from the zero address');\n        require(_to != address(0), 'TimeLockedToken:: _transfer: cannot transfer to the zero address');\n        require(\n            _to != address(this),\n            'TimeLockedToken:: _transfer: do not transfer tokens to the token contract itself'\n        );\n\n        require(balanceOf(_from) >= _value, 'TimeLockedToken:: _transfer: insufficient balance');\n\n        // check if enough unlocked balance to transfer\n        require(unlockedBalance(_from) >= _value, 'TimeLockedToken:: _transfer: attempting to transfer locked funds');\n        super._transfer(_from, _to, _value);\n        // voting power\n        _moveDelegates(\n            delegates[_from],\n            delegates[_to],\n            safe96(_value, 'TimeLockedToken:: _transfer: uint96 overflow')\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disable BABL token transfer until certain conditions are met\n     *\n     * @dev Override the _beforeTokenTransfer of ERC20 BABL tokens until certain conditions are met:\n     * Only allowing minting or transfers from Time Lock Registry and Rewards Distributor until transfers are allowed in the controller\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _value);\n        _require(\n            _from == address(0) ||\n                _from == address(timeLockRegistry) ||\n                _from == address(rewardsDistributor) ||\n                _to == address(timeLockRegistry) ||\n                tokenTransfersEnabled,\n            Errors.BABL_TRANSFERS_DISABLED\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of  vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function _cancelVestedTokensFromTimeLock(address lockedAccount) internal onlyTimeLockRegistry returns (uint256) {\n        require(distribution[lockedAccount] != 0, 'TimeLockedToken::cancelTokens:Not registered');\n\n        // get an update on locked amount from distributions at this precise moment\n        uint256 loosingAmount = lockedBalance(lockedAccount);\n\n        require(loosingAmount > 0, 'TimeLockedToken::cancelTokens:There are no more locked tokens');\n        require(\n            vestedToken[lockedAccount].teamOrAdvisor == true,\n            'TimeLockedToken::cancelTokens:cannot cancel locked tokens to Investors'\n        );\n\n        // set distribution mapping to 0\n        delete distribution[lockedAccount];\n\n        // set tokenVested mapping to 0\n        delete vestedToken[lockedAccount];\n\n        // transfer only locked tokens back to TimeLockRegistry Owner (msg.sender)\n        require(\n            transferFrom(lockedAccount, address(timeLockRegistry), loosingAmount),\n            'TimeLockedToken::cancelTokens:Transfer failed'\n        );\n\n        // emit cancel event\n        emit Cancel(lockedAccount, loosingAmount);\n\n        return loosingAmount;\n    }\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nlibrary SafeDecimalMath {\n    using LowGasSafeMath for uint256;\n\n    /* Number of decimal places in the representations. */\n    uint8 internal constant decimals = 18;\n\n    /* The number representing 1.0. */\n    uint256 internal constant UNIT = 10**uint256(decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() internal pure returns (uint256) {\n        return UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * Normalizing amount decimals between tokens\n     * @param assetFrom       ERC20 asset address\n     * @param assetTarget     ERC20 asset address\n     * @param quantity Value to normalize (e.g. capital)\n     */\n    function normalizeAmountTokens(\n        address assetFrom,\n        address assetTarget,\n        uint256 quantity\n    ) internal view returns (uint256) {\n        uint256 tokenDecimals = _isETH(assetFrom) ? 18 : ERC20(assetFrom).decimals();\n        uint256 tokenDecimalsTarget = _isETH(assetTarget) ? 18 : ERC20(assetTarget).decimals();\n        require(tokenDecimals <= 18 && tokenDecimalsTarget <= 18, 'Unsupported decimals');\n        if (tokenDecimals == tokenDecimalsTarget) {\n            return quantity;\n        }\n        if (tokenDecimalsTarget > tokenDecimals) {\n            return quantity.mul(10**(tokenDecimalsTarget.sub(tokenDecimals)));\n        }\n        return quantity.div(10**(tokenDecimals.sub(tokenDecimalsTarget)));\n    }\n\n    function _isETH(address _address) internal pure returns (bool) {\n        return _address == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || _address == address(0);\n    }\n}\n"
    },
    "contracts/lib/PreciseUnitMath.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {LowGasSafeMath} from './LowGasSafeMath.sol';\n\n/**\n * @title PreciseUnitMath\n * @author Set Protocol\n *\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n * dYdX's BaseMath library.\n *\n * CHANGELOG:\n * - 9/21/20: Added safePower function\n */\nlibrary PreciseUnitMath {\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // The number One in precise units.\n    uint256 internal constant PRECISE_UNIT = 10**18;\n    int256 internal constant PRECISE_UNIT_INT = 10**18;\n\n    // Max unsigned integer value\n    uint256 internal constant MAX_UINT_256 = type(uint256).max;\n    // Max and min signed integer value\n    int256 internal constant MAX_INT_256 = type(int256).max;\n    int256 internal constant MIN_INT_256 = type(int256).min;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function decimals() internal pure returns (uint256) {\n        return 18;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnitInt() internal pure returns (int256) {\n        return PRECISE_UNIT_INT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxUint256() internal pure returns (uint256) {\n        return MAX_UINT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxInt256() internal pure returns (int256) {\n        return MAX_INT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function minInt256() internal pure returns (int256) {\n        return MIN_INT_256;\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n     * significand of a number with 18 decimals precision.\n     */\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(b).div(PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down).\n     */\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISE_UNIT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded towards 0).\n     */\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(PRECISE_UNIT_INT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0).\n     */\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, 'Cant divide by 0');\n\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n     */\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'Cant divide by 0');\n        require(a != MIN_INT_256 || b != -1, 'Invalid input');\n\n        int256 result = a.div(b);\n        if (a ^ b < 0 && a % b != 0) {\n            result -= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Multiplies value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Divides value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\n    }\n\n    /**\n     * @dev Performs the power on a specified value, reverts on overflow.\n     */\n    function safePower(uint256 a, uint256 pow) internal pure returns (uint256) {\n        require(a > 0, 'Value must be positive');\n\n        uint256 result = 1;\n        for (uint256 i = 0; i < pow; i++) {\n            uint256 previousResult = result;\n\n            // Using safemath multiplication prevents overflows\n            result = previousResult.mul(a);\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/lib/Math.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// Libraries\nimport './SafeDecimalMath.sol';\n\n// https://docs.synthetix.io/contracts/source/libraries/math\nlibrary Math {\n    using LowGasSafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /**\n     * @dev Uses \"exponentiation by squaring\" algorithm where cost is 0(logN)\n     * vs 0(N) for naive repeated multiplication.\n     * Calculates x^n with x as fixed-point and n as regular unsigned int.\n     * Calculates to 18 digits of precision with SafeDecimalMath.unit()\n     */\n    function powDecimal(uint256 x, uint256 n) internal pure returns (uint256) {\n        // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n\n        uint256 result = SafeDecimalMath.unit();\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = result.multiplyDecimal(x);\n            }\n            x = x.multiplyDecimal(x);\n            n /= 2;\n        }\n        return result;\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n}\n"
    },
    "contracts/lib/Safe3296.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\nlibrary Safe3296 {\n    using LowGasSafeMath for uint256;\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"
    },
    "contracts/lib/BabylonErrors.sol": {
      "content": "/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// solhint-disable\n\n/**\n * @notice Forked from https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/lib/helpers/BalancerErrors.sol\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAB#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAB#\" part is a known constant\n        // (0x42414223): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414223000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Max deposit limit needs to be under the limit\n    uint256 internal constant MAX_DEPOSIT_LIMIT = 0;\n    // Creator needs to deposit\n    uint256 internal constant MIN_CONTRIBUTION = 1;\n    // Min Garden token supply >= 0\n    uint256 internal constant MIN_TOKEN_SUPPLY = 2;\n    // Deposit hardlock needs to be at least 1 block\n    uint256 internal constant DEPOSIT_HARDLOCK = 3;\n    // Needs to be at least the minimum\n    uint256 internal constant MIN_LIQUIDITY = 4;\n    // _reserveAssetQuantity is not equal to msg.value\n    uint256 internal constant MSG_VALUE_DO_NOT_MATCH = 5;\n    // Withdrawal amount has to be equal or less than msg.sender balance\n    uint256 internal constant MSG_SENDER_TOKENS_DO_NOT_MATCH = 6;\n    // Tokens are staked\n    uint256 internal constant TOKENS_STAKED = 7;\n    // Balance too low\n    uint256 internal constant BALANCE_TOO_LOW = 8;\n    // msg.sender doesn't have enough tokens\n    uint256 internal constant MSG_SENDER_TOKENS_TOO_LOW = 9;\n    //  There is an open redemption window already\n    uint256 internal constant REDEMPTION_OPENED_ALREADY = 10;\n    // Cannot request twice in the same window\n    uint256 internal constant ALREADY_REQUESTED = 11;\n    // Rewards and profits already claimed\n    uint256 internal constant ALREADY_CLAIMED = 12;\n    // Value have to be greater than zero\n    uint256 internal constant GREATER_THAN_ZERO = 13;\n    // Must be reserve asset\n    uint256 internal constant MUST_BE_RESERVE_ASSET = 14;\n    // Only contributors allowed\n    uint256 internal constant ONLY_CONTRIBUTOR = 15;\n    // Only controller allowed\n    uint256 internal constant ONLY_CONTROLLER = 16;\n    // Only creator allowed\n    uint256 internal constant ONLY_CREATOR = 17;\n    // Only keeper allowed\n    uint256 internal constant ONLY_KEEPER = 18;\n    // Fee is too high\n    uint256 internal constant FEE_TOO_HIGH = 19;\n    // Only strategy allowed\n    uint256 internal constant ONLY_STRATEGY = 20;\n    // Only active allowed\n    uint256 internal constant ONLY_ACTIVE = 21;\n    // Only inactive allowed\n    uint256 internal constant ONLY_INACTIVE = 22;\n    // Address should be not zero address\n    uint256 internal constant ADDRESS_IS_ZERO = 23;\n    // Not within range\n    uint256 internal constant NOT_IN_RANGE = 24;\n    // Value is too low\n    uint256 internal constant VALUE_TOO_LOW = 25;\n    // Value is too high\n    uint256 internal constant VALUE_TOO_HIGH = 26;\n    // Only strategy or protocol allowed\n    uint256 internal constant ONLY_STRATEGY_OR_CONTROLLER = 27;\n    // Normal withdraw possible\n    uint256 internal constant NORMAL_WITHDRAWAL_POSSIBLE = 28;\n    // User does not have permissions to join garden\n    uint256 internal constant USER_CANNOT_JOIN = 29;\n    // User does not have permissions to add strategies in garden\n    uint256 internal constant USER_CANNOT_ADD_STRATEGIES = 30;\n    // Only Protocol or garden\n    uint256 internal constant ONLY_PROTOCOL_OR_GARDEN = 31;\n    // Only Strategist\n    uint256 internal constant ONLY_STRATEGIST = 32;\n    // Only Integration\n    uint256 internal constant ONLY_INTEGRATION = 33;\n    // Only garden and data not set\n    uint256 internal constant ONLY_GARDEN_AND_DATA_NOT_SET = 34;\n    // Only active garden\n    uint256 internal constant ONLY_ACTIVE_GARDEN = 35;\n    // Contract is not a garden\n    uint256 internal constant NOT_A_GARDEN = 36;\n    // Not enough tokens\n    uint256 internal constant STRATEGIST_TOKENS_TOO_LOW = 37;\n    // Stake is too low\n    uint256 internal constant STAKE_HAS_TO_AT_LEAST_ONE = 38;\n    // Duration must be in range\n    uint256 internal constant DURATION_MUST_BE_IN_RANGE = 39;\n    // Max Capital Requested\n    uint256 internal constant MAX_CAPITAL_REQUESTED = 41;\n    // Votes are already resolved\n    uint256 internal constant VOTES_ALREADY_RESOLVED = 42;\n    // Voting window is closed\n    uint256 internal constant VOTING_WINDOW_IS_OVER = 43;\n    // Strategy needs to be active\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_ACTIVE = 44;\n    // Max capital reached\n    uint256 internal constant MAX_CAPITAL_REACHED = 45;\n    // Capital is less then rebalance\n    uint256 internal constant CAPITAL_IS_LESS_THAN_REBALANCE = 46;\n    // Strategy is in cooldown period\n    uint256 internal constant STRATEGY_IN_COOLDOWN = 47;\n    // Strategy is not executed\n    uint256 internal constant STRATEGY_IS_NOT_EXECUTED = 48;\n    // Strategy is not over yet\n    uint256 internal constant STRATEGY_IS_NOT_OVER_YET = 49;\n    // Strategy is already finalized\n    uint256 internal constant STRATEGY_IS_ALREADY_FINALIZED = 50;\n    // No capital to unwind\n    uint256 internal constant STRATEGY_NO_CAPITAL_TO_UNWIND = 51;\n    // Strategy needs to be inactive\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_INACTIVE = 52;\n    // Duration needs to be less\n    uint256 internal constant DURATION_NEEDS_TO_BE_LESS = 53;\n    // Can't sweep reserve asset\n    uint256 internal constant CANNOT_SWEEP_RESERVE_ASSET = 54;\n    // Voting window is opened\n    uint256 internal constant VOTING_WINDOW_IS_OPENED = 55;\n    // Strategy is executed\n    uint256 internal constant STRATEGY_IS_EXECUTED = 56;\n    // Min Rebalance Capital\n    uint256 internal constant MIN_REBALANCE_CAPITAL = 57;\n    // Not a valid strategy NFT\n    uint256 internal constant NOT_STRATEGY_NFT = 58;\n    // Garden Transfers Disabled\n    uint256 internal constant GARDEN_TRANSFERS_DISABLED = 59;\n    // Tokens are hardlocked\n    uint256 internal constant TOKENS_HARDLOCKED = 60;\n    // Max contributors reached\n    uint256 internal constant MAX_CONTRIBUTORS = 61;\n    // BABL Transfers Disabled\n    uint256 internal constant BABL_TRANSFERS_DISABLED = 62;\n    // Strategy duration range error\n    uint256 internal constant DURATION_RANGE = 63;\n    // Checks the min amount of voters\n    uint256 internal constant MIN_VOTERS_CHECK = 64;\n    // Ge contributor power error\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_WINDOW = 65;\n    // Not enough reserve set aside\n    uint256 internal constant NOT_ENOUGH_RESERVE = 66;\n    // Garden is already public\n    uint256 internal constant GARDEN_ALREADY_PUBLIC = 67;\n    // Withdrawal with penalty\n    uint256 internal constant WITHDRAWAL_WITH_PENALTY = 68;\n    // Withdrawal with penalty\n    uint256 internal constant ONLY_MINING_ACTIVE = 69;\n    // Overflow in supply\n    uint256 internal constant OVERFLOW_IN_SUPPLY = 70;\n    // Overflow in power\n    uint256 internal constant OVERFLOW_IN_POWER = 71;\n    // Not a system contract\n    uint256 internal constant NOT_A_SYSTEM_CONTRACT = 72;\n    // Strategy vs Garden mismatch\n    uint256 internal constant STRATEGY_GARDEN_MISMATCH = 73;\n    // Minimum quarters is 1\n    uint256 internal constant QUARTERS_MIN_1 = 74;\n    // Too many strategy operations\n    uint256 internal constant TOO_MANY_OPS = 75;\n    // Only operations\n    uint256 internal constant ONLY_OPERATION = 76;\n    // Strat params wrong length\n    uint256 internal constant STRAT_PARAMS_LENGTH = 77;\n    // Garden params wrong length\n    uint256 internal constant GARDEN_PARAMS_LENGTH = 78;\n    // Token names too long\n    uint256 internal constant NAME_TOO_LONG = 79;\n    // Contributor power overflows over garden power\n    uint256 internal constant CONTRIBUTOR_POWER_OVERFLOW = 80;\n    // Contributor power window out of bounds\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_DEPOSITS = 81;\n    // Contributor power window out of bounds\n    uint256 internal constant NO_REWARDS_TO_CLAIM = 82;\n    // Pause guardian paused this operation\n    uint256 internal constant ONLY_UNPAUSED = 83;\n    // Reentrant intent\n    uint256 internal constant REENTRANT_CALL = 84;\n    // Reserve asset not supported\n    uint256 internal constant RESERVE_ASSET_NOT_SUPPORTED = 85;\n    // Withdrawal/Deposit check min amount received\n    uint256 internal constant RECEIVE_MIN_AMOUNT = 86;\n    // Total Votes has to be positive\n    uint256 internal constant TOTAL_VOTES_HAVE_TO_BE_POSITIVE = 87;\n    // Signer has to be valid\n    uint256 internal constant INVALID_SIGNER = 88;\n    // Nonce has to be valid\n    uint256 internal constant INVALID_NONCE = 89;\n    // Garden is not public\n    uint256 internal constant GARDEN_IS_NOT_PUBLIC = 90;\n    // Setting max contributors\n    uint256 internal constant MAX_CONTRIBUTORS_SET = 91;\n    // Profit sharing mismatch for customized gardens\n    uint256 internal constant PROFIT_SHARING_MISMATCH = 92;\n    // Max allocation percentage\n    uint256 internal constant MAX_STRATEGY_ALLOCATION_PERCENTAGE = 93;\n    // new creator must not exist\n    uint256 internal constant NEW_CREATOR_MUST_NOT_EXIST = 94;\n    // only first creator can add\n    uint256 internal constant ONLY_FIRST_CREATOR_CAN_ADD = 95;\n    // invalid address\n    uint256 internal constant INVALID_ADDRESS = 96;\n    // creator can only renounce in some circumstances\n    uint256 internal constant CREATOR_CANNOT_RENOUNCE = 97;\n    // no price for trade\n    uint256 internal constant NO_PRICE_FOR_TRADE = 98;\n    // Max capital requested\n    uint256 internal constant ZERO_CAPITAL_REQUESTED = 99;\n    // Unwind capital above the limit\n    uint256 internal constant INVALID_CAPITAL_TO_UNWIND = 100;\n    // Mining % sharing does not match\n    uint256 internal constant INVALID_MINING_VALUES = 101;\n    // Max trade slippage percentage\n    uint256 internal constant MAX_TRADE_SLIPPAGE_PERCENTAGE = 102;\n    // Max gas fee percentage\n    uint256 internal constant MAX_GAS_FEE_PERCENTAGE = 103;\n    // Mismatch between voters and votes\n    uint256 internal constant INVALID_VOTES_LENGTH = 104;\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Modified from (Set Protocol IPriceOracle)\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPriceOracle\n * @author Babylon Finance\n *\n * Interface for interacting with PriceOracle\n */\ninterface IPriceOracle {\n    /* ============ Functions ============ */\n\n    function getPrice(address _assetOne, address _assetTwo) external view returns (uint256);\n\n    function getPriceNAV(address _assetOne, address _assetTwo) external view returns (uint256);\n\n    function getCompoundExchangeRate(address _asset) external view returns (uint256);\n\n    function getCreamExchangeRate(address _asset) external view returns (uint256);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/token/TimeLockRegistry.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\n/**\n * @title TimeLockRegistry\n * @notice Register Lockups for TimeLocked ERC20 Token BABL (e.g. vesting)\n * @author Babylon Finance\n * @dev This contract allows owner to register distributions for a TimeLockedToken\n *\n * To register a distribution, register method should be called by the owner.\n * claim() should be called only by the BABL Token smartcontract (modifier onlyBABLToken)\n *  when any account registered to receive tokens make its own claim\n * If case of a mistake, owner can cancel registration before the claim is done by the account\n *\n * Note this contract address must be setup in the TimeLockedToken's contract pointing\n * to interact with (e.g. setTimeLockRegistry() function)\n */\n\ncontract TimeLockRegistry is Ownable {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n\n    event Register(address receiver, uint256 distribution);\n    event Cancel(address receiver, uint256 distribution);\n    event Claim(address account, uint256 distribution);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyBABLToken() {\n        require(msg.sender == address(token), 'only BABL Token');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // time locked token\n    TimeLockedToken public token;\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param receiver Account being registered\n     * @param investorType Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingStarting Date When the vesting begins for such token owner\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    struct Registration {\n        address receiver;\n        uint256 distribution;\n        bool investorType;\n        uint256 vestingStartingDate;\n    }\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param team Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct TokenVested {\n        bool team;\n        bool cliff;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => TokenVested) public tokenVested;\n\n    // mapping from token owners under vesting conditions to BABL due amount (e.g. SAFT addresses, team members, advisors)\n    mapping(address => uint256) public registeredDistributions;\n\n    // array of all registrations\n    address[] public registrations;\n\n    // total amount of tokens registered\n    uint256 public totalTokens;\n\n    // vesting for Team Members\n    uint256 private constant teamVesting = 365 days * 4;\n\n    // vesting for Investors and Advisors\n    uint256 private constant investorVesting = 365 days * 3;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new Time Lock Registry and gives ownership to sender\n     * @param _token TimeLockedToken contract to use in this registry\n     */\n    constructor(TimeLockedToken _token) {\n        token = _token;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets registrations\n     *\n     * @return  address[]        Returns list of registrations\n     */\n\n    function getRegistrations() external view returns (address[] memory) {\n        return registrations;\n    }\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register multiple investors/team in a batch\n     * @param _registrations Registrations to process\n     */\n    function registerBatch(Registration[] memory _registrations) external onlyOwner {\n        for (uint256 i = 0; i < _registrations.length; i++) {\n            register(\n                _registrations[i].receiver,\n                _registrations[i].distribution,\n                _registrations[i].investorType,\n                _registrations[i].vestingStartingDate\n            );\n        }\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register new account under vesting conditions (Team, Advisors, Investors e.g. SAFT purchaser)\n     * @param receiver Address belonging vesting conditions\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    function register(\n        address receiver,\n        uint256 distribution,\n        bool investorType,\n        uint256 vestingStartingDate\n    ) public onlyOwner {\n        require(receiver != address(0), 'TimeLockRegistry::register: cannot register the zero address');\n        require(\n            receiver != address(this),\n            'TimeLockRegistry::register: Time Lock Registry contract cannot be an investor'\n        );\n        require(distribution != 0, 'TimeLockRegistry::register: Distribution = 0');\n        require(\n            registeredDistributions[receiver] == 0,\n            'TimeLockRegistry::register:Distribution for this address is already registered'\n        );\n        require(vestingStartingDate >= 1614553200, 'Cannot register earlier than March 2021'); // 1614553200 is UNIX TIME of 2021 March the 1st\n        require(\n            vestingStartingDate <= block.timestamp.add(30 days),\n            'Cannot register more than 30 days ahead in the future'\n        );\n        require(totalTokens.add(distribution) <= IERC20(token).balanceOf(address(this)), 'Not enough tokens');\n\n        totalTokens = totalTokens.add(distribution);\n        // register distribution\n        registeredDistributions[receiver] = distribution;\n        registrations.push(receiver);\n\n        // register token vested conditions\n        TokenVested storage newTokenVested = tokenVested[receiver];\n        newTokenVested.team = investorType;\n        newTokenVested.vestingBegin = vestingStartingDate;\n\n        if (newTokenVested.team == true) {\n            newTokenVested.vestingEnd = vestingStartingDate.add(teamVesting);\n        } else {\n            newTokenVested.vestingEnd = vestingStartingDate.add(investorVesting);\n        }\n        newTokenVested.lastClaim = vestingStartingDate;\n\n        tokenVested[receiver] = newTokenVested;\n\n        // emit register event\n        emit Register(receiver, distribution);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel distribution registration\n     * @dev A claim has not to be done earlier\n     * @param receiver Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelRegistration(address receiver) external onlyOwner returns (bool) {\n        require(registeredDistributions[receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[receiver];\n\n        // set distribution mapping to 0\n        delete registeredDistributions[receiver];\n\n        // set tokenVested mapping to 0\n        delete tokenVested[receiver];\n\n        // remove from the list of all registrations\n        registrations.remove(receiver);\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // emit cancel event\n        emit Cancel(receiver, amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel already delivered tokens. It might only apply when non-completion of vesting period of Team members or Advisors\n     * @dev An automatic override allowance is granted during the claim process\n     * @param account Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelDeliveredTokens(address account) external onlyOwner returns (bool) {\n        uint256 loosingAmount = token.cancelVestedTokens(account);\n\n        // emit cancel event\n        emit Cancel(account, loosingAmount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Recover tokens in Time Lock Registry smartcontract address by the owner\n     *\n     * @notice Send tokens from smartcontract address to the owner.\n     * It might only apply after a cancellation of vested tokens\n     * @param amount Amount to be recovered by the owner of the Time Lock Registry smartcontract from its balance\n     * @return Whether or not it succeeded\n     */\n    function transferToOwner(uint256 amount) external onlyOwner returns (bool) {\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Claim locked tokens by the registered account\n     *\n     * @notice Claim tokens due amount.\n     * @dev Claim is done by the user in the TimeLocked contract and the contract is the only allowed to call\n     * this function on behalf of the user to make the claim\n     * @return The amount of tokens registered and delivered after the claim\n     */\n    function claim(address _receiver) external onlyBABLToken returns (uint256) {\n        require(registeredDistributions[_receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[_receiver];\n        TokenVested storage claimTokenVested = tokenVested[_receiver];\n\n        claimTokenVested.lastClaim = block.timestamp;\n\n        // set distribution mapping to 0\n        delete registeredDistributions[_receiver];\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // register lockup in TimeLockedToken\n        // this will transfer funds from this contract and lock them for sender\n        token.registerLockup(\n            _receiver,\n            amount,\n            claimTokenVested.team,\n            claimTokenVested.vestingBegin,\n            claimTokenVested.vestingEnd,\n            claimTokenVested.lastClaim\n        );\n\n        // set tokenVested mapping to 0\n        delete tokenVested[_receiver];\n\n        // emit claim event\n        emit Claim(_receiver, amount);\n\n        return amount;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    function checkVesting(address address_)\n        external\n        view\n        returns (\n            bool team,\n            uint256 start,\n            uint256 end,\n            uint256 last\n        )\n    {\n        TokenVested storage checkTokenVested = tokenVested[address_];\n\n        return (\n            checkTokenVested.team,\n            checkTokenVested.vestingBegin,\n            checkTokenVested.vestingEnd,\n            checkTokenVested.lastClaim\n        );\n    }\n\n    function checkRegisteredDistribution(address address_) external view returns (uint256 amount) {\n        return registeredDistributions[address_];\n    }\n}\n"
    },
    "contracts/token/VoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title VoteToken\n * @notice Custom token which tracks voting power for governance\n * @dev This is an abstraction of a fork of the Compound governance contract\n * VoteToken is used by BABL to allow tracking voting power\n * Checkpoints are created every time state is changed which record voting power\n * Inherits standard ERC20 behavior\n */\n\nabstract contract VoteToken is Context, ERC20, Ownable, IVoteToken, ReentrancyGuard {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegating votes from msg.sender to delegatee\n     *\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n\n    function delegate(address delegatee) external override {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegate votes using signature to 'delegatee'\n     *\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external override {\n        address signatory;\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        if (prefix) {\n            bytes32 digestHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', digest));\n            signatory = ecrecover(digestHash, v, r, s);\n        } else {\n            signatory = ecrecover(digest, v, r, s);\n        }\n\n        require(balanceOf(signatory) > 0, 'VoteToken::delegateBySig: invalid delegator');\n        require(signatory != address(0), 'VoteToken::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory], 'VoteToken::delegateBySig: invalid nonce');\n        nonces[signatory]++;\n        require(block.timestamp <= expiry, 'VoteToken::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Check Delegate votes using signature to 'delegatee'\n     *\n     * @notice Get current voting power for an account\n     * @param account Account to get voting power for\n     * @return Voting power for an account\n     */\n    function getCurrentVotes(address account) external view virtual override returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get voting power at a specific block for an account\n     *\n     * @param account Account to get voting power for\n     * @param blockNumber Block to get voting power at\n     * @return Voting power for an account at specific block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view virtual override returns (uint96) {\n        require(blockNumber < block.number, 'BABLToken::getPriorVotes: not yet determined');\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function getMyDelegatee() external view override returns (address) {\n        return delegates[msg.sender];\n    }\n\n    function getDelegatee(address account) external view override returns (address) {\n        return delegates[account];\n    }\n\n    function getCheckpoints(address account, uint32 id)\n        external\n        view\n        override\n        returns (uint32 fromBlock, uint96 votes)\n    {\n        Checkpoint storage getCheckpoint = checkpoints[account][id];\n        return (getCheckpoint.fromBlock, getCheckpoint.votes);\n    }\n\n    function getNumberOfCheckpoints(address account) external view override returns (uint32) {\n        return numCheckpoints[account];\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Make a delegation\n     *\n     * @dev Internal function to delegate voting power to an account\n     * @param delegator The address of the account delegating votes from\n     * @param delegatee The address to delegate votes to\n     */\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = safe96(_balanceOf(delegator), 'VoteToken::_delegate: uint96 overflow');\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _balanceOf(address account) internal view virtual returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Move the delegates\n     *\n     * @dev Internal function to move delegates between accounts\n     * @param srcRep The address of the account delegating votes from\n     * @param dstRep The address of the account delegating votes to\n     * @param amount The voting power to move\n     */\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            // It must not revert but do nothing in cases of address(0) being part of the move\n            // Sub voting amount to source in case it is not the zero address (e.g. transfers)\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'VoteToken::_moveDelegates: vote amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n            if (dstRep != address(0)) {\n                // Add it to destination in case it is not the zero address (e.g. any transfer of tokens or delegations except a first mint to a specific address)\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'VoteToken::_moveDelegates: vote amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Internal function to write a checkpoint for voting power\n     *\n     * @dev internal function to write a checkpoint for voting power\n     * @param delegatee The address of the account delegating votes to\n     * @param nCheckpoints The num checkpoint\n     * @param oldVotes The previous voting power\n     * @param newVotes The new voting power\n     */\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, 'VoteToken::_writeCheckpoint: block number exceeds 32 bits');\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/interfaces/IVoteToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IVoteToken {\n    function delegate(address delegatee) external;\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external;\n\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function getMyDelegatee() external view returns (address);\n\n    function getDelegatee(address account) external view returns (address);\n\n    function getCheckpoints(address account, uint32 id) external view returns (uint32 fromBlock, uint96 votes);\n\n    function getNumberOfCheckpoints(address account) external view returns (uint32);\n}\n\ninterface IVoteTokenWithERC20 is IVoteToken, IERC20 {}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {UniversalERC20} from '../lib/UniversalERC20.sol';\nimport {BytesLib} from '../lib/BytesLib.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {ITradeIntegration} from '../interfaces/ITradeIntegration.sol';\nimport {IOperation} from '../interfaces/IOperation.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IMasterSwapper} from '../interfaces/IMasterSwapper.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\n\n/**\n * @title Strategy\n * @author Babylon Finance\n *\n * Base Strategy contract. Belongs to a garden. Abstract.\n * Will be extended from specific strategy contracts.\n */\ncontract Strategy is ReentrancyGuard, IStrategy, Initializable {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for int256;\n    using SafeDecimalMath for uint256;\n    using Math for int256;\n    using Math for uint256;\n    using AddressArrayUtils for address[];\n    using BytesLib for bytes;\n    using BytesLib for address;\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event Invoked(address indexed _target, uint256 indexed _value, bytes _data, bytes _returnValue);\n    event StrategyVoted(\n        address indexed _garden,\n        uint256 totalPositiveVotes,\n        uint256 totalNegativeVotes,\n        uint256 _timestamp\n    );\n    event StrategyExecuted(address indexed _garden, uint256 _capital, uint256 _fee, uint256 timestamp);\n    event StrategyFinalized(address indexed _garden, uint256 _capitalReturned, uint256 _fee, uint256 timestamp);\n    event StrategyReduced(address indexed _garden, uint256 _amountReduced, uint256 timestamp);\n    event StrategyExpired(address indexed _garden, uint256 _timestamp);\n    event StrategyDeleted(address indexed _garden, uint256 _timestamp);\n    event StrategyDurationChanged(uint256 _newDuration, uint256 _oldDuration);\n\n    /* ============ Modifiers ============ */\n\n    function _onlyStrategistOrGovernor() private view {\n        _require(msg.sender == strategist || msg.sender == controller.owner(), Errors.ONLY_STRATEGIST);\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    function _onlyOperation() private view {\n        bool found;\n        for (uint8 i = 0; i < opTypes.length; i++) {\n            found = found || msg.sender == controller.enabledOperations(opTypes[i]);\n        }\n        // Internal function used to reduce bytecode size\n        _require(found, Errors.ONLY_OPERATION);\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     */\n    function _onlyKeeper() private view {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     */\n    function _onlyIntegration(address _address) private view {\n        bool isIntegration;\n        for (uint256 i = 0; i < opIntegrations.length; i++) {\n            if (opIntegrations[i] == _address) {\n                isIntegration = true;\n                break;\n            }\n        }\n        IMasterSwapper masterSwapper = IMasterSwapper(IBabController(controller).masterSwapper());\n        _require(isIntegration || masterSwapper.isTradeIntegration(_address), Errors.ONLY_INTEGRATION);\n    }\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(\n            !IBabController(controller).isPaused(address(this)) || msg.sender == controller.owner(),\n            Errors.ONLY_UNPAUSED\n        );\n    }\n\n    /* ============ Constants ============ */\n\n    uint256 private constant DEFAULT_TRADE_SLIPPAGE = 25e15; // 2.5%\n    uint256 private constant HUNDRED_PERCENT = 1e18; // 100%\n    uint256 private constant MAX_CANDIDATE_PERIOD = 7 days;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    // Max Operations\n    uint256 private constant MAX_OPERATIONS = 6;\n\n    // Quadratic penalty for looses\n    uint256 private constant STAKE_QUADRATIC_PENALTY_FOR_LOSSES = 175e16; // 1.75e18\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Babylon Controller Address\n    IBabController private controller;\n\n    // Type of operation.\n    // 0 = BuyOperation\n    // 1 = LiquidityOperation\n    // 2 = VaultOperation\n    // 3 = LendOperation\n    // 4 = BorrowOperation\n\n    // Asset Status\n    // 0 = Liquid\n    // 1 = Put as collateral\n    // 2 = Borrowed\n    // 3 = staked\n\n    // Types and data for the operations of this strategy\n    uint8[] private opTypes;\n    address[] private opIntegrations;\n    address[] private opDatas; // DEPRECATED\n\n    // Garden that these strategies belong to\n    IGarden public override garden;\n\n    address public override strategist; // Address of the strategist that submitted the bet\n\n    uint256 public override enteredAt; // Timestamp when the strategy was submitted\n    uint256 public override enteredCooldownAt; // Timestamp when the strategy reached quorum\n    uint256 private executedAt; // Timestamp when the strategy was executed\n    uint256 private updatedAt; // Timestamp of last capital allocation update\n    uint256 private exitedAt; // Timestamp when the strategy was submitted\n\n    address[] public voters; // Addresses with the voters\n    uint256 public override totalPositiveVotes; // Total positive votes endorsing the strategy execution\n    uint256 public override totalNegativeVotes; // Total negative votes against the strategy execution\n    bool private finalized; // Flag that indicates whether we exited the strategy\n    bool private active; // Whether the strategy has met the voting quorum\n    bool private dataSet;\n    bool private hasMiningStarted; // DEPRECATED\n\n    uint256 public override duration; // Duration of the bet\n    uint256 public override stake; // Amount of stake by the strategist (in reserve asset) needs to be positive\n    uint256 public override maxCapitalRequested; // Amount of max capital to allocate\n    uint256 public override capitalAllocated; // Current amount of capital allocated\n    uint256 public override expectedReturn; // Expect return by this strategy\n    uint256 public override capitalReturned; // Actual return by this strategy\n    uint256 private startingGardenSupply; // garden token supply when strategy starts\n    address[] private tokensNeeded; // Not used anymore\n    uint256[] private tokenAmountsNeeded; // Not used anymore\n\n    uint256 public override strategyRewards; // Rewards allocated for this strategy updated on finalized\n    uint256 private endingGardenSupply; // garden token supply when strategy ends\n\n    // Voters mapped to their votes.\n    mapping(address => int256) private votes;\n\n    // Strategy opDatas encoded\n    bytes public override opEncodedData; // we use and reserve 64bytes for each operation as consecutives bytes64 word\n\n    // Rewards Distributor address\n    IRewardsDistributor private rewardsDistributor;\n\n    uint256 public override maxAllocationPercentage; //  Relative to garden capital. (1% = 1e16, 10% 1e17)\n\n    uint256 public override maxGasFeePercentage; // Relative to the capital allocated to the strategy (1% = 1e16, 10% 1e17)\n\n    uint256 public override maxTradeSlippagePercentage; // Relative to the capital of the trade (1% = 1e16, 10% 1e17)\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the strategy for a garden\n     *\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _controller                    Address of the controller\n     * @param _maxCapitalRequested           Max Capital requested denominated in the reserve asset (0 to be unlimited)\n     * @param _stake                         Stake with garden participations absolute amounts 1e18\n     * @param _strategyDuration              Strategy duration in seconds\n     * @param _expectedReturn                Expected return\n     * @param _maxAllocationPercentage       Max allocation percentage of garden capital\n     * @param _maxGasFeePercentage           Max gas fee percentage of garden capital\n     * @param _maxTradeSlippagePercentage    Max slippage allowed per trade in % of capital\n     */\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _maxAllocationPercentage,\n        uint256 _maxGasFeePercentage,\n        uint256 _maxTradeSlippagePercentage\n    ) external override initializer {\n        controller = IBabController(_controller);\n        garden = IGarden(_garden);\n\n        _require(controller.isSystemContract(_garden), Errors.NOT_A_GARDEN);\n        _require(IERC20(address(garden)).balanceOf(_strategist) > 0, Errors.STRATEGIST_TOKENS_TOO_LOW);\n        _require(_maxCapitalRequested > 0, Errors.MAX_CAPITAL_REQUESTED);\n\n        maxCapitalRequested = _maxCapitalRequested;\n\n        _setStake(_stake, _strategist);\n        _setDuration(_strategyDuration);\n        _setMaxTradeSlippage(_maxTradeSlippagePercentage);\n        _setMaxGasFeePercentage(_maxGasFeePercentage);\n        _setMaxAllocationPercentage(_maxAllocationPercentage);\n\n        strategist = _strategist;\n        enteredAt = block.timestamp;\n\n        rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        expectedReturn = _expectedReturn;\n\n        votes[_strategist] = _stake.toInt256();\n        totalPositiveVotes = _stake;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Sets the data for the operations of this strategy\n     * @param _opTypes                    An array with the op types\n     * @param _opIntegrations             Addresses with the integration for each op\n     * @param _opEncodedData              Bytes with the params for the op in the same position in the opTypes array\n     */\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes memory _opEncodedData\n    ) external override {\n        _require(\n            msg.sender == address(garden) && !dataSet && IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_GARDEN_AND_DATA_NOT_SET\n        );\n        uint256 opEncodedLength = _opEncodedData.length.div(64); // encoded without signature\n        _require(\n            opEncodedLength < MAX_OPERATIONS &&\n                opEncodedLength > 0 &&\n                (_opTypes.length == _opIntegrations.length) &&\n                (_opIntegrations.length == opEncodedLength),\n            Errors.TOO_MANY_OPS\n        );\n        for (uint256 i = 0; i < _opTypes.length; i++) {\n            IOperation(controller.enabledOperations(_opTypes[i])).validateOperation(\n                BytesLib.get64Bytes(_opEncodedData, i),\n                garden,\n                _opIntegrations[i],\n                i\n            );\n        }\n        opTypes = _opTypes;\n        opIntegrations = _opIntegrations;\n        opEncodedData = _opEncodedData;\n        dataSet = true;\n    }\n\n    /**\n     * Adds off-chain voting results on-chain.\n     * @param _voters                  An array of garden member who voted on strategy.\n     * @param _votes                   An array of votes by on strategy by garden members.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     */\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 _fee\n    ) external override {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(_voters.length >= garden.minVoters(), Errors.MIN_VOTERS_CHECK);\n        _require(!active && !finalized, Errors.VOTES_ALREADY_RESOLVED);\n        _require(block.timestamp.sub(enteredAt) <= MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OVER);\n        _require(_voters.length == _votes.length, Errors.INVALID_VOTES_LENGTH);\n        active = true;\n\n        // set votes to zero expecting keeper to provide correct values\n        totalPositiveVotes = 0;\n        totalNegativeVotes = 0;\n\n        // Set votes data\n        for (uint256 i = 0; i < _voters.length; i++) {\n            votes[_voters[i]] = _votes[i];\n            if (_votes[i] > 0) {\n                totalPositiveVotes = totalPositiveVotes.add(uint256(Math.abs(_votes[i])));\n            } else {\n                totalNegativeVotes = totalNegativeVotes.add(uint256(Math.abs(_votes[i])));\n            }\n        }\n\n        _require(totalPositiveVotes.sub(totalNegativeVotes) > 0, Errors.TOTAL_VOTES_HAVE_TO_BE_POSITIVE);\n\n        // Keeper will account for strategist vote/stake\n        voters = _voters;\n\n        // Initializes cooldown\n        enteredCooldownAt = block.timestamp;\n        emit StrategyVoted(address(garden), totalPositiveVotes, totalNegativeVotes, block.timestamp);\n        garden.payKeeper(msg.sender, _fee);\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     */\n    function executeStrategy(uint256 _capital, uint256 _fee) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(_capital > 0, Errors.MIN_REBALANCE_CAPITAL);\n        _executesStrategy(_capital, _fee, msg.sender);\n    }\n\n    /**\n     * Exits from an executed strategy.\n     * Returns balance back to the garden and sets the capital aside for withdrawals in ETH.\n     * Pays the keeper.\n     * Updates the reserve asset position accordingly.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     * @param _tokenURI                URL with the JSON for the strategy\n     */\n    function finalizeStrategy(uint256 _fee, string memory _tokenURI) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(executedAt > 0 && block.timestamp > executedAt.add(duration), Errors.STRATEGY_IS_NOT_OVER_YET);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        uint256 reserveAssetReturns = IERC20(garden.reserveAsset()).balanceOf(address(this));\n        // Execute exit operations\n        _exitStrategy(HUNDRED_PERCENT);\n        capitalReturned = IERC20(garden.reserveAsset()).balanceOf(address(this)).sub(reserveAssetReturns);\n        // Mark as finalized\n        finalized = true;\n        active = false;\n        exitedAt = block.timestamp;\n        // Mint NFT\n        IStrategyNFT(IBabController(controller).strategyNFT()).grantStrategyNFT(strategist, _tokenURI);\n        // Pay Keeper Fee\n        garden.payKeeper(msg.sender, _fee);\n        // Transfer rewards\n        _transferStrategyPrincipal();\n        // Send rest to garden if any\n        _sendReserveAssetToGarden();\n        updatedAt = exitedAt;\n        emit StrategyFinalized(address(garden), capitalReturned, _fee, block.timestamp);\n    }\n\n    /**\n     * Partially unwinds an strategy.\n     * Triggered from an immediate withdraw in the Garden.\n     * @param _amountToUnwind  The amount of capital to unwind\n     * @param _strategyNAV     NAV of the strategy to unwind.\n     */\n    function unwindStrategy(uint256 _amountToUnwind, uint256 _strategyNAV) external override nonReentrant {\n        _require(\n            (msg.sender == address(garden) && IBabController(controller).isSystemContract(address(garden))) ||\n                msg.sender == controller.owner(),\n            Errors.ONLY_PROTOCOL_OR_GARDEN\n        );\n        _onlyUnpaused();\n        _require(active && !finalized, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        // An unwind should not allow users to remove all capital from a strategy\n        _require(_amountToUnwind < _strategyNAV, Errors.INVALID_CAPITAL_TO_UNWIND);\n        // Exits and enters the strategy\n        _exitStrategy(_amountToUnwind.preciseDiv(_strategyNAV));\n        capitalAllocated = capitalAllocated.sub(_amountToUnwind);\n\n        rewardsDistributor.updateProtocolPrincipal(_amountToUnwind, false);\n\n        // Send the amount back to the garden for the immediate withdrawal\n        // TODO: Transfer the precise value; not entire balance\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n        updatedAt = block.timestamp;\n\n        emit StrategyReduced(address(garden), _amountToUnwind, block.timestamp);\n    }\n\n    /**\n     * Expires a candidate that has spent more than CANDIDATE_PERIOD without\n     * reaching quorum\n     * @param _fee              The keeper fee\n     */\n    function expireStrategy(uint256 _fee) external nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n        _require(block.timestamp.sub(enteredAt) > MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OPENED);\n        // pay keeper before expiring strategy\n        garden.payKeeper(msg.sender, _fee);\n        _deleteCandidateStrategy();\n        emit StrategyExpired(address(garden), block.timestamp);\n    }\n\n    /**\n     * Delete a candidate strategy by the strategist\n     */\n    function deleteCandidateStrategy() external {\n        _onlyStrategistOrGovernor();\n        _deleteCandidateStrategy();\n        emit StrategyDeleted(address(garden), block.timestamp);\n    }\n\n    /**\n     * Allows strategist to update some strategy params\n     * @dev\n     *   _params[0]  duration\n     *   _params[1]  maxGasFeePercentage\n     *   _params[2]  maxTradeSlippagePercentage\n     *   _params[3]  maxAllocationPercentage\n     * @param _params  New params\n     */\n    function updateParams(uint256[4] calldata _params) external override {\n        _onlyStrategistOrGovernor();\n        _onlyUnpaused();\n\n        _require(_params[0] < duration, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n\n        _setDuration(_params[0]);\n        _setMaxGasFeePercentage(_params[1]);\n        _setMaxTradeSlippage(_params[2]);\n        _setMaxAllocationPercentage(_params[3]);\n\n        emit StrategyDurationChanged(_params[0], duration);\n    }\n\n    /**\n     * Any tokens (other than the target) that are sent here by mistake are recoverable by contributors\n     * Converts it to the reserve asset and sends it to the garden.\n     * @param _token             Address of the token to sweep\n     */\n    function sweep(address _token) external nonReentrant {\n        _onlyUnpaused();\n        _require(\n            IERC20(address(garden)).balanceOf(msg.sender) > 0 &&\n                IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_CONTRIBUTOR\n        );\n        _require(_token != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(_token != garden.reserveAsset(), Errors.CANNOT_SWEEP_RESERVE_ASSET);\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _require(balance > 0, Errors.BALANCE_TOO_LOW);\n\n        _trade(_token, balance, garden.reserveAsset());\n        // Send reserve asset to garden\n        _sendReserveAssetToGarden();\n    }\n\n    /**\n     * Helper to invoke Approve on ERC20 from integrations in the strategy context\n     */\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external override {\n        _onlyIntegration(msg.sender);\n        _onlyUnpaused();\n        IERC20(_asset).safeApprove(_spender, 0);\n        IERC20(_asset).safeApprove(_spender, _quantity);\n    }\n\n    /**\n     * Helper to invoke a call to an external contract from integrations in the strategy context\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external override returns (bytes memory) {\n        _onlyIntegration(msg.sender);\n        _onlyUnpaused();\n        return _invoke(_target, _value, _data);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external override returns (uint256) {\n        _onlyOperation();\n        _onlyUnpaused();\n        return _trade(_sendToken, _sendQuantity, _receiveToken);\n    }\n\n    /**\n     * Deposits or withdraws weth from an operation in this context\n     * @param _isDeposit                    Whether is a deposit or withdraw\n     * @param _wethAmount                   Amount to deposit or withdraw\n     */\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) public override {\n        _onlyOperation();\n        _handleWeth(_isDeposit, _wethAmount);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Returns whether this strategy is currently active or not\n     */\n    function isStrategyActive() external view override returns (bool) {\n        return executedAt > 0 && exitedAt == 0;\n    }\n\n    /**\n     * Returns the number of operations in this strategy\n     */\n    function getOperationsCount() external view override returns (uint256) {\n        return opTypes.length;\n    }\n\n    /**\n     * Get the non-state related details of a Strategy\n     *\n     */\n    function getStrategyDetails()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            address(this),\n            strategist,\n            opIntegrations.length,\n            stake,\n            totalPositiveVotes,\n            totalNegativeVotes,\n            capitalAllocated,\n            capitalReturned,\n            duration,\n            expectedReturn,\n            maxCapitalRequested,\n            IBabController(controller).strategyNFT(),\n            enteredAt,\n            getNAV()\n        );\n    }\n\n    /**\n     * Get mining context details of a Strategy\n     *\n     */\n    function getStrategyRewardsContext()\n        external\n        view\n        override\n        returns (\n            address,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        uint256[] memory data = new uint256[](14);\n        bool[] memory boolData = new bool[](2);\n\n        data[0] = executedAt;\n        data[1] = exitedAt;\n        data[2] = updatedAt;\n        data[3] = enteredAt;\n        data[4] = totalPositiveVotes;\n        data[5] = totalNegativeVotes;\n        data[6] = capitalAllocated;\n        data[7] = capitalReturned;\n        data[8] = capitalAllocated.add(capitalAllocated.preciseMul(expectedReturn));\n        data[9] = strategyRewards;\n        boolData[0] = capitalReturned >= capitalAllocated ? true : false;\n        boolData[1] = capitalReturned >= data[8] ? true : false;\n        data[10] = boolData[0] ? capitalReturned.sub(capitalAllocated) : 0; // no profit\n        data[11] = boolData[1] ? capitalReturned.sub(data[8]) : data[8].sub(capitalReturned);\n        data[12] = startingGardenSupply;\n        data[13] = endingGardenSupply;\n        return (strategist, data, boolData);\n    }\n\n    /**\n     * Get the state of a Strategy\n     *\n     */\n    function getStrategyState()\n        external\n        view\n        override\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (address(this), active, dataSet, finalized, executedAt, exitedAt, updatedAt);\n    }\n\n    /**\n     * Get the operation params by index\n     *\n     */\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        override\n        returns (\n            uint8,\n            address,\n            bytes memory\n        )\n    {\n        _require(_index >= 0 && _index < opTypes.length, Errors.NOT_IN_RANGE);\n        // _getOpDecodedData guarantee backward compatibility with OpData\n        return (opTypes[_index], opIntegrations[_index], _getOpDecodedData(_index));\n    }\n\n    /**\n     * Gets the NAV of assets under management.\n     * It is the sum of the NAV of all the operations\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV() public view override returns (uint256) {\n        uint256 positiveNav;\n        uint256 negativeNav;\n        address reserveAsset = garden.reserveAsset();\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(uint256(opTypes[i])));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            try operation.getNAV(_getOpDecodedData(i), garden, opIntegrations[i]) returns (\n                uint256 opNAV,\n                bool positive\n            ) {\n                if (positive) {\n                    positiveNav = positiveNav.add(opNAV);\n                } else {\n                    negativeNav = negativeNav.add(opNAV);\n                }\n            } catch {}\n        }\n        uint256 lastOp = opTypes.length - 1;\n        if (opTypes[lastOp] == 4) {\n            // Backward compatibility\n            // pointer to the starting byte of the ethereum token address\n            address token =\n                opDatas.length > 0\n                    ? opDatas[lastOp]\n                    : BytesLib.decodeOpDataAddressAssembly(opEncodedData, (64 * lastOp) + 12);\n            uint256 borrowBalance = IERC20(token).universalBalanceOf(address(this));\n            if (borrowBalance > 0) {\n                uint256 price = _getPrice(reserveAsset, token);\n                positiveNav = positiveNav.add(\n                    SafeDecimalMath.normalizeAmountTokens(token, reserveAsset, borrowBalance).preciseDiv(price)\n                );\n            }\n        }\n        if (negativeNav > positiveNav) {\n            // Underwater, will display using operation NAV\n            return 0;\n        }\n        return positiveNav.sub(negativeNav);\n    }\n\n    /**\n     * Gets the votes casted by the contributor in this strategy\n     *\n     * @param _address           Address of the contributor\n     * @return _votes            Number of votes cast\n     */\n    function getUserVotes(address _address) external view override returns (int256) {\n        return votes[_address];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _setStake(uint256 _stake, address _strategist) internal {\n        _require(\n            _stake > 0 &&\n                IERC20(address(garden)).balanceOf(_strategist).sub(garden.getLockedBalance(_strategist)) >= _stake,\n            Errors.TOKENS_STAKED\n        );\n        stake = _stake;\n    }\n\n    function _setMaxAllocationPercentage(uint256 _maxAllocationPercentage) internal {\n        _require(_maxAllocationPercentage <= 1e18, Errors.MAX_STRATEGY_ALLOCATION_PERCENTAGE);\n        maxAllocationPercentage = _maxAllocationPercentage;\n    }\n\n    function _setMaxGasFeePercentage(uint256 _maxGasFeePercentage) internal {\n        _require(_maxGasFeePercentage <= 10e16, Errors.MAX_GAS_FEE_PERCENTAGE);\n        maxGasFeePercentage = _maxGasFeePercentage;\n    }\n\n    function _setMaxTradeSlippage(uint256 _maxTradeSlippagePercentage) internal {\n        _require(_maxTradeSlippagePercentage <= 20e16, Errors.MAX_TRADE_SLIPPAGE_PERCENTAGE);\n        maxTradeSlippagePercentage = _maxTradeSlippagePercentage;\n    }\n\n    function _setDuration(uint256 _strategyDuration) internal {\n        _require(\n            _strategyDuration >= garden.minStrategyDuration() && _strategyDuration <= garden.maxStrategyDuration(),\n            Errors.DURATION_MUST_BE_IN_RANGE\n        );\n        duration = _strategyDuration;\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * Keeper will validate that quorum is reached, cacluates all the voting data and push it.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     * @param _keeper                   The address of the keeper to pay\n     */\n    function _executesStrategy(\n        uint256 _capital,\n        uint256 _fee,\n        address payable _keeper\n    ) private {\n        _require(active, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(capitalAllocated.add(_capital) <= maxCapitalRequested, Errors.MAX_CAPITAL_REACHED);\n        _require(\n            block.timestamp.sub(enteredCooldownAt) >= garden.strategyCooldownPeriod(),\n            Errors.STRATEGY_IN_COOLDOWN\n        );\n        // Execute enter operation\n        garden.allocateCapitalToStrategy(_capital);\n        capitalAllocated = capitalAllocated.add(_capital);\n        _enterStrategy(_capital);\n        // Sets the executed timestamp on first execution\n        if (executedAt == 0) {\n            executedAt = block.timestamp;\n            // Checkpoint of garden supply at start\n            startingGardenSupply = IERC20(address(garden)).totalSupply();\n        }\n        rewardsDistributor.updateProtocolPrincipal(_capital, true);\n        garden.payKeeper(_keeper, _fee);\n        updatedAt = block.timestamp;\n        emit StrategyExecuted(address(garden), _capital, _fee, block.timestamp);\n    }\n\n    /**\n     * Enters the strategy.\n     * Executes all the operations in order\n     * @param _capital  Amount of capital that the strategy receives\n     */\n    function _enterStrategy(uint256 _capital) private {\n        uint256 capitalForNexOperation = _capital;\n        address assetAccumulated = garden.reserveAsset();\n        uint8 assetStatus; // liquid\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i]));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            (assetAccumulated, capitalForNexOperation, assetStatus) = operation.executeOperation(\n                assetAccumulated,\n                capitalForNexOperation,\n                assetStatus,\n                _getOpDecodedData(i),\n                garden,\n                opIntegrations[i]\n            );\n        }\n    }\n\n    /**\n     * Exits the strategy.\n     * Exists all the operations starting by the end.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function _exitStrategy(uint256 _percentage) private {\n        address assetFinalized = garden.reserveAsset();\n        uint256 capitalPending;\n        uint8 assetStatus;\n        for (uint256 i = opTypes.length; i > 0; i--) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i - 1]));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            (assetFinalized, capitalPending, assetStatus) = operation.exitOperation(\n                assetFinalized,\n                capitalPending,\n                assetStatus,\n                _percentage,\n                _getOpDecodedData(i - 1),\n                garden,\n                opIntegrations[i - 1]\n            );\n        }\n        // Consolidate to reserve asset if needed\n        if (assetFinalized != garden.reserveAsset() && capitalPending > 0) {\n            if (assetFinalized == address(0)) {\n                _handleWeth(true, address(this).balance);\n                assetFinalized = WETH;\n            }\n            if (assetFinalized != garden.reserveAsset()) {\n                _trade(assetFinalized, IERC20(assetFinalized).balanceOf(address(this)), garden.reserveAsset());\n            }\n        }\n    }\n\n    /**\n     * Deletes this strategy and returns the stake to the strategist\n     */\n    function _deleteCandidateStrategy() private {\n        _require(executedAt == 0 && !finalized, Errors.STRATEGY_IS_EXECUTED);\n        IGarden(garden).expireCandidateStrategy(address(this));\n    }\n\n    /**\n     * Low level function that allows an integration to make an arbitrary function\n     * call to any contract from the garden (garden as msg.sender).\n     *\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function _invoke(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) private returns (bytes memory _returnValue) {\n        _returnValue = _target.functionCallWithValue(_data, _value);\n        emit Invoked(_target, _value, _data, _returnValue);\n        return _returnValue;\n    }\n\n    function _sendReserveAssetToGarden() private {\n        // Sends the rest back if any\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     */\n    function _trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) private returns (uint256) {\n        // Uses on chain oracle for all internal strategy operations to avoid attacks\n        uint256 pricePerTokenUnit = _getPrice(_sendToken, _receiveToken);\n        _require(pricePerTokenUnit != 0, Errors.NO_PRICE_FOR_TRADE);\n        // minAmount must have receive token decimals\n        uint256 exactAmount =\n            SafeDecimalMath.normalizeAmountTokens(\n                _sendToken,\n                _receiveToken,\n                _sendQuantity.preciseMul(pricePerTokenUnit)\n            );\n        uint256 minAmountExpected =\n            exactAmount.sub(\n                exactAmount.preciseMul(\n                    maxTradeSlippagePercentage != 0 ? maxTradeSlippagePercentage : DEFAULT_TRADE_SLIPPAGE\n                )\n            );\n        ITradeIntegration(IBabController(controller).masterSwapper()).trade(\n            address(this),\n            _sendToken,\n            _sendQuantity,\n            _receiveToken,\n            minAmountExpected\n        );\n        return minAmountExpected;\n    }\n\n    function _transferStrategyPrincipal() private {\n        address reserveAsset = garden.reserveAsset();\n        int256 strategyReturns = capitalReturned.toInt256().sub(capitalAllocated.toInt256());\n        uint256 protocolProfits;\n        uint256 burningAmount;\n        // Strategy returns were positive\n        // in reserve asset, e.g., WETH, USDC, DAI, WBTC\n        uint256 profits = capitalReturned > capitalAllocated ? capitalReturned.sub(capitalAllocated) : 0;\n        if (capitalReturned >= capitalAllocated) {\n            // Send weth performance fee to the protocol\n            protocolProfits = IBabController(controller).protocolPerformanceFee().preciseMul(profits);\n            if (protocolProfits > 0) {\n                // We avoid a transfer in case capitalReturned == capitalAllocated\n                IERC20(reserveAsset).safeTransfer(IBabController(controller).treasury(), protocolProfits);\n            }\n            strategyReturns = strategyReturns.sub(protocolProfits.toInt256());\n        } else {\n            // Returns were negative so let's burn the strategiest stake\n            burningAmount = (stake.sub(capitalReturned.preciseDiv(capitalAllocated).preciseMul(stake))).multiplyDecimal(\n                STAKE_QUADRATIC_PENALTY_FOR_LOSSES\n            );\n        }\n        // Return the balance back to the garden\n        IERC20(reserveAsset).safeTransfer(address(garden), capitalReturned.sub(protocolProfits));\n        // profitsSharing[0]: strategistProfit %, profitsSharing[1]: stewardsProfit %, profitsSharing[2]: lpProfit %\n        if (address(rewardsDistributor) == address(0)) {\n            rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        }\n        uint256[3] memory profitsSharing = rewardsDistributor.getGardenProfitsSharing(address(garden));\n        // Checkpoint of garden supply (must go before burning tokens if penalty for strategist)\n        endingGardenSupply = IERC20(address(garden)).totalSupply();\n        garden.finalizeStrategy(\n            profits.sub(profits.preciseMul(profitsSharing[2])).sub(protocolProfits),\n            strategyReturns,\n            burningAmount\n        );\n        rewardsDistributor.updateProtocolPrincipal(capitalAllocated, false);\n        // Must be zero in case the mining program didnt started on time\n        strategyRewards = uint256(rewardsDistributor.getStrategyRewards(address(this)));\n    }\n\n    function _getPrice(address _assetOne, address _assetTwo) private view returns (uint256) {\n        try IPriceOracle(IBabController(controller).priceOracle()).getPrice(_assetOne, _assetTwo) returns (\n            uint256 price\n        ) {\n            return price;\n        } catch {\n            return 0;\n        }\n    }\n\n    // backward compatibility with OpData in case of ongoing strategies with deprecated OpData\n    function _getOpDecodedData(uint256 _index) private view returns (bytes memory) {\n        return\n            opDatas.length > 0 ? abi.encode(opDatas[_index], address(0)) : BytesLib.get64Bytes(opEncodedData, _index);\n    }\n\n    function _handleWeth(bool _isDeposit, uint256 _wethAmount) private {\n        _onlyUnpaused();\n        if (_isDeposit) {\n            IWETH(WETH).deposit{value: _wethAmount}();\n            return;\n        }\n        IWETH(WETH).withdraw(_wethAmount);\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract StrategyV14 is Strategy {}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/lib/UniversalERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n    function universalTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            address(uint160(to)).transfer(amount);\n            return true;\n        } else {\n            token.safeTransfer(to, amount);\n            return true;\n        }\n    }\n\n    function universalTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isETH(token)) {\n            require(from == msg.sender && msg.value >= amount, 'msg.value is zero');\n            if (to != address(this)) {\n                address(uint160(to)).transfer(amount);\n            }\n            if (msg.value > amount) {\n                msg.sender.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n\n    function universalApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (!isETH(token)) {\n            if (amount > 0 && token.allowance(address(this), to) > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, amount);\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function universalDecimals(IERC20 token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return 18;\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 5000}(abi.encodeWithSignature('decimals()'));\n\n        return success ? abi.decode(data, (uint256)) : 18;\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return address(token) == address(ZERO_ADDRESS);\n    }\n}\n"
    },
    "contracts/lib/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * original version by @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n *  Adapted by Babylon Finance.\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity 0.7.6;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n                case 2 {\n                    // Since the new array still fits in the slot, we just need to\n                    // update the contents of the slot.\n                    // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                    sstore(\n                        _preBytes.slot,\n                        // all the modifications to the slot are inside this\n                        // next block\n                        add(\n                            // we can just add to the slot contents because the\n                            // bytes we want to change are the LSBs\n                            fslot,\n                            add(\n                                mul(\n                                    div(\n                                        // load the bytes from memory\n                                        mload(add(_postBytes, 0x20)),\n                                        // zero all bytes to the right\n                                        exp(0x100, sub(32, mlength))\n                                    ),\n                                    // and now shift left the number of bytes to\n                                    // leave space for the length in the slot\n                                    exp(0x100, sub(32, newlength))\n                                ),\n                                // increase length by the double of the memory\n                                // bytes length\n                                mul(mlength, 2)\n                            )\n                        )\n                    )\n                }\n                case 1 {\n                    // The stored value fits in the slot, but the combined value\n                    // will exceed it.\n                    // get the keccak hash to get the contents of the array\n                    mstore(0x0, _preBytes.slot)\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                    // save new length\n                    sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                    // The contents of the _postBytes array start 32 bytes into\n                    // the structure. Our first read should obtain the `submod`\n                    // bytes that can fit into the unused space in the last word\n                    // of the stored array. To get this, we read 32 bytes starting\n                    // from `submod`, so the data we read overlaps with the array\n                    // contents by `submod` bytes. Masking the lowest-order\n                    // `submod` bytes allows us to add that value directly to the\n                    // stored value.\n\n                    let submod := sub(32, slength)\n                    let mc := add(_postBytes, submod)\n                    let end := add(_postBytes, mlength)\n                    let mask := sub(exp(0x100, submod), 1)\n\n                    sstore(\n                        sc,\n                        add(\n                            and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                            and(mload(mc), mask)\n                        )\n                    )\n\n                    for {\n                        mc := add(mc, 0x20)\n                        sc := add(sc, 1)\n                    } lt(mc, end) {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } {\n                        sstore(sc, mload(mc))\n                    }\n\n                    mask := exp(0x100, sub(mc, end))\n\n                    sstore(sc, mul(div(mload(mc), mask), mask))\n                }\n                default {\n                    // get the keccak hash to get the contents of the array\n                    mstore(0x0, _preBytes.slot)\n                    // Start copying to the last used word of the stored array.\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                    // save new length\n                    sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                    // Copy over the first `submod` bytes of the new data as in\n                    // case 1 above.\n                    let slengthmod := mod(slength, 32)\n                    let mlengthmod := mod(mlength, 32)\n                    let submod := sub(32, slengthmod)\n                    let mc := add(_postBytes, submod)\n                    let end := add(_postBytes, mlength)\n                    let mask := sub(exp(0x100, submod), 1)\n\n                    sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                    for {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } lt(mc, end) {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } {\n                        sstore(sc, mload(mc))\n                    }\n\n                    mask := exp(0x100, sub(mc, end))\n\n                    sstore(sc, mul(div(mload(mc), mask), mask))\n                }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, 'toUint32_outOfBounds');\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, 'toUint64_outOfBounds');\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, 'toUint96_outOfBounds');\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, 'toUint128_outOfBounds');\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, 'toBytes32_outOfBounds');\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n                case 1 {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                    let cb := 1\n\n                    let mc := add(_preBytes, 0x20)\n                    let end := add(mc, length)\n\n                    for {\n                        let cc := add(_postBytes, 0x20)\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                    } eq(add(lt(mc, end), cb), 2) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        // if any of these checks fails then arrays are not equal\n                        if iszero(eq(mload(mc), mload(cc))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n                case 1 {\n                    // slength can contain both the length and contents of the array\n                    // if length < 32 bytes so let's prepare for that\n                    // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                    if iszero(iszero(slength)) {\n                        switch lt(slength, 32)\n                            case 1 {\n                                // blank the last byte which is the length\n                                fslot := mul(div(fslot, 0x100), 0x100)\n\n                                if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                                    // unsuccess:\n                                    success := 0\n                                }\n                            }\n                            default {\n                                // cb is a circuit breaker in the for loop since there's\n                                //  no said feature for inline assembly loops\n                                // cb = 1 - don't breaker\n                                // cb = 0 - break\n                                let cb := 1\n\n                                // get the keccak hash to get the contents of the array\n                                mstore(0x0, _preBytes.slot)\n                                let sc := keccak256(0x0, 0x20)\n\n                                let mc := add(_postBytes, 0x20)\n                                let end := add(mc, mlength)\n\n                                // the next line is the loop condition:\n                                // while(uint256(mc < end) + cb == 2)\n                                for {\n\n                                } eq(add(lt(mc, end), cb), 2) {\n                                    sc := add(sc, 1)\n                                    mc := add(mc, 0x20)\n                                } {\n                                    if iszero(eq(sload(sc), mload(mc))) {\n                                        // unsuccess:\n                                        success := 0\n                                        cb := 0\n                                    }\n                                }\n                            }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n\n        return success;\n    }\n\n    function get64Bytes(bytes memory _data, uint256 _index) internal pure returns (bytes memory) {\n        return slice(_data, (64 * _index), 64);\n    }\n\n    function decodeOpDataAddressAssembly(bytes memory _data, uint256 _startingByte) internal pure returns (address) {\n        return toAddress(_data, _startingByte);\n    }\n\n    function decodeOpDataAddress(bytes calldata _data) internal pure returns (address) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        return abi.decode(_data, (address));\n    }\n\n    function decodeOpDataAddressAndUint(bytes calldata _data) internal pure returns (address, uint256) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        return abi.decode(_data, (address, uint256));\n    }\n\n    function decodeOpDataAsType(\n        bytes memory _data,\n        uint8 _type,\n        uint8 _offset\n    ) internal pure returns (bytes memory) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        // type: 0 - uint8, 1: uint256, 2: bool, 3: address\n        if (_type == 0 || _type == 2) {\n            // boolean is also 1 byte\n            // returning bytes type\n            return slice(_data, _offset, 1); // to return uint8 type better use toUint8(_data, _offset);\n        } else if (_type == 1) {\n            // returning bytes type\n            return slice(_data, _offset, 32); // to return uint256 type better use toUint256(_data, _offset);\n        } else if (_type == 3) {\n            // returning bytes type\n            return slice(_data, _offset, 20); // to return address type better use toAddress(_data, _offset);\n        }\n        // Default uint\n        return slice(_data, _offset, 1);\n    }\n}\n"
    },
    "contracts/interfaces/external/weth/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/ITradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ITrade\n * @author Babylon Finance\n *\n * Interface for trading protocol integrations\n */\ninterface ITradeIntegration {\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external;\n}\n"
    },
    "contracts/interfaces/IOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IStrategy} from './IStrategy.sol';\n\n/**\n * @title IOperation\n * @author Babylon Finance\n *\n * Interface for an strategy operation\n */\ninterface IOperation {\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view returns (uint256, bool);\n\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IMasterSwapper.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IMasterSwapper {\n    /* ============ Functions ============ */\n\n    function isTradeIntegration(address _integration) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IStrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IStrategyNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Strategy NFT.\n */\ninterface IStrategyNFT {\n    struct StratDetail {\n        string name;\n        string symbol;\n        uint256 tokenId;\n    }\n\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI) external returns (uint256);\n\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external;\n\n    function getStrategyTokenURI(address _stratgy) external view returns (string memory);\n\n    function getStrategyName(address _strategy) external view returns (string memory);\n}\n"
    },
    "contracts/strategies/operations/BorrowOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {Errors, _require} from '../../lib/BabylonErrors.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title BorrowOperation\n * @author Babylon Finance\n *\n * Executes a borrow operation\n */\ncontract BorrowOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the borrow operation\n     *\n     * param _data                   Operation data\n     * param _garden                 Garden\n     * param _integration            Integration used\n     * @param _index                  Index of this operation\n     */\n    function validateOperation(\n        bytes calldata, /* _data */\n        IGarden, /* _garden */\n        address, /* _integration */\n        uint256 _index\n    ) external view override onlyStrategy {\n        require(_index > 0, 'The operation cannot be the first. Needs to be a lend first');\n    }\n\n    /**\n     * Executes the borrow operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * @param _assetStatus        Status of the asset amount\n     * @param _data               Operation data (e.g. Token to borrow)\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes memory _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address borrowToken = BytesLib.decodeOpDataAddressAssembly(_data, 12);\n        uint256 normalizedAmount = _getBorrowAmount(_asset, borrowToken, _capital, _integration);\n        require(_capital > 0 && _assetStatus == 1 && _asset != borrowToken, 'There is no collateral locked');\n        _onlyPositiveCollateral(msg.sender, _asset, _integration);\n        IBorrowIntegration(_integration).borrow(msg.sender, borrowToken, normalizedAmount);\n        borrowToken = borrowToken == address(0) ? WETH : borrowToken;\n        return (borrowToken, IERC20(borrowToken).balanceOf(address(msg.sender)), 0); // borrowings are liquid\n    }\n\n    function _onlyPositiveCollateral(\n        address _sender,\n        address _asset,\n        address _integration\n    ) internal view {\n        require(\n            IBorrowIntegration(_integration).getCollateralBalance(_sender, _asset) > 0,\n            'There is no collateral locked'\n        );\n    }\n\n    function _getBorrowAmount(\n        address _asset,\n        address _borrowToken,\n        uint256 _capital,\n        address _integration\n    ) internal view returns (uint256) {\n        uint256 price = _getPrice(_asset, _borrowToken);\n        // % of the total collateral value in the borrow token\n        uint256 amountToBorrow =\n            _capital.preciseMul(price).preciseMul(IBorrowIntegration(_integration).maxCollateralFactor());\n        uint256 normalizedAmount = SafeDecimalMath.normalizeAmountTokens(_asset, _borrowToken, amountToBorrow);\n        return normalizedAmount;\n    }\n\n    /**\n     * Exits the borrow operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = BytesLib.decodeOpDataAddress(_data);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        uint256 debtAmount = IBorrowIntegration(_integration).getBorrowBalance(msg.sender, assetToken);\n        uint256 debtTokenBalance =\n            address(0) == assetToken ? address(msg.sender).balance : IERC20(assetToken).balanceOf(address(msg.sender));\n        uint256 amountToRepay =\n            debtAmount > debtTokenBalance\n                ? debtTokenBalance.preciseMul(_percentage)\n                : debtAmount.preciseMul(_percentage);\n        IBorrowIntegration(_integration).repay(\n            msg.sender,\n            assetToken,\n            amountToRepay // We repay the percentage of all that we can\n        );\n        return (assetToken, IBorrowIntegration(_integration).getBorrowBalance(msg.sender, assetToken), 2);\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset borrowed\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override onlyStrategy returns (uint256, bool) {\n        address borrowToken = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 tokensOwed = IBorrowIntegration(_integration).getBorrowBalance(msg.sender, borrowToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), borrowToken);\n        uint256 NAV =\n            SafeDecimalMath.normalizeAmountTokens(borrowToken, _garden.reserveAsset(), tokensOwed).preciseDiv(price);\n        return (NAV, false);\n    }\n}\n"
    },
    "contracts/interfaces/IBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IBorrowIntegration\n * @author Babylon Finance\n *\n * Interface for borrow integrations\n */\ninterface IBorrowIntegration {\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 borrowAmount\n    ) external;\n\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external;\n\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor) external;\n\n    function maxCollateralFactor() external view returns (uint256);\n\n    function getBorrowBalance(address _strategy, address _asset) external view returns (uint256);\n\n    function getCollateralBalance(address _strategy, address asset) external view returns (uint256);\n\n    function getRemainingLiquidity(address _strategy) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/Operation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IOperation} from '../../interfaces/IOperation.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\n/**\n * @title LongStrategy\n * @author Babylon Finance\n *\n * Holds the data for a long strategy\n */\nabstract contract Operation is IOperation {\n    using SafeMath for uint256;\n    using BytesLib for uint256;\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy() {\n        IStrategy strategy = IStrategy(msg.sender);\n        IGarden garden = strategy.garden();\n        require(IBabController(controller).isSystemContract(address(garden)), 'Only a garden can call this');\n        require(garden.strategyMapping(msg.sender), 'Sender must be a strategy');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Address of the controller\n    address public controller;\n    // Name of the operation\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) {\n        require(_controller != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ Virtual External Functions ============ */\n\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view virtual override;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view virtual override returns (uint256, bool);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the operation\n     */\n    function getName() external view override returns (string memory) {\n        return name;\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle\n     */\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        try\n            oracle.getPrice(_assetOne == address(0) ? WETH : _assetOne, _assetTwo == address(0) ? WETH : _assetTwo)\n        returns (uint256 price) {\n            return price;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle including univ2\n     */\n    function _getPriceNAV(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return\n            oracle.getPriceNAV(_assetOne == address(0) ? WETH : _assetOne, _assetTwo == address(0) ? WETH : _assetTwo);\n    }\n}\n"
    },
    "contracts/strategies/operations/LendOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title LendOperation\n * @author Babylon Finance\n *\n * Executes a lend operation\n */\ncontract LendOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the lend operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {}\n\n    /**\n     * Executes the lend operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _data               OpData e.g. Address of the asset to lend\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = BytesLib.decodeOpDataAddress(_data); // We just use the first 20 bytes from the whole opEncodedData\n        if (assetToken != _asset) {\n            // Trade to WETH if is 0x0 (eth in compound)\n            if (assetToken != address(0) || _asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, _capital, assetToken == address(0) ? WETH : assetToken);\n            }\n        }\n        uint256 numTokensToSupply;\n        if (assetToken == address(0)) {\n            // change it to plain eth for compound\n            IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            numTokensToSupply = address(msg.sender).balance;\n        } else {\n            numTokensToSupply = IERC20(assetToken).balanceOf(msg.sender);\n        }\n        uint256 exactAmount = ILendIntegration(_integration).getExpectedShares(assetToken, numTokensToSupply);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ILendIntegration(_integration).supplyTokens(msg.sender, assetToken, numTokensToSupply, minAmountExpected);\n        return (assetToken, numTokensToSupply, 1); // put as collateral\n    }\n\n    /**\n     * Exits the lend operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address _borrowToken,\n        uint256 _remaining,\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes memory _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = BytesLib.decodeOpDataAddressAssembly(_data, 12);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        _redeemTokens(_borrowToken, _remaining, _percentage, msg.sender, _integration, assetToken);\n        _tokenToTrade(assetToken, msg.sender, _garden, _integration);\n        return (_garden.reserveAsset(), IERC20(_garden.reserveAsset()).balanceOf(msg.sender), 0);\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset lent\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        address lendToken = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 assetTokenAmount = ILendIntegration(_integration).getInvestmentTokenAmount(msg.sender, lendToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), lendToken);\n        uint256 NAV =\n            SafeDecimalMath.normalizeAmountTokens(lendToken, _garden.reserveAsset(), assetTokenAmount).preciseDiv(\n                price\n            );\n        address rewardsToken = _getRewardToken(_integration);\n        if (rewardsToken != address(0)) {\n            uint256 rewardsAmount = ILendIntegration(_integration).getRewardsAccrued(msg.sender);\n            if (rewardsAmount > 0) {\n                uint256 priceRewards = _getPrice(_garden.reserveAsset(), rewardsToken);\n                // We add rewards\n                if (priceRewards != 0) {\n                    NAV = NAV.add(\n                        SafeDecimalMath\n                            .normalizeAmountTokens(rewardsToken, _garden.reserveAsset(), rewardsAmount)\n                            .preciseDiv(priceRewards)\n                    );\n                }\n            }\n        }\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    function _redeemTokens(\n        address _borrowToken,\n        uint256 _remaining,\n        uint256 _percentage,\n        address _sender,\n        address _integration,\n        address _assetToken\n    ) internal {\n        // Normalize to underlying asset if any (ctokens for compound)\n        uint256 numTokensToRedeem = ILendIntegration(_integration).getInvestmentTokenAmount(_sender, _assetToken);\n        // Apply percentage\n        numTokensToRedeem = numTokensToRedeem.preciseMul(_percentage);\n        uint256 remainingDebtInCollateralTokens = _getRemainingDebt(_borrowToken, _assetToken, _remaining);\n        remainingDebtInCollateralTokens = SafeDecimalMath.normalizeAmountTokens(\n            _borrowToken,\n            _assetToken,\n            remainingDebtInCollateralTokens\n        );\n\n        if (_remaining > 0) {\n            // Update amount so we can exit if there is debt\n            numTokensToRedeem = numTokensToRedeem.sub(remainingDebtInCollateralTokens.mul(200).div(100));\n        }\n        uint256 exchangeRate = ILendIntegration(_integration).getExchangeRatePerToken(_assetToken);\n\n        ILendIntegration(_integration).redeemTokens(\n            msg.sender,\n            _assetToken,\n            numTokensToRedeem,\n            exchangeRate.mul(numTokensToRedeem.sub(numTokensToRedeem.preciseMul(SLIPPAGE_ALLOWED.mul(2))))\n        );\n    }\n\n    function _tokenToTrade(\n        address _assetToken,\n        address _sender,\n        IGarden _garden,\n        address _integration\n    ) internal {\n        address tokenToTradeFrom = _assetToken;\n        // if eth, convert it to weth\n        if (_assetToken == address(0)) {\n            tokenToTradeFrom = WETH;\n            IStrategy(_sender).handleWeth(true, _sender.balance);\n        }\n        if (tokenToTradeFrom != _garden.reserveAsset()) {\n            IStrategy(_sender).trade(\n                tokenToTradeFrom,\n                IERC20(tokenToTradeFrom).balanceOf(_sender),\n                _garden.reserveAsset()\n            );\n        }\n        address rewardsToken = _getRewardToken(_integration);\n        if (rewardsToken != address(0)) {\n            uint256 rewardsBalance = IERC20(rewardsToken).balanceOf(_sender);\n            // Add rewards\n            if (rewardsBalance > 1e16) {\n                IStrategy(_sender).trade(rewardsToken, rewardsBalance, _garden.reserveAsset());\n            }\n        }\n    }\n\n    function _getRemainingDebt(\n        address _borrowToken,\n        address _assetToken,\n        uint256 _remaining\n    ) private view returns (uint256) {\n        if (_remaining == 0) {\n            return 0;\n        }\n        uint256 price = _getPrice(_borrowToken, _assetToken);\n        return _remaining.preciseMul(price);\n    }\n\n    function _getRewardToken(address _integration) private view returns (address) {\n        try ILendIntegration(_integration).getRewardToken() returns (address rewardsToken) {\n            return rewardsToken;\n        } catch {\n            return address(0);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title ILendIntegration\n * @author Babylon Finance\n *\n * Interface for lending integrations such as Compound, Aave.\n */\ninterface ILendIntegration {\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external;\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external;\n\n    function getRewardToken() external view returns (address);\n\n    function getRewardsAccrued(address _strategy) external view returns (uint256);\n\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply) external view returns (uint256);\n\n    function getExchangeRatePerToken(address _assetToken) external view returns (uint256);\n\n    function getInvestmentToken(address _assetToken) external view returns (address);\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/DepositVaultOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {ConvexStakeIntegration} from '../../integrations/passive/ConvexStakeIntegration.sol';\nimport {IBooster} from '../../interfaces/external/convex/IBooster.sol';\nimport {IBasicRewards} from '../../interfaces/external/convex/IBasicRewards.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title DepositVaultOperation/Stake Operation\n * @author Babylon Finance\n *\n * Executes a stake (deposit vault) operation\n */\ncontract DepositVaultOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    IBooster private constant booster = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant LDO = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32; // lDO\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the deposit vault operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(BytesLib.decodeOpDataAddress(_data) != address(0), 'Incorrect vault address!');\n    }\n\n    /**\n     * Executes the deposit vault operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _data               OpData e.g. Address of the vault to enter\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address yieldVault = BytesLib.decodeOpDataAddress(_data);\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        if (vaultAsset != _asset) {\n            // get ETH if it's needed\n            if (vaultAsset == address(0)) {\n                if (_asset != WETH) {\n                    IStrategy(msg.sender).trade(_asset, _capital, WETH);\n                }\n                IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            } else {\n                IStrategy(msg.sender).trade(_asset, _capital, vaultAsset);\n            }\n        }\n        uint256 minAmountExpected = _getMinAmountExpected(yieldVault, _capital, _integration);\n        IPassiveIntegration(_integration).enterInvestment(\n            msg.sender,\n            yieldVault,\n            minAmountExpected,\n            vaultAsset,\n            vaultAsset == address(0) ? address(msg.sender).balance : IERC20(vaultAsset).balanceOf(msg.sender)\n        );\n        vaultAsset = _getResultAsset(_integration, yieldVault);\n        return (vaultAsset, IERC20(vaultAsset).balanceOf(msg.sender), 0); // liquid\n    }\n\n    function _getMinAmountExpected(\n        address _yieldVault,\n        uint256 _capital,\n        address _integration\n    ) internal view returns (uint256) {\n        uint256 exactAmount = IPassiveIntegration(_integration).getExpectedShares(_yieldVault, _capital);\n        return exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n    }\n\n    /**\n     * Exits the deposit vault operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address yieldVault = BytesLib.decodeOpDataAddress(_data);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        uint256 amountVault =\n            IERC20(_getResultAsset(_integration, yieldVault)).balanceOf(msg.sender).preciseMul(_percentage);\n        uint256 minAmount =\n            amountVault.sub(amountVault.preciseMul(SLIPPAGE_ALLOWED)).preciseDiv(\n                IPassiveIntegration(_integration).getPricePerShare(yieldVault).mul(\n                    10**PreciseUnitMath.decimals().sub(vaultAsset == address(0) ? 18 : ERC20(vaultAsset).decimals())\n                )\n            );\n        IPassiveIntegration(_integration).exitInvestment(msg.sender, yieldVault, amountVault, vaultAsset, minAmount);\n        return (\n            vaultAsset,\n            vaultAsset != address(0) ? IERC20(vaultAsset).balanceOf(msg.sender) : address(msg.sender).balance,\n            0\n        );\n    }\n\n    /**\n     * Gets the NAV of the deposit vault op in the reserve asset\n     *\n     * @param _data               OpData e.g. Vault\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        address vault = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(vault); // USDC, DAI, WETH\n        uint256 balance = IERC20(_getResultAsset(_integration, vault)).balanceOf(msg.sender);\n        uint256 price = _getPrice(_garden.reserveAsset(), vaultAsset);\n        // try to get price of an investment token from Oracle\n        // markets sometimes price assets differently than\n        // their underlying protocols, e.g., stETH/Lido\n        uint256 pricePerShare = _getPrice(vault, vaultAsset);\n        // if failed to fetch price from Oracle get it from the underlying protocol\n        if (pricePerShare == 0) {\n            pricePerShare = IPassiveIntegration(_integration).getPricePerShare(vault);\n            // Normalization of pricePerShare\n            pricePerShare = pricePerShare.mul(\n                10**PreciseUnitMath.decimals().sub(vaultAsset == address(0) ? 18 : ERC20(vaultAsset).decimals())\n            );\n        }\n        //Balance normalization\n        balance = SafeDecimalMath.normalizeAmountTokens(vaultAsset, _garden.reserveAsset(), balance);\n        uint256 NAV = pricePerShare.preciseMul(balance).preciseDiv(price);\n        // Get value of pending rewards\n        NAV = NAV.add(_getRewardsNAV(_integration, vault, _garden.reserveAsset()));\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    // Function to provide backward compatibility\n    function _getResultAsset(address _integration, address _yieldVault) private view returns (address) {\n        try IPassiveIntegration(_integration).getResultAsset(_yieldVault) returns (address _resultAsset) {\n            return _resultAsset;\n        } catch {\n            return _yieldVault;\n        }\n    }\n\n    function _getRewardsNAV(\n        address _integration,\n        address _yieldVault,\n        address _reserveAsset\n    ) private view returns (uint256) {\n        // Patching old convex stETH.\n        if (\n            address(msg.sender) == 0x3FeaD42999D537477CE39335aA7b4951e8e78233 ||\n            address(msg.sender) == 0x4f85dD417d19058cA81564f41572fb90D2F7e935\n        ) {\n            uint256 nav =\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x0A760466E1B4621579a82a39CB56Dda2F4E70f03).earned(msg.sender).mul(2)\n                );\n            nav = nav.add(\n                _getPrice(LDO, _reserveAsset).preciseMul(\n                    IBasicRewards(0x008aEa5036b819B4FEAEd10b2190FBb3954981E8).earned(msg.sender)\n                )\n            );\n            return nav;\n        }\n        // Patching 3Pool\n        if (address(msg.sender) == 0x9D78319EDA31663B487204F0CA88A046e742eE16) {\n            return\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x689440f2Ff927E1f24c72F1087E1FAF471eCe1c8).earned(msg.sender).mul(2)\n                );\n        }\n        // Patching IB\n        if (_yieldVault == 0x912EC00eaEbf3820a9B0AC7a5E15F381A1C91f22) {\n            return\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x3E03fFF82F77073cc590b656D42FceB12E4910A8).earned(msg.sender).mul(2)\n                );\n        }\n        try IPassiveIntegration(_integration).getRewards(msg.sender, _yieldVault) returns (\n            address rewardToken,\n            uint256 amount\n        ) {\n            if (rewardToken != address(0) && amount > 0) {\n                return _getPrice(rewardToken, _reserveAsset).preciseMul(amount);\n            }\n            return 0;\n        } catch {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPassiveIntegration\n * @author Babylon Finance\n *\n * Interface for passive investments protocol integrations\n */\ninterface IPassiveIntegration {\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external;\n\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external;\n\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount) external view returns (uint256);\n\n    function getPricePerShare(address _investmentAddress) external view returns (uint256);\n\n    function getInvestmentAsset(address _investmentAddress) external view returns (address);\n\n    function getResultAsset(address _investmentAddress) external view returns (address);\n\n    function getRewards(address _strategy, address _investmentAddress) external view returns (address, uint256);\n}\n"
    },
    "contracts/integrations/passive/ConvexStakeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IBooster} from '../../interfaces/external/convex/IBooster.sol';\nimport {IBasicRewards} from '../../interfaces/external/convex/IBasicRewards.sol';\n\n/**\n * @title ConvexStakeIntegration\n * @author Babylon Finance Protocol\n *\n * Lido Integration\n */\ncontract ConvexStakeIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IBooster private constant booster = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B; // cvx\n\n    mapping(address => uint256) private cacheConvexTokenToPid;\n    uint256 private elementsCached = 0;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('convex_v2', _controller) {\n        _updateCache();\n    }\n\n    /**\n     * Gets the PID in convex of a convex lp token\n     * @param _asset                         Address of the convex lp token\n     * @return uint256                       Pid of the pool in convex\n     */\n    function getPid(address _asset) public view returns (bool, uint256) {\n        if (cacheConvexTokenToPid[_asset] > 0) {\n            return (true, cacheConvexTokenToPid[_asset] - 1);\n        }\n        uint256 poolLength = booster.poolLength();\n        if (elementsCached >= poolLength) {\n            return (false, 0);\n        }\n        for (uint256 i = elementsCached; i < poolLength; i++) {\n            (, address token, , , , ) = booster.poolInfo(i);\n            if (token == _asset) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _updateCache() public {\n        uint256 poolLength = booster.poolLength();\n        if (elementsCached >= poolLength) {\n            return;\n        }\n        for (uint256 i = elementsCached; i < poolLength; i++) {\n            (, address token, , , , ) = booster.poolInfo(i);\n            cacheConvexTokenToPid[token] = i + 1;\n        }\n        elementsCached = poolLength;\n    }\n\n    function _getSpender(address _asset, uint8 _op) internal view override returns (address) {\n        if (_op == 0) {\n            return address(booster);\n        }\n        // Reward pool\n        return _getRewardPool(_asset);\n    }\n\n    function _getExpectedShares(\n        address, /* _asset */\n        uint256 _amount\n    ) internal pure override returns (uint256) {\n        return _amount;\n    }\n\n    function _getPricePerShare(\n        address /* _asset */\n    ) internal pure override returns (uint256) {\n        return 1e18;\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address lptoken) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (lptoken, , , , , ) = booster.poolInfo(pid);\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Convex pool does not exist');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('deposit(uint256,uint256,bool)', pid, _maxAmountIn, true);\n        return (address(booster), 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensIn */\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Withdraw all and claim\n        bytes memory methodData = abi.encodeWithSignature('withdrawAllAndUnwrap(bool)', true);\n        // Go through the reward pool instead of the booster\n        return (_getRewardPool(_asset), 0, methodData);\n    }\n\n    function _getRewardPool(address _asset) private view returns (address reward) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (, , , reward, , ) = booster.poolInfo(pid);\n    }\n\n    function _getResultAsset(address _investment) internal view virtual override returns (address) {\n        return _getRewardPool(_investment);\n    }\n\n    function _getConvexLPToken(address _asset) private view returns (address token) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (, token, , , , ) = booster.poolInfo(pid);\n    }\n\n    function _getRewards(address _strategy, address _asset)\n        internal\n        view\n        override\n        returns (address token, uint256 balance)\n    {\n        IBasicRewards rewards = IBasicRewards(_getRewardPool(_asset));\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 totalAmount = rewards.earned(_strategy).mul(2); // * 2 accounts roughly for CVX\n        // add extra rewards and convert to reward token\n        uint256 extraRewardsLength = rewards.extraRewardsLength();\n        if (extraRewardsLength > 0) {\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                IBasicRewards extraRewards = IBasicRewards(rewards.extraRewards(i));\n                totalAmount = totalAmount.add(\n                    oracle.getPrice(rewards.extraRewards(i), extraRewards.rewardToken()).preciseMul(\n                        extraRewards.earned(_strategy)\n                    )\n                );\n            }\n        }\n        return (rewards.rewardToken(), totalAmount);\n    }\n}\n"
    },
    "contracts/interfaces/external/convex/IBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface IBooster {\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            bool\n        );\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    function poolLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/convex/IBasicRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface IBasicRewards {\n    function getReward(address _account, bool _claimExtras) external;\n\n    function getReward(address _account) external;\n\n    function stakeFor(address, uint256) external;\n\n    function earned(address _account) external view returns (uint256);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function extraRewards(uint256 _index) external view returns (address);\n}\n"
    },
    "contracts/integrations/passive/PassiveIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title PassiveIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract PassiveIntegration is BaseIntegration, ReentrancyGuard, IPassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address investment; // Investment address\n        uint256 totalSupply; // Total Supply of the investment\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event InvestmentEntered(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        address tokenIn,\n        uint256 investmentTokensOut\n    );\n\n    event InvestmentExited(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        uint256 investmentTokensOut\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits tokens into an investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokensOut        Min amount of investment tokens to receive\n     * @param _tokenIn                    Token address to deposit\n     * @param _maxAmountIn                Max amount of the token to deposit\n     */\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_investmentAddress, _maxAmountIn, 0);\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        // Approve spending of the token\n        if (_tokenIn != address(0)) {\n            investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress, 0), _tokenIn, _maxAmountIn);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getEnterInvestmentCalldata(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit InvestmentEntered(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _investmentAddress,\n            _tokenIn,\n            _investmentTokensOut\n        );\n    }\n\n    /**\n     * Exits an outside passive investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to exit\n     * @param _investmentTokenIn          Quantity of investment tokens to return\n     * @param _tokenOut                   Token address to withdraw\n     * @param _minAmountOut               Min token quantities to receive from the investment\n     */\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        _validatePreExitInvestmentData(investmentInfo);\n\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_investmentAddress, _investmentTokenIn, 1);\n\n        if (targetAddressP != address(0)) {\n            // Approve spending of the pre action token\n            if (_preActionNeedsApproval()) {\n                investmentInfo.strategy.invokeApprove(\n                    _getSpender(_investmentAddress, 1),\n                    targetAddressP,\n                    IERC20(targetAddressP).balanceOf(_strategy)\n                );\n            }\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n            _investmentAddress = _getAssetAfterExitPreAction(_investmentAddress);\n            _investmentTokenIn = IERC20(_investmentAddress).balanceOf(_strategy);\n        }\n\n        // Approve spending of the investment token\n        investmentInfo.strategy.invokeApprove(\n            _getSpender(_investmentAddress, 1),\n            _investmentAddress,\n            _investmentTokenIn\n        );\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getExitInvestmentCalldata(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit InvestmentExited(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            investmentInfo.investment,\n            _investmentTokenIn\n        );\n    }\n\n    /**\n     * Gets the amount of shares expected to get after depositing _ethAmount\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @param _ethAmount                         Amount of eth to invest\n     * @return uint256                           Amount of investment shares to receive\n     */\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_investmentAddress, _ethAmount);\n    }\n\n    /**\n     * Gets how much eth one unit of the investment is worth\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return uint256                           Returns the price in ETH of an investment share\n     */\n    function getPricePerShare(address _investmentAddress) external view override returns (uint256) {\n        return _getPricePerShare(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset needed to enter the investment\n     *\n     * @return address                           Returns the asset that this investment needs\n     */\n    function getInvestmentAsset(address _investmentAddress) external view override returns (address) {\n        return _getInvestmentAsset(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset you obtained after entering the investment\n     *\n     * @return address                            Returns the asset that this investment obtains\n     */\n    function getResultAsset(address _investmentAddress) external view override returns (address) {\n        return _getResultAsset(_investmentAddress);\n    }\n\n    /**\n     * Gets the rewards and the token that they are denominated in\n     *\n     * @param _strategy                           Address of the strategy\n     * @param _investmentAddress                  Address of the investment\n     * @return address                            Returns the address with the token of extra rewards\n     * @return uint256                            Extra rewards received so far\n     */\n    function getRewards(address _strategy, address _investmentAddress)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        return _getRewards(_strategy, _investmentAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * @param _strategy                                 Address of the strategy\n     * @param _investment                               Address of the investment\n     * @param _investmentTokensInTransaction            Number of investment tokens involved\n     * hparam _tokenIn                                  Addresseses of the deposit token\n     * @param _limitDepositToken                        Limit quantity of the deposit/withdrawal token\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _investment,\n        uint256 _investmentTokensInTransaction,\n        address, /*_tokenIn*/\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.investment = _getResultAsset(_investment);\n        investmentInfo.totalSupply = IERC20(_investment).totalSupply();\n        investmentInfo.investmentTokensInGarden = IERC20(investmentInfo.investment).balanceOf(_strategy);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal pure {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal pure {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The strategy does not have enough investment tokens'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The strategy did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) <=\n                (_investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction) + 100,\n            'The strategy did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                       Addresses of tokens to send to the investment\n     * hparam  _maxAmountIn                   Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _investmentAddress */\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 /* _maxAmountIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of token to receive\n     * hparam  _minAmountOut                   Amount of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /*_strategy */\n        address, /*_investmentAddress */\n        uint256, /*_investmentTokensIn */\n        address, /*_tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getExpectedShares(\n        address, //_investmentAddress\n        uint256 // _ethAmount\n    ) internal view virtual returns (uint256);\n\n    function _getPricePerShare(\n        address //_investmentAddress\n    ) internal view virtual returns (uint256);\n\n    function _getInvestmentAsset(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getSpender(\n        address, //_investmentAddress,\n        uint8 // op\n    ) internal view virtual returns (address);\n\n    function _getRewards(\n        address, // _strategy\n        address //_investmentAddress\n    ) internal view virtual returns (address, uint256) {\n        return (address(0), 0);\n    }\n\n    function _preActionNeedsApproval() internal view virtual returns (bool) {\n        return false;\n    }\n\n    function _getAssetAfterExitPreAction(address _asset) internal view virtual returns (address) {\n        return _asset;\n    }\n\n    function _getResultAsset(address _investment) internal view virtual returns (address) {\n        return _investment;\n    }\n}\n"
    },
    "contracts/integrations/BaseIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\n\n/**\n * @title BaseIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses common Integration-related state and functions.\n */\nabstract contract BaseIntegration {\n    using SafeCast for int256;\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySystemContract() {\n        require(controller.isSystemContract(msg.sender), 'Only system can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the controller\n    IBabController public controller;\n    // Wrapped ETH address\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant ETH_ADD_CURVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address internal constant sETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\n    address internal constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    // Name of the integration\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n\n    constructor(string memory _name, IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the integration\n     */\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getTokenOrETHBalance(address _strategy, address _token) internal view returns (uint256) {\n        if (_token == address(0) || _token == ETH_ADD_CURVE) {\n            return _strategy.balance;\n        }\n        return ERC20(_token).balanceOf(_strategy);\n    }\n}\n"
    },
    "contracts/strategies/operations/BuyOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\n\n/**\n * @title BuyOperation\n * @author Babylon Finance\n *\n * Executes a buy operation\n */\ncontract BuyOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the buy operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        address asset = BytesLib.decodeOpDataAddress(_data);\n        require(asset != address(0), 'Incorrect asset address');\n        require(asset != _garden.reserveAsset(), 'Receive token must be different');\n    }\n\n    /**\n     * Executes the buy operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _data               OpData e.g. Address of the token to buy\n     * param _garden             Garden of the strategy\n     * param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address token = BytesLib.decodeOpDataAddress(_data);\n        // Replace old AXS with new AXS\n        if (token == 0xF5D669627376EBd411E34b98F19C868c8ABA5ADA) {\n            token = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b;\n        }\n        IStrategy(msg.sender).trade(_asset, _capital, token);\n        return (token, ERC20(token).balanceOf(address(msg.sender)), 0); // liquid\n    }\n\n    /**\n     * Exits the buy operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address token = BytesLib.decodeOpDataAddress(_data);\n        // Replace old AXS with new AXS\n        if (token == 0xF5D669627376EBd411E34b98F19C868c8ABA5ADA) {\n            token = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b;\n        }\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        IStrategy(msg.sender).trade(\n            token,\n            ERC20(token).balanceOf(address(msg.sender)).preciseMul(_percentage),\n            _garden.reserveAsset()\n        );\n        return (_garden.reserveAsset(), ERC20(_garden.reserveAsset()).balanceOf(msg.sender), 0);\n    }\n\n    /**\n     * Gets the NAV of the buy op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset bought\n     * @param _garden             Garden the strategy belongs to\n     * param _integration         Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address /* _integration */\n    ) external view override returns (uint256, bool) {\n        address token = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        // Replace old AXS with new AXS\n        if (token == 0xF5D669627376EBd411E34b98F19C868c8ABA5ADA) {\n            token = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b;\n        }\n        uint256 price = _getPriceNAV(_garden.reserveAsset(), token);\n        uint256 NAV =\n            SafeDecimalMath\n                .normalizeAmountTokens(token, _garden.reserveAsset(), ERC20(token).balanceOf(msg.sender))\n                .preciseDiv(price);\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n}\n"
    },
    "contracts/integrations/trade/MasterSwapper.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {ICurveAddressProvider} from '../../interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from '../../interfaces/external/curve/ICurveRegistry.sol';\nimport {ISynthetix} from '../../interfaces/external/synthetix/ISynthetix.sol';\nimport {ISnxProxy} from '../../interfaces/external/synthetix/ISnxProxy.sol';\nimport {ISnxSynth} from '../../interfaces/external/synthetix/ISnxSynth.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title MasterSwapper\n * @author Babylon Finance Protocol\n *\n * Master class for integration with trading protocols\n */\n\n// - MasterSwapper\n//   * Uni V2 TWAP\n//   * Synthetix Contract. Exchange\n//     Support proxy or no proxy between synths\n//     - Only between pairs of synths. Great for bigger trades\n//\n// * Implement CurveTradeIntegration\n// * Implement SynthetixTradeIntegration\n// * Implemen  UniswapV2TradeIntegration\ncontract MasterSwapper is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct TradeInfo {\n        IGarden garden; // Garden\n        address strategy; // Strategy\n        string exchangeName; // Which exchange to use\n        address sendToken; // Address of token being sold\n        address receiveToken; // Address of token being bought\n        uint256 gardenTotalSupply; // Total supply of Garden in Precise Units (10^18)\n        uint256 totalSendQuantity; // Total quantity of sold tokens\n        uint256 totalMinReceiveQuantity; // Total minimum quantity of token to receive back\n        uint256 preTradeSendTokenBalance; // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance; // Total initial balance of token being bought\n    }\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == controller.owner(), 'Only governance can call this');\n        _;\n    }\n\n    /* ============ Events ============ */\n\n    /* ============ Constants ============ */\n\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    ITradeIntegration internal curve;\n    ITradeIntegration internal univ3;\n    ITradeIntegration internal synthetix;\n    ITradeIntegration internal univ2;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the master swapper\n     *\n     * @param _controller             Address of the controller\n     * @param _curve                  Address of curve trade integration\n     * @param _univ3                  Address of univ3 trade integration\n     * @param _synthetix              Address of synthetix trade integration\n     * @param _univ2                  Address of univ2 trade integration\n     */\n    constructor(\n        IBabController _controller,\n        ITradeIntegration _curve,\n        ITradeIntegration _univ3,\n        ITradeIntegration _synthetix,\n        ITradeIntegration _univ2\n    ) BaseIntegration('master_swapper_v2', _controller) {\n        curve = _curve;\n        univ3 = _univ3;\n        synthetix = _synthetix;\n        univ2 = _univ2;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade choosing the appropriate protocol for it\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) public override nonReentrant {\n        _trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity);\n    }\n\n    /**\n     * Function to update the internal mappings of the swapper\n     * @param _index                   Index to update\n     * @param _newAddress              New address\n     */\n    function updateTradeAddress(uint256 _index, address _newAddress) external onlyGovernance {\n        require(_newAddress != address(0), 'New address i not valid');\n        if (_index == 0) {\n            curve = ITradeIntegration(_newAddress);\n        }\n        if (_index == 1) {\n            univ3 = ITradeIntegration(_newAddress);\n        }\n        if (_index == 2) {\n            synthetix = ITradeIntegration(_newAddress);\n        }\n        if (_index == 3) {\n            univ2 = ITradeIntegration(_newAddress);\n        }\n    }\n\n    function isTradeIntegration(address _integration) external view returns (bool) {\n        return\n            _integration == address(curve) ||\n            _integration == address(univ3) ||\n            _integration == address(synthetix) ||\n            _integration == address(univ2);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) private {\n        if (_sendToken == _receiveToken) {\n            return;\n        }\n        // Synthetix Direct\n        address _sendTokenSynth = _getSynth(_sendToken);\n        address _receiveTokenSynth = _getSynth(_receiveToken);\n        if (\n            (_sendTokenSynth != address(0) && _receiveTokenSynth != address(0)) ||\n            (_sendTokenSynth != address(0) && (_receiveToken == DAI || _receiveToken == USDC)) ||\n            (_receiveToken != address(0) && (_sendTokenSynth == DAI || _sendTokenSynth == USDC))\n        ) {\n            try\n                ITradeIntegration(synthetix).trade(\n                    _strategy,\n                    _sendToken,\n                    _sendQuantity,\n                    _receiveToken,\n                    _minReceiveQuantity\n                )\n            {\n                return;\n            } catch {}\n        }\n        // Curve Direct\n        if (_curveSwap(_strategy, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity)) {\n            return;\n        }\n        // Abstract Synths out\n        if (_sendTokenSynth != address(0)) {\n            uint256 reserveBalance = _getTokenOrETHBalance(_strategy, DAI);\n            // Trade to DAI through sUSD\n            try ITradeIntegration(synthetix).trade(_strategy, _sendToken, _sendQuantity, DAI, 1) {\n                // Change DAI to receive token\n                _trade(\n                    _strategy,\n                    DAI,\n                    _getTokenOrETHBalance(_strategy, DAI).sub(reserveBalance),\n                    _receiveToken,\n                    _minReceiveQuantity\n                );\n                return;\n            } catch {}\n        }\n        // Trade to DAI and then do DAI to synh\n        if (_receiveTokenSynth != address(0)) {\n            uint256 reserveBalance = 0;\n\n            if (_sendToken != DAI) {\n                reserveBalance = _getTokenOrETHBalance(_strategy, DAI);\n                _trade(_strategy, _sendToken, _sendQuantity, DAI, 1);\n            }\n            try\n                ITradeIntegration(synthetix).trade(\n                    _strategy,\n                    DAI,\n                    _getTokenOrETHBalance(_strategy, DAI).sub(reserveBalance),\n                    _receiveToken,\n                    _minReceiveQuantity\n                )\n            {\n                return;\n            } catch {\n                require(false, 'Failed midway in out synth');\n            }\n        }\n        // Go through UNIv3 first\n        try ITradeIntegration(univ3).trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity) {\n            return;\n        } catch {}\n        // Try Curve through reserve assets\n        if (\n            _checkCurveThroughReserves(\n                [DAI, WETH, WBTC],\n                _strategy,\n                _sendToken,\n                _receiveToken,\n                _sendQuantity,\n                _minReceiveQuantity\n            )\n        ) {\n            return;\n        }\n        // Update balance in case we tried some curve paths but had to revert\n        uint256 sendBalanceLeft = _getTokenOrETHBalance(_strategy, _sendToken);\n        _sendQuantity = _sendQuantity < sendBalanceLeft ? _sendQuantity : sendBalanceLeft;\n        // Try Univ3 through WETH\n        if (_sendToken != WETH && _receiveToken != WETH) {\n            uint256 sendBalance = _getTokenOrETHBalance(_strategy, WETH);\n            try ITradeIntegration(univ3).trade(_strategy, _sendToken, _sendQuantity, WETH, 1) {\n                sendBalance = _getTokenOrETHBalance(_strategy, WETH).sub(sendBalance);\n                try ITradeIntegration(univ3).trade(_strategy, WETH, sendBalance, _receiveToken, _minReceiveQuantity) {\n                    return;\n                } catch {\n                    // Revert trade\n                    ITradeIntegration(univ3).trade(_strategy, WETH, sendBalance, _sendToken, 1);\n                }\n            } catch {}\n        }\n        // Try Univ3 through DAI\n        if (_sendToken != DAI && _receiveToken != DAI) {\n            uint256 sendBalance = _getTokenOrETHBalance(_strategy, DAI);\n            try ITradeIntegration(univ3).trade(_strategy, _sendToken, _sendQuantity, DAI, 1) {\n                sendBalance = _getTokenOrETHBalance(_strategy, DAI).sub(sendBalance);\n                try ITradeIntegration(univ3).trade(_strategy, DAI, sendBalance, _receiveToken, _minReceiveQuantity) {\n                    return;\n                } catch {\n                    // Revert trade\n                    ITradeIntegration(univ3).trade(_strategy, DAI, sendBalance, _sendToken, 1);\n                }\n            } catch {}\n        }\n        sendBalanceLeft = _getTokenOrETHBalance(_strategy, _sendToken);\n        _sendQuantity = _sendQuantity < sendBalanceLeft ? _sendQuantity : sendBalanceLeft;\n        if (_minReceiveQuantity > 1) {\n            // Try on univ2 (only direct trade) through WETH\n            uint256 sendBalance = _getTokenOrETHBalance(_strategy, WETH);\n            if (_sendToken != WETH) {\n                try ITradeIntegration(univ2).trade(_strategy, _sendToken, _sendQuantity, WETH, 2) {\n                    sendBalance = _getTokenOrETHBalance(_strategy, WETH).sub(sendBalance);\n                } catch {}\n            }\n            if (_receiveToken != WETH) {\n                try ITradeIntegration(univ2).trade(_strategy, WETH, sendBalance, _receiveToken, _minReceiveQuantity) {\n                    return;\n                } catch {}\n            }\n        }\n        require(false, 'Master swapper could not swap');\n    }\n\n    function _checkCurveThroughReserves(\n        address[3] memory _reserves,\n        address _strategy,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) private returns (bool) {\n        for (uint256 i = 0; i < _reserves.length; i++) {\n            if (_sendToken != _reserves[i]) {\n                if (\n                    _checkCurveRoutesThroughReserve(\n                        _reserves[i],\n                        _strategy,\n                        _sendToken,\n                        _receiveToken,\n                        _sendQuantity,\n                        _minReceiveQuantity\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _checkCurveRoutesThroughReserve(\n        address _reserve,\n        address _strategy,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) private returns (bool) {\n        uint256 reserveBalance = _getTokenOrETHBalance(_strategy, _reserve);\n        bool swapped = false;\n        uint256 diff = reserveBalance;\n        // Going through curve but switching first to reserve\n        if (_sendToken != _reserve && _findCurvePool(_reserve, _receiveToken) != address(0)) {\n            uint256 sendBalance = _getTokenOrETHBalance(_strategy, _sendToken);\n            try\n                ITradeIntegration(univ3).trade(\n                    _strategy,\n                    _sendToken,\n                    sendBalance < _sendQuantity ? sendBalance : _sendQuantity, // can be lower than sendQuantity if we tried swapping\n                    _reserve,\n                    1\n                )\n            {\n                if (_reserve == _receiveToken) {\n                    return true;\n                }\n                diff = _getTokenOrETHBalance(_strategy, _reserve).sub(reserveBalance);\n                swapped = true;\n            } catch {}\n        }\n        if (_sendToken == _reserve || swapped) {\n            if (_curveSwap(_strategy, _reserve, _receiveToken, diff, _minReceiveQuantity)) {\n                return true;\n            }\n            if (swapped) {\n                require(false, 'Curve Swap failed midway'); // Should never happen\n            }\n        }\n        // Going through curve to reserve and then receive Token\n        if (_sendToken != _reserve) {\n            uint256 sendBalance = _getTokenOrETHBalance(_strategy, _sendToken);\n            swapped = false;\n            reserveBalance = _getTokenOrETHBalance(_strategy, _reserve);\n            if (\n                _curveSwap(\n                    _strategy,\n                    _sendToken,\n                    _reserve,\n                    sendBalance < _sendQuantity ? sendBalance : _sendQuantity,\n                    1\n                )\n            ) {\n                swapped = true;\n                diff = _getTokenOrETHBalance(_strategy, _reserve).sub(reserveBalance);\n                if (_reserve == _receiveToken) {\n                    return true;\n                }\n            }\n        }\n        if (_sendToken == _reserve || swapped) {\n            try ITradeIntegration(univ3).trade(_strategy, _reserve, diff, _receiveToken, _minReceiveQuantity) {\n                return true;\n            } catch {\n                if (swapped) {\n                    // Undo curve swap to reserve\n                    _curveSwap(_strategy, _reserve, _sendToken, diff, 1);\n                }\n            }\n        }\n        return false;\n    }\n\n    function _findCurvePool(address _fromToken, address _toToken) private view returns (address) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        address curvePool = curveRegistry.find_pool_for_coins(_fromToken, _toToken);\n        if (curvePool == address(0) && _fromToken == WETH) {\n            curvePool = curveRegistry.find_pool_for_coins(ETH_ADD_CURVE, _toToken);\n        }\n        if (curvePool == address(0) && _toToken == WETH) {\n            curvePool = curveRegistry.find_pool_for_coins(_fromToken, ETH_ADD_CURVE);\n        }\n        return curvePool;\n    }\n\n    function _curveSwap(\n        address _strategy,\n        address _fromToken,\n        address _toToken,\n        uint256 _sendTokenAmount,\n        uint256 _minReceiveQuantity\n    ) private returns (bool) {\n        address curvePool = _findCurvePool(_fromToken, _toToken);\n        if (curvePool != address(0)) {\n            try ITradeIntegration(curve).trade(_strategy, _fromToken, _sendTokenAmount, _toToken, _minReceiveQuantity) {\n                return true;\n            } catch {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    function _getSynth(address _token) private view returns (address) {\n        ISynthetix snx = ISynthetix(ISnxProxy(SNX).target());\n        try snx.synths(stringToBytes32(ERC20(_token).symbol())) returns (ISnxSynth _synth) {\n            return address(_synth);\n        } catch {\n            return address(0);\n        }\n    }\n\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 _id) external view returns (address);\n\n    function max_id() external view returns (uint256);\n\n    function get_id_info(uint256 _id)\n        external\n        view\n        returns (\n            address,\n            bool,\n            uint256,\n            uint256,\n            string calldata\n        );\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICurveRegistry {\n    function get_pool_from_lp_token(address _lpToken) external view returns (address);\n\n    function get_lp_token(address _pool) external view returns (address);\n\n    function find_pool_for_coins(\n        address _from,\n        address _to,\n        uint256 _i\n    ) external view returns (address);\n\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\n\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\n\n    function get_rates(address _pool) external view returns (uint256[8] memory);\n\n    function get_virtual_price_from_lp_token(address _lpToken) external view returns (uint256);\n\n    function is_meta(address _pool) external view returns (bool);\n\n    function get_pool_name(address _pool) external view returns (string memory);\n\n    function get_A(address _pool) external view returns (uint256);\n\n    function get_coins(address _pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address _pool) external view returns (address[8] memory);\n\n    function get_coin_indices(\n        address _pool,\n        address _from,\n        address _to\n    )\n        external\n        view\n        returns (\n            int128,\n            int128,\n            bool\n        );\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\nimport './ISnxSynth.sol';\n\ninterface ISynthetix {\n    // Views\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint256);\n\n    function collateral(address account) external view returns (uint256);\n\n    function collateralisationRatio(address issuer) external view returns (uint256);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint256);\n\n    function debtBalanceOfAndTotalDebt(address issuer, bytes32 currencyKey)\n        external\n        view\n        returns (uint256 debtBalance, uint256 totalSystemValue);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint256 maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint256 maxIssuable,\n            uint256 alreadyIssued,\n            uint256 totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISnxSynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint256);\n\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint256);\n\n    function transferableSynthetix(address account) external view returns (uint256);\n\n    // Mutative Functions\n    function burnSynths(uint256 amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint256 amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint256 amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint256 amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint256 reclaimed,\n            uint256 refunded,\n            uint256 numEntries\n        );\n\n    function liquidateDelinquentAccount(address account, uint256 susdAmount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISnxProxy {\n    // Views\n    function target() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxSynth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISnxSynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint256);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint256 value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint256 amount) external;\n\n    function issue(address account, uint256 amount) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/strategies/operations/AddLiquidityOperation.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title AddLiquidityOperation\n * @author Babylon Finance\n *\n * Executes an add liquidity operation\n */\ncontract AddLiquidityOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the add liquidity operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(IPoolIntegration(_integration).isPool(_data), 'Not a valid pool');\n    }\n\n    /**\n     * Executes the add liquidity operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _data               OpData e.g. Address of the pool to enter\n     * @param _garden             Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_data, false);\n        uint256[] memory _poolWeights = IPoolIntegration(_integration).getPoolWeights(_data);\n        // Get the tokens needed to enter the pool\n        uint256[] memory maxAmountsIn = _maxAmountsIn(_asset, _capital, _garden, _poolWeights, poolTokens);\n        uint256 poolTokensOut = IPoolIntegration(_integration).getPoolTokensOut(_data, poolTokens[0], maxAmountsIn[0]);\n        IPoolIntegration(_integration).joinPool(\n            msg.sender,\n            _data,\n            poolTokensOut.sub(poolTokensOut.preciseMul(SLIPPAGE_ALLOWED)),\n            poolTokens,\n            maxAmountsIn\n        );\n        return (\n            _getLPTokenFromBytes(_integration, _data),\n            IERC20(_getLPTokenFromBytes(_integration, _data)).balanceOf(msg.sender),\n            0\n        ); // liquid\n    }\n\n    /**\n     * Exits the add liquidity operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= 1e18, 'Unwind Percentage <= 100%');\n        address pool = BytesLib.decodeOpDataAddress(_data);\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_data, false);\n        uint256 lpTokens =\n            IERC20(IPoolIntegration(_integration).getLPToken(pool)).balanceOf(msg.sender).preciseMul(_percentage); // Sell all pool tokens\n        uint256[] memory _minAmountsOut = IPoolIntegration(_integration).getPoolMinAmountsOut(_data, lpTokens);\n        IPoolIntegration(_integration).exitPool(\n            msg.sender,\n            _data,\n            lpTokens, // Sell all pool tokens\n            poolTokens,\n            _minAmountsOut\n        );\n        // Exit Pool tokens\n        address reserveAsset = _garden.reserveAsset();\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] != reserveAsset) {\n                if (_isETH(poolTokens[i])) {\n                    IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n                    poolTokens[i] = WETH;\n                }\n                if (poolTokens[i] != reserveAsset) {\n                    IStrategy(msg.sender).trade(\n                        poolTokens[i],\n                        IERC20(poolTokens[i]).balanceOf(msg.sender),\n                        reserveAsset\n                    );\n                }\n            }\n        }\n        _sellRewardTokens(_integration, _data, reserveAsset);\n        return (reserveAsset, IERC20(reserveAsset).balanceOf(msg.sender), 0);\n    }\n\n    /**\n     * Gets the NAV of the add liquidity op in the reserve asset\n     *\n     * @param _data               OpData e.g. PoolId or asset address\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address pool = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        pool = IPoolIntegration(_integration).getPool(pool);\n        IERC20 lpToken = IERC20(IPoolIntegration(_integration).getLPToken(pool));\n        // Price lp token directly if possible\n        uint256 price = _getPrice(address(lpToken), _garden.reserveAsset());\n        if (price != 0) {\n            return (\n                SafeDecimalMath.normalizeAmountTokens(\n                    address(lpToken),\n                    _garden.reserveAsset(),\n                    lpToken.balanceOf(msg.sender).preciseMul(price)\n                ),\n                true\n            );\n        }\n        uint256 NAV;\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_data, true);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            address asset = _isETH(poolTokens[i]) ? WETH : poolTokens[i];\n            price = _getPrice(_garden.reserveAsset(), asset);\n            // If the actual token doesn't have a price, use underlying as approx\n            if (price == 0) {\n                uint256 rate;\n                (asset, rate) = IPoolIntegration(_integration).getUnderlyingAndRate(_data, i);\n                if (rate != 0) {\n                    price = _getPrice(_garden.reserveAsset(), asset);\n                    price = price.preciseDiv(rate);\n                }\n            }\n            uint256 balance = !_isETH(poolTokens[i]) ? IERC20(poolTokens[i]).balanceOf(pool) : pool.balance;\n            if (price != 0 && balance != 0) {\n                NAV += SafeDecimalMath.normalizeAmountTokens(\n                    asset,\n                    _garden.reserveAsset(),\n                    balance.mul(lpToken.balanceOf(msg.sender)).div(lpToken.totalSupply()).preciseDiv(price)\n                );\n            }\n        }\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getMaxAmountTokenPool(\n        address _asset,\n        uint256 _capital,\n        IGarden, /* _garden */\n        uint256 _poolWeight,\n        address _poolToken\n    ) private returns (uint256) {\n        uint256 normalizedAssetAmount = _capital.preciseMul(_poolWeight);\n        uint256 price = _getPrice(_asset, _isETH(_poolToken) ? WETH : _poolToken);\n        uint256 normalizedTokenAmount =\n            SafeDecimalMath.normalizeAmountTokens(_asset, _poolToken, normalizedAssetAmount.preciseMul(price));\n        if (_poolToken != _asset && !_isETH(_poolToken)) {\n            IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, _poolToken);\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(_poolToken).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(_poolToken).balanceOf(msg.sender);\n            return normalizedTokenAmount;\n        }\n        if (_isETH(_poolToken)) {\n            if (_asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, WETH); // normalized amount in original asset decimals\n            }\n            // Convert WETH to ETH\n            // We consider the slippage in the trade\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(WETH).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(WETH).balanceOf(msg.sender);\n            IStrategy(msg.sender).handleWeth(false, normalizedTokenAmount); // normalized WETH/ETH amount with 18 decimals\n        } else {\n            // Reserve asset\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(_poolToken).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(_poolToken).balanceOf(msg.sender);\n        }\n        return normalizedTokenAmount;\n    }\n\n    function _maxAmountsIn(\n        address _asset,\n        uint256 _capital,\n        IGarden _garden,\n        uint256[] memory _poolWeights,\n        address[] memory poolTokens\n    ) internal returns (uint256[] memory) {\n        uint256[] memory maxAmountsIn = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            maxAmountsIn[i] = _getMaxAmountTokenPool(_asset, _capital, _garden, _poolWeights[i], poolTokens[i]);\n        }\n        return maxAmountsIn;\n    }\n\n    function _getLPTokenFromBytes(address _integration, bytes calldata _data) internal view returns (address) {\n        return IPoolIntegration(_integration).getLPToken(BytesLib.decodeOpDataAddress(_data));\n    }\n\n    function _isETH(address _address) internal pure returns (bool) {\n        return _address == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || _address == address(0);\n    }\n\n    /**\n     * Sells the reward tokens obtained.\n     * @param _integration                    Address of the integration\n     * @param _data                           Calldata\n     * @param _reserveAsset                   Reserve Asset\n     */\n    function _sellRewardTokens(\n        address _integration,\n        bytes calldata _data,\n        address _reserveAsset\n    ) internal {\n        try IPoolIntegration(_integration).getRewardTokens(_data) returns (address[] memory rewards) {\n            for (uint256 i = 0; i < rewards.length; i++) {\n                if (rewards[i] != address(0)) {\n                    try\n                        IStrategy(msg.sender).trade(rewards[i], IERC20(rewards[i]).balanceOf(msg.sender), _reserveAsset)\n                    {} catch {}\n                }\n            }\n        } catch {}\n    }\n}\n"
    },
    "contracts/interfaces/IPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\n/**\n * @title IPoolIntegration\n * @author Babylon Finance\n *\n * Interface for liquiditypool protocol integrations\n */\ninterface IPoolIntegration {\n    function joinPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] memory _poolTokens,\n        uint256[] memory _maxAmountsIn\n    ) external;\n\n    function exitPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensIn,\n        address[] memory _poolTokens,\n        uint256[] memory _minAmountsOut\n    ) external;\n\n    function getPoolTokens(bytes calldata _pool, bool forNAV) external view returns (address[] memory);\n\n    function getPoolWeights(bytes calldata _pool) external view returns (uint256[] memory);\n\n    function getLPToken(address _pool) external view returns (address);\n\n    function getPool(address _pool) external view returns (address);\n\n    function totalSupply(address _pool) external view returns (uint256);\n\n    function getUnderlyingAndRate(bytes calldata _pool, uint256 _i) external view returns (address, uint256);\n\n    function getPoolTokensOut(\n        bytes calldata _pool,\n        address _tokenAddress,\n        uint256 _maxAmountsIn\n    ) external view returns (uint256);\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _poolTokenAmount)\n        external\n        view\n        returns (uint256[] memory _minAmountsOut);\n\n    function isPool(bytes calldata _pool) external view returns (bool);\n\n    function getRewardTokens(bytes calldata _pool) external view returns (address[] memory);\n}\n"
    },
    "contracts/integrations/pool/PoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {AddressArrayUtils} from '../../lib/AddressArrayUtils.sol';\n\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title PoolIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with pool protocols\n */\nabstract contract PoolIntegration is BaseIntegration, ReentrancyGuard, IPoolIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Struct ============ */\n\n    struct PoolInfo {\n        IGarden garden; // Garden address\n        IStrategy strategy; // Strategy address\n        bytes pool; // OpData 64 bytes each OpData\n        address lpToken; // LP address\n        uint256 totalSupply; // Total Supply of the pool\n        uint256 poolTokensInTransaction; // Pool tokens affected by this transaction\n        uint256 poolTokensInStrategy; // Pool tokens strategy balance\n        uint256[] limitPoolTokenQuantities;\n    }\n\n    /* ============ Events ============ */\n\n    event PoolEntered(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensOut);\n\n    event PoolExited(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensIn);\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 5e16; // 5%\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Joins a pool\n     *\n     * @param _strategy             Address of the strategy\n     * @param _pool                 OpData e.g. Address of the pool token to join\n     * @param _poolTokensOut        Min amount of pool tokens to receive\n     * @param _tokensIn             Array of token addresses to deposit\n     * @param _maxAmountsIn         Array of max token quantities to pull out from the garden\n     */\n    function joinPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _pool, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        _validatePreJoinPoolData(poolInfo);\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Approve spending of the tokens\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            // No need to approve ETH\n            if (_tokensIn[i] != address(0) && _tokensIn[i] != ETH_ADD_CURVE) {\n                poolInfo.strategy.invokeApprove(_getSpender(_pool), _tokensIn[i], _maxAmountsIn[i]);\n            }\n        }\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getJoinPoolCalldata(_strategy, _pool, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        poolInfo.poolTokensInTransaction = IERC20(poolInfo.lpToken).balanceOf(address(poolInfo.strategy)).sub(\n            poolInfo.poolTokensInStrategy\n        );\n        _validatePostJoinPoolData(poolInfo);\n        emit PoolEntered(address(poolInfo.strategy), address(poolInfo.garden), poolAddress, _poolTokensOut);\n    }\n\n    /**\n     * Exits a liquidity pool. Accrue protocol fee (if any)\n     *\n     * @param _strategy               Address of the strategy\n     * @param _pool                   Pool info e.g. PoolId or Address of the pool token to join + metadata\n     * @param _poolTokensIn           Pool tokens to exchange for the underlying tokens\n     * @param _tokensOut              Array of token addresses to withdraw\n     * @param _minAmountsOut          Array of min token quantities to receive from the pool\n     */\n    function exitPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    ) external override nonReentrant onlySystemContract {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _pool, _poolTokensIn, _tokensOut, _minAmountsOut);\n        _validatePreExitPoolData(poolInfo);\n        // Approve spending of the pool token\n        poolInfo.strategy.invokeApprove(_getSpender(_pool), poolInfo.lpToken, _poolTokensIn);\n\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getExitPoolCalldata(_strategy, _pool, _poolTokensIn, _tokensOut, _minAmountsOut);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        _validatePostExitPoolData(poolInfo);\n\n        emit PoolExited(address(poolInfo.strategy), address(poolInfo.garden), poolAddress, _poolTokensIn);\n    }\n\n    /**\n     * Checks whether a pool address is valid\n     *\n     * @param _pool                 OpData e.g. Pool address to check\n     * @return bool                 True if the address is a pool\n     */\n    function isPool(bytes memory _pool) external view override returns (bool) {\n        return _isPool(_pool);\n    }\n\n    /**\n     * Returns the actual address of the LP token. Different for curve.\n     * @param _pool                    Address of the pool\n     * @return address                 Address of the LP token\n     */\n    function getLPToken(address _pool) external view override returns (address) {\n        return _getLpToken(_pool);\n    }\n\n    /**\n     * Gets the underlying pool that holds the internal tokens. Different for curve.\n     * @param _pool                    Address of the maybe pool\n     * @return address                 Address of the pool itself\n     */\n    function getPool(address _pool) external view override returns (address) {\n        return _getPool(_pool);\n    }\n\n    /**\n     * Returns the total supply of the pool tokens\n     * @param _pool                    Address of the pool\n     * @return address                 Total supply of the token\n     */\n    function totalSupply(address _pool) external view override returns (uint256) {\n        return _totalSupply(_pool);\n    }\n\n    /**\n     * Returns the underlying coin\n     * @param _pool                    Address of the pool\n     * @param _i                       Index of coin in the pool\n     * @return address                 Underlying coin\n     * @return uint256                 Rate from coin to underlying\n     */\n    function getUnderlyingAndRate(bytes calldata _pool, uint256 _i) external view override returns (address, uint256) {\n        return _getUnderlyingAndRate(_pool, _i);\n    }\n\n    function getPoolTokens(\n        bytes calldata, /* _pool */\n        bool /* forNAV */\n    ) public view virtual override returns (address[] memory);\n\n    function getPoolWeights(\n        bytes calldata /*_pool */\n    ) external view virtual override returns (uint256[] memory);\n\n    function getRewardTokens(bytes calldata _pool) external view virtual override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return _getRewardTokens(poolAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return PoolInfo struct\n     *\n     * @param _strategy                      Address of the strategy\n     * @param _pool                          Pool info e.g. Address of the pool + metadata\n     * @param _poolTokensInTransaction       Number of pool tokens involved\n     * hparam _poolTokens                    Addresseses of the pool tokens\n     * @param _limitPoolTokenQuantities      Limit quantity of the pool tokens\n     *\n     * return PoolInfo             Struct containing data for pool\n     */\n    function _createPoolInfo(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensInTransaction,\n        address[] calldata, /* _poolTokens */\n        uint256[] calldata _limitPoolTokenQuantities\n    ) internal view returns (PoolInfo memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        PoolInfo memory poolInfo;\n        poolInfo.lpToken = _getLpToken(poolAddress);\n        poolInfo.strategy = IStrategy(_strategy);\n        poolInfo.garden = IGarden(poolInfo.strategy.garden());\n        poolInfo.pool = _pool;\n        poolInfo.poolTokensInStrategy = IERC20(poolInfo.lpToken).balanceOf(_strategy);\n        poolInfo.poolTokensInTransaction = _poolTokensInTransaction;\n        poolInfo.limitPoolTokenQuantities = _limitPoolTokenQuantities;\n\n        return poolInfo;\n    }\n\n    /**\n     * Validate pre pool join data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Min pool tokens to receive must be greater than 0');\n    }\n\n    /**\n     * Validate pre pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Pool tokens to exchange must be greater than 0');\n        require(\n            _poolInfo.poolTokensInStrategy >= _poolInfo.poolTokensInTransaction,\n            'The strategy does not have enough pool tokens'\n        );\n    }\n\n    /**\n     * Validate post join pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            (IERC20(_poolInfo.lpToken).balanceOf(address(_poolInfo.strategy)) > _poolInfo.poolTokensInStrategy),\n            'The strategy did not receive the pool tokens'\n        );\n    }\n\n    /**\n     * Validate post exit pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            IERC20(_poolInfo.lpToken).balanceOf(address(_poolInfo.strategy)) ==\n                _poolInfo.poolTokensInStrategy - _poolInfo.poolTokensInTransaction,\n            'The strategy did not return the pool tokens'\n        );\n        // TODO: validate individual tokens received\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * hparam  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata, /* _pool */\n        uint256, /* _poolTokensOut */\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata /* _maxAmountsIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * hparam  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory, /* _pool */\n        uint256, /* _poolTokensIn */\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata /* _minAmountsOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _isPool(bytes memory _pool) internal view virtual returns (bool);\n\n    function _totalSupply(address _pool) internal view virtual returns (uint256) {\n        return IERC20(_pool).totalSupply();\n    }\n\n    function _getUnderlyingAndRate(bytes calldata _pool, uint256 _i) internal view virtual returns (address, uint256) {\n        return (getPoolTokens(_pool, false)[_i], 1e18);\n    }\n\n    function _getSpender(\n        bytes calldata /* _pool */\n    ) internal view virtual returns (address);\n\n    function _getLpToken(address _pool) internal view virtual returns (address) {\n        return _pool;\n    }\n\n    function _getPool(address _pool) internal view virtual returns (address) {\n        return _pool;\n    }\n\n    function _getRewardTokens(\n        address /* _pool */\n    ) internal view virtual returns (address[] memory) {\n        return new address[](1);\n    }\n}\n"
    },
    "contracts/integrations/pool/UniswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IUniswapV2Router} from '../../interfaces/external/uniswap/IUniswapV2Router.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapPoolIntegration protocol integration\n */\ncontract UniswapPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IUniswapV2Router public uniRouter;\n\n    /* ============ Constants ============ */\n\n    uint8 public immutable MAX_DELTA_BLOCKS = 5;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _uniswapRouterAddress         Address of Uniswap router\n     */\n    constructor(IBabController _controller, address _uniswapRouterAddress)\n        PoolIntegration('uniswap_pool', _controller)\n    {\n        require(address(_controller) != address(0) && _uniswapRouterAddress != address(0), 'invalid address');\n        uniRouter = IUniswapV2Router(_uniswapRouterAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory result = new address[](2);\n        result[0] = IUniswapV2Pair(poolAddress).token0();\n        result[1] = IUniswapV2Pair(poolAddress).token1();\n        return result;\n    }\n\n    function getPoolWeights(\n        bytes calldata /* _pool */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 totalSupply = IUniswapV2Pair(poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        result[0] = IERC20(IUniswapV2Pair(poolAddress).token0())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = IERC20(IUniswapV2Pair(poolAddress).token1())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal pure override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IUniswapV2Pair(poolAddress).MINIMUM_LIQUIDITY() > 0;\n    }\n\n    function _getSpender(\n        bytes calldata /* _pool */\n    ) internal view override returns (address) {\n        return address(uniRouter);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address _strategy,\n        bytes calldata, /* _pool */\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        return (address(uniRouter), 0, _getMethodData(_strategy, _tokensIn, _maxAmountsIn));\n    }\n\n    function _getMethodData(\n        address _strategy,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) private view returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                'addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)',\n                _tokensIn[0],\n                _tokensIn[1],\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED)),\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address _strategy,\n        bytes memory, /* _pool */\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)',\n                _tokensOut[0],\n                _tokensOut[1],\n                _poolTokensIn,\n                _minAmountsOut[0],\n                _minAmountsOut[1],\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n\n        return (address(uniRouter), 0, methodData);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\n\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {ICToken} from './interfaces/external/compound/ICToken.sol';\nimport {ISnxExchangeRates} from './interfaces/external/synthetix/ISnxExchangeRates.sol';\nimport {ICurveAddressProvider} from './interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from './interfaces/external/curve/ICurveRegistry.sol';\nimport {ICurvePoolV3} from './interfaces/external/curve/ICurvePoolV3.sol';\nimport {IUniswapV2Router} from './interfaces/external/uniswap/IUniswapV2Router.sol';\nimport {ISnxSynth} from './interfaces/external/synthetix/ISnxSynth.sol';\nimport {ISnxProxy} from './interfaces/external/synthetix/ISnxProxy.sol';\nimport {IYearnRegistry} from './interfaces/external/yearn/IYearnRegistry.sol';\nimport {IYearnVault} from './interfaces/external/yearn/IYearnVault.sol';\nimport {IStETH} from './interfaces/external/lido/IStETH.sol';\nimport {IWstETH} from './interfaces/external/lido/IWstETH.sol';\n\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance Protocol\n *\n * Uses Uniswap V3 to get a price of a token pair\n */\ncontract PriceOracle is IPriceOracle {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeMath for uint256;\n\n    /* ============ Constants ============ */\n\n    // Address of Uniswap factory\n    IUniswapV3Factory internal constant factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    ISnxExchangeRates internal constant snxEchangeRates = ISnxExchangeRates(0xd69b189020EF614796578AfE4d10378c5e7e1138);\n    // Address of Curve Registry\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n    IUniswapV2Router internal constant uniRouterV2 = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IYearnRegistry private constant yearnRegistry = IYearnRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\n\n    address internal constant ETH_ADD_CURVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    IStETH private constant stETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    IWstETH private constant wstETH = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    address private constant TRI_CURVE_POOL = 0x80466c64868E1ab14a1Ddf27A676C3fcBE638Fe5;\n\n    // the desired seconds agos array passed to the observe method\n    uint32 private constant SECONDS_GRANULARITY = 30;\n    uint256 private constant CURVE_SLIPPAGE = 6e16;\n\n    uint24 private constant FEE_LOW = 500;\n    uint24 private constant FEE_MEDIUM = 3000;\n    uint24 private constant FEE_HIGH = 10000;\n    int24 private constant maxTwapDeviation = 5000;\n    int24 private constant baseThreshold = 1000;\n\n    /* ============ State Variables ============ */\n\n    // Mapping of cToken addresses\n    mapping(address => address) public cTokenToAsset;\n    // Mapping of interest bearing aave tokens\n    mapping(address => address) public aTokenToAsset;\n    // Mapping of cream tokens\n    mapping(address => address) public crTokenToAsset;\n    // Mapping of synths\n    mapping(address => bool) public synths;\n    // Mapping of yearn vaults\n    mapping(address => bool) public vaults;\n\n    /* ============ Constructor ============ */\n\n    constructor() {\n        cTokenToAsset[0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI\n        cTokenToAsset[0x35A18000230DA775CAc24873d00Ff85BccdeD550] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // UNI\n        cTokenToAsset[0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5] = WETH; // ETH\n        cTokenToAsset[0x39AA39c021dfbaE8faC545936693aC917d5E7563] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        cTokenToAsset[0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        cTokenToAsset[0xccF4429DB6322D5C611ee964527D42E5d685DD6a] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC\n        cTokenToAsset[0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4] = 0xc00e94Cb662C3520282E6f5717214004A7f26888; // COMP\n        cTokenToAsset[0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; // BAT\n        cTokenToAsset[0xFAce851a4921ce59e912d19329929CE6da6EB0c7] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // LINK\n        cTokenToAsset[0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1] = 0x1985365e9f78359a9B6AD760e32412f4a445E862; // REP\n        cTokenToAsset[0xF5DCe57282A584D2746FaF1593d3121Fcac444dC] = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; // SAI\n        cTokenToAsset[0x12392F67bdf24faE0AF363c24aC620a2f67DAd86] = 0x0000000000085d4780B73119b644AE5ecd22b376; // TUSD\n        cTokenToAsset[0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498; // ZRX\n\n        aTokenToAsset[0xFFC97d72E13E01096502Cb8Eb52dEe56f74DAD7B] = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; // aave\n        aTokenToAsset[0x272F97b7a56a387aE942350bBC7Df5700f8a4576] = 0xba100000625a3754423978a60c9317c58a424e3D; // bal\n        aTokenToAsset[0x05Ec93c0365baAeAbF7AefFb0972ea7ECdD39CF1] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; // bat\n        aTokenToAsset[0xA361718326c15715591c299427c62086F69923D9] = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; // busd\n        aTokenToAsset[0x8dAE6Cb04688C62d939ed9B68d32Bc62e49970b1] = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n        aTokenToAsset[0x028171bCA77440897B824Ca71D1c56caC55b68A3] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // dai\n        aTokenToAsset[0xaC6Df26a590F08dcC95D5a4705ae8abbc88509Ef] = 0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c; // enj\n        aTokenToAsset[0xD37EE7e4f452C6638c96536e68090De8cBcdb583] = 0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd; // gusd\n        aTokenToAsset[0x39C6b3e42d6A679d7D776778Fe880BC9487C2EDA] = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200; // knc\n        aTokenToAsset[0xa06bC25B5805d5F8d82847D191Cb4Af5A3e873E0] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // link\n        aTokenToAsset[0xa685a61171bb30d4072B338c80Cb7b2c865c873E] = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942; // mana\n        aTokenToAsset[0xc713e5E149D5D0715DcD1c156a020976e7E56B88] = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2; // mkr\n        aTokenToAsset[0xc9BC48c72154ef3e5425641a3c747242112a46AF] = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919; // rai\n        aTokenToAsset[0xCC12AbE4ff81c9378D670De1b57F8e0Dd228D77a] = 0x408e41876cCCDC0F92210600ef50372656052a38; // ren\n        aTokenToAsset[0x35f6B052C598d933D69A4EEC4D04c73A191fE6c2] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F; // snx\n        aTokenToAsset[0x6C5024Cd4F8A59110119C56f8933403A539555EB] = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51; // susd\n        aTokenToAsset[0x101cc05f4A51C0319f570d5E146a8C625198e636] = 0x0000000000085d4780B73119b644AE5ecd22b376; // tusd\n        aTokenToAsset[0xB9D7CB55f463405CDfBe4E90a6D2Df01C2B92BF1] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // uni\n        aTokenToAsset[0xBcca60bB61934080951369a648Fb03DF4F96263C] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // usdc\n        aTokenToAsset[0x3Ed3B47Dd13EC9a98b44e6204A523E766B225811] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // usdt\n        aTokenToAsset[0x9ff58f4fFB29fA2266Ab25e75e2A8b3503311656] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // wbtc\n        aTokenToAsset[0x030bA81f1c18d280636F32af80b9AAd02Cf0854e] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // weth\n        aTokenToAsset[0xF256CC7847E919FAc9B808cC216cAc87CCF2f47a] = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // xsushi\n        aTokenToAsset[0x5165d24277cD063F5ac44Efd447B27025e888f37] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e; // yfi\n        aTokenToAsset[0xDf7FF54aAcAcbFf42dfe29DD6144A69b629f8C9e] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498; // zrx\n\n        crTokenToAsset[0xD06527D5e56A3495252A528C4987003b712860eE] = WETH;\n        crTokenToAsset[0x797AAB1ce7c01eB727ab980762bA88e7133d2157] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        crTokenToAsset[0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        crTokenToAsset[0xCbaE0A83f4f9926997c8339545fb8eE32eDc6b76] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e; // YFI\n        crTokenToAsset[0xcE4Fe9b4b8Ff61949DCfeB7e03bc9FAca59D2Eb3] = 0xba100000625a3754423978a60c9317c58a424e3D; // BAL\n        crTokenToAsset[0x19D1666f543D42ef17F66E376944A22aEa1a8E46] = 0xc00e94Cb662C3520282E6f5717214004A7f26888; // COMP\n        crTokenToAsset[0x9baF8a5236d44AC410c0186Fe39178d5AAD0Bb87] = 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8; // YCRV\n        crTokenToAsset[0x892B14321a4FCba80669aE30Bd0cd99a7ECF6aC0] = 0x2ba592F78dB6436527729929AAf6c908497cB200; // CREAM\n        crTokenToAsset[0x697256CAA3cCaFD62BB6d3Aa1C7C5671786A5fD9] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // LINK\n        crTokenToAsset[0x8B86e0598616a8d4F1fdAE8b59E55FB5Bc33D0d6] = 0x80fB784B7eD66730e8b1DBd9820aFD29931aab03; // LEND\n        crTokenToAsset[0xc7Fd8Dcee4697ceef5a2fd4608a7BD6A94C77480] = 0xD533a949740bb3306d119CC777fa900bA034cd52; // CRV\n        crTokenToAsset[0x17107f40d70f4470d20CB3f138a052cAE8EbD4bE] = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D; // RENBTC\n        crTokenToAsset[0x1FF8CDB51219a8838b52E9cAc09b71e591BC998e] = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; // BUSD\n        crTokenToAsset[0x3623387773010d9214B10C551d6e7fc375D31F58] = 0xa3BeD4E1c75D00fa6f4E5E6922DB7261B5E9AcD2; // MTA\n        crTokenToAsset[0x4EE15f44c6F0d8d1136c83EfD2e8E4AC768954c6] = 0x4EE15f44c6F0d8d1136c83EfD2e8E4AC768954c6; // YYCRV\n        crTokenToAsset[0x338286C0BC081891A4Bda39C7667ae150bf5D206] = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2; // SUSHI\n        crTokenToAsset[0x10FDBD1e48eE2fD9336a482D746138AE19e649Db] = 0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9; // FTT\n        crTokenToAsset[0x01da76DEa59703578040012357b81ffE62015C2d] = 0xe1237aA7f535b0CC33Fd973D66cBf830354D16c7; // YETH\n        crTokenToAsset[0xef58b2d5A1b8D3cDE67b8aB054dC5C831E9Bc025] = 0x476c5E26a75bd202a9683ffD34359C0CC15be0fF; // SRM\n        crTokenToAsset[0xe89a6D0509faF730BD707bf868d9A2A744a363C7] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // UNI\n        crTokenToAsset[0xeFF039C3c1D668f408d09dD7B63008622a77532C] = 0x0d438F3b5175Bebc262bF23753C1E53d03432bDE; // WNXM\n        crTokenToAsset[0x22B243B96495C547598D9042B6f94B01C22B2e9E] = 0x87eDfFDe3E14c7a66c9b9724747a1C5696b742e6; // SWAG\n        crTokenToAsset[0x8b3FF1ed4F36C2c2be675AFb13CC3AA5d73685a5] = 0xaaAEBE6Fe48E54f431b0C390CfaF0b017d09D42d; // CEL\n        crTokenToAsset[0x2A537Fa9FFaea8C1A41D3C2B68a9cb791529366D] = 0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b; // DPI\n        crTokenToAsset[0x7ea9C63E216D5565c3940A2B3d150e59C2907Db3] = 0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541; // BBTC\n        crTokenToAsset[0x3225E3C669B39C7c8B3e204a8614bB218c5e31BC] = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; // AAVE\n        crTokenToAsset[0xf55BbE0255f7f4E70f63837Ff72A577fbDDbE924] = 0x0391D2021f89DC339F60Fff84546EA23E337750f; // BOND\n        crTokenToAsset[0x903560b1CcE601794C584F58898dA8a8b789Fc5d] = 0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44; // KP3R\n        crTokenToAsset[0x054B7ed3F45714d3091e82aAd64A1588dC4096Ed] = 0x0316EB71485b0Ab14103307bf65a021042c6d380; // HBTC\n        crTokenToAsset[0xd5103AfcD0B3fA865997Ef2984C66742c51b2a8b] = 0x9AFb950948c2370975fb91a441F36FDC02737cD4; // HFIL\n        crTokenToAsset[0xfd609a03B393F1A1cFcAcEdaBf068CAD09a924E2] = 0xcBc1065255cBc3aB41a6868c22d1f1C573AB89fd; // CRETH2\n        crTokenToAsset[0xD692ac3245bb82319A31068D6B8412796eE85d2c] = 0xdF574c24545E5FfEcb9a659c229253D4111d87e1; // HUSD\n        crTokenToAsset[0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI\n        crTokenToAsset[0x10a3da2BB0Fae4D591476fd97D6636fd172923a8] = 0x584bC13c7D411c00c01A62e8019472dE68768430; // HEGIC\n        crTokenToAsset[0x3C6C553A95910F9FC81c98784736bd628636D296] = 0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723; // ESD\n        crTokenToAsset[0x21011BC93d9E515B9511A817A1eD1D6d468f49Fc] = 0x4688a8b1F292FDaB17E9a90c8Bc379dC1DBd8713; // COVER\n        crTokenToAsset[0x85759961b116f1D36fD697855c57A6ae40793D9B] = 0x111111111117dC0aa78b770fA6A738034120C302; // 1INCH\n        crTokenToAsset[0x7Aaa323D7e398be4128c7042d197a2545f0f1fea] = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07; // OMG\n        crTokenToAsset[0x011a014d5e8Eb4771E575bB1000318D509230Afa] = 0xBb2b8038a1640196FbE3e38816F3e67Cba72D940; // UNI-V2-WBTC-ETH\n        crTokenToAsset[0xE6C3120F38F56deb38B69b65cC7dcAF916373963] = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852; // UNI-V2-ETH-USDT\n        crTokenToAsset[0x4Fe11BC316B6d7A345493127fBE298b95AdaAd85] = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc; // UNI-V2-USDC-ETH\n        crTokenToAsset[0xcD22C4110c12AC41aCEfA0091c432ef44efaAFA0] = 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11; // UNI-V2-DAI-ETH\n        crTokenToAsset[0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2] = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // XSUSHI\n        crTokenToAsset[0x73f6cBA38922960b7092175c0aDD22Ab8d0e81fC] = 0xCEfF51756c56CeFFCA006cD410B03FFC46dd3a58; // SLP-WBTC-ETH\n        crTokenToAsset[0x38f27c03d6609a86FF7716ad03038881320BE4Ad] = 0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f; // SLP-DAI-ETH\n        crTokenToAsset[0x5EcaD8A75216CEa7DFF978525B2D523a251eEA92] = 0x397FF1542f962076d0BFE58eA045FfA2d347ACa0; // SLP-USDC-ETH\n        crTokenToAsset[0x5C291bc83d15f71fB37805878161718eA4b6AEe9] = 0x06da0fd433C1A5d7a4faa01111c044910A184553; // SLP-ETH-USDT\n        crTokenToAsset[0x6BA0C66C48641e220CF78177C144323b3838D375] = 0x795065dCc9f64b5614C407a6EFDC400DA6221FB0; // SLP-SUSHI-ETH\n        crTokenToAsset[0xd532944df6DFd5Dd629E8772F03D4fC861873abF] = 0x088ee5007C98a9677165D78dD2109AE4a3D04d0C; // SLP-YFI-ETH\n        crTokenToAsset[0x197070723CE0D3810a0E47F06E935c30a480D4Fc] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC\n        crTokenToAsset[0xC25EAE724f189Ba9030B2556a1533E7c8A732E14] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F; // SNX\n        crTokenToAsset[0x25555933a8246Ab67cbf907CE3d1949884E82B55] = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51; // SUSD\n        crTokenToAsset[0xc68251421eDDa00a10815E273fA4b1191fAC651b] = 0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5; // PICKLE\n        crTokenToAsset[0x65883978aDA0e707c3b2BE2A6825b1C4BDF76A90] = 0x8Ab7404063Ec4DBcfd4598215992DC3F8EC853d7; // AKRO\n        crTokenToAsset[0x8B950f43fCAc4931D408F1fcdA55C6CB6cbF3096] = 0x19D97D8fA813EE2f51aD4B4e04EA08bAf4DFfC28; // BBADGER\n        crTokenToAsset[0x59089279987DD76fC65Bf94Cb40E186b96e03cB3] = 0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26; // OGN\n        crTokenToAsset[0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6] = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2; // AMP\n        crTokenToAsset[0xb092b4601850E23903A42EaCBc9D8A0EeC26A4d5] = 0x853d955aCEf822Db058eb8505911ED77F175b99e; // FRAX\n        crTokenToAsset[0x1d0986Fb43985c88Ffa9aD959CC24e6a087C7e35] = 0xa1faa113cbE53436Df28FF0aEe54275c13B40975; // ALPHA\n        crTokenToAsset[0x51F48b638F82e8765F7a26373A2Cb4CcB10C07af] = 0xa47c8bf37f92aBed4A126BDA807A7b7498661acD; // UST\n        crTokenToAsset[0xc36080892c64821fa8e396bc1bD8678fA3b82b17] = 0x4E15361FD6b4BB609Fa63C81A2be19d873717870; // FTM\n        crTokenToAsset[0x8379BAA817c5c5aB929b03ee8E3c48e45018Ae41] = 0x3155BA85D5F96b2d030a4966AF206230e46849cb; // RUNE\n        crTokenToAsset[0x299e254A8a165bBeB76D9D69305013329Eea3a3B] = 0xbC396689893D065F41bc2C6EcbeE5e0085233447; // PERP\n        crTokenToAsset[0xf8445C529D363cE114148662387eba5E62016e20] = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919; // RAI\n        crTokenToAsset[0x7C3297cFB4c4bbd5f44b450c0872E0ADA5203112] = 0x967da4048cD07aB37855c090aAF366e4ce1b9F48; // OCEAN\n        crTokenToAsset[0xA87e8e61dfAC8af5944D353Cd26B96B20d5f4D01] = 0x986b4AFF588a109c09B50A03f42E4110E29D353F; // YVECRV CHECK!\n        crTokenToAsset[0x081FE64df6dc6fc70043aedF3713a3ce6F190a21] = 0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF; // RARI\n        crTokenToAsset[0x28526Bb33d7230E65E735dB64296413731C5402e] = 0xb753428af26E81097e7fD17f40c88aaA3E04902c; // SFI\n        crTokenToAsset[0x45406ba53bB84Cd32A58e7098a2D4D1b11B107F6] = 0x27b7b1ad7288079A66d12350c828D3C00A6F07d7; // YVCurve-IB CHECK!\n        crTokenToAsset[0x6d1B9e01aF17Dd08d6DEc08E210dfD5984FF1C20] = 0x986b4AFF588a109c09B50A03f42E4110E29D353F; // YVCurve-sETH\n        crTokenToAsset[0x1F9b4756B008106C806c7E64322d7eD3B72cB284] = 0xdCD90C7f6324cfa40d7169ef80b12031770B4325; // YVCurve-stETH\n        crTokenToAsset[0xab10586C918612BA440482db77549d26B7ABF8f7] = 0x1337DEF16F9B486fAEd0293eb623Dc8395dFE46a; // ARMOR\n        crTokenToAsset[0xdFFf11DFe6436e42a17B86e7F419Ac8292990393] = 0x1337DEF18C680aF1f9f45cBcab6309562975b1dD; // ARNXM\n        crTokenToAsset[0xDbb5e3081dEf4b6cdD8864aC2aeDA4cBf778feCf] = 0xec67005c4E498Ec7f55E092bd1d35cbC47C91892; // MLN\n        crTokenToAsset[0x71cEFCd324B732d4E058AfAcBA040d908c441847] = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421; // VSP\n        crTokenToAsset[0x1A122348B73B58eA39F822A89e6ec67950c2bBD0] = 0xbA4cFE5741b357FA371b506e5db0774aBFeCf8Fc; // VVSP\n        crTokenToAsset[0x523EFFC8bFEfC2948211A05A905F761CBA5E8e9E] = 0x6810e776880C02933D47DB1b9fc05908e5386b96; // GNO\n        crTokenToAsset[0x4202D97E00B9189936EdF37f8D01cfF88BDd81d4] = 0xa9fE4601811213c340e850ea305481afF02f5b28; // YVWETH\n        crTokenToAsset[0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4] = 0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4; // YUSD\n        crTokenToAsset[0x98E329eB5aae2125af273102f3440DE19094b77c] = 0xCC4304A31d09258b0029eA7FE63d032f52e44EFe; // SWAP\n        crTokenToAsset[0x8C3B7a4320ba70f8239F83770c4015B5bc4e6F91] = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA; // FEI\n        crTokenToAsset[0xE585c76573D7593ABF21537B607091F76c996E73] = 0x4691937a7508860F876c9c0a2a617E7d9E945D4B; // WOO\n        crTokenToAsset[0x81E346729723C4D15d0FB1c5679b9f2926Ff13C6] = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; // BNT\n\n        synths[0x57Ab1ec28D129707052df4dF418D58a2D46d5f51] = true; // ProxyERC20sUSD\n        synths[0x176C674Ee533C6139B0dc8b458D72A93dCB3e705] = true; // ProxyiAAVE\n        synths[0x8A8079c7149B8A1611e5C5d978DCA3bE16545F83] = true; // ProxyiADA\n        synths[0xAFD870F32CE54EfdBF677466B612bf8ad164454B] = true; // ProxyiBNB\n        synths[0xD6014EA05BDe904448B743833dDF07c3C7837481] = true; // ProxyiBTC\n        synths[0x336213e1DDFC69f4701Fc3F86F4ef4A160c1159d] = true; // ProxyiCEX\n        synths[0x6345728B1ccE16E6f8C509950b5c84FFF88530d9] = true; // ProxyiCOMP\n        synths[0xCB98f42221b2C251A4E74A1609722eE09f0cc08E] = true; // ProxyiDASH\n        synths[0x14d10003807AC60d07BB0ba82cAeaC8d2087c157] = true; // ProxyiDEFI\n        synths[0x46a97629C9C1F58De6EC18C7F536e7E6d6A6ecDe] = true; // ProxyiDOT\n        synths[0xF4EebDD0704021eF2a6Bbe993fdf93030Cd784b4] = true; // ProxyiEOS\n        synths[0xd50c1746D835d2770dDA3703B69187bFfeB14126] = true; // ProxyiETC\n        synths[0xA9859874e1743A32409f75bB11549892138BBA1E] = true; // ProxyiETH\n        synths[0x2d7aC061fc3db53c39fe1607fB8cec1B2C162B01] = true; // ProxyiLINK\n        synths[0x79da1431150C9b82D2E5dfc1C68B33216846851e] = true; // ProxyiLTC\n        synths[0xA5a5DF41883Cdc00c4cCC6E8097130535399d9a3] = true; // ProxyiOIL\n        synths[0x0fEd38108bdb8e62ef7b5680E8E0726E2F29e0De] = true; // ProxyiREN\n        synths[0xC5807183a9661A533CB08CbC297594a0B864dc12] = true; // ProxyiTRX\n        synths[0x36A00FF9072570eF4B9292117850B8FE08d96cce] = true; // ProxyiUNI\n        synths[0x4AdF728E2Df4945082cDD6053869f51278fae196] = true; // ProxyiXMR\n        synths[0x27269b3e45A4D3E79A3D6BFeE0C8fB13d0D711A6] = true; // ProxyiXRP\n        synths[0x8deef89058090ac5655A99EEB451a4f9183D1678] = true; // ProxyiXTZ\n        synths[0x592244301CeA952d6daB2fdC1fE6bd9E53917306] = true; // ProxyiYFI\n        synths[0xcD39b5434a0A92cf47D1F567a7dF84bE356814F0] = true; // Proxys1INCH\n        synths[0x7537AAe01f3B218DAE75e10d952473823F961B87] = true; // ProxysAAPL\n        synths[0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076] = true; // ProxysAAVE\n        synths[0xe36E2D3c7c34281FA3bC737950a68571736880A1] = true; // ProxysADA\n        synths[0x9CF7E61853ea30A41b02169391b393B901eac457] = true; // ProxysAMZN\n        synths[0xF48e200EAF9906362BB1442fca31e0835773b8B4] = true; // ProxysAUD\n        synths[0x617aeCB6137B5108D1E7D4918e3725C8cEbdB848] = true; // ProxysBNB\n        synths[0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6] = true; // ProxysBTC\n        synths[0xeABACD844A196D7Faf3CE596edeBF9900341B420] = true; // ProxysCEX\n        synths[0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d] = true; // ProxysCHF\n        synths[0x9EeF4CA7aB9fa8bc0650127341C2d3F707a40f8A] = true; // ProxysCOIN\n        synths[0xEb029507d3e043DD6C87F2917C4E82B902c35618] = true; // ProxysCOMP\n        synths[0xD38aEb759891882e78E957c80656572503D8c1B1] = true; // ProxysCRV\n        synths[0xfE33ae95A9f0DA8A845aF33516EDc240DCD711d6] = true; // ProxysDEFI\n        synths[0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6] = true; // ProxysDOT\n        synths[0x88C8Cf3A212c0369698D13FE98Fcb76620389841] = true; // ProxysEOS\n        synths[0x22602469d704BfFb0936c7A7cfcD18f7aA269375] = true; // ProxysETC\n        synths[0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb] = true; // ProxysETH\n        synths[0xD71eCFF9342A5Ced620049e616c5035F1dB98620] = true; // ProxysEUR\n        synths[0xf50B5e535F62a56A9BD2d8e2434204E726c027Fa] = true; // ProxysFB\n        synths[0x23348160D7f5aca21195dF2b70f28Fce2B0be9fC] = true; // ProxysFTSE\n        synths[0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F] = true; // ProxysGBP\n        synths[0xC63B8ECCE56aB9C46184eC6aB85e4771fEa4c8AD] = true; // ProxysGOOG\n        synths[0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d] = true; // ProxysJPY\n        synths[0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B] = true; // ProxysKRW\n        synths[0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6] = true; // ProxysLINK\n        synths[0xC14103C2141E842e228FBaC594579e798616ce7A] = true; // ProxysLTC\n        synths[0x745a824D6aBBD236AA794b5530062778A6Ad7523] = true; // ProxysMSFT\n        synths[0x5A7E3c07604EB515C16b36cd51906a65f021F609] = true; // ProxysNFLX\n        synths[0x757de3ac6B830a931eF178C6634c5C551773155c] = true; // ProxysNIKKEI\n        synths[0x6d16cF3EC5F763d4d99cB0B0b110eefD93B11B56] = true; // ProxysOIL\n        synths[0xD31533E8d0f3DF62060e94B3F1318137bB6E3525] = true; // ProxysREN\n        synths[0x0352557B007A4Aae1511C114409b932F06F9E2f4] = true; // ProxysRUNE\n        synths[0xf2E08356588EC5cd9E437552Da87C0076b4970B0] = true; // ProxysTRX\n        synths[0x918dA91Ccbc32B7a6A0cc4eCd5987bbab6E31e6D] = true; // ProxysTSLA\n        synths[0x30635297E450b930f8693297eBa160D9e6c8eBcf] = true; // ProxysUNI\n        synths[0x6A22e5e94388464181578Aa7A6B869e00fE27846] = true; // ProxysXAG\n        synths[0x261EfCdD24CeA98652B9700800a13DfBca4103fF] = true; // ProxysXAU\n        synths[0x5299d6F7472DCc137D7f3C4BcfBBB514BaBF341A] = true; // ProxysXMR\n        synths[0xa2B0fDe6D710e201d0d608e924A484d1A5fEd57c] = true; // ProxysXRP\n        synths[0x2e59005c5c0f0a4D77CcA82653d48b46322EE5Cd] = true; // ProxysXTZ\n        synths[0x992058B7DB08F9734d84485bfbC243C4ee6954A7] = true; // ProxysYFI\n\n        vaults[0xC4dAf3b5e2A9e93861c3FBDd25f1e943B8D87417] = true; // Curve USDP Pool yVault\n        vaults[0x49b3E44e54b6220aF892DbA48ae45F1Ea6bC4aE9] = true; // TUSD yVault\n        vaults[0x25212Df29073FfFA7A67399AcEfC2dd75a831A1A] = true; // Curve EURS Pool yVault\n        vaults[0xDdb166C6CB38CEDe52d12c405b6e906c1fB6f9d7] = true; // crvRenWSBTC yVault\n        vaults[0x32651dD149a6EC22734882F790cBEB21402663F9] = true; // USDT yVault\n        vaults[0x1f6BDffBadD98e410F83C66D1278241375F5199f] = true; // WBTC yVault\n        vaults[0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9] = true; // USDC yVault\n        vaults[0xA696a63cc78DfFa1a63E9E50587C197387FF6C7E] = true; // WBTC yVault\n        vaults[0xE537B5cc158EB71037D4125BDD7538421981E6AA] = true; // Curve 3Crypto Pool yVault\n        vaults[0xa5cA62D95D24A4a350983D5B8ac4EB8638887396] = true; // sUSD yVault\n        vaults[0x4A3FE75762017DB0eD73a71C9A06db7768DB5e66] = true; // COMP yVault\n        vaults[0x0FCDAeDFb8A7DfDa2e9838564c5A1665d856AFDF] = true; // yearn Curve.fi MUSD/3Crv\n        vaults[0xd9788f3931Ede4D5018184E198699dC6d66C1915] = true; // AAVE yVault\n        vaults[0x722f76f34cB5c3B008A50E0664e55A53F4F461AB] = true; // yvUSDT MetaVault\n        vaults[0x27b7b1ad7288079A66d12350c828D3C00A6F07d7] = true; // Curve Iron Bank Pool yVault\n        vaults[0x8ee57c05741aA9DB947A744E713C15d4d19D8822] = true; // Curve yBUSD Pool yVault\n        vaults[0x32413274504908460f0c373C7f20F429Fb80ed3A] = true; // saCRV yVault\n        vaults[0x8B58Aa42A4Aa222b684078459CE03Dd0A43342B1] = true; // USDP yVault\n        vaults[0x5737022626C282a89D105fD2e89ed6928EbDAe93] = true; // eCRV yVault\n        vaults[0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c] = true; // yearn Curve.fi yDAI/yUSDC/yUSDT/yTUSD\n        vaults[0x3149950258FbBcE1638d6C23ac93A692604Ef864] = true; // crvRenWBTC yVault\n        vaults[0x8cc94ccd0f3841a468184aCA3Cc478D2148E1757] = true; // Curve mUSD Pool yVault\n        vaults[0x3C90033684F2504D55eeb652720785F70FA692D4] = true; // crvCOMP\n        vaults[0x0F6121fB28C7C42916d663171063c62684598f9F] = true; // HBTC yVault\n        vaults[0x23D3D0f1c697247d5e0a9efB37d8b0ED0C464f7f] = true; // Curve tBTC Pool yVault\n        vaults[0xcC7E70A958917cCe67B4B87a8C30E6297451aE98] = true; // yearn Curve.fi GUSD/3Crv\n        vaults[0x8fA3A9ecd9EFb07A8CE90A6eb014CF3c0E3B32Ef] = true; // Curve BBTC Pool yVault\n        vaults[0xdA816459F1AB5631232FE5e97a05BBBb94970c95] = true; // DAI yVault\n        vaults[0x6D2F347DCFc55C6AC80e515a58344acd7FeF0B84] = true; // bCRV yVault\n        vaults[0x0e880118C29F095143dDA28e64d95333A9e75A47] = true; // eCRV yVault\n        vaults[0x80bbeE2fa460dA291e796B9045e93d19eF948C6A] = true; // Curve Pax Pool yVault\n        vaults[0x03403154afc09Ce8e44C3B185C82C6aD5f86b9ab] = true; // yearn Curve.fi aDAI/aUSDC/aUSDT\n        vaults[0xFe8A3837cFf919C800bdC5d1ac6136F84497d679] = true; // UNI yVault\n        vaults[0x0ff3773a6984aD900f7FB23A9acbf07AC3aDFB06] = true; // Curve Y Pool yVault\n        vaults[0xD6Ea40597Be05c201845c0bFd2e96A60bACde267] = true; // Curve Compound Pool yVault\n        vaults[0x597aD1e0c13Bfe8025993D9e79C69E1c0233522e] = true; // yearn USD//C\n        vaults[0xBacB69571323575C6a5A3b4F9EEde1DC7D31FBc1] = true; // yearn Curve.fi aDAI/aSUSD\n        vaults[0xac333895ce1A73875CF7B4Ecdc5A743C12f3d82B] = true; // WETH yVault\n        vaults[0x4962B6C40B5E9433E029c5c423F6b1ce7fF28b0f] = true; // sUSD yVault\n        vaults[0x7158c1Bee7a0Fa5BD6AFFc77b2309991D7ADCdd4] = true; // USDC yVault\n        vaults[0xAc1C90b9c76d56BA2e24F3995F7671c745f8f308] = true; // AAVE yVault\n        vaults[0x8e6741b456a074F0Bc45B8b82A755d4aF7E965dF] = true; // yearn Curve.fi DUSD/3Crv\n        vaults[0x3D980E50508CFd41a13837A60149927a11c03731] = true; // Curve triCrypto Pool yVault\n        vaults[0xe1237aA7f535b0CC33Fd973D66cBf830354D16c7] = true; // yearn Wrapped Ether\n        vaults[0xFBEB78a723b8087fD2ea7Ef1afEc93d35E8Bed42] = true; // UNI yVault\n        vaults[0xdb25cA703181E7484a155DD612b06f57E12Be5F0] = true; // YFI yVault\n        vaults[0xFe39Ce91437C76178665D64d7a2694B0f6f17fE3] = true; // yearn Curve.fi USDN/3Crv\n        vaults[0xe11ba472F74869176652C35D30dB89854b5ae84D] = true; // HEGIC yVault\n        vaults[0xB4AdA607B9d6b2c9Ee07A275e9616B84AC560139] = true; // Curve FRAX Pool yVault\n        vaults[0xa2619fDFB99ABeb533a1147461f3f1109c5ADe75] = true; // WETH yVault\n        vaults[0x629c759D1E83eFbF63d84eb3868B564d9521C129] = true; // yearn Curve.fi cDAI/cUSDC\n        vaults[0x1133b2E2F51becCF25b2f8d0cA48c1d93DD5ab12] = true; // OCEAN yVault\n        vaults[0x1Ae8Ccd120A05080d9A01C3B4F627F865685D091] = true; // WBTC yVault\n        vaults[0x7356f09C294Cb9c6428AC7327B24B0f29419C181] = true; // SNX yVault\n        vaults[0x873fB544277FD7b977B196a826459a69E27eA4ea] = true; // RAI yVault\n        vaults[0x2147935D9739da4E691b8Ae2e1437492A394eBf5] = true; // WETH ubiVault\n        vaults[0x3D27705c64213A5DcD9D26880c1BcFa72d5b6B0E] = true; // Curve USDK Pool yVault\n        vaults[0x4C4A6A22bCE915C724A66b82128577F1B24831eD] = true; // Curve EURT Pool yVault\n        vaults[0xB98Df7163E61bf053564bde010985f67279BBCEC] = true; // DAI yVault\n        vaults[0x5fA5B62c8AF877CB37031e0a3B2f34A78e3C56A6] = true; // Curve LUSD Pool yVault\n        vaults[0x625b7DF2fa8aBe21B0A976736CDa4775523aeD1E] = true; // Curve HBTC Pool yVault\n        vaults[0x5120FeaBd5C21883a4696dBCC5D123d6270637E9] = true; // WETH yVault\n        vaults[0x30FCf7c6cDfC46eC237783D94Fc78553E79d4E9C] = true; // Curve DUSD Pool yVault\n        vaults[0xf8768814b88281DE4F532a3beEfA5b85B69b9324] = true; // Curve TUSD Pool yVault\n        vaults[0xF6C9E9AF314982A4b38366f4AbfAa00595C5A6fC] = true; // yearn Curve.fi UST/3Crv\n        vaults[0xcE0F1Ef5aAAB82547acc699d3Ab93c069bb6e547] = true; // sUSD-hedging yVault\n        vaults[0x96Ea6AF74Af09522fCB4c28C269C26F59a31ced6] = true; // yearn Curve.fi LINK/sLINK\n        vaults[0xAaAee277F21Bb7D2Bf49E6b36d0d94DC229B0B25] = true; // LUSD yVault\n        vaults[0x0d4EA8536F9A13e4FBa16042a46c30f092b06aA5] = true; // Curve EURT Pool yVault\n        vaults[0x39CAF13a104FF567f71fd2A4c68C026FDB6E740B] = true; // Curve Aave Pool yVault\n        vaults[0x671a912C10bba0CFA74Cfc2d6Fba9BA1ed9530B2] = true; // LINK yVault\n        vaults[0xe9Dc63083c464d6EDcCFf23444fF3CFc6886f6FB] = true; // Curve oBTC Pool yVault\n        vaults[0x7047F90229a057C13BF847C0744D646CFb6c9E1A] = true; // Curve renBTC Pool yVault\n        vaults[0xb4D1Be44BfF40ad6e506edf43156577a3f8672eC] = true; // Curve sAave Pool yVault\n        vaults[0x5B707472eeF1553646740a7e5BEcFD41B9B4Ef4C] = true; // COMP yVault\n        vaults[0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a] = true; // Yearn Compounding veCRV yVault\n        vaults[0xa442BEB83baBC33D93c8Bec471070Ce59b88fb7d] = true; // WETH yVault\n        vaults[0x9cA85572E6A3EbF24dEDd195623F188735A5179f] = true; // yearn Curve.fi DAI/USDC/USDT\n        vaults[0x7Da96a3891Add058AdA2E826306D812C638D87a7] = true; // USDT yVault\n        vaults[0x477faf103dADc5Fe5BAa40951cf7512dcBC18126] = true; // USDC yVault\n        vaults[0x054AF22E1519b020516D72D749221c24756385C9] = true; // Curve HUSD Pool yVault\n        vaults[0xBF7AA989192b020a8d3e1C65a558e123834325cA] = true; // HBTC yVault\n        vaults[0x19D3364A399d251E894aC732651be8B0E4e85001] = true; // DAI yVault\n        vaults[0x3466c90017F82DDA939B01E8DBd9b0f97AEF8DfC] = true; // sUSD yVault\n        vaults[0xB8C3B7A2A618C552C23B1E4701109a9E756Bab67] = true; // 1INCH yVault\n        vaults[0x7F83935EcFe4729c4Ea592Ab2bC1A32588409797] = true; // yearn Curve.fi oBTC/sbtcCRV\n        vaults[0x3408324Dbb537886CADc180f6FfCf674eE215F67] = true; // \"renBTC yVault\"\n        vaults[0x3c5DF3077BcF800640B5DAE8c91106575a4826E6] = true; // Curve pBTC Pool yVault\n        vaults[0x0e8A7717A4FD7694682E7005957dD5d7598bF14A] = true; // yExperimentalWBTC\n        vaults[0xD2C65E20C3fDE3F18097e7414e65596e0C83B1a9] = true; // ICE yVault\n        vaults[0x7Ff566E1d69DEfF32a7b244aE7276b9f90e9D0f6] = true; // yearn Curve.fi renBTC/wBTC/sBTC\n        vaults[0x4856A7EFBbFcaE92AB13c5e2e322Fc77647bB856] = true; // RAI yVault\n        vaults[0x5533ed0a3b83F70c3c4a1f69Ef5546D3D4713E44] = true; // yearn Curve.fi DAI/USDC/USDT/sUSD\n        vaults[0xbD65955F752B2eF093B34B05e5FFb439AE8e5049] = true; // COMP yVault\n        vaults[0xa9fE4601811213c340e850ea305481afF02f5b28] = true; // WETH yVault\n        vaults[0x71955515ADF20cBDC699B8bC556Fc7Fd726B31B0] = true; // USDC yVault\n        vaults[0x6d765CbE5bC922694afE112C140b8878b9FB0390] = true; // SUSHI yVault\n        vaults[0x497590d2d57f05cf8B42A36062fA53eBAe283498] = true; // SUSHI yVault\n        vaults[0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8] = true; // Curve MIM Pool yVault\n        vaults[0xED0244B688cF059f32f45E38A6ac6E479D6755f6] = true; // WETH yVault\n        vaults[0x4B5BfD52124784745c1071dcB244C6688d2533d3] = true; // Curve Y Pool yVault\n        vaults[0x2f08119C6f07c006695E079AAFc638b8789FAf18] = true; // yearn Tether USD\n        vaults[0x46AFc2dfBd1ea0c0760CAD8262A5838e803A37e5] = true; // yearn Curve.fi hBTC/wBTC\n        vaults[0x123964EbE096A920dae00Fb795FFBfA0c9Ff4675] = true; // yearn Curve.fi pBTC/sbtcCRV\n        vaults[0x03c31f3444357087d5f568d24AE17f9177c8AA84] = true; // LINK yVault\n        vaults[0xC116dF49c02c5fD147DE25Baa105322ebF26Bd97] = true; // Curve RSV Pool yVault\n        vaults[0x2F194Da57aa855CAa02Ea3Ab991fa5d38178B9e6] = true; // UNI yVault\n        vaults[0x98B058b2CBacF5E99bC7012DF757ea7CFEbd35BC] = true; // yearn Curve.fi EURS/sEUR\n        vaults[0x07FB4756f67bD46B748b16119E802F1f880fb2CC] = true; // yearn Curve.fi tBTC/sbtcCrv\n        vaults[0x3B96d491f067912D18563d56858Ba7d6EC67a6fa] = true; // Curve USDN Pool yVault\n        vaults[0x39546945695DCb1c037C836925B355262f551f55] = true; // yearn Curve.fi HUSD/3Crv\n        vaults[0xBfedbcbe27171C418CDabC2477042554b1904857] = true; // Curve rETH Pool yVault\n        vaults[0x37d19d1c4E1fa9DC47bD1eA12f742a0887eDa74a] = true; // yearn TrueUSD\n        vaults[0x8472E9914C0813C4b465927f82E213EA34839173] = true; // sBTC yVault\n        vaults[0xFD0877d9095789cAF24c98F7CCe092fa8E120775] = true; // TUSD yVault\n        vaults[0xF11b141BE4D1985E41c3AEa99417e27603F67c4c] = true; // wAAVE\n        vaults[0xA8B1Cb4ed612ee179BDeA16CCa6Ba596321AE52D] = true; // yearn Curve.fi bBTC/sbtcCRV\n        vaults[0xcB550A6D4C8e3517A939BC79d0c7093eb7cF56B5] = true; // WBTC yVault\n        vaults[0x6Ede7F19df5df6EF23bD5B9CeDb651580Bdf56Ca] = true; // Curve BUSD Pool yVault\n        vaults[0x881b06da56BB5675c54E4Ed311c21E54C5025298] = true; // yearn ChainLink Token\n        vaults[0x79fF6c5A23B492619661F7c5b73a961114A4C940] = true; // AAVE yVault\n        vaults[0x986b4AFF588a109c09B50A03f42E4110E29D353F] = true; // Curve sETH Pool yVault\n        vaults[0xf4fDbc7C66Dc9832D672Ffe6242B6A386CeAd5DE] = true; // sUSD yVault\n        vaults[0xdCD90C7f6324cfa40d7169ef80b12031770B4325] = true; // Curve stETH Pool yVault\n        vaults[0x132d8D2C76Db3812403431fAcB00F3453Fc42125] = true; // Curve ankrETH Pool yVault\n        vaults[0xF962B098Ecc4352aA2AD1d4164BD2b8367fd94c3] = true; // LINK yVault\n        vaults[0xbda3A6CB2aaef41805F6317841d7B8654eC8b124] = true; // crvRenWBTC yVault\n        vaults[0xACd43E627e64355f1861cEC6d3a6688B31a6F952] = true; // yearn Dai Stablecoin\n        vaults[0x75A3f32ba5e60A094729257EE44841F9552baFb9] = true; // AAVE yVault\n        vaults[0x84E13785B5a27879921D6F685f041421C7F482dA] = true; // Curve 3pool yVault\n        vaults[0xf2db9a7c0ACd427A680D640F02d90f6186E71725] = true; // Curve LINK Pool yVault\n        vaults[0x19b8Bc5CcF9700e16f2780bEA152F01C449f45D0] = true; // ALCX yVault\n        vaults[0xF29AE508698bDeF169B89834F76704C3B205aedf] = true; // SNX yVault\n        vaults[0x63859212aa05d60295a2F18a9e0C707040605BAd] = true; // DAI ubiVault\n        vaults[0x1B5eb1173D2Bf770e50F10410C9a96F7a8eB6e75] = true; // yearn Curve.fi USDP/3Crv\n        vaults[0x2994529C0652D127b7842094103715ec5299bBed] = true; // yearn Curve.fi yDAI/yUSDC/yUSDT/yBUSD\n        vaults[0xdf5110EF6bc751cBaf76D35B8A3f312b581B5173] = true; // DAI ubiVault\n        vaults[0x1C6a9783F812b3Af3aBbf7de64c3cD7CC7D1af44] = true; // Curve UST Pool yVault\n        vaults[0x56A5Fd5104a4956898753dfb060ff32882Ae0eb4] = true; // ALCX yVault\n        vaults[0x5a770DbD3Ee6bAF2802D29a901Ef11501C44797A] = true; // Curve sUSD Pool yVault\n        vaults[0xb32747B4045479B77a8b8Eb44029ba12580214F8] = true; // SUSHI yVault\n        vaults[0xE14d13d8B3b85aF791b2AADD661cDBd5E6097Db1] = true; // YFI yVault\n        vaults[0xE625F5923303f1CE7A43ACFEFd11fd12f30DbcA4] = true; // yearn Curve.fi ETH/aETH\n        vaults[0x29E240CFD7946BA20895a7a02eDb25C210f9f324] = true; // yearn Aave Interest bearing LINK\n        vaults[0x2a38B9B0201Ca39B17B460eD2f11e4929559071E] = true; // Curve GUSD Pool yVault\n        vaults[0x28a5b95C101df3Ded0C0d9074DB80C438774B6a9] = true; // Curve USDT Pool yVault\n        vaults[0x8414Db07a7F743dEbaFb402070AB01a4E0d2E45e] = true; // Curve sBTC Pool yVault\n        vaults[0xAf322a2eDf31490250fdEb0D712621484b09aBB6] = true; // USDT yVault\n        vaults[0xBA2E7Fed597fd0E3e70f5130BcDbbFE06bB94fe1] = true; // yearn yearn.finance\n        vaults[0x5b189D92983E941273b26e3b46e5a16206c08827] = true; // eCRV yVault\n        vaults[0xa258C4606Ca8206D8aA700cE2143D7db854D168c] = true; // WETH yVault\n        vaults[0xA74d4B67b3368E83797a35382AFB776bAAE4F5C8] = true; // Curve alUSD Pool yVault\n        vaults[0x63739d137EEfAB1001245A8Bd1F3895ef3e186E7] = true; // DAI yVault\n        vaults[0x5334e150B938dd2b6bd040D9c4a03Cff0cED3765] = true; // yearn Curve.fi renBTC/wBTC\n        vaults[0xE0db48B4F71752C4bEf16De1DBD042B82976b8C7] = true; // yearn mStable USD\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return price                Price of the pair\n     */\n    function getPriceNAV(address _tokenIn, address _tokenOut) public view override returns (uint256 price) {\n        price = _getPrice(_tokenIn, _tokenOut, true);\n        require(price != 0, 'Price not found');\n        return price;\n    }\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return price                Price of the pair\n     */\n    function getPrice(address _tokenIn, address _tokenOut) public view virtual override returns (uint256 price) {\n        price = _getPrice(_tokenIn, _tokenOut, false);\n        require(price != 0, 'Price not found');\n        return price;\n    }\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @param _forNAV               Whether it is just for display purposes\n     * @return price                Price of the pair\n     */\n    function _getPrice(\n        address _tokenIn,\n        address _tokenOut,\n        bool _forNAV\n    ) internal view returns (uint256 price) {\n        // Same asset. Returns base unit\n        if (_tokenIn == _tokenOut) {\n            return 10**18;\n        }\n        uint256 exchangeRate;\n        // Comp assets\n        if (cTokenToAsset[_tokenIn] != address(0)) {\n            exchangeRate = getCompoundExchangeRate(_tokenIn);\n            return getPrice(cTokenToAsset[_tokenIn], _tokenOut).preciseMul(exchangeRate);\n        }\n        if (cTokenToAsset[_tokenOut] != address(0)) {\n            exchangeRate = getCompoundExchangeRate(_tokenOut);\n            return getPrice(_tokenIn, cTokenToAsset[_tokenOut]).preciseDiv(exchangeRate);\n        }\n\n        // aave tokens. 1 to 1 with underlying\n        if (aTokenToAsset[_tokenIn] != address(0)) {\n            return getPrice(aTokenToAsset[_tokenIn], _tokenOut);\n        }\n        if (aTokenToAsset[_tokenOut] != address(0)) {\n            return getPrice(_tokenIn, aTokenToAsset[_tokenOut]);\n        }\n\n        // crTokens Cream prices 0xde19f5a7cF029275Be9cEC538E81Aa298E297266\n        // cTkens use same interface as compound\n        if (crTokenToAsset[_tokenIn] != address(0)) {\n            exchangeRate = getCreamExchangeRate(_tokenIn);\n            return getPrice(crTokenToAsset[_tokenIn], _tokenOut).preciseMul(exchangeRate);\n        }\n        if (crTokenToAsset[_tokenOut] != address(0)) {\n            exchangeRate = getCreamExchangeRate(_tokenOut);\n            return getPrice(_tokenIn, crTokenToAsset[_tokenOut]).preciseDiv(exchangeRate);\n        }\n\n        // Checks synthetix\n        if (synths[_tokenIn]) {\n            address targetImpl = ISnxProxy(_tokenIn).target();\n            exchangeRate = snxEchangeRates.rateForCurrency(ISnxSynth(targetImpl).currencyKey());\n            return getPrice(USDC, _tokenOut).preciseMul(exchangeRate);\n        }\n\n        if (synths[_tokenOut]) {\n            address targetImpl = ISnxProxy(_tokenOut).target();\n            exchangeRate = snxEchangeRates.rateForCurrency(ISnxSynth(targetImpl).currencyKey());\n            return getPrice(_tokenIn, USDC).preciseDiv(exchangeRate);\n        }\n\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        // Direct curve pair\n        price = _checkPairThroughCurve(_tokenIn, _tokenOut);\n\n        if (price != 0) {\n            return price;\n        }\n\n        // Curve LP tokens\n        if (_tokenIn != TRI_CURVE_POOL) {\n            address crvPool = curveRegistry.get_pool_from_lp_token(_tokenIn);\n            if (crvPool != address(0)) {\n                address denominator = _cleanCurvePoolDenominator(crvPool, curveRegistry);\n                return\n                    curveRegistry.get_virtual_price_from_lp_token(_tokenIn).preciseMul(\n                        getPrice(denominator, _tokenOut)\n                    );\n            }\n        }\n        if (_tokenOut != TRI_CURVE_POOL) {\n            address crvPool = curveRegistry.get_pool_from_lp_token(_tokenOut);\n            if (crvPool != address(0)) {\n                address denominator = _cleanCurvePoolDenominator(crvPool, curveRegistry);\n                return\n                    getPrice(_tokenIn, denominator).preciseDiv(\n                        curveRegistry.get_virtual_price_from_lp_token(_tokenOut)\n                    );\n            }\n        }\n\n        // Yearn vaults\n        if (_isYearnVault(_tokenIn)) {\n            price = IYearnVault(_tokenIn).pricePerShare().preciseMul(\n                getPrice(IYearnVault(_tokenIn).token(), _tokenOut)\n            );\n            uint256 yvDecimals = ERC20(_tokenIn).decimals();\n            if (yvDecimals < 18) {\n                price = price.mul(10**(18 - yvDecimals));\n            }\n            return price;\n        }\n\n        if (_isYearnVault(_tokenOut)) {\n            address vaultAsset = IYearnVault(_tokenOut).token();\n            price = getPrice(_tokenIn, vaultAsset).preciseDiv(IYearnVault(_tokenOut).pricePerShare());\n\n            uint256 yvDecimals = ERC20(_tokenOut).decimals();\n            if (yvDecimals < 18) {\n                price = price.div(10**(18 - yvDecimals));\n            }\n            return price;\n        }\n\n        uint256 uniPrice = 0;\n        // Curve pair through DAI\n        if (_tokenIn != DAI && _tokenOut != DAI) {\n            price = _checkPairThroughCurve(DAI, _tokenOut);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(_tokenIn, DAI);\n                if (uniPrice != 0) {\n                    return uniPrice.preciseMul(price);\n                }\n            }\n            price = _checkPairThroughCurve(_tokenIn, DAI);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(DAI, _tokenOut);\n                if (uniPrice != 0) {\n                    return price.preciseMul(uniPrice);\n                }\n            }\n        }\n        // Curve pair through WETH\n        if (_tokenIn != WETH && _tokenOut != WETH) {\n            price = _checkPairThroughCurve(WETH, _tokenOut);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(_tokenIn, WETH);\n                if (uniPrice != 0) {\n                    return uniPrice.preciseMul(price);\n                }\n            }\n            price = _checkPairThroughCurve(_tokenIn, WETH);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(WETH, _tokenOut);\n                if (uniPrice != 0) {\n                    return price.preciseMul(uniPrice);\n                }\n            }\n        }\n        // Curve Pair through WBTC\n        if (_tokenIn != WBTC && _tokenOut != WBTC) {\n            price = _checkPairThroughCurve(WBTC, _tokenOut);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(_tokenIn, WBTC);\n                if (uniPrice != 0) {\n                    return uniPrice.preciseMul(price);\n                }\n            }\n            price = _checkPairThroughCurve(_tokenIn, WBTC);\n            if (price != 0) {\n                uniPrice = _getUNIV3Price(WBTC, _tokenOut);\n                if (uniPrice != 0) {\n                    return price.preciseMul(uniPrice);\n                }\n            }\n        }\n        // Checks stETH && wstETH (Lido tokens)\n        if (_tokenIn == address(stETH) || _tokenIn == address(wstETH)) {\n            uint256 shares = 1e18;\n            if (_tokenIn == address(wstETH)) {\n                shares = wstETH.getStETHByWstETH(shares);\n            }\n            return getPrice(WETH, _tokenOut).preciseMul(stETH.getPooledEthByShares(shares));\n        }\n        if (_tokenOut == address(stETH) || _tokenOut == address(wstETH)) {\n            uint256 shares = 1e18;\n            if (_tokenOut == address(wstETH)) {\n                shares = wstETH.getStETHByWstETH(shares);\n            }\n            return getPrice(_tokenIn, WETH).preciseDiv(stETH.getSharesByPooledEth(shares));\n        }\n        // UniV3 through WETH\n        if (_tokenIn != WETH && _tokenOut != WETH) {\n            uint256 divisor = _getUNIV3Price(_tokenOut, WETH);\n            if (divisor != 0) {\n                return _getUNIV3Price(_tokenIn, WETH).preciseDiv(divisor);\n            }\n        }\n        // Direct UNI3\n        price = _getUNIV3Price(_tokenIn, _tokenOut);\n        if (price != 0) {\n            return price;\n        }\n        // UniV3 through DAI\n        if (_tokenIn != DAI && _tokenOut != DAI) {\n            uint256 divisor = _getUNIV3Price(_tokenOut, DAI);\n            if (divisor != 0) {\n                return _getUNIV3Price(_tokenIn, DAI).preciseDiv(divisor);\n            }\n        }\n        // Use only univ2 for UI\n        if (_forNAV) {\n            price = _getUNIV2Price(_tokenIn, _tokenOut);\n        }\n        // No valid price\n        return price;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _cleanCurvePoolDenominator(address _pool, ICurveRegistry _curveRegistry) internal view returns (address) {\n        address[8] memory coins = _curveRegistry.get_underlying_coins(_pool);\n        if (coins[0] != address(0)) {\n            return coins[0] == ETH_ADD_CURVE ? WETH : coins[0];\n        }\n        if (coins[1] != address(0)) {\n            return coins[1] == ETH_ADD_CURVE ? WETH : coins[1];\n        }\n        if (coins[2] != address(0)) {\n            return coins[2] == ETH_ADD_CURVE ? WETH : coins[2];\n        }\n        return address(0);\n    }\n\n    // Susceptible to flash loans.\n    // Only use for UI and getNAV\n    function _getUNIV2Price(address _tokenIn, address _tokenOut) internal view returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = _tokenIn;\n        path[1] = _tokenOut;\n        return uniRouterV2.getAmountsOut(ERC20(_tokenIn).decimals(), path)[1];\n    }\n\n    function _getUNIV3Price(address _tokenIn, address _tokenOut) internal view returns (uint256) {\n        bool found;\n        int24 tick;\n        IUniswapV3Pool pool;\n        // We try the low pool first\n        (found, pool, tick) = _checkPool(_tokenIn, _tokenOut);\n        if (!found) {\n            return 0;\n        }\n        return\n            OracleLibrary\n                .getQuoteAtTick(\n                tick,\n                // because we use 1e18 as a precision unit\n                uint128(uint256(1e18).mul(10**(uint256(18).sub(ERC20(_tokenOut).decimals())))),\n                _tokenIn,\n                _tokenOut\n            )\n                .div(10**(uint256(18).sub(ERC20(_tokenIn).decimals())));\n    }\n\n    function _checkPool(address _tokenIn, address _tokenOut)\n        internal\n        view\n        returns (\n            bool,\n            IUniswapV3Pool,\n            int24\n        )\n    {\n        int24 tick;\n        IUniswapV3Pool pool = _getUniswapPoolWithHighestLiquidity(_tokenIn, _tokenOut);\n        if (address(pool) != address(0)) {\n            uint256 poolLiquidity = uint256(pool.liquidity());\n            if (poolLiquidity > 0) {\n                (, tick, , , , , ) = pool.slot0();\n                return (_checkPrice(tick, pool), pool, tick);\n            }\n        }\n        return (false, IUniswapV3Pool(0), 0);\n    }\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow >= liquidityMedium && liquidityLow >= liquidityHigh) {\n            return poolLow;\n        }\n        if (liquidityMedium >= liquidityLow && liquidityMedium >= liquidityHigh) {\n            return poolMedium;\n        }\n        return poolHigh;\n    }\n\n    /// @dev Revert if current price is too close to min or max ticks allowed\n    /// by Uniswap, or if it deviates too much from the TWAP. Should be called\n    /// whenever base and limit ranges are updated. In practice, prices should\n    /// only become this extreme if there's no liquidity in the Uniswap pool.\n    function _checkPrice(int24 mid, IUniswapV3Pool _pool) internal view returns (bool) {\n        int24 tickSpacing = _pool.tickSpacing();\n        // TODO: Add the other param from charm\n        if (mid < TickMath.MIN_TICK + baseThreshold + tickSpacing) {\n            // \"price too low\"\n            return false;\n        }\n        if (mid > TickMath.MAX_TICK - baseThreshold - tickSpacing) {\n            // \"price too high\"\n            return false;\n        }\n\n        // Check TWAP deviation. This check prevents price manipulation before\n        // the rebalance and also avoids rebalancing when price has just spiked.\n        int56 twap = _getTwap(_pool);\n\n        int56 deviation = mid > twap ? mid - twap : twap - mid;\n        // Fail twap check\n        return deviation < maxTwapDeviation;\n    }\n\n    // given the cumulative prices of the start and end of a period, and the length of the period, compute the average\n    function _getTwap(IUniswapV3Pool _pool) private view returns (int56 twap) {\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = SECONDS_GRANULARITY;\n        secondsAgo[1] = 0;\n        // observe fails if the pair has no observations\n        try _pool.observe(secondsAgo) returns (\n            int56[] memory tickCumulatives,\n            uint160[] memory /* secondsPerLiquidityCumulativeX128s */\n        ) {\n            return (tickCumulatives[1] - tickCumulatives[0]) / SECONDS_GRANULARITY;\n        } catch {\n            return 0;\n        }\n    }\n\n    function getCompoundExchangeRate(address _asset) public view override returns (uint256) {\n        uint256 exchangeRateNormalized = ICToken(_asset).exchangeRateStored();\n        if (ERC20(cTokenToAsset[_asset]).decimals() > 8) {\n            exchangeRateNormalized = exchangeRateNormalized.div(10**(ERC20(cTokenToAsset[_asset]).decimals() - 8));\n        } else {\n            exchangeRateNormalized = exchangeRateNormalized.mul(10**(8 - ERC20(cTokenToAsset[_asset]).decimals()));\n        }\n        return exchangeRateNormalized;\n    }\n\n    function getCreamExchangeRate(address _asset) public view override returns (uint256) {\n        uint256 exchangeRateNormalized = ICToken(_asset).exchangeRateStored();\n        if (ERC20(crTokenToAsset[_asset]).decimals() > 8) {\n            exchangeRateNormalized = exchangeRateNormalized.div(10**(ERC20(crTokenToAsset[_asset]).decimals() - 8));\n        } else {\n            exchangeRateNormalized = exchangeRateNormalized.mul(10**(8 - ERC20(crTokenToAsset[_asset]).decimals()));\n        }\n        return exchangeRateNormalized;\n    }\n\n    function _getPriceThroughCurve(\n        address _curvePool,\n        address _tokenIn,\n        address _tokenOut\n    ) private view returns (uint256) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        (int128 i, int128 j, ) = curveRegistry.get_coin_indices(_curvePool, _tokenIn, _tokenOut);\n        uint256 price = 0;\n        if (_curvePool == TRI_CURVE_POOL) {\n            price = ICurvePoolV3(_curvePool).get_dy(\n                uint256(i),\n                uint256(j),\n                10**(_tokenIn == ETH_ADD_CURVE ? 18 : ERC20(_tokenIn).decimals())\n            );\n        } else {\n            price = ICurvePoolV3(_curvePool).get_dy(\n                i,\n                j,\n                10**(_tokenIn == ETH_ADD_CURVE ? 18 : ERC20(_tokenIn).decimals())\n            );\n        }\n        price = price.mul(10**(18 - (_tokenOut == ETH_ADD_CURVE ? 18 : ERC20(_tokenOut).decimals())));\n        uint256 delta = price.preciseMul(CURVE_SLIPPAGE);\n        if (price < uint256(1e18).add(delta) && price > uint256(1e18).sub(delta)) {\n            return price;\n        }\n        return 0;\n    }\n\n    function _checkPairThroughCurve(address _tokenIn, address _tokenOut) private view returns (uint256) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        address curvePool = curveRegistry.find_pool_for_coins(_tokenIn, _tokenOut);\n        if (_tokenIn == WETH && curvePool == address(0)) {\n            _tokenIn = ETH_ADD_CURVE;\n            curvePool = curveRegistry.find_pool_for_coins(ETH_ADD_CURVE, _tokenOut);\n        }\n        if (_tokenOut == WETH && curvePool == address(0)) {\n            _tokenOut = ETH_ADD_CURVE;\n            curvePool = curveRegistry.find_pool_for_coins(_tokenIn, ETH_ADD_CURVE);\n        }\n        if (curvePool != address(0)) {\n            uint256 price = _getPriceThroughCurve(curvePool, _tokenIn, _tokenOut);\n            return price;\n        }\n        return 0;\n    }\n\n    function _isYearnVault(address _token) private view returns (bool) {\n        return vaults[_token];\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / period);\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % period != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICToken {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function repayBorrowBehalf(address borrower, uint256 amount) external payable returns (uint256);\n\n    function borrowBalanceCurrent(address account) external view returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ISnxExchangeRates {\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint256 value);\n\n    function rateForCurrency(bytes32 sourceCurrencyKey) external view returns (uint256 value);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePoolV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface ICurvePoolV3 {\n    function coins(uint256 arg0) external view returns (address out);\n\n    function underlying_coins(uint256 arg0) external view returns (address out);\n\n    function underlying_coins(int128 arg0) external view returns (address out);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function balances(uint256 arg0) external view returns (uint256 out);\n\n    function lp_token() external view returns (address out);\n\n    function token() external view returns (address out);\n\n    function curve() external view returns (address out);\n\n    function pool() external view returns (address out);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnRegistry {\n    function latestVault(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function token() external view returns (address);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 shares) external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IStETH.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IStETH is IERC20 {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\n\n    function submit(address _referral) external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IWstETH.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH is IERC20 {\n    /**\n     * @notice Exchanges stETH to wstETH\n     * @param _stETHAmount amount of stETH to wrap in exchange for wstETH\n     * @dev Requirements:\n     *  - `_stETHAmount` must be non-zero\n     *  - msg.sender must approve at least `_stETHAmount` stETH to this\n     *    contract.\n     *  - msg.sender must have at least `_stETHAmount` of stETH.\n     * User should first approve _stETHAmount to the WstETH contract\n     * @return Amount of wstETH user receives after wrap\n     */\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n\n    /**\n     * @notice Shortcut to stake ETH and auto-wrap returned stETH\n     */\n    // receive() external payable {\n    //     uint256 shares = stETH.submit{value: msg.value}(address(0));\n    //     _mint(msg.sender, shares);\n    // }\n\n    /**\n     * @notice Get amount of wstETH for a given amount of stETH\n     * @param _stETHAmount amount of stETH\n     * @return Amount of wstETH for a given stETH amount\n     */\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a given amount of wstETH\n     * @param _wstETHAmount amount of wstETH\n     * @return Amount of stETH for a given wstETH amount\n     */\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of wstETH for a 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\n/**\n * @title Treasury\n * @author Babylon Finance\n *\n * Contract that will receive the fees earned by the protocol.\n * Governance will be able to send funds from the treasury.\n */\ncontract Treasury is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    /* ============ Events ============ */\n\n    event TreasuryFundsSent(address _asset, uint256 _amount, address _to);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     */\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION: Send an asset amount to an address\n     *\n     * @param _asset            Address of the asset to send\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryFunds(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external onlyOwner nonReentrant {\n        require(_asset != address(0), 'Asset must exist');\n        require(_to != address(0), 'Target address must exist');\n\n        IERC20(_asset).safeTransfer(_to, _amount);\n\n        emit TreasuryFundsSent(_asset, _amount, _to);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Send an ETH amount to an address\n     *\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryETH(uint256 _amount, address payable _to) external onlyOwner nonReentrant {\n        require(_to != address(0), 'Target address must exist');\n        require(address(this).balance >= _amount, 'Not enough funds in treasury');\n\n        Address.sendValue(_to, _amount);\n\n        emit TreasuryFundsSent(address(0), _amount, _to);\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n"
    },
    "contracts/token/BABLToken.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title BABL Token\n * @dev The BABLToken contract is ERC20 using 18 decimals as a standard\n * Is Ownable to transfer ownership to Governor Alpha for Decentralized Governance\n * It overrides the mint and maximum supply to control the timing and maximum cap allowed along the time.\n */\n\ncontract BABLToken is TimeLockedToken {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new mint ocurr\n    event MintedNewTokens(address account, uint256 tokensminted);\n\n    /// @notice An event thats emitted when maxSupplyAllowed changes\n    event MaxSupplyChanged(uint256 previousMaxValue, uint256 newMaxValue);\n\n    /// @notice An event that emitted when maxSupplyAllowedAfter changes\n    event MaxSupplyAllowedAfterChanged(uint256 previousAllowedAfterValue, uint256 newAllowedAfterValue);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @dev EIP-20 token name for this token\n    string private constant NAME = 'Babylon.Finance';\n\n    /// @dev EIP-20 token symbol for this token\n    string private constant SYMBOL = 'BABL';\n\n    /// @dev Maximum number of tokens in circulation of 1 million for the first 8 years (using 18 decimals as ERC20 standard)\n    uint256 public maxSupplyAllowed = 1_000_000e18; //\n\n    /// @notice The timestamp after which a change on maxSupplyAllowed may occur\n    uint256 public maxSupplyAllowedAfter;\n\n    /// @notice Cap on the percentage of maxSupplyAllowed that can be increased per year after maxSupplyAllowedAfter\n    uint8 public constant MAX_SUPPLY_CAP = 5;\n\n    /// @notice Cap on the percentage of totalSupply that can be minted at each mint after the initial 1 Million BABL\n    uint8 public constant MINT_CAP = 2;\n\n    /// @notice The timestamp after which minting may occur after FIRST_EPOCH_MINT (8 years)\n    uint256 public mintingAllowedAfter;\n\n    /// @notice The timestamp of BABL Token deployment\n    uint256 public BABLTokenDeploymentTimestamp;\n\n    /// @dev First Epoch Mint where no more than 1 Million BABL can be minted (>= 8 Years)\n    uint32 private constant FIRST_EPOCH_MINT = 365 days * 8;\n\n    /// @dev Minimum time between mints after\n    uint32 private constant MIN_TIME_BETWEEN_MINTS = 365 days;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new BABL token and gives ownership to sender\n     */\n    constructor(IBabController newController) TimeLockedToken(NAME, SYMBOL) {\n        // Timestamp of contract deployment\n        BABLTokenDeploymentTimestamp = block.timestamp;\n\n        // Set-up the minimum time of 8 years to wait until the maxSupplyAllowed can be changed (it will also include a max cap)\n        maxSupplyAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        //Starting with a maxSupplyAllowed of 1 million for the first 8 years\n        _mint(msg.sender, 1_000_000e18);\n\n        //Set-up the minimum time of 8 years for additional mints\n        mintingAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        // Set the Babylon Controller\n        controller = newController;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows to mint new tokens\n     *\n     * @notice Mint new BABL tokens. Initial 1 Million BABL. After 8 years new BABL could be minted by governance decision\n     * @dev MINT_CAP The new maximum limit, limited by a 2% cap of totalSupply for each new mint and always limited by maxSupplyAllowed.\n     * mintingAllowedAfter Defines the next time allowed for a new mint\n     * @param _to The address of the destination account that will receive the new BABL tokens\n     * @param _amount The number of tokens to be minted\n     * @return Whether or not the mint succeeded\n     */\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        require(totalSupply().add(_amount) <= maxSupplyAllowed, 'BABLToken::mint: max supply exceeded');\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::mint: minting not allowed after the FIRST_EPOCH_MINT has passed >= 8 years'\n        );\n        require(_amount > 0, 'BABLToken::mint: mint should be higher than zero');\n        require(\n            block.timestamp >= mintingAllowedAfter,\n            'BABLToken::mint: minting not allowed yet because mintingAllowedAfter'\n        );\n        require(_to != address(0), 'BABLToken::mint: cannot transfer to the zero address');\n        require(_to != address(this), 'BABLToken::mint: cannot mint to the address of this contract');\n\n        // set-up the new time where a new (the next) mint can be allowed\n        mintingAllowedAfter = block.timestamp.add(MIN_TIME_BETWEEN_MINTS);\n\n        // mint the amount\n        uint96 amount = safe96(_amount, 'BABLToken::mint: amount exceeds 96 bits');\n\n        // After FIRST_EPOCH_MINT (8 years) a MINT_CAP applies\n        require(\n            amount <= totalSupply().mul(MINT_CAP).div(100),\n            'BABLToken::mint: exceeded mint cap of 2% of total supply'\n        );\n        _mint(_to, amount);\n\n        emit MintedNewTokens(_to, amount);\n\n        // move delegates to add voting power to the destination\n        _moveDelegates(address(0), delegates[_to], amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change maxSupplyAllowed\n     *\n     * @notice Set-up a greater maxSupplyAllowed value to allow more tokens to be minted\n     * @param newMaxSupply The new maximum limit, limited by a maximum of 5% cap per year\n     * @param newMaxSupplyAllowedAfter The new waiting period to change the maxSupplyAllowed limited for a minimum of 1 year\n     * @return Whether or not the changeMaxSupply succeeded\n     */\n    function changeMaxSupply(uint256 newMaxSupply, uint256 newMaxSupplyAllowedAfter) external onlyOwner returns (bool) {\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed until 8 years after deployment'\n        );\n        require(\n            block.timestamp >= maxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed yet'\n        );\n\n        // update the amount\n        require(\n            newMaxSupply > maxSupplyAllowed,\n            'BABLToken::changeMaxSupply: changeMaxSupply should be higher than previous value'\n        );\n        uint256 limitedNewSupply = maxSupplyAllowed.add(maxSupplyAllowed.mul(MAX_SUPPLY_CAP).div(100));\n        require(newMaxSupply <= limitedNewSupply, 'BABLToken::changeMaxSupply: exceeded of allowed 5% cap');\n        emit MaxSupplyChanged(maxSupplyAllowed, newMaxSupply);\n        maxSupplyAllowed = safe96(newMaxSupply, 'BABLToken::changeMaxSupply: potential max amount exceeds 96 bits');\n\n        // update the new waiting time until a new change could be done >= 1 year since this change\n        uint256 futureTime = block.timestamp.add(365 days);\n        require(\n            newMaxSupplyAllowedAfter >= futureTime,\n            'BABLToken::changeMaxSupply: the newMaxSupplyAllowedAfter should be at least 1 year in the future'\n        );\n        emit MaxSupplyAllowedAfterChanged(maxSupplyAllowedAfter, newMaxSupplyAllowedAfter);\n        maxSupplyAllowedAfter = safe96(\n            newMaxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: new newMaxSupplyAllowedAfter exceeds 96 bits'\n        );\n\n        return true;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the value of maxSupplyAllowed\n     *\n     * @return Returns the value of maxSupplyAllowed at the time\n     */\n    function maxSupply() external view returns (uint96, uint256) {\n        uint96 safeMaxSupply =\n            safe96(maxSupplyAllowed, 'BABLToken::maxSupplyAllowed: maxSupplyAllowed exceeds 96 bits'); // Overflow check\n        return (safeMaxSupply, maxSupplyAllowedAfter);\n    }\n}\n"
    },
    "contracts/gardens/Garden.sol": {
      "content": "/*\n Copyright 2021 Babylon Finance.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\n\n/**\n * @title BaseGarden\n * @author Babylon Finance\n *\n * Class that holds common garden-related state and functions\n */\ncontract Garden is ERC20Upgradeable, ReentrancyGuard, IGarden {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    /* ============ Events ============ */\n\n    // DO NOT TOUCH for the love of GOD\n    event GardenDeposit(address indexed _to, uint256 reserveToken, uint256 reserveTokenQuantity, uint256 timestamp);\n    event GardenWithdrawal(\n        address indexed _from,\n        address indexed _to,\n        uint256 reserveToken,\n        uint256 reserveTokenQuantity,\n        uint256 timestamp\n    );\n    event AddStrategy(address indexed _strategy, string _name, uint256 _expectedReturn);\n\n    event RewardsForContributor(address indexed _contributor, uint256 indexed _amount);\n    event BABLRewardsForContributor(address indexed _contributor, uint256 _rewards);\n\n    /* ============ Constants ============ */\n\n    // Wrapped ETH address\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    // Strategy cooldown period\n    uint256 private constant MIN_COOLDOWN_PERIOD = 60 seconds;\n    uint256 private constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    uint8 private constant MAX_EXTRA_CREATORS = 4;\n    uint256 private constant EARLY_WITHDRAWAL_PENALTY = 25e15;\n    uint256 private constant MAX_TOTAL_STRATEGIES = 20; // Max number of strategies\n    uint256 private constant TEN_PERCENT = 1e17;\n\n    bytes32 private constant DEPOSIT_BY_SIG_TYPEHASH =\n        keccak256('DepositBySig(uint256 _amountIn,uint256 _minAmountOut,bool _mintNft,uint256 _nonce,uint256 _maxFee)');\n    bytes32 private constant WITHDRAW_BY_SIG_TYPEHASH =\n        keccak256(\n            'WithdrawBySig(uint256 _amountIn,uint256 _minAmountOut,uint256,_nonce,uint256 _maxFee,uint256 _withPenalty)'\n        );\n\n    /* ============ Structs ============ */\n\n    struct Contributor {\n        uint256 lastDepositAt;\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        uint256 claimedBABL;\n        uint256 claimedRewards;\n        uint256 withdrawnSince;\n        uint256 totalDeposits;\n        uint256 nonce;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address public override reserveAsset;\n\n    // Address of the controller\n    address public override controller;\n\n    // Address of the rewards distributor\n    IRewardsDistributor private rewardsDistributor;\n\n    // The person that creates the garden\n    address public override creator;\n\n    bool private active; // DEPRECATED;\n    bool public override privateGarden;\n\n    uint256 private principal; // DEPRECATED;\n\n    // The amount of funds set aside to be paid as rewards. Should NEVER be spent\n    // on anything else ever.\n    uint256 public override reserveAssetRewardsSetAside;\n\n    uint256 private reserveAssetPrincipalWindow; // DEPRECATED\n    int256 public override absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 public override minLiquidityAsset;\n\n    uint256 public override depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    uint256 private withdrawalsOpenUntil; // DEPRECATED\n\n    // Contributors\n    mapping(address => Contributor) private contributors;\n    uint256 public override totalContributors;\n    uint256 private maxContributors; // DEPRECATED\n    uint256 public override maxDepositLimit; // Limits the amount of deposits\n\n    uint256 public override gardenInitializedAt; // Garden Initialized at timestamp\n    // Number of garden checkpoints used to control the garden power and each contributor power with accuracy\n    uint256 private pid;\n\n    // Min contribution in the garden\n    uint256 public override minContribution; //wei\n    uint256 private minGardenTokenSupply; // DEPRECATED\n\n    // Strategies variables\n    uint256 public override totalStake;\n    uint256 public override minVotesQuorum = TEN_PERCENT; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 public override minVoters;\n    uint256 public override minStrategyDuration; // Min duration for an strategy\n    uint256 public override maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 public override strategyCooldownPeriod;\n\n    address[] private strategies; // Strategies that are either in candidate or active state\n    address[] private finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) public override strategyMapping;\n    mapping(address => bool) public override isGardenStrategy; // Security control mapping\n\n    // Keeper debt in reserve asset if any, repaid upon every strategy finalization\n    uint256 public override keeperDebt;\n    uint256 public override totalKeeperFees;\n\n    // Allow public strategy creators for certain gardens\n    bool public override publicStrategists;\n\n    // Allow public strategy stewards for certain gardens\n    bool public override publicStewards;\n\n    // Addresses for extra creators\n    address[MAX_EXTRA_CREATORS] public override extraCreators;\n\n    /* ============ Modifiers ============ */\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    function _onlyContributor() private view {\n        _require(balanceOf(msg.sender) > 0, Errors.ONLY_CONTRIBUTOR);\n    }\n\n    /**\n     * Throws if the sender is not an strategy of this garden\n     */\n    function _onlyStrategy() private view {\n        _require(strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n    }\n\n    /**\n     * Checks if the address passed is a creator in the garden\n     */\n    function _onlyCreator(address _creator) private view {\n        _require(_isCreator(_creator), Errors.ONLY_CREATOR);\n    }\n\n    /**\n     * Check if msg.sender is keeper\n     */\n    function _onlyKeeper() private view {\n        _require(IBabController(controller).isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * When a new Garden is created.\n     * All parameter validations are on the BabController contract. Validations are performed already on the\n     * BabController.\n     * WARN: If the reserve Asset is different than WETH the gardener needs to have approved the controller.\n     *\n     * @param _reserveAsset                     Address of the reserve asset ERC20\n     * @param _controller                       Address of the controller\n     * @param _creator                          Address of the creator\n     * @param _name                             Name of the Garden\n     * @param _symbol                           Symbol of the Garden\n     * @param _gardenParams                     Array of numeric garden params\n     * @param _initialContribution              Initial Contribution by the Gardener\n     * @param _publicGardenStrategistsStewards  Public garden, public strategists rights and public stewards rights\n     */\n    function initialize(\n        address _reserveAsset,\n        address _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) public payable override initializer {\n        __ERC20_init(_name, _symbol);\n\n        controller = _controller;\n        reserveAsset = _reserveAsset;\n        creator = _creator;\n        rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        _require(address(rewardsDistributor) != address(0), Errors.ADDRESS_IS_ZERO);\n        privateGarden = !(IBabController(controller).allowPublicGardens() && _publicGardenStrategistsStewards[0]);\n        publicStrategists = !privateGarden && _publicGardenStrategistsStewards[1];\n\n        publicStewards = !privateGarden && _publicGardenStrategistsStewards[2];\n        _require(\n            _gardenParams[3] > 0 &&\n                _initialContribution >= _gardenParams[3] &&\n                _initialContribution <= _gardenParams[0],\n            Errors.MIN_CONTRIBUTION\n        );\n        gardenInitializedAt = block.timestamp;\n        _start(\n            _gardenParams[0],\n            _gardenParams[1],\n            _gardenParams[2],\n            _gardenParams[3],\n            _gardenParams[4],\n            _gardenParams[5],\n            _gardenParams[6],\n            _gardenParams[7],\n            _gardenParams[8]\n        );\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice\n     *   Deposits the _amountIn in reserve asset into the garden. Gurantee to\n     *   recieve at least _minAmountOut.\n     * @dev\n     *   WARN: If the reserve asset is different than ETH the sender needs to\n     *   have approved the garden.\n     *   Efficient to use of strategies.length == 0, otherwise can consume a lot\n     *   of gas ~2kk. Use `depositBySig` for gas efficiency.\n     * @param _amountIn               Amount of the reserve asset that is received from contributor\n     * @param _minAmountOut           Min amount of Garden shares to receive by contributor\n     * @param _to                     Address to mint Garden shares to\n     * @param _mintNft                Whether to mint NFT or not\n     */\n    function deposit(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        bool _mintNft\n    ) external payable override nonReentrant {\n        // calculate pricePerShare\n        uint256 pricePerShare;\n        // if there are no strategies then NAV === liquidReserve\n        if (strategies.length == 0) {\n            pricePerShare = totalSupply() == 0\n                ? PreciseUnitMath.preciseUnit()\n                : liquidReserve().preciseDiv(uint256(10)**ERC20Upgradeable(reserveAsset).decimals()).preciseDiv(\n                    totalSupply()\n                );\n        } else {\n            // Get valuation of the Garden with the quote asset as the reserve asset.\n            pricePerShare = IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                reserveAsset\n            );\n        }\n\n        _internalDeposit(_amountIn, _minAmountOut, _to, msg.sender, _mintNft, pricePerShare, minContribution);\n    }\n\n    function depositBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        bool _mintNft,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override nonReentrant {\n        _onlyKeeper();\n        _require(_fee <= _maxFee, Errors.FEE_TOO_HIGH);\n\n        bytes32 hash =\n            keccak256(\n                abi.encode(DEPOSIT_BY_SIG_TYPEHASH, address(this), _amountIn, _minAmountOut, _mintNft, _nonce, _maxFee)\n            )\n                .toEthSignedMessageHash();\n        address signer = ECDSA.recover(hash, v, r, s);\n\n        _require(signer != address(0), Errors.INVALID_SIGNER);\n\n        // to prevent replay attacks\n        _require(contributors[signer].nonce == _nonce, Errors.INVALID_NONCE);\n\n        // If a Keeper fee is greater than zero then reduce user shares to\n        // exchange and pay keeper the fee.\n        if (_fee > 0) {\n            // account for non 18 decimals ERC20 tokens, e.g. USDC\n            uint256 feeShares = _reserveToShares(_fee, _pricePerShare);\n            _internalDeposit(\n                _amountIn.sub(_fee),\n                _minAmountOut.sub(feeShares),\n                signer,\n                signer,\n                _mintNft,\n                _pricePerShare,\n                minContribution > _fee ? minContribution.sub(_fee) : 0\n            );\n            // pay Keeper the fee\n            IERC20(reserveAsset).safeTransferFrom(signer, msg.sender, _fee);\n        } else {\n            _internalDeposit(_amountIn, _minAmountOut, signer, signer, _mintNft, _pricePerShare, minContribution);\n        }\n    }\n\n    /**\n     * @notice\n     *   Withdraws the reserve asset relative to the token participation in the garden\n     *   and sends it back to the sender.\n     * @dev\n     *   ATTENTION. Do not call withPenalty unless certain. If penalty is set,\n     *   it will be applied regardless of the garden state.\n     *   It is advised to first try to withdraw with no penalty and it this\n     *   reverts then try to with penalty.\n     * @param _amountIn         Quantity of the garden token to withdrawal\n     * @param _minAmountOut     Min quantity of reserve asset to receive\n     * @param _to               Address to send component assets to\n     * @param _withPenalty      Whether or not this is an immediate withdrawal\n     * @param _unwindStrategy   Strategy to unwind\n     */\n    function withdraw(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external override nonReentrant {\n        // Get valuation of the Garden with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 pricePerShare =\n            IGardenValuer(IBabController(controller).gardenValuer()).calculateGardenValuation(\n                address(this),\n                reserveAsset\n            );\n\n        _require(msg.sender == _to, Errors.ONLY_CONTRIBUTOR);\n        _withdrawInternal(\n            _amountIn,\n            _minAmountOut,\n            _to,\n            _withPenalty,\n            _unwindStrategy,\n            pricePerShare,\n            _withPenalty ? IStrategy(_unwindStrategy).getNAV() : 0,\n            0\n        );\n    }\n\n    /**\n     * @notice\n     *   Exchanges user's gardens shairs for amount in reserve asset. This\n     *   method allows users to leave garden and reclaim their inital investment\n     *   plus profits or losses.\n     * @dev\n     *   Should be called instead of the `withdraw` to save gas due to\n     *   pricePerShare caculated off-chain. Doesn't allow to unwind strategies\n     *   contrary to `withdraw`.\n     *   The Keeper fee is paid out of user's shares.\n     *   The true _minAmountOut is actually _minAmountOut - _maxFee due to the\n     *   Keeper fee.\n     * @param _amountIn        Quantity of the garden tokens to withdraw.\n     * @param _minAmountOut    Min quantity of reserve asset to receive.\n     * @param _nonce           Current nonce to prevent replay attacks.\n     * @param _maxFee          Max fee user is willing to pay keeper. Fee is\n     *                         substracted from the withdrawn amount. Fee is\n     *                         expressed in reserve asset.\n     * @param _withPenalty     Whether or not this is an immediate withdrawal\n     * @param _unwindStrategy  Strategy to unwind\n     * @param _pricePerShare   Price per share of the garden calculated off-chain by Keeper.\n     * @param _strategyNAV     NAV of the strategy to unwind.\n     * @param _fee             Actual fee keeper demands. Have to be less than _maxFee.\n     */\n    function withdrawBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override nonReentrant {\n        _onlyKeeper();\n        _require(_fee <= _maxFee, Errors.FEE_TOO_HIGH);\n\n        address signer = _getWithdrawSigner(_amountIn, _minAmountOut, _nonce, _maxFee, _withPenalty, v, r, s);\n\n        _withdrawInternal(\n            _amountIn,\n            _minAmountOut.sub(_maxFee),\n            payable(signer),\n            _withPenalty,\n            _unwindStrategy,\n            _pricePerShare,\n            _strategyNAV,\n            _fee\n        );\n    }\n\n    /**\n     * User can claim the rewards from the strategies that his principal\n     * was invested in.\n     */\n    function claimReturns(address[] calldata _finalizedStrategies) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyContributor();\n        Contributor storage contributor = contributors[msg.sender];\n        _require(block.timestamp > contributor.claimedAt, Errors.ALREADY_CLAIMED); // race condition check\n        // Flashloan protection\n        _require(block.timestamp.sub(contributor.lastDepositAt) >= depositHardlock, Errors.DEPOSIT_HARDLOCK);\n        uint256[] memory rewards = new uint256[](7);\n\n        rewards = rewardsDistributor.getRewards(address(this), msg.sender, _finalizedStrategies);\n        _require(rewards[5] > 0 || rewards[6] > 0, Errors.NO_REWARDS_TO_CLAIM);\n\n        if (rewards[6] > 0) {\n            contributor.claimedRewards = contributor.claimedRewards.add(rewards[6]); // Rewards claimed properly\n            reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.sub(rewards[6]);\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n            _safeSendReserveAsset(msg.sender, rewards[6]);\n            emit RewardsForContributor(msg.sender, rewards[6]);\n        }\n        if (rewards[5] > 0) {\n            contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n            // Send BABL rewards\n            uint256 amount = rewardsDistributor.sendTokensToContributor(msg.sender, rewards[5]);\n            contributor.claimedBABL = contributor.claimedBABL.add(amount); // BABL Rewards claimed properly\n            emit BABLRewardsForContributor(msg.sender, amount);\n        }\n    }\n\n    /**\n     * @notice\n     *  When strategy ends puts saves returns, rewards and marks strategy as\n     *  finalized.\n     *\n     * @param _rewards        Amount of Reserve Asset to set aside forever\n     * @param _returns        Profits or losses that the strategy received\n     * @param _burningAmount  The amount of strategist stake to burn in case of\n     *                        strategy losses.\n     */\n    function finalizeStrategy(\n        uint256 _rewards,\n        int256 _returns,\n        uint256 _burningAmount\n    ) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyStrategy();\n\n        // burn statgist stake\n        if (_burningAmount > 0) {\n            address strategist = IStrategy(msg.sender).strategist();\n            if (_burningAmount >= balanceOf(strategist)) {\n                // Avoid underflow condition\n                _burningAmount = balanceOf(strategist);\n            }\n            _burn(strategist, _burningAmount);\n        }\n\n        reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.add(_rewards);\n\n        // Mark strategy as finalized\n        absoluteReturns = absoluteReturns.add(_returns);\n        strategies = strategies.remove(msg.sender);\n        finalizedStrategies.push(msg.sender);\n        strategyMapping[msg.sender] = false;\n    }\n\n    /**\n     * @notice\n     *   Pays gas costs back to the keeper from executing transactions\n     *   including the past debt\n     * @dev\n     *   We assume that calling keeper functions should be less expensive than\n     *   1 million gas and the gas price should be lower than 1000 gwei.\n     * @param _keeper  Keeper that executed the transaction\n     * @param _fee     The fee paid to keeper to compensate the gas cost\n     */\n    function payKeeper(address payable _keeper, uint256 _fee) public override nonReentrant {\n        _onlyUnpaused();\n        _require(msg.sender == address(this) || strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n        _require(IBabController(controller).isValidKeeper(_keeper), Errors.ONLY_KEEPER);\n\n        if (reserveAsset == WETH) {\n            // 1 ETH\n            _require(_fee <= (1e6 * 1e12), Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == DAI) {\n            // 2000 DAI\n            _require(_fee <= 2000 * 1e18, Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == USDC) {\n            // 2000 USDC\n            _require(_fee <= 2000 * 1e6, Errors.FEE_TOO_HIGH);\n        } else if (reserveAsset == WBTC) {\n            // 0.05 WBTC\n            _require(_fee <= 0.05 * 1e8, Errors.FEE_TOO_HIGH);\n        } else {\n            _revert(Errors.RESERVE_ASSET_NOT_SUPPORTED);\n        }\n\n        keeperDebt = keeperDebt.add(_fee);\n        // Pay Keeper in Reserve Asset\n        if (keeperDebt > 0 && liquidReserve() >= 0) {\n            uint256 toPay = liquidReserve() > keeperDebt ? keeperDebt : liquidReserve();\n            IERC20(reserveAsset).safeTransfer(_keeper, toPay);\n            totalKeeperFees = totalKeeperFees.add(toPay);\n            keeperDebt = keeperDebt.sub(toPay);\n        }\n    }\n\n    /**\n     * Makes a previously private garden public\n     */\n    function makeGardenPublic() external override {\n        _onlyCreator(msg.sender);\n        _require(privateGarden && IBabController(controller).allowPublicGardens(), Errors.GARDEN_ALREADY_PUBLIC);\n        privateGarden = false;\n    }\n\n    /**\n     * Gives the right to create strategies and/or voting power to garden users\n     */\n    function setPublicRights(bool _publicStrategists, bool _publicStewards) external override {\n        _onlyCreator(msg.sender);\n        _require(!privateGarden, Errors.GARDEN_IS_NOT_PUBLIC);\n        publicStrategists = _publicStrategists;\n        publicStewards = _publicStewards;\n    }\n\n    /* ============ Strategy Functions ============ */\n    /**\n     * Creates a new strategy calling the factory and adds it to the array\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _stratParams                   Num params for the strategy\n     * @param _opTypes                      Type for every operation in the strategy\n     * @param _opIntegrations               Integration to use for every operation\n     * @param _opEncodedDatas               Param for every operation in the strategy\n     */\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes calldata _opEncodedDatas\n    ) external override {\n        _onlyUnpaused();\n        _onlyContributor();\n        (, , bool canCreateStrategies) = _getUserPermission(msg.sender);\n        _require(canCreateStrategies, Errors.USER_CANNOT_ADD_STRATEGIES);\n        _require(strategies.length < MAX_TOTAL_STRATEGIES, Errors.VALUE_TOO_HIGH);\n        address strategy =\n            IStrategyFactory(IBabController(controller).strategyFactory()).createStrategy(\n                _name,\n                _symbol,\n                msg.sender,\n                address(this),\n                _stratParams\n            );\n        strategyMapping[strategy] = true;\n        totalStake = totalStake.add(_stratParams[1]);\n        strategies.push(strategy);\n        IStrategy(strategy).setData(_opTypes, _opIntegrations, _opEncodedDatas);\n        isGardenStrategy[strategy] = true;\n        emit AddStrategy(strategy, _name, _stratParams[3]);\n    }\n\n    /**\n     * Allocates garden capital to an strategy\n     *\n     * @param _capital        Amount of capital to allocate to the strategy\n     */\n    function allocateCapitalToStrategy(uint256 _capital) external override {\n        _onlyStrategy();\n\n        uint256 protocolMgmtFee = IBabController(controller).protocolManagementFee().preciseMul(_capital);\n        _require(_capital.add(protocolMgmtFee) <= liquidReserve(), Errors.MIN_LIQUIDITY);\n\n        // Take protocol mgmt fee\n        IERC20(reserveAsset).safeTransfer(IBabController(controller).treasury(), protocolMgmtFee);\n\n        // Send Capital to strategy\n        IERC20(reserveAsset).safeTransfer(msg.sender, _capital);\n    }\n\n    /*\n     * Remove an expire candidate from the strategy Array\n     * @param _strategy      Strategy to remove\n     */\n    function expireCandidateStrategy(address _strategy) external override {\n        _onlyStrategy();\n        strategies = strategies.remove(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /*\n     * Creator transfer his creator rights to another account.\n     * Must be a creator or an aux creator\n     * @param _newCreator  New creator address\n     * @param _index       Index of the creator if it is in the extra\n     */\n    function transferCreatorRights(address _newCreator, uint8 _index) external override {\n        _onlyCreator(msg.sender);\n        _require(!_isCreator(_newCreator), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        // Make sure creator can still have normal permissions after renouncing\n        // Creator can only renounce to 0x in public gardens\n        _require(_newCreator != address(0) || !privateGarden, Errors.CREATOR_CANNOT_RENOUNCE);\n        if (msg.sender == creator) {\n            creator = _newCreator;\n            return;\n        }\n        _require(extraCreators[_index] == msg.sender, Errors.ONLY_CREATOR);\n        extraCreators[_index] = _newCreator;\n    }\n\n    /*\n     * Adds extra creators. Only the original creator can call this.\n     * Can only be called if all the addresses are zero\n     * @param _newCreators  Addresses of the new creators\n     */\n    function addExtraCreators(address[MAX_EXTRA_CREATORS] memory _newCreators) external override {\n        _require(msg.sender == creator, Errors.ONLY_FIRST_CREATOR_CAN_ADD);\n        _assignExtraCreator(0, _newCreators[0]);\n        _assignExtraCreator(1, _newCreators[1]);\n        _assignExtraCreator(2, _newCreators[2]);\n        _assignExtraCreator(3, _newCreators[3]);\n    }\n\n    /**\n     * Updates Garden Params\n     * Can only be called by the creator\n     * @param _newParams  New params\n     */\n    function updateGardenParams(uint256[9] memory _newParams) external override {\n        _onlyCreator(msg.sender);\n        _start(\n            _newParams[0], // uint256 _maxDepositLimit\n            _newParams[1], // uint256 _minLiquidityAsset,\n            _newParams[2], // uint256 _depositHardlock,\n            _newParams[3], // uint256 _minContribution,\n            _newParams[4], // uint256 _strategyCooldownPeriod,\n            _newParams[5], // uint256 _minVotesQuorum,\n            _newParams[6], // uint256 _minStrategyDuration,\n            _newParams[7], // uint256 _maxStrategyDuration,\n            _newParams[8] // uint256 _minVoters\n        );\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets current strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getStrategies() external view override returns (address[] memory) {\n        return strategies;\n    }\n\n    /**\n     * Gets finalized strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getFinalizedStrategies() external view override returns (address[] memory) {\n        return finalizedStrategies;\n    }\n\n    function getContributor(address _contributor)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Contributor storage contributor = contributors[_contributor];\n        uint256 contributorPower = rewardsDistributor.getContributorPower(address(this), _contributor, block.timestamp);\n        uint256 balance = balanceOf(_contributor);\n        uint256 lockedBalance = getLockedBalance(_contributor);\n        return (\n            contributor.lastDepositAt,\n            contributor.initialDepositAt,\n            contributor.claimedAt,\n            contributor.claimedBABL,\n            contributor.claimedRewards,\n            contributor.totalDeposits > contributor.withdrawnSince\n                ? contributor.totalDeposits.sub(contributor.withdrawnSince)\n                : 0,\n            balance,\n            lockedBalance,\n            contributorPower,\n            contributor.nonce\n        );\n    }\n\n    /**\n     * Checks balance locked for strategists in active strategies\n     *\n     * @param _contributor                 Address of the account\n     *\n     * @return  uint256                    Returns the amount of locked garden tokens for the account\n     */\n    function getLockedBalance(address _contributor) public view override returns (uint256) {\n        uint256 lockedAmount;\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            if (_contributor == strategy.strategist()) {\n                lockedAmount = lockedAmount.add(strategy.stake());\n            }\n        }\n        // Avoid overflows if off-chain voting system fails\n        if (balanceOf(_contributor) < lockedAmount) lockedAmount = balanceOf(_contributor);\n        return lockedAmount;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * FUND LEAD ONLY.  Starts the Garden with allowed reserve assets,\n     * fees and issuance premium. Only callable by the Garden's creator\n     *\n     * @param _maxDepositLimit             Max deposit limit\n     * @param _minLiquidityAsset           Number that represents min amount of liquidity denominated in ETH\n     * @param _depositHardlock             Number that represents the time deposits are locked for\n     *                                     an user after he deposits\n     * @param _minContribution             Min contribution to the garden\n     * @param _strategyCooldownPeriod      How long after the strategy has been activated, will it be ready\n     *                                     to be executed\n     * @param _minVotesQuorum              Percentage of votes needed to activate an strategy (0.01% = 1e14, 1% = 1e16)\n     * @param _minStrategyDuration         Min duration of an strategy\n     * @param _maxStrategyDuration         Max duration of an strategy\n     * @param _minVoters                   The minimum amount of voters needed for quorum\n     */\n    function _start(\n        uint256 _maxDepositLimit,\n        uint256 _minLiquidityAsset,\n        uint256 _depositHardlock,\n        uint256 _minContribution,\n        uint256 _strategyCooldownPeriod,\n        uint256 _minVotesQuorum,\n        uint256 _minStrategyDuration,\n        uint256 _maxStrategyDuration,\n        uint256 _minVoters\n    ) private {\n        _require(\n            _minLiquidityAsset >= IBabController(controller).minLiquidityPerReserve(reserveAsset) &&\n                _minLiquidityAsset > 0,\n            Errors.MIN_LIQUIDITY\n        );\n        _require(_depositHardlock > 0, Errors.DEPOSIT_HARDLOCK);\n        _require(\n            _strategyCooldownPeriod <= MAX_COOLDOWN_PERIOD && _strategyCooldownPeriod >= MIN_COOLDOWN_PERIOD,\n            Errors.NOT_IN_RANGE\n        );\n        _require(_minVotesQuorum >= TEN_PERCENT.div(2) && _minVotesQuorum <= TEN_PERCENT.mul(5), Errors.VALUE_TOO_LOW);\n        _require(\n            _maxStrategyDuration >= _minStrategyDuration &&\n                _minStrategyDuration >= 1 days &&\n                _maxStrategyDuration <= 500 days,\n            Errors.DURATION_RANGE\n        );\n        _require(_minVoters >= 1 && _minVoters < 10, Errors.MIN_VOTERS_CHECK);\n\n        minContribution = _minContribution;\n        strategyCooldownPeriod = _strategyCooldownPeriod;\n        minVotesQuorum = _minVotesQuorum;\n        minVoters = _minVoters;\n        minStrategyDuration = _minStrategyDuration;\n        maxStrategyDuration = _maxStrategyDuration;\n        maxDepositLimit = _maxDepositLimit;\n        minLiquidityAsset = _minLiquidityAsset;\n        depositHardlock = _depositHardlock;\n    }\n\n    function _sharesToReserve(uint256 _shares, uint256 _pricePerShare) internal view returns (uint256) {\n        // in case of USDC that would with 6 decimals\n        return _shares.preciseMul(_pricePerShare).preciseMul(10**ERC20Upgradeable(reserveAsset).decimals());\n    }\n\n    function _reserveToShares(uint256 _reserve, uint256 _pricePerShare) internal view returns (uint256) {\n        return _reserve.preciseDiv(10**ERC20Upgradeable(reserveAsset).decimals()).preciseDiv(_pricePerShare);\n    }\n\n    function _withdrawInternal(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee\n    ) internal {\n        _onlyUnpaused();\n        _require(balanceOf(_to) > 0, Errors.ONLY_CONTRIBUTOR);\n        // Flashloan protection\n        _require(block.timestamp.sub(contributors[_to].lastDepositAt) >= depositHardlock, Errors.DEPOSIT_HARDLOCK);\n\n        uint256 prevBalance = balanceOf(_to);\n        // Strategists cannot withdraw locked stake while in active strategies\n        // Withdrawal amount has to be equal or less than msg.sender balance minus the locked balance\n        // any amountIn higher than user balance is treated as withdrawAll\n        _amountIn = _amountIn > prevBalance.sub(getLockedBalance(_to))\n            ? prevBalance.sub(getLockedBalance(_to))\n            : _amountIn;\n        _require(_amountIn <= prevBalance.sub(getLockedBalance(_to)), Errors.TOKENS_STAKED);\n\n        uint256 amountOut = _sharesToReserve(_amountIn, _pricePerShare);\n\n        // if withPenaltiy then unwind strategy\n        if (_withPenalty && !(liquidReserve() >= amountOut)) {\n            amountOut = amountOut.sub(amountOut.preciseMul(EARLY_WITHDRAWAL_PENALTY));\n            // When unwinding a strategy, a slippage on integrations will result in receiving less tokens\n            // than desired so we have have to account for this with a 5% slippage.\n            // TODO: if there is more than 5% slippage that will block\n            // withdrawal\n            _require(_unwindStrategy != address(0), Errors.ADDRESS_IS_ZERO);\n            IStrategy(_unwindStrategy).unwindStrategy(amountOut.add(amountOut.preciseMul(5e16)), _strategyNAV);\n        }\n\n        _require(amountOut >= _minAmountOut && _amountIn > 0, Errors.RECEIVE_MIN_AMOUNT);\n\n        _require(liquidReserve() >= amountOut, Errors.MIN_LIQUIDITY);\n\n        // We need previous supply before burning new tokens to get accurate rewards calculations\n        uint256 prevSupply = totalSupply();\n        _burn(_to, _amountIn);\n        _safeSendReserveAsset(_to, amountOut.sub(_fee));\n        if (_fee > 0) {\n            // If fee > 0 pay Accountant\n            IERC20(reserveAsset).safeTransfer(msg.sender, _fee);\n        }\n        _updateContributorWithdrawalInfo(_to, amountOut, prevBalance, prevSupply, _amountIn);\n\n        emit GardenWithdrawal(_to, _to, amountOut, _amountIn, block.timestamp);\n    }\n\n    function _getWithdrawSigner(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        bool _withPenalty,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 hash =\n            keccak256(\n                abi.encode(\n                    WITHDRAW_BY_SIG_TYPEHASH,\n                    address(this),\n                    _amountIn,\n                    _minAmountOut,\n                    _nonce,\n                    _maxFee,\n                    _withPenalty\n                )\n            )\n                .toEthSignedMessageHash();\n        address signer = ECDSA.recover(hash, v, r, s);\n        _require(signer != address(0), Errors.INVALID_SIGNER);\n        // to prevent replay attacks\n        _require(contributors[signer].nonce == _nonce, Errors.INVALID_NONCE);\n        return signer;\n    }\n\n    function _internalDeposit(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        address _from,\n        bool _mintNft,\n        uint256 _pricePerShare,\n        uint256 _minContribution\n    ) private {\n        _onlyUnpaused();\n        _require(_to != address(0), Errors.ADDRESS_IS_ZERO);\n        (bool canDeposit, , ) = _getUserPermission(_from);\n        _require(_isCreator(_to) || (canDeposit && _from == _to), Errors.USER_CANNOT_JOIN);\n\n        if (maxDepositLimit > 0) {\n            // This is wrong; but calculate principal would be gas expensive\n            _require(liquidReserve().add(_amountIn) <= maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);\n        }\n\n        _require(_amountIn >= _minContribution, Errors.MIN_CONTRIBUTION);\n\n        uint256 reserveAssetBalanceBefore = IERC20(reserveAsset).balanceOf(address(this));\n\n        // If reserve asset is WETH and user sent ETH then wrap it\n        if (reserveAsset == WETH && msg.value > 0) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            // Transfer ERC20 to the garden\n            IERC20(reserveAsset).safeTransferFrom(_from, address(this), _amountIn);\n        }\n\n        // Make sure we received the correct amount of reserve asset\n        _require(\n            IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetBalanceBefore) == _amountIn,\n            Errors.MSG_VALUE_DO_NOT_MATCH\n        );\n\n        uint256 previousBalance = balanceOf(_to);\n        uint256 previousSupply = totalSupply();\n\n        uint256 normalizedAmountIn = _amountIn.preciseDiv(uint256(10)**ERC20Upgradeable(reserveAsset).decimals());\n        uint256 sharesToMint = normalizedAmountIn.preciseDiv(_pricePerShare);\n\n        // make sure contributor gets desired amount of shares\n        _require(sharesToMint >= _minAmountOut, Errors.RECEIVE_MIN_AMOUNT);\n\n        // mint shares\n        _mint(_to, sharesToMint);\n        // We need to update at Rewards Distributor smartcontract for rewards accurate calculations\n        _updateContributorDepositInfo(_to, previousBalance, _amountIn, previousSupply, sharesToMint);\n\n        // Mint the garden NFT\n        if (_mintNft) {\n            IGardenNFT(IBabController(controller).gardenNFT()).grantGardenNFT(_to);\n        }\n\n        emit GardenDeposit(_to, _minAmountOut, _amountIn, block.timestamp);\n    }\n\n    /**\n     * Gets liquid reserve available for to Garden.\n     */\n    function liquidReserve() private view returns (uint256) {\n        uint256 reserve = IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetRewardsSetAside);\n        return reserve > keeperDebt ? reserve.sub(keeperDebt) : 0;\n    }\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 _amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, _amount);\n        _require(\n            from == address(0) ||\n                to == address(0) ||\n                (IBabController(controller).gardenTokensTransfersEnabled() && !privateGarden),\n            Errors.GARDEN_TRANSFERS_DISABLED\n        );\n    }\n\n    function _safeSendReserveAsset(address payable _to, uint256 _amount) private {\n        if (reserveAsset == WETH) {\n            // Check that the withdrawal is possible\n            // Unwrap WETH if ETH balance lower than amount\n            if (address(this).balance < _amount) {\n                IWETH(WETH).withdraw(_amount.sub(address(this).balance));\n            }\n            // Send ETH\n            Address.sendValue(_to, _amount);\n        } else {\n            // Send reserve asset\n            IERC20(reserveAsset).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorDepositInfo(\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _reserveAssetQuantity,\n        uint256 _previousSupply,\n        uint256 _newTokens\n    ) private {\n        Contributor storage contributor = contributors[_contributor];\n        // If new contributor, create one, increment count, and set the current TS\n        if (_previousBalance == 0 || contributor.initialDepositAt == 0) {\n            totalContributors = totalContributors.add(1);\n            contributor.initialDepositAt = block.timestamp;\n        }\n        // We make checkpoints around contributor deposits to give the right rewards afterwards\n        contributor.totalDeposits = contributor.totalDeposits.add(_reserveAssetQuantity);\n        contributor.lastDepositAt = block.timestamp;\n        contributor.nonce = contributor.nonce + 1;\n        // We need to update at Rewards Distributor smartcontract for rewards accurate calculations\n        rewardsDistributor.updateGardenPowerAndContributor(\n            address(this),\n            _contributor,\n            _previousBalance,\n            _previousSupply,\n            _newTokens,\n            true // deposit\n        );\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorWithdrawalInfo(\n        address _contributor,\n        uint256 _amountOut,\n        uint256 _previousBalance,\n        uint256 _previousSupply,\n        uint256 _tokensToBurn\n    ) private {\n        Contributor storage contributor = contributors[_contributor];\n        // If withdrawn everything\n        if (balanceOf(_contributor) == 0) {\n            contributor.lastDepositAt = 0;\n            contributor.initialDepositAt = 0;\n            contributor.withdrawnSince = 0;\n            contributor.totalDeposits = 0;\n            totalContributors = totalContributors.sub(1);\n        } else {\n            contributor.withdrawnSince = contributor.withdrawnSince.add(_amountOut);\n        }\n        // We need to update at Rewards Distributor SC for rewards accurate calculations\n        rewardsDistributor.updateGardenPowerAndContributor(\n            address(this),\n            _contributor,\n            _previousBalance,\n            _previousSupply,\n            _tokensToBurn,\n            false // withdraw\n        );\n        contributor.nonce = contributor.nonce + 1;\n    }\n\n    /**\n     * Check contributor permissions for deposit [0], vote [1] and create strategies [2]\n     */\n    function _getUserPermission(address _user)\n        internal\n        view\n        returns (\n            bool canDeposit,\n            bool canVote,\n            bool canCreateStrategy\n        )\n    {\n        IMardukGate mgate = IMardukGate(IBabController(controller).mardukGate());\n        bool betaAccess = true;\n        canDeposit = (betaAccess && !privateGarden) || mgate.canJoinAGarden(address(this), _user);\n        canVote = (betaAccess && publicStewards) || mgate.canVoteInAGarden(address(this), _user);\n        canCreateStrategy = (betaAccess && publicStrategists) || mgate.canAddStrategiesInAGarden(address(this), _user);\n    }\n\n    // Checks if an address is a creator\n    function _isCreator(address _creator) private view returns (bool) {\n        return\n            _creator != address(0) &&\n            (extraCreators[0] == _creator ||\n                extraCreators[1] == _creator ||\n                extraCreators[2] == _creator ||\n                extraCreators[3] == _creator ||\n                _creator == creator);\n    }\n\n    // Assign extra creators\n    function _assignExtraCreator(uint8 _index, address _newCreator) private {\n        _require(!_isCreator(_newCreator), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        _require(extraCreators[_index] == address(0), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        extraCreators[_index] = _newCreator;\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract GardenV14 is Garden {}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/interfaces/IStrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IStrategyFactory\n * @author Babylon Finance\n *\n * Interface for the strategy factory\n */\ninterface IStrategyFactory {\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IGardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\ninterface IGardenValuer {\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256);\n\n    function getLossesGarden(address _garden, uint256 _since) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IGardenNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Garden NFT.\n */\ninterface IGardenNFT {\n    function grantGardenNFT(address _user) external returns (uint256);\n\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external;\n\n    function gardenTokenURIs(address _garden) external view returns (string memory);\n\n    function gardenSeeds(address _garden) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IMardukGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.7.6;\n\nimport {IBabylonGate} from './IBabylonGate.sol';\n\n/**\n * @title IMardukGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IMardukGate is IBabylonGate {\n    /* ============ Functions ============ */\n\n    function canAccessBeta(address _user) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/integrations/borrow/CompoundBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {ICEther} from '../../interfaces/external/compound/ICEther.sol';\nimport {ICompoundPriceOracle} from '../../interfaces/external/compound/ICompoundPriceOracle.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\n\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title CompoundBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses compound borring logic.\n */\ncontract CompoundBorrowIntegration is BorrowIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == controller.owner(), 'Only governance can call this');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    address constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address constant CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     */\n    constructor(IBabController _controller, uint256 _maxCollateralFactor)\n        BorrowIntegration('compoundborrow', _controller, _maxCollateralFactor)\n    {\n        assetToCToken[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643; // DAI\n        assetToCToken[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984] = 0x35A18000230DA775CAc24873d00Ff85BccdeD550; // UNI\n        assetToCToken[address(0)] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // ETH\n        assetToCToken[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; // USDC\n        assetToCToken[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9; // USDT\n        assetToCToken[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; // WBTC\n        assetToCToken[0xc00e94Cb662C3520282E6f5717214004A7f26888] = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4; // COMP\n        assetToCToken[0x0D8775F648430679A709E98d2b0Cb6250d2887EF] = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E; // BAT\n        assetToCToken[0x514910771AF9Ca656af840dff83E8264EcF986CA] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7; // LINK\n        assetToCToken[0x1985365e9f78359a9B6AD760e32412f4a445E862] = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1; // REP\n        assetToCToken[0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359] = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC; // SAI\n        assetToCToken[0x0000000000085d4780B73119b644AE5ecd22b376] = 0x12392F67bdf24faE0AF363c24aC620a2f67DAd86; // TUSD\n        assetToCToken[0xE41d2489571d322189246DaFA5ebDe1F4699F498] = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407; // ZRX\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external onlyGovernance {\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            ,\n            // err\n            // cTokenBalance\n            uint256 borrowBalance,\n\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        return borrowBalance;\n    }\n\n    /**\n     * Get the amount of collateral depposited\n     * @param asset   The collateral to check\n     *\n     */\n    function getCollateralBalance(address _strategy, address asset) external view override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            // err\n            uint256 cTokenBalance, // borrow balance\n            ,\n            uint256 exchangeRateMantissa\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        uint256 decimals = IERC20(asset).universalDecimals();\n        // Source: balanceOfUnderlying from any ctoken\n        return cTokenBalance.mul(exchangeRateMantissa).div(10**decimals);\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        IComptroller comptroller = IComptroller(CompoundComptrollerAddress);\n        (\n            ,\n            /* error */\n            uint256 liquidity, /* shortfall */\n\n        ) = comptroller.getAccountLiquidity(_strategy);\n        return liquidity;\n    }\n\n    /* ============ Overriden Functions ============ */\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (CompoundComptrollerAddress, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('borrow(uint256)', _amount);\n\n        return (assetToCToken[_asset], 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (assetToCToken[_asset] == CEtherAddress) {\n            methodData = abi.encodeWithSignature('repayBorrow()');\n        } else {\n            methodData = abi.encodeWithSignature('repayBorrow(uint256)', _amount);\n        }\n        return (assetToCToken[_asset], assetToCToken[_asset] == CEtherAddress ? _amount : 0, methodData);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getCollateralAsset(\n        address _asset,\n        uint8 /* _borrowOp */\n    ) internal view override returns (address) {\n        // TODO: check this\n        return assetToCToken[_asset];\n    }\n\n    function _getSpender(address _asset) internal view override returns (address) {\n        return assetToCToken[_asset];\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICEther {\n    function mint() external payable;\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function repayBorrow() external payable;\n\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/ICompoundPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICompoundPriceOracle {\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IComptroller {\n    /**\n     * @notice Marker function used for light validation when updating the comptroller of a market\n     * @dev Implementations should simply return true.\n     * @return true\n     */\n    function isComptroller() external view returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    function compAccrued(address holder) external view returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getAssetsIn(address account) external view returns (address[] memory);\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/integrations/borrow/BorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title BorrowIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with borrowing protocols\n */\nabstract contract BorrowIntegration is BaseIntegration, ReentrancyGuard, IBorrowIntegration {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct DebtInfo {\n        IStrategy strategy; // Idea address\n        IGarden garden; // Garden address\n        address asset; // Asset involved in the operation\n        uint256 amount; // Amount involved in the operation\n        uint256 debt; // Amount of debt at the start of the operation\n        uint8 borrowOp; // Borrow operation type\n    }\n\n    uint8 constant BORROW_OPERATION_BORROW = 0;\n    uint8 constant BORROW_OPERATION_REPAY = 1;\n\n    /* ============ Events ============ */\n\n    event AmountBorrowed(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    event AmountRepaid(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    /* ============ State Variables ============ */\n    uint256 public override maxCollateralFactor;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     */\n    constructor(\n        string memory _name,\n        IBabController _controller,\n        uint256 _maxCollateralFactor\n    ) BaseIntegration(_name, _controller) {\n        maxCollateralFactor = _maxCollateralFactor;\n    }\n\n    /* ============ External Functions ============ */\n    // Governance function\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor)\n        external\n        override\n        nonReentrant\n        onlySystemContract\n    {\n        maxCollateralFactor = _newMaxCollateralFactor;\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * hparam asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(\n        address, /* strategy */\n        address /* asset */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address, /* strategy */\n        address /* asset */\n    ) external view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(\n        address /* strategy */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Borrows an asset\n     * @param asset The asset to be borrowed\n     * @param amount The amount to borrow\n     */\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_BORROW);\n\n        _validatePreBorrow(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_BORROW);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getBorrowCalldata(_strategy, asset, amount);\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostBorrow(debtInfo);\n        emit AmountBorrowed(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /**\n     * Repays a borrowed asset debt\n     * @param asset The asset to be repaid\n     * @param amount The amount to repay\n     */\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_REPAY);\n\n        _validatePreRepay(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_REPAY);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n        if (asset != address(0)) {\n            // Approves the repayment contract to take the tokens\n            debtInfo.strategy.invokeApprove(_getSpender(asset), asset, amount);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getRepayCalldata(_strategy, asset, amount);\n\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostRepay(debtInfo);\n\n        emit AmountRepaid(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return DebtInfo struct\n     *\n     * @param _strategy            The strategy executing this integration\n     * @param _asset               The asset involved in the op\n     * @param _amount              The amount involved in the op\n     * @param _borrowOp            Type of borrow operation\n     * return DebtInfo             Struct containing data for the debt position\n     */\n    function _createDebtInfo(\n        address _strategy,\n        address _asset,\n        uint256 _amount,\n        uint8 _borrowOp\n    ) internal view returns (DebtInfo memory) {\n        DebtInfo memory debtInfo;\n        debtInfo.strategy = IStrategy(_strategy);\n        debtInfo.garden = IGarden(debtInfo.strategy.garden());\n        debtInfo.asset = _asset;\n        debtInfo.debt = getBorrowBalance(_strategy, debtInfo.asset);\n        debtInfo.amount = _amount;\n        debtInfo.borrowOp = _borrowOp;\n\n        return debtInfo;\n    }\n\n    /**\n     * Validate pre borrow.\n     *\n     * hparam _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreBorrow(DebtInfo memory _debtInfo) internal view {\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate post borrow.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostBorrow(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'Did not receive the borrowed asset');\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate pre repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreRepay(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'We do not have enough to repay debt');\n    }\n\n    /**\n     * Validate post repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostRepay(DebtInfo memory _debtInfo) internal view {\n        // debt is paid\n        require(getBorrowBalance(address(_debtInfo.strategy), _debtInfo.asset) < _debtInfo.debt, 'Debt was not repaid');\n    }\n\n    /* ============ Virtual Functions ============ */\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getCollateralAsset(\n        address, /* _asset */\n        uint8 /* _borrowOp */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n\n    function _getSpender(\n        address /* asset */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n}\n"
    },
    "contracts/strategies/StrategyNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\n\n/**\n * @title StrategyNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Strategy\n */\ncontract StrategyNFT is ERC721, IStrategyNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event StrategyNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy {\n        IStrategy strategy = IStrategy(msg.sender);\n        require(\n            IGarden(strategy.garden()).strategyMapping(msg.sender) && controller.isSystemContract(msg.sender),\n            'Only the strategy can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    mapping(address => StratDetail) public stratDetails;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(bytes(_name).length < 50, 'Strategy Name is too long');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user                           Address of the user\n     * @param _strategyTokenURI               Strategy token URI\n     */\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI)\n        external\n        override\n        onlyStrategy\n        returns (uint256)\n    {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, _strategyTokenURI);\n        stratDetails[msg.sender].tokenId = newItemId;\n        emit StrategyNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the name an symbol for a new created strategy\n     *\n     * @param _strategy               Address of the strategy\n     * @param _name                   Strategy Name\n     * @param _symbol                 Strategy Symbol\n     */\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        StratDetail storage stratDetail = stratDetails[_strategy];\n        stratDetail.name = _name;\n        stratDetail.symbol = _symbol;\n    }\n\n    function getStrategyTokenURI(address _strategy) external view override returns (string memory) {\n        return tokenURI(stratDetails[_strategy].tokenId);\n    }\n\n    function getStrategyName(address _strategy) external view override returns (string memory) {\n        return stratDetails[_strategy].name;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/strategies/StrategyFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title StrategyFactory\n * @author Babylon Finance\n *\n * Factory to create investment strategy contracts\n */\ncontract StrategyFactory is IStrategyFactory {\n    modifier onlyGarden {\n        require(\n            controller.isGarden(msg.sender) && IGarden(msg.sender).controller() == address(controller),\n            'Only the garden can create strategies'\n        );\n        _;\n    }\n\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a new investment strategy using minimal proxies\n     *\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _stratParams                   Strat Params\n     */\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external override onlyGarden returns (address) {\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IStrategy.initialize.selector,\n                        _strategist,\n                        _garden,\n                        controller,\n                        _stratParams[0],\n                        _stratParams[1],\n                        _stratParams[2],\n                        _stratParams[3],\n                        _stratParams[4],\n                        _stratParams[5],\n                        _stratParams[6]\n                    )\n                )\n            );\n        IStrategyNFT(controller.strategyNFT()).saveStrategyNameAndSymbol(proxy, _name, _symbol);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../access/Ownable.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) public {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "contracts/proxy/SafeBeaconProxy.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/BeaconProxy.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to create garden contracts\n */\ncontract SafeBeaconProxy is BeaconProxy {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable BeaconProxy(beacon, data) {}\n\n    /**\n     * @dev Accepts all ETH transfers but does not proxy calls to the implementation.\n     *\n     * Due to EIP-2929 the proxy overhead gas cost is higher than 2300 gas which is the stipend used by address.transfer.\n     * This results to a `out of gas` error for proxy calls initiated by code `address.transfer`.\n     * A notable example is WETH https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\n     * A downside of this approach is that a proxy implementation contract can not handle receiving pure ETH.\n     * In a scope of Babylon project this is acceptable but should be kept in mind at all times.\n     *\n     */\n    receive() external payable override {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\nimport \"./IBeacon.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) public payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).implementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/MardukGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IMardukGate} from './interfaces/IMardukGate.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title MardukGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists without NFT and checks Ishtar Gate when needed\n */\ncontract MardukGate is IMardukGate, Ownable {\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission);\n    event GardenCreationPower(address indexed _member, bool _creation);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n    IIshtarGate private ishtarGate;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => mapping(address => bool)) public isOverriden;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => bool) public betaAccess;\n    mapping(address => uint256) public gardenAccessCount;\n\n    mapping(address => address[]) public invitesPerGarden;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == address(controller), 'Controller must match');\n        require(_isCreator(IGarden(_garden), msg.sender), 'Only creator can give access to garden');\n        require(IBabController(controller).isGarden(address(_garden)));\n        require(gardenAccessCount[_garden] <= maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _ishtarGate         Address of the ishtar gate\n     */\n    constructor(IBabController _controller, IIshtarGate _ishtarGate) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(address(_ishtarGate) != address(0), 'Ishtar Gate must exist');\n        controller = _controller;\n        ishtarGate = _ishtarGate;\n        maxNumberOfInvites = ishtarGate.maxNumberOfInvites() > 0 ? ishtarGate.maxNumberOfInvites() : 100;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Gives user access to a specific garden via Marduk Gate\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override returns (uint256) {\n        require(\n            _isCreator(IGarden(_garden), msg.sender) || msg.sender == address(_garden),\n            'Only creator or garden can change params'\n        );\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Uses Marduk Gate to grant a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Grants an user/remove garden creation capabilities via Marduk Gate.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Grants a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can access the beta\n     *\n     * @param _user                     Address of the user\n     * @return bool               Whether or not the user can access the beta\n     */\n    function canAccessBeta(address _user) external view override returns (bool) {\n        return IERC721(address(ishtarGate)).balanceOf(_user) > 0 || betaAccess[_user];\n    }\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return ishtarGate.canCreate(_user) || canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= JUST_LP;\n        }\n        return ishtarGate.canJoinAGarden(_garden, _user);\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= STEWARD;\n        }\n        return ishtarGate.canVoteInAGarden(_garden, _user);\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= STRATEGIST;\n        }\n        return ishtarGate.canAddStrategiesInAGarden(_garden, _user);\n    }\n\n    /**\n     * Returns all the invites sent from a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @return address[]                  All the invites sent\n     */\n    function getInvitesPerGarden(address _garden) external view returns (address[] memory) {\n        return invitesPerGarden[_garden];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Grants access to an user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        require(_permission <= 3, 'Permission out of bounds');\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            require(gardenAccessCount[_garden] < maxNumberOfInvites, 'Max Number of invites reached');\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n            invitesPerGarden[_garden].push(_user);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        isOverriden[_garden][_user] = true;\n        betaAccess[_user] = true;\n        emit GardenAccess(_user, _garden, _permission);\n        return 0;\n    }\n\n    /**\n     * Grants access to an user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate);\n        return 0;\n    }\n\n    // Checks if an address is a creator\n    function _isCreator(IGarden _garden, address _member) private view returns (bool) {\n        return\n            _member != address(0) &&\n            (_garden.extraCreators(0) == _member ||\n                _garden.extraCreators(1) == _member ||\n                _garden.extraCreators(2) == _member ||\n                _garden.extraCreators(3) == _member ||\n                _member == _garden.creator());\n    }\n}\n"
    },
    "contracts/IshtarGate.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title IshtarGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists for Babylon Finance using an NFT\n */\ncontract IshtarGate is ERC721, IIshtarGate, Ownable {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event IshtarGateAwarded(address indexed _member, uint256 indexed _newItemId);\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission, uint256 _tokenId);\n    event GardenCreationPower(address indexed _member, bool _creation, uint256 _tokenId);\n    event GateURIUpdated(string indexed _newURI, string indexed _oldURI);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    // Address of the Ishtar Gate JSON (Shared JSON)\n    string public override tokenURI;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => uint256) public gardenAccessCount;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == address(controller), 'Controller must match');\n        require(msg.sender == garden.creator(), 'Only creator can give access to garden');\n        require(IBabController(controller).isGarden(address(_garden)));\n        require(gardenAccessCount[_garden] <= maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _tokenURI           URL of the Ishtar Gate JSON metadata\n     */\n    constructor(IBabController _controller, string memory _tokenURI) ERC721('IshtarGate', 'ISHT') {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n        tokenURI = _tokenURI;\n        maxNumberOfInvites = 10;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Updates the token URI of the gate NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateGardenURI(string memory _tokenURI) external override onlyOwner {\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit GateURIUpdated(tokenURI, oldURI);\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override onlyGardenCreator(_garden) returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= JUST_LP || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STEWARD || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STRATEGIST || IGarden(_garden).creator() == _user);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new gate to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetGateNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit IshtarGateAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        require(_permission <= 3, 'Permission out of bounds');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            require(gardenAccessCount[_garden] < maxNumberOfInvites, 'Max Number of invites reached');\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        emit GardenAccess(_user, _garden, _permission, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate, newItemId);\n        return newItemId;\n    }\n}\n"
    },
    "contracts/integrations/lend/CompoundLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\n\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title CompoundLendIntegration\n * @author Babylon Finance Protocol\n *\n * Compound lend integration.\n */\ncontract CompoundLendIntegration is LendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the protocol\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == controller.owner(), 'Only governance can call this');\n        _;\n    }\n\n    /* ============ Constant ============ */\n\n    address internal constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address internal constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address private constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     */\n    constructor(IBabController _controller) LendIntegration('compoundlend', _controller) {\n        assetToCToken[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643; // DAI\n        assetToCToken[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984] = 0x35A18000230DA775CAc24873d00Ff85BccdeD550; // UNI\n        assetToCToken[address(0)] = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5; // ETH\n        assetToCToken[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0x39AA39c021dfbaE8faC545936693aC917d5E7563; // USDC\n        assetToCToken[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9; // USDT\n        assetToCToken[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; // WBTC\n        assetToCToken[0xc00e94Cb662C3520282E6f5717214004A7f26888] = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4; // COMP\n        assetToCToken[0x0D8775F648430679A709E98d2b0Cb6250d2887EF] = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E; // BAT\n        assetToCToken[0x514910771AF9Ca656af840dff83E8264EcF986CA] = 0xFAce851a4921ce59e912d19329929CE6da6EB0c7; // LINK\n        assetToCToken[0x1985365e9f78359a9B6AD760e32412f4a445E862] = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1; // REP\n        assetToCToken[0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359] = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC; // SAI\n        assetToCToken[0x0000000000085d4780B73119b644AE5ecd22b376] = 0x12392F67bdf24faE0AF363c24aC620a2f67DAd86; // TUSD\n        assetToCToken[0xE41d2489571d322189246DaFA5ebDe1F4699F498] = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407; // ZRX\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external onlyGovernance {\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        ICToken ctoken = ICToken(_getInvestmentToken(_assetToken));\n        return ctoken.balanceOf(_address).mul(ctoken.exchangeRateStored()).div(10**18);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getRewardToken() internal pure override returns (address) {\n        return COMP;\n    }\n\n    function _getRewardsAccrued(address _strategy) internal view override returns (uint256) {\n        return IComptroller(CompoundComptrollerAddress).compAccrued(_strategy);\n    }\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        return assetToCToken[_assetToken] != address(0);\n    }\n\n    function _getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 oneCTokenInUderlying = _getExchangeRatePerToken(_assetToken);\n        return oneCTokenInUderlying.mul(_numTokensToSupply).div(10**18);\n    }\n\n    // TODO: Test this\n    function _getExchangeRatePerToken(address _assetToken) internal view override returns (uint256) {\n        address cToken = assetToCToken[_assetToken];\n        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateStored();\n        uint256 assetDecimals = IERC20(_assetToken).universalDecimals();\n        // cTokens always have 8 decimals.\n        if (assetDecimals < 8) {\n            uint256 mantissa = 8 - assetDecimals;\n            return exchangeRateCurrent.mul(10**mantissa);\n        } else {\n            uint256 mantissa = assetDecimals - 8;\n            return exchangeRateCurrent.div(10**mantissa);\n        }\n    }\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('redeemUnderlying(uint256)', _numTokensToSupply);\n\n        return (assetToCToken[_assetToken], 0, methodData);\n    }\n\n    function _claimRewardsCallData(address _strategy)\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('claimComp(address)', _strategy);\n\n        return (CompoundComptrollerAddress, 0, methodData);\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (assetToCToken[_assetToken] == cETH) {\n            methodData = abi.encodeWithSignature('mint()');\n        } else {\n            methodData = abi.encodeWithSignature('mint(uint256)', _numTokensToSupply);\n        }\n        // If it is ETH, send the value\n        return (assetToCToken[_assetToken], assetToCToken[_assetToken] == cETH ? _numTokensToSupply : 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (CompoundComptrollerAddress, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getSpender(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n}\n"
    },
    "contracts/integrations/lend/LendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title LendIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with lending protocols\n */\nabstract contract LendIntegration is BaseIntegration, ReentrancyGuard, ILendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address assetToken;\n        address investment; // Investment address\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 underlyingTokensInGarden; // Underlying tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event TokensSupplied(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToSupply\n    );\n\n    event TokensRedeemed(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToRedeem,\n        uint256 protocolFee\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n    function getInvestmentToken(address _assetToken) external view override returns (address) {\n        return _getInvestmentToken(_assetToken);\n    }\n\n    /**\n     * Returns the reward token\n     *\n     * @return address       Address of the reward token\n     */\n    function getRewardToken() external view override returns (address) {\n        return _getRewardToken();\n    }\n\n    /**\n     * Returns the number of reward tokens accrued\n     *\n     * @param _strategy      Address of the strategy\n     * @return address       Address of the reward token\n     */\n    function getRewardsAccrued(address _strategy) external view override returns (uint256) {\n        return _getRewardsAccrued(_strategy);\n    }\n\n    /**\n     * Checks whether an investment address is valid\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return bool                              True if the address is a investment\n     */\n    function isInvestment(address _investmentAddress) external view returns (bool) {\n        return _isInvestment(_investmentAddress);\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken)\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToSupply,\n                _minAmountExpected\n            );\n\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToSupply, 0);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        // not needed for eth\n        if (_assetToken != address(0)) {\n            investmentInfo.strategy.invokeApprove(_getSpender(_assetToken), _assetToken, _numTokensToSupply);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getSupplyCalldata(_strategy, _assetToken, _numTokensToSupply);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToSupply\n        );\n    }\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToRedeem,\n                _minAmountExpected\n            );\n\n        _validatePreExitInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToRedeem, 1);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getRedeemCalldata(_strategy, _assetToken, _numTokensToRedeem);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n\n        // Claim rewards\n        (address targetAddressR, uint256 callValueR, bytes memory methodDataR) = _claimRewardsCallData(_strategy);\n        if (targetAddressR != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressR, callValueR, methodDataR);\n        }\n\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToRedeem\n        );\n    }\n\n    function getExchangeRatePerToken(address _assetToken) external view override returns (uint256) {\n        return _getExchangeRatePerToken(_assetToken);\n    }\n\n    /**\n     * Gets the amount of cTokens expected to get after depositing ERC20 asset.\n     *\n     * @param _numTokensToSupply                 Amount of ERC20 tokens to supply\n     * @return uint256                           Amount of supply tokens to receive\n     */\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_assetToken, _numTokensToSupply);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            getInvestmentTokenAmount(address(_investmentInfo.strategy), _investmentInfo.assetToken) >\n                _investmentInfo.investmentTokensInGarden,\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        uint256 balance =\n            _investmentInfo.assetToken == address(0)\n                ? address(_investmentInfo.strategy).balance\n                : IERC20(_investmentInfo.assetToken).balanceOf(address(_investmentInfo.strategy));\n        require(balance > _investmentInfo.underlyingTokensInGarden, 'The garden did not return the investment tokens');\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    function _isInvestment(\n        address //_investmentAddress\n    ) internal view virtual returns (bool);\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _assetToken,\n        address _investmentToken,\n        uint256 _investmentTokensInTransaction,\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.assetToken = _assetToken;\n        investmentInfo.investment = _investmentToken;\n        investmentInfo.investmentTokensInGarden = getInvestmentTokenAmount(_strategy, _assetToken);\n        investmentInfo.underlyingTokensInGarden = _assetToken == address(0)\n            ? address(_strategy).balance\n            : IERC20(_assetToken).balanceOf(address(_strategy));\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    function _getExpectedShares(address, uint256) internal view virtual returns (uint256);\n\n    function _getExchangeRatePerToken(address) internal view virtual returns (uint256);\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * hparam  _strategy                Address of the strat\n     * hparam  _assetToken              Address of the token\n     * hparam  _numTokensToSupply       Number of tokens\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return claim rewards action call data\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _claimRewardsCallData(\n        address /*_strategy */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getRewardToken() internal view virtual returns (address);\n\n    function _getRewardsAccrued(address _strategy) internal view virtual returns (uint256);\n\n    function _getInvestmentToken(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/trade/TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\n\n/**\n * @title TradeIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with trading protocols\n */\nabstract contract TradeIntegration is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct TradeInfo {\n        IGarden garden; // Garden\n        IStrategy strategy; // Strategy\n        string exchangeName; // Which exchange to use\n        address sendToken; // Address of token being sold\n        address receiveToken; // Address of token being bought\n        uint256 gardenTotalSupply; // Total supply of Garden in Precise Units (10^18)\n        uint256 totalSendQuantity; // Total quantity of sold tokens\n        uint256 totalMinReceiveQuantity; // Total minimum quantity of token to receive back\n        uint256 preTradeSendTokenBalance; // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance; // Total initial balance of token being bought\n    }\n\n    /* ============ Events ============ */\n\n    event ComponentExchanged(\n        IGarden indexed _garden,\n        IStrategy indexed _strategy,\n        address indexed _sendToken,\n        address _receiveToken,\n        string _exchangeName,\n        uint256 _totalSendAmount,\n        uint256 _totalReceiveAmount\n    );\n\n    /* ============ Constants ============ */\n\n    uint24 internal constant FEE_LOW = 500;\n    uint24 internal constant FEE_MEDIUM = 3000;\n    uint24 internal constant FEE_HIGH = 10000;\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external override nonReentrant onlySystemContract {\n        TradeInfo memory tradeInfo =\n            _createTradeInfo(_strategy, name, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity);\n        _validatePreTradeData(tradeInfo, _sendQuantity);\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_sendToken, _receiveToken, _sendQuantity);\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            if (_getPreApprovalSpender(targetAddressP) != address(0)) {\n                tradeInfo.strategy.invokeApprove(\n                    _getPreApprovalSpender(targetAddressP),\n                    tradeInfo.sendToken,\n                    tradeInfo.totalSendQuantity\n                );\n            }\n            tradeInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n        // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n        (address targetExchange, uint256 callValue, bytes memory methodData) =\n            _getTradeCallData(_strategy, tradeInfo.sendToken, tradeInfo.totalSendQuantity, tradeInfo.receiveToken);\n        if (targetExchange != address(0)) {\n            // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n            tradeInfo.strategy.invokeApprove(\n                _getSpender(targetExchange),\n                tradeInfo.sendToken,\n                tradeInfo.totalSendQuantity\n            );\n            tradeInfo.strategy.invokeFromIntegration(targetExchange, callValue, methodData);\n        }\n        // Post actions\n        uint256 receiveTokenAmount = _getTokenOrETHBalance(address(_strategy), _getPostActionToken(_receiveToken));\n        (targetAddressP, callValueP, methodDataP) = _getPostActionCallData(\n            _sendToken,\n            _receiveToken,\n            receiveTokenAmount\n        );\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            if (_getPostApprovalSpender(targetAddressP) != address(0)) {\n                tradeInfo.strategy.invokeApprove(\n                    _getPostApprovalSpender(targetAddressP),\n                    _getPostActionToken(_receiveToken),\n                    receiveTokenAmount\n                );\n            }\n            // Invoke protocol specific call\n            tradeInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        uint256 exchangedQuantity = _validatePostTrade(tradeInfo);\n        uint256 newSendTokens = tradeInfo.preTradeSendTokenBalance.sub(tradeInfo.totalSendQuantity);\n        emit ComponentExchanged(\n            tradeInfo.garden,\n            tradeInfo.strategy,\n            _sendToken,\n            _receiveToken,\n            tradeInfo.exchangeName,\n            newSendTokens,\n            exchangedQuantity\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return TradeInfo struct\n     *\n     * @param _strategy             Address of the strategy\n     * @param _exchangeName         Human readable name of the exchange in the integrations registry\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     * @param _minReceiveQuantity   Min units of token in SetToken to be received from the exchange\n     *\n     * return TradeInfo             Struct containing data for trade\n     */\n    function _createTradeInfo(\n        address _strategy,\n        string memory _exchangeName,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) internal view returns (TradeInfo memory) {\n        TradeInfo memory tradeInfo;\n\n        tradeInfo.strategy = IStrategy(_strategy);\n        tradeInfo.garden = tradeInfo.strategy.garden();\n\n        tradeInfo.exchangeName = _exchangeName;\n\n        tradeInfo.sendToken = _sendToken;\n        tradeInfo.receiveToken = _receiveToken;\n\n        tradeInfo.gardenTotalSupply = ERC20(address(tradeInfo.strategy.garden())).totalSupply();\n\n        tradeInfo.totalSendQuantity = _sendQuantity;\n\n        tradeInfo.totalMinReceiveQuantity = _minReceiveQuantity;\n        tradeInfo.preTradeSendTokenBalance = ERC20(_sendToken).balanceOf(_strategy);\n        tradeInfo.preTradeReceiveTokenBalance = ERC20(_receiveToken).balanceOf(_strategy);\n        return tradeInfo;\n    }\n\n    /**\n     * Validate pre trade data. Check exchange is valid, token quantity is valid.\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * @param _sendQuantity         Amount of tokens sent\n     */\n    function _validatePreTradeData(TradeInfo memory _tradeInfo, uint256 _sendQuantity) internal view {\n        require(_tradeInfo.totalSendQuantity > 0, 'Token to sell must be nonzero');\n        require(\n            ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy)) >= _sendQuantity,\n            'Strategy needs to have enough liquid tokens'\n        );\n        require(_checkLiquidity(_tradeInfo, _sendQuantity), 'Not enough liquidity');\n    }\n\n    /**\n     * Validate post trade data.\n     *\n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @return uint256                  Total quantity of receive token that was exchanged\n     */\n    function _validatePostTrade(TradeInfo memory _tradeInfo) internal view returns (uint256) {\n        uint256 exchangedQuantity =\n            ERC20(_tradeInfo.receiveToken).balanceOf(address(_tradeInfo.strategy)).sub(\n                _tradeInfo.preTradeReceiveTokenBalance\n            );\n        uint256 sendTokenBalance = ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy));\n        uint256 realUsed = _tradeInfo.preTradeSendTokenBalance.sub(sendTokenBalance);\n        // Uses at least 90% of the send token (disallow partial liquidity trades)\n        require(realUsed >= _tradeInfo.totalSendQuantity.preciseMul(9e17), 'Partial trade not allowed');\n        require(exchangedQuantity >= _tradeInfo.totalMinReceiveQuantity, 'Slippage greater than allowed');\n        return exchangedQuantity;\n    }\n\n    /**\n     * Return exchange calldata which is already generated from the exchange API\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the exchange\n     * hparam _sendQuantity         Units of reserve asset token sent to the exchange\n     * hparam _receiveToken         Address of the token that will be received from the exchange\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken */\n        uint256, /*_sendQuantity */\n        address /* _receiveToken */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Checks liquidity of the trade. Reverts if not enough\n     *\n     * hparam _tradeInfo               Trade Info\n     * hparam _sendQuantity            Amount of send tokens to exchange\n     *\n     */\n    function _checkLiquidity(\n        TradeInfo memory, /* _tradeInfo */\n        uint256 /*_sendQuantity */\n    ) internal view virtual returns (bool);\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * hparam  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _sendToken */\n        address, /* _receiveToken */\n        uint256 /* _sendQuantity */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * hparam  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address, /* _sendToken */\n        address, /* _receiveToken */\n        uint256 /* _sendQuantity */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @param _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal view virtual returns (address);\n\n    /**\n     * Returns the address to approve the pre action. This is the TokenTaker address\n     *\n     * hparam _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getPreApprovalSpender(\n        address /* _swapTarget */\n    ) internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * Returns the address to approve the post action. This is the TokenTaker address\n     *\n     * hparam _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getPostApprovalSpender(\n        address /* _swapTarget */\n    ) internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function _getPostActionToken(address _receiveToken) internal view virtual returns (address) {\n        return _receiveToken;\n    }\n}\n"
    },
    "contracts/integrations/trade/UniswapV3TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport 'hardhat/console.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {ISwapRouter} from '../../interfaces/external/uniswap-v3/ISwapRouter.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\n/**\n * @title UniswapV3TradeIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapV3 trade integration\n */\ncontract UniswapV3TradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    // Address of Uniswap V3 SwapRouter contract\n    address private constant swapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('univ3_3', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through UniswapV3.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        bytes memory path;\n        if (_sendToken == WETH || _receiveToken == WETH) {\n            (, uint24 fee) = _getUniswapPoolWithHighestLiquidity(_sendToken, _receiveToken);\n            path = abi.encodePacked(_sendToken, fee, _receiveToken);\n        } else {\n            (, uint24 fee0) = _getUniswapPoolWithHighestLiquidity(_sendToken, WETH);\n            (, uint24 fee1) = _getUniswapPoolWithHighestLiquidity(_receiveToken, WETH);\n            path = abi.encodePacked(_sendToken, fee0, WETH, fee1, _receiveToken);\n        }\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(\n                path,\n                _strategy,\n                block.timestamp,\n                _sendQuantity,\n                1 // we check for amountOutMinimum in the post trade check\n            );\n\n        bytes memory callData = abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n        return (swapRouter, 0, callData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _swapTarget */\n    ) internal pure override returns (address) {\n        return address(swapRouter);\n    }\n\n    /**\n     * Checks liquidity of the trade\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * hparam _sendQuantity         Units of token sent\n     */\n    function _checkLiquidity(\n        TradeInfo memory _tradeInfo,\n        uint256 /* _sendQuantity */\n    ) internal view override returns (bool) {\n        address reserveAsset = _tradeInfo.garden.reserveAsset();\n        uint256 liquidityInReserve = _getUniswapHighestLiquidity(_tradeInfo, reserveAsset);\n        uint256 minLiquidityReserveAsset = _tradeInfo.garden.minLiquidityAsset();\n        return liquidityInReserve >= minLiquidityReserveAsset;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getUniswapHighestLiquidity(TradeInfo memory _tradeInfo, address _reserveAsset)\n        private\n        view\n        returns (uint256)\n    {\n        address sendToken = _tradeInfo.sendToken;\n        address receiveToken = _tradeInfo.receiveToken;\n        // Exit if going to same asset\n        if (sendToken == receiveToken) {\n            return _tradeInfo.garden.minLiquidityAsset();\n        }\n        (IUniswapV3Pool pool, ) = _getUniswapPoolWithHighestLiquidity(sendToken, receiveToken);\n        if (address(pool) == address(0)) {\n            return 0;\n        }\n        uint256 poolLiquidity = uint256(pool.liquidity());\n        uint256 liquidityInReserve;\n        address denominator;\n\n        if (pool.token0() == DAI || pool.token0() == WETH || pool.token0() == USDC || pool.token0() == WBTC) {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token1()).balanceOf(address(pool)));\n            denominator = pool.token0();\n        } else {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token0()).balanceOf(address(pool)));\n            denominator = pool.token1();\n        }\n        // Normalize to reserve asset\n        if (denominator != _reserveAsset) {\n            IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n            uint256 price = oracle.getPrice(denominator, _reserveAsset);\n            // price is always in 18 decimals\n            // preciseMul returns in the same decimals than liquidityInReserve, so we have to normalize into reserve Asset decimals\n            // normalization into reserveAsset decimals\n            liquidityInReserve = SafeDecimalMath.normalizeAmountTokens(\n                denominator,\n                _reserveAsset,\n                liquidityInReserve.preciseMul(price)\n            );\n        }\n        return liquidityInReserve;\n    }\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool, uint24 fee)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow > liquidityMedium && liquidityLow >= liquidityHigh) {\n            return (poolLow, FEE_LOW);\n        }\n        if (liquidityMedium > liquidityLow && liquidityMedium >= liquidityHigh) {\n            return (poolMedium, FEE_MEDIUM);\n        }\n        return (poolHigh, FEE_HIGH);\n    }\n\n    function _getReserveAsWeth(address _token, address _reserveAsset) internal pure returns (address) {\n        return _reserveAsset == _token ? WETH : _token;\n    }\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/BabylonViewer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from './lib/SafeDecimalMath.sol';\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGardenValuer} from './interfaces/IGardenValuer.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IMardukGate} from './interfaces/IMardukGate.sol';\nimport {IGardenNFT} from './interfaces/IGardenNFT.sol';\nimport {IStrategyNFT} from './interfaces/IStrategyNFT.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {Math} from './lib/Math.sol';\n\n/**\n * @title BabylonViewer\n * @author Babylon Finance\n *\n * Class that holds common view functions to retrieve garden information effectively\n */\ncontract BabylonViewer {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using Math for int256;\n    using SafeDecimalMath for uint256;\n\n    IBabController public controller;\n    uint24 internal constant FEE_LOW = 500;\n    uint24 internal constant FEE_MEDIUM = 3000;\n    uint24 internal constant FEE_HIGH = 10000;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets garden principal\n     *\n     * @param _garden            Address of the garden to fetch\n     * @return                   Garden principal\n     */\n    function getGardenPrincipal(address _garden) public view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        IERC20 reserveAsset = IERC20(garden.reserveAsset());\n        uint256 principal = reserveAsset.balanceOf(address(garden)).sub(garden.reserveAssetRewardsSetAside());\n        uint256 protocolMgmtFee = IBabController(controller).protocolManagementFee();\n        address[] memory strategies = garden.getStrategies();\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            principal = principal.add(strategy.capitalAllocated()).add(\n                protocolMgmtFee.preciseMul(strategy.capitalAllocated())\n            );\n        }\n        address[] memory finalizedStrategies = garden.getFinalizedStrategies();\n        for (uint256 i = 0; i < finalizedStrategies.length; i++) {\n            IStrategy strategy = IStrategy(finalizedStrategies[i]);\n            principal = principal.add(protocolMgmtFee.preciseMul(strategy.capitalAllocated()));\n        }\n        principal = principal.add(garden.totalKeeperFees());\n        int256 absoluteReturns = garden.absoluteReturns();\n        if (absoluteReturns > 0) {\n            principal = principal.sub(uint256(absoluteReturns));\n        } else {\n            principal = principal.add(uint256(-absoluteReturns));\n        }\n        return principal;\n    }\n\n    /**\n     * Gets garden details\n     *\n     * @param _garden            Address of the garden to fetch\n     * @return                   Garden complete details\n     */\n    function getGardenDetails(address _garden)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            address[5] memory,\n            address,\n            bool[4] memory,\n            address[] memory,\n            address[] memory,\n            uint256[10] memory,\n            uint256[10] memory,\n            uint256[3] memory\n        )\n    {\n        IGarden garden = IGarden(_garden);\n        uint256 principal = getGardenPrincipal(_garden);\n        uint256[] memory totalSupplyValuationAndSeed = new uint256[](4);\n        totalSupplyValuationAndSeed[0] = IERC20(_garden).totalSupply();\n        totalSupplyValuationAndSeed[1] = totalSupplyValuationAndSeed[0] > 0\n            ? IGardenValuer(controller.gardenValuer()).calculateGardenValuation(_garden, garden.reserveAsset())\n            : 0;\n        totalSupplyValuationAndSeed[2] = _getGardenSeed(_garden);\n        totalSupplyValuationAndSeed[3] = ERC20(garden.reserveAsset()).balanceOf(address(garden));\n        if (totalSupplyValuationAndSeed[3] > garden.keeperDebt()) {\n            totalSupplyValuationAndSeed[3] = totalSupplyValuationAndSeed[3].sub(garden.keeperDebt());\n        }\n        if (totalSupplyValuationAndSeed[3] > garden.reserveAssetRewardsSetAside()) {\n            totalSupplyValuationAndSeed[3] = totalSupplyValuationAndSeed[3].sub(garden.reserveAssetRewardsSetAside());\n        } else {\n            totalSupplyValuationAndSeed[3] = 0;\n        }\n\n        uint256[3] memory profits = _getGardenProfitSharing(_garden);\n        return (\n            ERC20(_garden).name(),\n            ERC20(_garden).symbol(),\n            [\n                garden.creator(),\n                garden.extraCreators(0),\n                garden.extraCreators(1),\n                garden.extraCreators(2),\n                garden.extraCreators(3)\n            ],\n            garden.reserveAsset(),\n            [true, garden.privateGarden(), garden.publicStrategists(), garden.publicStewards()],\n            garden.getStrategies(),\n            garden.getFinalizedStrategies(),\n            [\n                garden.depositHardlock(),\n                garden.minVotesQuorum(),\n                garden.maxDepositLimit(),\n                garden.minVoters(),\n                garden.minStrategyDuration(),\n                garden.maxStrategyDuration(),\n                garden.strategyCooldownPeriod(),\n                garden.minContribution(),\n                garden.minLiquidityAsset(),\n                garden.totalKeeperFees().add(garden.keeperDebt())\n            ],\n            [\n                principal,\n                garden.reserveAssetRewardsSetAside(),\n                uint256(garden.absoluteReturns()),\n                garden.gardenInitializedAt(),\n                garden.totalContributors(),\n                garden.totalStake(),\n                totalSupplyValuationAndSeed[1] > 0\n                    ? totalSupplyValuationAndSeed[0].preciseMul(totalSupplyValuationAndSeed[1])\n                    : 0,\n                totalSupplyValuationAndSeed[0],\n                totalSupplyValuationAndSeed[2],\n                totalSupplyValuationAndSeed[3]\n            ],\n            profits\n        );\n    }\n\n    /**\n     * Gets complete strategy details\n     *\n     * @param _strategy            Address of the strategy to fetch\n     * @return                     All strategy details\n     */\n    function getCompleteStrategy(address _strategy)\n        external\n        view\n        returns (\n            address,\n            string memory,\n            uint256[16] memory,\n            bool[] memory,\n            uint256[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        bool[] memory status = new bool[](3);\n        uint256[] memory ts = new uint256[](4);\n        // ts[0]: executedAt, ts[1]: exitedAt, ts[2]: updatedAt\n        (, status[0], status[1], status[2], ts[0], ts[1], ts[2]) = strategy.getStrategyState();\n        uint256 rewards =\n            ts[1] != 0 ? IRewardsDistributor(controller.rewardsDistributor()).getStrategyRewards(_strategy) : 0;\n        ts[3] = strategy.enteredCooldownAt();\n        return (\n            strategy.strategist(),\n            IStrategyNFT(controller.strategyNFT()).getStrategyName(_strategy),\n            [\n                strategy.getOperationsCount(),\n                strategy.stake(),\n                strategy.totalPositiveVotes(),\n                strategy.totalNegativeVotes(),\n                strategy.capitalAllocated(),\n                strategy.capitalReturned(),\n                strategy.duration(),\n                strategy.expectedReturn(),\n                strategy.maxCapitalRequested(),\n                strategy.enteredAt(),\n                strategy.getNAV(),\n                rewards,\n                strategy.maxAllocationPercentage(),\n                strategy.maxGasFeePercentage(),\n                strategy.maxTradeSlippagePercentage(),\n                strategy.isStrategyActive() ? _estimateStrategyRewards(_strategy) : 0\n            ],\n            status,\n            ts\n        );\n    }\n\n    function getOperationsStrategy(address _strategy)\n        public\n        view\n        returns (\n            uint8[] memory,\n            address[] memory,\n            bytes[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 count = strategy.getOperationsCount();\n        uint8[] memory types = new uint8[](count);\n        address[] memory integrations = new address[](count);\n        bytes[] memory datas = new bytes[](count);\n\n        for (uint8 i = 0; i < count; i++) {\n            (types[i], integrations[i], datas[i]) = strategy.getOperationByIndex(i);\n        }\n        return (types, integrations, datas);\n    }\n\n    function getPermissions(address _user) external view returns (bool, bool) {\n        IMardukGate gate = IMardukGate(controller.mardukGate());\n        bool hasProphet = IERC721Enumerable(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43).balanceOf(_user) > 0;\n        return (gate.canAccessBeta(_user) || hasProphet, gate.canCreate(_user) || hasProphet);\n    }\n\n    function getGardenPermissions(address _garden, address _user)\n        public\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        IMardukGate gate = IMardukGate(controller.mardukGate());\n        bool accessBeta = true;\n        return (\n            gate.canJoinAGarden(_garden, _user) || (accessBeta && !IGarden(_garden).privateGarden()),\n            gate.canVoteInAGarden(_garden, _user) || (accessBeta && IGarden(_garden).publicStewards()),\n            gate.canAddStrategiesInAGarden(_garden, _user) || (accessBeta && IGarden(_garden).publicStrategists())\n        );\n    }\n\n    function getGardensUser(address _user, uint256 _offset) external view returns (address[] memory, bool[] memory) {\n        address[] memory gardens = controller.getGardens();\n        address[] memory userGardens = new address[](100);\n        bool[] memory hasUserDeposited = new bool[](100);\n        uint256 limit = gardens.length <= 100 ? gardens.length : _offset.add(100);\n        limit = limit < gardens.length ? limit : gardens.length;\n        uint8 resultIndex;\n        for (uint256 i = _offset; i < limit; i++) {\n            (bool depositPermission, , ) = getGardenPermissions(gardens[i], _user);\n            if (depositPermission) {\n                userGardens[resultIndex] = gardens[i];\n                hasUserDeposited[resultIndex] = IERC20(gardens[i]).balanceOf(_user) > 0;\n                resultIndex = resultIndex + 1;\n            }\n        }\n        return (userGardens, hasUserDeposited);\n    }\n\n    function getGardenUserAvgPricePerShare(address _garden, address _user) public view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        uint256[] memory contribution = new uint256[](2);\n        (, , , , , contribution[0], contribution[1], , , ) = garden.getContributor(_user);\n\n        // Avg price per user share = deposits / garden tokens\n        // contributor[0] -> Deposits (ERC20 reserveAsset with X decimals)\n        // contributor[1] -> Balance (Garden tokens) with 18 decimals\n        return contribution[1] > 0 ? contribution[0].preciseDiv(contribution[1]) : 0;\n    }\n\n    /**\n     * Gets the number of tokens that can vote in this garden\n     *\n     * @param _garden  Garden to retrieve votes for\n     * @param _members All members of a garden\n     * @return uint256 Total number of tokens that can vote\n     */\n    function getPotentialVotes(address _garden, address[] calldata _members) external view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        if (garden.publicStewards()) {\n            return IERC20(_garden).totalSupply();\n        }\n        uint256 total = 0;\n        for (uint256 i = 0; i < _members.length; i++) {\n            (bool canDeposit, bool canVote, ) = getGardenPermissions(_garden, _members[i]);\n            if (canDeposit && canVote) {\n                total = total.add(IERC20(_garden).balanceOf(_members[i]));\n            }\n        }\n        return total;\n    }\n\n    function getUserStrategyActions(address[] memory _strategies, address _user)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 strategiesCreated;\n        uint256 totalVotes;\n        for (uint8 i = 0; i < _strategies.length; i++) {\n            IStrategy strategy = IStrategy(_strategies[i]);\n            if (strategy.strategist() == _user) {\n                strategiesCreated = strategiesCreated.add(1);\n            }\n            int256 votes = strategy.getUserVotes(_user);\n            if (votes != 0) {\n                totalVotes = totalVotes.add(uint256(Math.abs(votes)));\n            }\n        }\n        return (strategiesCreated, totalVotes);\n    }\n\n    function getContributionAndRewards(address _garden, address _user)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        IGarden garden = IGarden(_garden);\n        uint256[] memory contribution = new uint256[](10);\n        uint256[] memory pendingRewards = new uint256[](4);\n        (\n            contribution[0],\n            contribution[1],\n            contribution[2],\n            contribution[3],\n            contribution[4],\n            contribution[5],\n            ,\n            ,\n            contribution[8],\n\n        ) = garden.getContributor(_user);\n        contribution[6] = IERC20(_garden).balanceOf(_user);\n        contribution[7] = garden.getLockedBalance(_user);\n        uint256[] memory totalRewards =\n            IRewardsDistributor(controller.rewardsDistributor()).getRewards(\n                _garden,\n                _user,\n                garden.getFinalizedStrategies()\n            );\n        contribution[9] = getGardenUserAvgPricePerShare(_garden, _user);\n        pendingRewards = _estimateUserRewards(_user, garden.getStrategies());\n        return (contribution, totalRewards, pendingRewards);\n    }\n\n    function getPriceAndLiquidity(address _tokenIn, address _reserveAsset) public view returns (uint256, uint256) {\n        return (\n            IPriceOracle(controller.priceOracle()).getPrice(_tokenIn, _reserveAsset),\n            _getUniswapHighestLiquidity(_tokenIn, _reserveAsset)\n        );\n    }\n\n    function getAllProphets(address _address) public view returns (uint256[] memory) {\n        IERC721Enumerable prophets = IERC721Enumerable(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43);\n        uint256 prophetsNumber = prophets.balanceOf(_address);\n        uint256[] memory prophetIds = new uint256[](prophetsNumber);\n        for (uint256 i = 0; i < prophetsNumber; i++) {\n            prophetIds[i] = prophets.tokenOfOwnerByIndex(_address, i);\n        }\n        return prophetIds;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getGardenSeed(address _garden) private view returns (uint256) {\n        return IGardenNFT(controller.gardenNFT()).gardenSeeds(_garden);\n    }\n\n    function _getGardenProfitSharing(address _garden) private view returns (uint256[3] memory) {\n        return IRewardsDistributor(controller.rewardsDistributor()).getGardenProfitsSharing(_garden);\n    }\n\n    function _getUniswapHighestLiquidity(address _sendToken, address _reserveAsset) private view returns (uint256) {\n        // Exit if going to same asset\n        if (_sendToken == _reserveAsset) {\n            return 1e30;\n        }\n        (IUniswapV3Pool pool, ) = _getUniswapPoolWithHighestLiquidity(_sendToken, _reserveAsset);\n        if (address(pool) == address(0)) {\n            return 0;\n        }\n        uint256 poolLiquidity = uint256(pool.liquidity());\n        uint256 liquidityInReserve;\n        address denominator;\n\n        if (pool.token0() == _reserveAsset) {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token1()).balanceOf(address(pool)));\n            denominator = pool.token0();\n        } else {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token0()).balanceOf(address(pool)));\n            denominator = pool.token1();\n        }\n        // Normalize to reserve asset\n        if (denominator != _reserveAsset) {\n            IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n            uint256 price = oracle.getPrice(denominator, _reserveAsset);\n            // price is always in 18 decimals\n            // preciseMul returns in the same decimals than liquidityInReserve, so we have to normalize into reserve Asset decimals\n            // normalization into reserveAsset decimals\n            liquidityInReserve = SafeDecimalMath.normalizeAmountTokens(\n                denominator,\n                _reserveAsset,\n                liquidityInReserve.preciseMul(price)\n            );\n        }\n        return liquidityInReserve;\n    }\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool, uint24 fee)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow > liquidityMedium && liquidityLow >= liquidityHigh) {\n            return (poolLow, FEE_LOW);\n        }\n        if (liquidityMedium > liquidityLow && liquidityMedium >= liquidityHigh) {\n            return (poolMedium, FEE_MEDIUM);\n        }\n        return (poolHigh, FEE_HIGH);\n    }\n\n    /**\n     * returns the estimated accrued BABL of a strategy\n     */\n    function _estimateStrategyRewards(address _strategy) private view returns (uint256) {\n        return IRewardsDistributor(controller.rewardsDistributor()).estimateStrategyRewards(_strategy);\n    }\n\n    /**\n     * returns the estimated accrued BABL for a user related to one strategy\n     */\n    function _estimateUserRewards(address _contributor, address[] memory _strategies)\n        private\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory totalRewards = new uint256[](8);\n        address rewardsDistributor = address(controller.rewardsDistributor());\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            uint256[] memory tempRewards = new uint256[](8);\n            if (!IStrategy(_strategies[i]).isStrategyActive()) {\n                continue;\n            }\n            tempRewards = IRewardsDistributor(rewardsDistributor).estimateUserRewards(_strategies[i], _contributor);\n\n            totalRewards[0] = totalRewards[0].add(tempRewards[0]);\n            totalRewards[1] = totalRewards[1].add(tempRewards[1]);\n            totalRewards[2] = totalRewards[2].add(tempRewards[2]);\n            totalRewards[3] = totalRewards[3].add(tempRewards[3]);\n            totalRewards[4] = totalRewards[4].add(tempRewards[4]);\n            totalRewards[5] = totalRewards[5].add(tempRewards[5]);\n            totalRewards[6] = totalRewards[6].add(tempRewards[6]);\n            totalRewards[7] = totalRewards[7].add(tempRewards[7]);\n        }\n        return totalRewards;\n    }\n}\n"
    },
    "contracts/gardens/GardenNFT.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n//\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Garden\n */\ncontract GardenNFT is ERC721, IGardenNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event GardenNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGarden {\n        require(\n            controller.isSystemContract(msg.sender) && IGarden(msg.sender).controller() == address(controller),\n            'Only the garden can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    Counters.Counter private _tokenIds;\n    mapping(address => string) public override gardenTokenURIs;\n    mapping(address => uint256) public override gardenSeeds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     */\n    function grantGardenNFT(address _user) external override onlyGarden returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, gardenTokenURIs[msg.sender]);\n        emit GardenNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the Garden URI and seed\n     *\n     * @param _garden               Address of the garden\n     * @param _gardenTokenURI     Garden Token URI\n     */\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        gardenTokenURIs[_garden] = _gardenTokenURI;\n        gardenSeeds[_garden] = _seed;\n    }\n}\n"
    },
    "contracts/gardens/GardenFactory.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to deploy Gardens on-chain\n */\ncontract GardenFactory is IGardenFactory {\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a garden using minimal proxies\n     * @param _reserveAsset             Address of the reserve asset ERC20\n     * @param _creator                  Address of the creator\n     * @param _name                     Name of the Garden\n     * @param _symbol                   Symbol of the Garden\n     * @param _tokenURI                 URL of the garden NFT JSON\n     * @param _seed                     Seed to regenerate the garden NFT\n     * @param _gardenParams             Array of numeric params in the garden\n     * @param _initialContribution      Initial Contribution by the Gardener\n     * @param _publicGardenStrategistsStewards Public strategist rights and\n     * public stewards rights\n     */\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external override returns (address) {\n        require(msg.sender == address(controller), 'Only the controller can create gardens');\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IGarden.initialize.selector,\n                        _reserveAsset,\n                        controller,\n                        _creator,\n                        _name,\n                        _symbol,\n                        _gardenParams,\n                        _initialContribution,\n                        _publicGardenStrategistsStewards\n                    )\n                )\n            );\n        IGardenNFT(controller.gardenNFT()).saveGardenURIAndSeed(proxy, _tokenURI, _seed);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "contracts/integrations/trade/UniswapV2TradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\n\n/**\n * @title UniswapV2TradeIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapV3 trade integration\n */\ncontract UniswapV2TradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    // Address of Uniswap V2 SwapRouter contract\n    address private constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('univ2', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through UniswapV3.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address[] memory path = new address[](2);\n        path[0] = _sendToken;\n        path[1] = _receiveToken;\n        bytes memory callData =\n            abi.encodeWithSignature(\n                'swapExactTokensForTokens(uint256,uint256,address[],address,uint256)',\n                _sendQuantity,\n                1,\n                path,\n                _strategy,\n                block.timestamp\n            );\n        return (router, 0, callData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _swapTarget */\n    ) internal pure override returns (address) {\n        return router;\n    }\n\n    /**\n     * Checks liquidity of the trade\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * hparam _sendQuantity         Units of token in SetToken sent to the exchange\n     */\n    function _checkLiquidity(\n        TradeInfo memory _tradeInfo,\n        uint256 /* _sendQuantity */\n    ) internal pure override returns (bool) {\n        // Can only use V2 with ops that have minQuantity set\n        return _tradeInfo.totalMinReceiveQuantity > 1;\n    }\n\n    /* ============ Private Functions ============ */\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/integrations/trade/SynthetixTradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ISynthetix} from '../../interfaces/external/synthetix/ISynthetix.sol';\nimport {ISnxProxy} from '../../interfaces/external/synthetix/ISnxProxy.sol';\nimport {ISnxSynth} from '../../interfaces/external/synthetix/ISnxSynth.sol';\nimport {ISnxEtherWrapper} from '../../interfaces/external/synthetix/ISnxEtherWrapper.sol';\nimport {ISnxDepot} from '../../interfaces/external/synthetix/ISnxDepot.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title SynthetixTradeIntegration\n * @author Babylon Finance Protocol\n *\n * Synthethix trade integration\n */\ncontract SynthetixTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n    /* ============ Constants ============ */\n\n    address private constant curvesUSD = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('synthetix_trade', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through synthetix.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (address sendTokenImpl, address receiveTokenImpl, uint256 realSendAmount) =\n            _getTokens(_sendToken, _receiveToken, _sendQuantity, _strategy);\n        require(sendTokenImpl != address(0) && receiveTokenImpl != address(0), 'Syntetix needs synth or DAI or USDC');\n        if (sendTokenImpl == receiveTokenImpl) {\n            return (address(0), 0, bytes(''));\n        }\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'exchange(bytes32,uint256,bytes32)',\n                ISnxSynth(sendTokenImpl).currencyKey(),\n                realSendAmount,\n                ISnxSynth(receiveTokenImpl).currencyKey()\n            );\n        return (ISnxProxy(SNX).target(), 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _sendToken,\n        address, /* _receiveToken */\n        uint256 _sendQuantity\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_sendToken == DAI) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 0, 3, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        if (_sendToken == USDC) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 0, 1, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return post action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * @param  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address, /* _sendToken */\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Burn sETH to WETH if needed\n        if (_receiveToken == DAI) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 3, 0, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        if (_receiveToken == USDC) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 1, 0, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Returns the address to approve the pre action. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getPreApprovalSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Returns the address to approve the post action. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getPostApprovalSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    function _getPostActionToken(address _receiveToken) internal pure override returns (address) {\n        if (_receiveToken == DAI || _receiveToken == USDC) {\n            return sUSD;\n        }\n        return _receiveToken;\n    }\n\n    /**\n     * Checks liquidity of the trade\n     *\n     * hparam _tradeInfo            Struct containing trade information used in internal functions\n     * hparam _sendQuantity         Units of token in SetToken sent to the exchange\n     */\n    function _checkLiquidity(\n        TradeInfo memory, /* _tradeInfo */\n        uint256 /* _sendQuantity */\n    ) internal pure override returns (bool) {\n        // address reserveAsset = _tradeInfo.garden.reserveAsset();\n        // uint256 minLiquidityReserveAsset = _tradeInfo.garden.minLiquidityAsset();\n        // TODO: Check\n        return true;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getTokens(\n        address _sendToken,\n        address _receiveToken,\n        uint256, /* _sendQuantity */\n        address _strategy\n    )\n        private\n        view\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        ISynthetix synthetix = ISynthetix(ISnxProxy(SNX).target());\n        if (_sendToken == DAI || _sendToken == USDC) {\n            _sendToken = sUSD;\n        }\n        if (_receiveToken == DAI || _receiveToken == USDC) {\n            _receiveToken = sUSD;\n        }\n        address sendTokenImpl;\n        address receiveTokenImpl;\n        try synthetix.synths(stringToBytes32(ERC20(_sendToken).symbol())) returns (ISnxSynth _synth) {\n            sendTokenImpl = address(_synth);\n        } catch {\n            sendTokenImpl = address(0);\n        }\n        try synthetix.synths(stringToBytes32(ERC20(_receiveToken).symbol())) returns (ISnxSynth _synth) {\n            receiveTokenImpl = address(_synth);\n        } catch {\n            receiveTokenImpl = address(0);\n        }\n        return (sendTokenImpl, receiveTokenImpl, ERC20(_sendToken).balanceOf(_strategy));\n    }\n\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxEtherWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/idepot\ninterface ISnxEtherWrapper {\n    // Mints sEth. WETH -> sETH. Needs approval\n    function mint(uint256 _amount) external;\n\n    // Burns sETH. sETH -> WETH\n    function burn(uint256 _amount) external;\n\n    function capacity() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxDepot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/idepot\ninterface ISnxDepot {\n    // Views\n    function fundsWallet() external view returns (address payable);\n\n    function maxEthPurchase() external view returns (uint256);\n\n    function minimumDepositAmount() external view returns (uint256);\n\n    function synthsReceivedForEther(uint256 amount) external view returns (uint256);\n\n    function totalSellableDeposits() external view returns (uint256);\n\n    // Mutative functions\n    function depositSynths(uint256 amount) external;\n\n    function exchangeEtherForSynths() external payable returns (uint256);\n\n    function exchangeEtherForSynthsAtRate(uint256 guaranteedRate) external payable returns (uint256);\n\n    function withdrawMyDepositedSynths() external;\n\n    // Note: On mainnet no SNX has been deposited. The following functions are kept alive for testnet SNX faucets.\n    function exchangeEtherForSNX() external payable returns (uint256);\n\n    function exchangeEtherForSNXAtRate(uint256 guaranteedRate, uint256 guaranteedSynthetixRate)\n        external\n        payable\n        returns (uint256);\n\n    function exchangeSynthsForSNX(uint256 synthAmount) external returns (uint256);\n\n    function synthetixReceivedForEther(uint256 amount) external view returns (uint256);\n\n    function synthetixReceivedForSynths(uint256 amount) external view returns (uint256);\n\n    function withdrawSynthetix(uint256 amount) external;\n}\n"
    },
    "contracts/integrations/passive/YearnVaultIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IYearnRegistry} from '../../interfaces/external/yearn/IYearnRegistry.sol';\nimport {IYearnVault} from '../../interfaces/external/yearn/IYearnVault.sol';\n\n/**\n * @title YearnIntegration\n * @author Babylon Finance Protocol\n *\n * Yearn v2 Vault Integration\n */\ncontract YearnVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IYearnRegistry private constant registry = IYearnRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('yearnvaultsv2', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(\n        address _asset,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _asset;\n    }\n\n    function _getExpectedShares(address _asset, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Yearn\n        return\n            _amount.preciseDiv(IYearnVault(_asset).pricePerShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_asset).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _asset) internal view override returns (uint256) {\n        return IYearnVault(_asset).pricePerShare();\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address) {\n        return IYearnVault(_asset).token();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.deposit.selector, _maxAmountIn);\n\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.withdraw.selector, _investmentTokensIn);\n\n        return (_asset, 0, methodData);\n    }\n}\n"
    },
    "contracts/integrations/passive/LidoStakeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IStETH} from '../../interfaces/external/lido/IStETH.sol';\nimport {IWstETH} from '../../interfaces/external/lido/IWstETH.sol';\n\n/**\n * @title LidoStakeIntegration\n * @author Babylon Finance Protocol\n *\n * Lido Integration\n */\ncontract LidoStakeIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IStETH private constant stETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    IWstETH private constant wstETH = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    address private constant curveSteth = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('lidostaking', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(address _asset, uint8 _op) internal pure override returns (address) {\n        if (_op == 1) {\n            return curveSteth;\n        }\n        return _asset;\n    }\n\n    function _getExpectedShares(address _asset, uint256 _amount) internal view override returns (uint256) {\n        uint256 shares = stETH.getSharesByPooledEth(_amount);\n        if (_asset == address(wstETH)) {\n            return wstETH.getWstETHByStETH(shares);\n        }\n        return shares;\n    }\n\n    function _getPricePerShare(address _asset) internal view override returns (uint256) {\n        uint256 shares = 1e18;\n        // wrapped steth\n        if (_asset == address(wstETH)) {\n            shares = wstETH.getStETHByWstETH(shares);\n        }\n        return stETH.getPooledEthByShares(shares);\n    }\n\n    function _getInvestmentAsset(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        // Both take ETH\n        return address(0);\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (_asset == address(stETH)) {\n            methodData = abi.encodeWithSignature('submit(address)', controller.treasury());\n        } else {\n            // wstETH is just a raw transfer and does both\n            methodData = bytes('');\n        }\n\n        return (_asset, _maxAmountIn, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     * @param  _op                       Type of op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256 _amount,\n        uint256 _op\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_op == 1 && _asset == address(wstETH)) {\n            // Exit 0p && wsteth need to unwrap before redeeming\n            bytes memory methodData = abi.encodeWithSignature('unwrap(uint256)', _amount);\n            return (address(wstETH), 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 1, 0, _investmentTokensIn, 1);\n        // Need to swap via curve. Lido doesn't implement withdraw yet\n        return (curveSteth, 0, methodData);\n    }\n\n    function _preActionNeedsApproval() internal pure override returns (bool) {\n        return true;\n    }\n\n    function _getAssetAfterExitPreAction(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        return address(stETH);\n    }\n}\n"
    },
    "contracts/integrations/passive/HarvestVaultIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\n\nimport {IHarvestVault} from '../../interfaces/external/harvest/IVault.sol';\n\n/**\n * @title HarvestIntegration\n * @author Babylon Finance Protocol\n *\n * Harvest v2 Vault Integration\n */\ncontract HarvestVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('harvestvaults', _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(\n        address _vault,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _vault;\n    }\n\n    function _getExpectedShares(address _vault, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Harvest\n        return\n            _amount.preciseDiv(IHarvestVault(_vault).getPricePerFullShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_vault).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _vault) internal view override returns (uint256) {\n        return IHarvestVault(_vault).getPricePerFullShare();\n    }\n\n    function _getInvestmentAsset(address _vault) internal view override returns (address) {\n        return IHarvestVault(_vault).underlying();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.deposit.selector, _maxAmountIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.withdraw.selector, _investmentTokensIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/harvest/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IHarvestVault {\n    function underlyingBalanceInVault() external view returns (uint256);\n\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    function governance() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n    function deposit(uint256 amountWei) external;\n\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256 numberOfShares) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/lend/AaveLendIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {AaveToken} from '../../interfaces/external/aave/AaveToken.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/external/aave/ILendingPoolAddressesProvider.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\nimport {IStakedAave} from '../../interfaces/external/aave/IStakedAave.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title AaveLendIntegration\n * @author Babylon Finance Protocol\n *\n * Aave lend integration.\n */\ncontract AaveLendIntegration is LendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Constant ============ */\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n\n    address private constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n    address private constant stkAAVE = 0x4da27a545c0c5B758a6BA100e3a049001de870f5;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     */\n    constructor(IBabController _controller) LendIntegration('aavelend', _controller) {}\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        return IERC20(_getInvestmentToken(_assetToken)).balanceOf(_address);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getRewardToken() internal pure override returns (address) {\n        return AAVE;\n    }\n\n    function _getRewardsAccrued(address _strategy) internal view override returns (uint256) {\n        return IStakedAave(stkAAVE).stakerRewardsToClaim(_strategy);\n    }\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress != address(0);\n    }\n\n    function _getExpectedShares(\n        address, /* _assetToken */\n        uint256 _numTokensToSupply\n    ) internal pure override returns (uint256) {\n        // love it 😍\n        return _numTokensToSupply;\n    }\n\n    function _getExchangeRatePerToken(\n        address /* _assetToken */\n    ) internal pure override returns (uint256) {\n        // love it 😍\n        return 1;\n    }\n\n    /**\n     * Claim rewards calldata\n     *\n     * hparam  _strategy                 Address of the strategy\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _claimRewardsCallData(address _strategy)\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('claimRewards(address,uint256)', _strategy, IERC20(stkAAVE).balanceOf(_strategy));\n\n        return (stkAAVE, 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(address,uint256,address,uint16)',\n                _assetToken,\n                _numTokensToSupply,\n                _strategy,\n                0\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Returns calldata for redeeming the collateral\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getRedeemCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('withdraw(address,uint256,address)', _assetToken, _numTokensToSupply, _strategy);\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getSpender(\n        address /* _investmentAddress */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/AaveToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the gardens on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the gardens\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the gardens, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if gardens can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\ninterface IStakedAave {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function stakerRewardsToClaim(address input) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/integrations/borrow/AaveBorrowIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title AaveBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses aave borring/lending logic.\n */\ncontract AaveBorrowIntegration is BorrowIntegration {\n    using SafeERC20 for IERC20;\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n    uint256 constant interestRateMode = 1; // Stable Interest\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed (from 0 to a 100)\n     */\n    constructor(IBabController _controller, uint256 _maxCollateralFactor)\n        BorrowIntegration('aaveborrow', _controller, _maxCollateralFactor)\n    {}\n\n    /* ============ External Functions ============ */\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view override returns (uint256) {\n        (, uint256 stableDebt, , , , , , , ) = dataProvider.getUserReserveData(asset, _strategy);\n        return stableDebt;\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address _strategy,\n        address /* asset */\n    ) external view override returns (uint256) {\n        (\n            uint256 totalCollateral, // uint256 totalDebt, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n            ,\n            ,\n\n        ) =\n            // uint256 healthFactor\n            lendingPool.getUserAccountData(_strategy);\n        return totalCollateral;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        (\n            ,\n            ,\n            // uint256 totalCollateral,\n            // uint256 totalDebt,\n            uint256 borrowingPower, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n\n        ) =\n            // uint256 healthFactor\n            lendingPool.getUserAccountData(_strategy);\n        return borrowingPower;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * @param  _strategy                 Address of the strategy executing\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'borrow(address,uint256,uint256,uint16,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                0,\n                _strategy\n            );\n\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * @param  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'repay(address,uint256,uint256,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                _strategy\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getCollateralAsset(\n        address asset,\n        uint8 /* _borrowOp */\n    ) internal pure override returns (address) {\n        return asset;\n    }\n\n    function _getSpender(\n        address /* asset */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getDebtToken(address asset) internal view returns (address) {\n        // Get the relevant debt token address\n        (, address stableDebtTokenAddress, ) = dataProvider.getReserveTokensAddresses(asset);\n        return stableDebtTokenAddress;\n    }\n}\n"
    },
    "contracts/GardenValuer.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title GardenValuer\n * @author Babylon Finance\n *\n * Contract that returns the valuation of a Garden using price oracle data used in contracts\n * that are external to the system.\n *\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract GardenValuer {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    address public controller;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _controller             Address of controller contract\n     */\n    constructor(address _controller) {\n        require(_controller != address(0), 'Incorrect address');\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Gets the valuation of a Garden using data from the price oracle.\n     * Adds all the active strategies plus the reserve asset and ETH.\n     * Note: this works for external\n     * positions and negative (debt) positions.\n     *\n     * Note: There is a risk that the valuation is off if airdrops aren't retrieved\n     *\n     * @param _garden               Garden instance to get valuation\n     * @param _quoteAsset           Quote asset for the valuation\n     *\n     * @return                 Token valuation in terms of quote asset in precise units 1e18\n     */\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256) {\n        IPriceOracle priceOracle = IPriceOracle(IBabController(controller).priceOracle());\n        require(\n            address(priceOracle) != address(0) &&\n                _garden != address(0) &&\n                _quoteAsset != address(0) &&\n                IBabController(controller).isSystemContract(_garden),\n            'Incorrect input data'\n        );\n        address reserveAsset = IGarden(_garden).reserveAsset();\n        uint256 totalSupply = ERC20(_garden).totalSupply();\n        // If there are no tokens return 0\n        if (totalSupply == 0) {\n            return 0;\n        }\n        uint8 quoteAssetDecimals = ERC20(_quoteAsset).decimals();\n\n        uint256 reservePrice;\n        // Get price of the reserveAsset in _quoteAsset\n        if (reserveAsset == _quoteAsset) {\n            // meaning 1 reserveAsset equals to 1 _quoteAsset\n            reservePrice = 1 ether;\n        } else {\n            reservePrice = priceOracle.getPrice(reserveAsset, _quoteAsset);\n        }\n\n        address[] memory strategies = IGarden(_garden).getStrategies();\n        uint256 valuation;\n        for (uint256 j = 0; j < strategies.length; j++) {\n            IStrategy strategy = IStrategy(strategies[j]);\n            // strategies return their valuation in garden's reserveAsset\n            valuation = valuation.add(strategy.getNAV());\n        }\n\n        // Add garden reserve assets and garden's reserve asset\n        valuation = valuation.add(ERC20(reserveAsset).balanceOf(address(_garden)));\n\n        // Subtract the reserves set aside for rewards\n        valuation = valuation.sub(IGarden(_garden).reserveAssetRewardsSetAside());\n\n        // Subtract Keeper debt\n        valuation = valuation.sub(IGarden(_garden).keeperDebt());\n\n        // Get the valuation in terms of the quote asset\n        valuation = valuation.preciseMul(reservePrice);\n\n        if (quoteAssetDecimals < 18) {\n            valuation = valuation.mul(10**(18 - quoteAssetDecimals));\n        }\n\n        return valuation.preciseDiv(ERC20(_garden).totalSupply());\n    }\n}\n"
    },
    "contracts/integrations/pool/CurvePoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport 'hardhat/console.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ICurvePoolV3} from '../../interfaces/external/curve/ICurvePoolV3.sol';\nimport {ICurvePoolInt128} from '../../interfaces/external/curve/ICurvePoolInt128.sol';\nimport {ICurveAddressProvider} from '../../interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from '../../interfaces/external/curve/ICurveRegistry.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\n/**\n * @title CurvePoolIntegration\n * @author Babylon Finance Protocol\n *\n * Curve liquidity providing integration\n */\ncontract CurvePoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ Constant ============ */\n    address private constant TRICRYPTO = 0x331aF2E331bd619DefAa5DAc6c038f53FCF9F785; // Pool only takes ETH\n    address private constant STETH = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022; // pool requires first amount to match msg.value\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B; // cvx\n\n    // Address of Curve Registry\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n    /* ============ State Variables ============ */\n\n    // Mapping of pools to deposit contract\n    mapping(address => address) public poolToDeposit;\n\n    // Whether to deposit using the underlying coins\n    mapping(address => bool) public usesUnderlying;\n\n    // Whether it supports the underlying param in add liquidity and remove liquidity\n    mapping(address => bool) public supportsUnderlyingParam;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PoolIntegration('curve_pool', _controller) {\n        require(address(_controller) != address(0), 'invalid address');\n        usesUnderlying[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = true; // aave\n        usesUnderlying[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = true; // compound\n        usesUnderlying[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = true; // usdt\n        usesUnderlying[0x06364f10B501e868329afBc005b3492902d6C763] = true; // PAX\n        usesUnderlying[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = true; // ironbank\n        usesUnderlying[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = true; // busd\n        usesUnderlying[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = true; // y\n        usesUnderlying[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = true; // susd\n        usesUnderlying[0x8925D9d9B4569D737a48499DeF3f67BaA5a144b9] = true; // yv2\n        usesUnderlying[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = true; // saave\n\n        poolToDeposit[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = 0xeB21209ae4C2c9FF2a86ACA31E123764A3B6Bc06; // compound\n        poolToDeposit[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = 0xac795D2c97e60DF6a99ff1c814727302fD747a80; // usdt\n        poolToDeposit[0x06364f10B501e868329afBc005b3492902d6C763] = 0xA50cCc70b6a011CffDdf45057E39679379187287; // pax\n        poolToDeposit[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = 0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB; // busd\n        poolToDeposit[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = 0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3; // y\n        poolToDeposit[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = 0xFCBa3E75865d2d561BE8D220616520c171F12851; // susd\n\n        supportsUnderlyingParam[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = true; // aave\n        supportsUnderlyingParam[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = true; // ironbank\n        supportsUnderlyingParam[0x8925D9d9B4569D737a48499DeF3f67BaA5a144b9] = true; // yv2\n        supportsUnderlyingParam[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = true; // saave\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(bytes calldata _pool, bool forNAV) public view override returns (address[] memory) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory result = new address[](_getNCoins(poolAddress));\n        address[8] memory coins;\n        if (usesUnderlying[poolAddress] && !forNAV) {\n            coins = curveRegistry.get_underlying_coins(poolAddress);\n        } else {\n            coins = curveRegistry.get_coins(poolAddress);\n        }\n        for (uint8 i = 0; i < _getNCoins(poolAddress); i++) {\n            result[i] = coins[i];\n        }\n        // Override weth to ETH because it only accepts ETH\n        if (poolAddress == TRICRYPTO && !forNAV) {\n            result[2] = address(0);\n        }\n        return result;\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory poolTokens = getPoolTokens(_pool, false);\n        uint256[] memory result = new uint256[](_getNCoins(poolAddress));\n        if (poolAddress == TRICRYPTO) {\n            result[0] = 0;\n            result[1] = 0;\n            result[2] = uint256(1e18);\n        }\n        for (uint8 i = 0; i < poolTokens.length; i++) {\n            result[i] = uint256(1e18).div(poolTokens.length);\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(\n        bytes calldata _pool,\n        uint256 /* _liquidity */\n    ) external view override returns (uint256[] memory _minAmountsOut) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256[] memory result = new uint256[](_getNCoins(poolAddress));\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        try curveRegistry.get_A(poolAddress) returns (\n            uint256 /* A */\n        ) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    function _getSpender(bytes calldata _pool) internal view override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return poolAddress;\n    }\n\n    function _totalSupply(\n        address /* _pool */\n    ) internal pure override returns (uint256) {\n        return uint256(1e18);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 poolCoins = _getNCoins(poolAddress); //_decodeOpDataAsUint8(_pool, 0);\n\n        // Encode method data for Garden to invoke\n        bytes memory methodData = _getAddLiquidityMethodData(poolAddress, poolCoins, _maxAmountsIn, _poolTokensOut);\n\n        uint256 value = 0;\n        if (poolAddress == TRICRYPTO) {\n            // get the value of eth\n            value = _maxAmountsIn[2];\n        }\n        // If any is eth, set as value\n        for (uint256 i = 0; i < poolCoins; i++) {\n            if (_tokensIn[i] == address(0) || _tokensIn[i] == ETH_ADD_CURVE) {\n                value = _maxAmountsIn[i];\n            }\n        }\n        // If we need a deposit contract to deposit underlying, switch\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return (poolAddress, value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        uint256 poolCoins = _getNCoins(poolAddress); //_decodeOpDataAsUint8(_pool, 0);\n\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = _getRemoveLiquidityMethodData(poolAddress, poolCoins, _minAmountsOut, _poolTokensIn);\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return (poolAddress, 0, methodData);\n    }\n\n    function _getAddLiquidityMethodData(\n        address _poolAddress,\n        uint256 ncoins,\n        uint256[] calldata _maxAmountsIn,\n        uint256 minMintAmount\n    ) private view returns (bytes memory) {\n        if (ncoins == 2) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[2],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[2],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 3) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[3],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[3],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 4) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[4],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[4],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 5) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[5],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        _maxAmountsIn[4],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[5],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        _maxAmountsIn[4],\n                        minMintAmount\n                    );\n            }\n        }\n        return bytes('');\n    }\n\n    function _getRemoveLiquidityMethodData(\n        address _poolAddress,\n        uint256 ncoins,\n        uint256[] calldata _minAmountsOut,\n        uint256 _poolTokensIn\n    ) private view returns (bytes memory) {\n        if (ncoins == 2) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[2],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[2])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1]\n                    );\n            }\n        }\n        if (ncoins == 3) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[3],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[3])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2]\n                    );\n            }\n        }\n        if (ncoins == 4) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[4],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[4])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3]\n                    );\n            }\n        }\n        if (ncoins == 5) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[5],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[3],\n                        _minAmountsOut[4],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[5])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3],\n                        _minAmountsOut[4]\n                    );\n            }\n        }\n        return bytes('');\n    }\n\n    function _getLpToken(address _pool) internal view override returns (address) {\n        // For Deposits & stable swaps that support it get the LP token, otherwise get the pool\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        return curveRegistry.get_lp_token(_pool);\n    }\n\n    // Used when the contract is the Deposit\n    function _getPool(address _pool) internal pure override returns (address) {\n        return _pool;\n    }\n\n    function _getUnderlyingAndRate(bytes calldata _pool, uint256 _i) internal view override returns (address, uint256) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return (curveRegistry.get_underlying_coins(poolAddress)[_i], curveRegistry.get_rates(poolAddress)[_i]);\n    }\n\n    function _getNCoins(address _pool) private view returns (uint256) {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        return curveRegistry.get_n_coins(_pool)[0];\n    }\n\n    function _getRewardTokens(\n        address /* _pool */\n    ) internal pure override returns (address[] memory) {\n        address[] memory rewards = new address[](2);\n        rewards[0] = CRV;\n        rewards[1] = CVX;\n        return rewards;\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePoolInt128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICurvePoolInt128 {\n    function coins(int128 arg0) external view returns (address out);\n\n    function underlying_coins(int128 arg0) external view returns (address out);\n\n    function balances(int128 arg0) external view returns (uint256 out);\n\n    function lp_token() external view returns (address out);\n\n    function token() external view returns (address out);\n\n    function curve() external view returns (address out);\n\n    function pool() external view returns (address out);\n}\n"
    },
    "contracts/integrations/trade/CurveTradeIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ICurveAddressProvider} from '../../interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from '../../interfaces/external/curve/ICurveRegistry.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title CurveTradeIntegration\n * @author Babylon Finance Protocol\n *\n * Curve trade integration\n */\ncontract CurveTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n\n    address private constant tricurvePool = 0x80466c64868E1ab14a1Ddf27A676C3fcBE638Fe5;\n    // Address of Curve Registry\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('curve_trade', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through curve.\n     *\n     * hparam _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        (address curvePool, address realSendToken, address realReceiveToken) =\n            _getPoolAndTokens(_sendToken, _receiveToken);\n        require(curvePool != address(0), 'No curve pool to trade the pair');\n        (int128 i, int128 j, bool underlying) =\n            curveRegistry.get_coin_indices(curvePool, realSendToken, realReceiveToken);\n        bytes memory methodData =\n            abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', i, j, _sendQuantity, 1);\n        if (tricurvePool == curvePool) {\n            if (realSendToken == ETH_ADD_CURVE) {\n                methodData = abi.encodeWithSignature(\n                    'exchange(uint256,uint256,uint256,uint256,bool)',\n                    i,\n                    j,\n                    _sendQuantity,\n                    1,\n                    true\n                );\n            } else {\n                methodData = abi.encodeWithSignature(\n                    'exchange(uint256,uint256,uint256,uint256)',\n                    i,\n                    j,\n                    _sendQuantity,\n                    1\n                );\n            }\n        }\n        if (underlying) {\n            methodData = abi.encodeWithSignature(\n                'exchange_underlying(int128,int128,uint256,uint256)',\n                i,\n                j,\n                _sendQuantity,\n                1\n            );\n        }\n        return (curvePool, realSendToken == ETH_ADD_CURVE ? _sendQuantity : 0, methodData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Checks liquidity of the trade\n     *\n     * hparam _tradeInfo            Struct containing trade information used in internal functions\n     * hparam _sendQuantity         Units of token in SetToken sent to the exchange\n     */\n    function _checkLiquidity(\n        TradeInfo memory, /* _tradeInfo */\n        uint256 /* _sendQuantity */\n    ) internal pure override returns (bool) {\n        // No need to check liquidity in curve\n        return true;\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Unwrap WETH to ETH\n        (, address _realSendToken, ) = _getPoolAndTokens(_sendToken, _receiveToken);\n        if (_realSendToken == ETH_ADD_CURVE) {\n            bytes memory methodData = abi.encodeWithSignature('withdraw(uint256)', _sendQuantity);\n            return (WETH, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return post action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * @param  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Wrap ETH to WETH\n        (, , address _realReceiveToken) = _getPoolAndTokens(_sendToken, _receiveToken);\n        if (_realReceiveToken == ETH_ADD_CURVE) {\n            bytes memory methodData = abi.encodeWithSignature('deposit()');\n            return (WETH, _sendQuantity, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getPostActionToken(\n        address /* _receiveToken */\n    ) internal pure override returns (address) {\n        return ETH_ADD_CURVE;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getPoolAndTokens(address _sendToken, address _receiveToken)\n        private\n        view\n        returns (\n            address,\n            address,\n            address\n        )\n    {\n        ICurveRegistry curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        address curvePool = curveRegistry.find_pool_for_coins(_sendToken, _receiveToken, 0);\n        if (_sendToken == WETH && curvePool == address(0)) {\n            _sendToken = ETH_ADD_CURVE;\n            curvePool = curveRegistry.find_pool_for_coins(ETH_ADD_CURVE, _receiveToken, 0);\n        }\n        if (_receiveToken == WETH && curvePool == address(0)) {\n            _receiveToken = ETH_ADD_CURVE;\n            curvePool = curveRegistry.find_pool_for_coins(_sendToken, ETH_ADD_CURVE, 0);\n        }\n        return (curvePool, _sendToken, _receiveToken);\n    }\n}\n"
    },
    "contracts/integrations/pool/SushiswapPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {UniswapPoolIntegration} from './UniswapPoolIntegration.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\n/**\n * @title SushiswapPoolIntegration\n * @author Babylon Finance Protocol\n *\n * Sushiswap Protocol pool integration\n */\ncontract SushiswapPoolIntegration is UniswapPoolIntegration {\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _sushiswapRouterAddress         Address of Sushiswap router\n     */\n    constructor(IBabController _controller, address _sushiswapRouterAddress)\n        UniswapPoolIntegration(_controller, _sushiswapRouterAddress)\n    {\n        name = 'sushiswap_pool';\n    }\n}\n"
    },
    "contracts/integrations/pool/OneInchPoolIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IMooniswapFactory} from '../../interfaces/external/1inch/IMooniswapFactory.sol';\nimport {IMooniswap} from '../../interfaces/external/1inch/IMooniswap.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * OneInchPoolIntegration protocol trade integration\n */\ncontract OneInchPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IMooniswapFactory public mooniswapFactory;\n\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _mooniswapFactoryAddress         Address of the Mooniswap factory\n     */\n    constructor(IBabController _controller, address _mooniswapFactoryAddress)\n        PoolIntegration('oneinch_pool', _controller)\n    {\n        require(address(_controller) != address(0) && _mooniswapFactoryAddress != address(0), 'invalid address');\n        mooniswapFactory = IMooniswapFactory(_mooniswapFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return IMooniswap(poolAddress).getTokens();\n    }\n\n    function getPoolWeights(\n        bytes calldata /* _pool */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory tokens = IMooniswap(poolAddress).getTokens();\n        uint256 totalSupply = IMooniswap(poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        uint256 token0Balance =\n            (tokens[0] != address(0) ? IERC20(tokens[0]).balanceOf(poolAddress) : poolAddress.balance);\n        uint256 token1Balance =\n            (tokens[1] != address(0) ? IERC20(tokens[1]).balanceOf(poolAddress) : poolAddress.balance);\n        result[0] = token0Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = token1Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IMooniswapFactory(mooniswapFactory).isPool(IMooniswap(poolAddress));\n    }\n\n    function _getSpender(bytes calldata _pool) internal pure override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(uint256[2],uint256[2])',\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED * 2)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED * 2))\n            );\n        uint256 value = 0;\n        // Add ETH if one of the tokens\n        if (_tokensIn[0] == address(0)) {\n            value = _maxAmountsIn[0];\n        }\n        if (_tokensIn[1] == address(0)) {\n            value = _maxAmountsIn[1];\n        }\n\n        return (poolAddress, value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './IMooniswap.sol';\nimport './IMooniswapFactoryGovernance.sol';\n\ninterface IMooniswapFactory is IMooniswapFactoryGovernance {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n\n    function isPool(IMooniswap mooniswap) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IMooniswap is IERC20 {\n    function getTokens() external view returns (address[] memory _tokens);\n\n    function tokens(uint256 i) external view returns (IERC20);\n\n    function getBalanceForAddition(IERC20 token) external view returns (uint256);\n\n    function getBalanceForRemoval(IERC20 token) external view returns (uint256);\n\n    function getReturn(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts)\n        external\n        payable\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function depositFor(\n        uint256[2] memory maxAmounts,\n        uint256[2] memory minAmounts,\n        address target\n    ) external payable returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function withdraw(uint256 amount, uint256[] memory minReturns)\n        external\n        returns (uint256[2] memory withdrawnAmounts);\n\n    function withdrawFor(\n        uint256 amount,\n        uint256[] memory minReturns,\n        address payable target\n    ) external returns (uint256[2] memory withdrawnAmounts);\n\n    function swap(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    ) external payable returns (uint256 result);\n\n    function swapFor(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral,\n        address payable receiver\n    ) external payable returns (uint256 result);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactoryGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IMooniswapFactoryGovernance {\n    function shareParameters()\n        external\n        view\n        returns (\n            uint256 _referralShare,\n            uint256 _governanceShare,\n            address _governanceWallet,\n            address _referralFeeReceiver\n        );\n\n    function defaults()\n        external\n        view\n        returns (\n            uint256 _defaultFee,\n            uint256 _defaultSlippageFee,\n            uint256 _defaultDecayPeriod\n        );\n\n    function defaultFee() external view returns (uint256);\n\n    function defaultSlippageFee() external view returns (uint256);\n\n    function defaultDecayPeriod() external view returns (uint256);\n\n    function virtualDefaultFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultSlippageFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultDecayPeriod()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function referralShare() external view returns (uint256);\n\n    function governanceShare() external view returns (uint256);\n\n    function governanceWallet() external view returns (address);\n\n    function feeCollector() external view returns (address);\n\n    function isFeeCollector(address) external view returns (bool);\n\n    function isActive() external view returns (bool);\n}\n"
    },
    "contracts/integrations/pool/BalancerIntegration.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IBFactory} from '../../interfaces/external/balancer/IBFactory.sol';\nimport {IBPool} from '../../interfaces/external/balancer/IBPool.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Balancer protocol trade integration\n */\ncontract BalancerIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    IBFactory public coreFactory;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _coreFactoryAddress           Address of Balancer core factory address\n     */\n    constructor(IBabController _controller, address _coreFactoryAddress) PoolIntegration('balancer', _controller) {\n        require(address(_controller) != address(0) && _coreFactoryAddress != address(0), 'invalid address');\n        coreFactory = IBFactory(_coreFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return IBPool(poolAddress).getCurrentTokens();\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory poolTokens = IBPool(poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint8 i = 0; i < poolTokens.length; i++) {\n            result[i] = IBPool(poolAddress).getNormalizedWeight(poolTokens[i]);\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata _pool,\n        address _poolToken,\n        uint256 _maxAmountsIn\n    ) external view override returns (uint256) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 tokenBalance = IBPool(poolAddress).getBalance(_poolToken);\n        return IBPool(poolAddress).totalSupply().preciseMul(_maxAmountsIn.preciseDiv(tokenBalance));\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 lpTokensTotalSupply = IBPool(poolAddress).totalSupply();\n        address[] memory poolTokens = IBPool(poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            result[i] = IERC20(poolTokens[i])\n                .balanceOf(poolAddress)\n                .mul(_liquidity)\n                .div(lpTokensTotalSupply)\n                .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        }\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return coreFactory.isBPool(poolAddress);\n    }\n\n    function _getSpender(bytes calldata _pool) internal pure override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('joinPool(uint256,uint256[])', _poolTokensOut, _maxAmountsIn);\n\n        return (poolAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('exitPool(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/balancer/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IBPool} from './IBPool.sol';\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n\n    function newBPool() external returns (IBPool);\n}\n"
    },
    "contracts/interfaces/external/balancer/IBPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IBPool {\n    function isPublicSwap() external view returns (bool);\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address t) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getCurrentTokens() external view returns (address[] memory tokens);\n\n    function getFinalTokens() external view returns (address[] memory tokens);\n\n    function getDenormalizedWeight(address token) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getNormalizedWeight(address token) external view returns (uint256);\n\n    function getBalance(address token) external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function getController() external view returns (address);\n\n    function setSwapFee(uint256 swapFee) external;\n\n    function setController(address manager) external;\n\n    function setPublicSwap(bool external_) external;\n\n    function finalize() external;\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function unbind(address token) external;\n\n    function gulp(address token) external;\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut);\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external returns (uint256 tokenAmountIn);\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 tokenAmountOut);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) external pure returns (uint256 spotPrice);\n\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/mocks/RevertOracle.sol": {
      "content": "/*\n    Copyright 2021 Babylon Finance\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {PriceOracle} from '../PriceOracle.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance Protocol\n *\n * Uses Uniswap V3 to get a price of a token pair\n */\ncontract RevertOracle is PriceOracle {\n    function getPrice(\n        address, /* _tokenIn */\n        address /* _tokenOut */\n    ) public pure override returns (uint256) {\n        require(false, 'Price not found');\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}