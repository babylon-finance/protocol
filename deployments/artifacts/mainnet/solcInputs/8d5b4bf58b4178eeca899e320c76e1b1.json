{
  "language": "Solidity",
  "sources": {
    "contracts/BabController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {AddressUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport {IRewardsDistributor} from './interfaces/IRewardsDistributor.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IGardenFactory} from './interfaces/IGardenFactory.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IIntegration} from './interfaces/IIntegration.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IHypervisor} from './interfaces/IHypervisor.sol';\nimport {IWETH} from './interfaces/external/weth/IWETH.sol';\n\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\nimport {LowGasSafeMath} from './lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\n\n/**\n * @title BabController\n * @author Babylon Finance Protocol\n *\n * BabController is a smart contract used to deploy new gardens contracts and house the\n * integrations and resources of the system.\n */\ncontract BabController is OwnableUpgradeable, IBabController {\n    using AddressArrayUtils for address[];\n    using Address for address;\n    using AddressUpgradeable for address;\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Events ============ */\n\n    event GardenAdded(address indexed _garden, address indexed _factory);\n    event GardenRemoved(address indexed _garden);\n\n    event ControllerIntegrationAdded(address _integration, string indexed _integrationName);\n    event ControllerIntegrationRemoved(address _integration, string indexed _integrationName);\n    event ControllerIntegrationEdited(address _newIntegration, string indexed _integrationName);\n    event ControllerOperationSet(uint8 indexed _kind, address _address);\n    event MasterSwapperChanged(address indexed _newTradeIntegration, address _oldTradeIntegration);\n\n    event ReserveAssetAdded(address indexed _reserveAsset);\n    event ReserveAssetRemoved(address indexed _reserveAsset);\n    event ProtocolWantedAssetUpdated(address indexed _wantedAsset, bool _wanted);\n    event GardenAffiliateRateUpdated(address indexed _garden, uint256 _affiliateRate);\n    event AffiliateRewardsClaimed(address indexed _user, uint256 _rewardsClaimed);\n    event AffiliateRewards(address indexed _depositor, address indexed _referrer, uint256 _reserve, uint256 _reward);\n    event LiquidityMinimumEdited(address indexed _resesrveAsset, uint256 _newMinLiquidityReserve);\n\n    event PriceOracleChanged(address indexed _priceOracle, address _oldPriceOracle);\n    event RewardsDistributorChanged(address indexed _rewardsDistributor, address _oldRewardsDistributor);\n    event TreasuryChanged(address _newTreasury, address _oldTreasury);\n    event IshtarGateChanged(address _newIshtarGate, address _oldIshtarGate);\n    event MardukGateChanged(address _newMardukGate, address _oldMardukGate);\n    event GardenValuerChanged(address indexed _gardenValuer, address _oldGardenValuer);\n    event GardenFactoryChanged(address indexed _gardenFactory, address _oldGardenFactory);\n    event UniswapFactoryChanged(address indexed _newUniswapFactory, address _oldUniswapFactory);\n    event GardenNFTChanged(address indexed _newGardenNFT, address _oldStrategyNFT);\n    event StrategyNFTChanged(address indexed _newStrategyNFT, address _oldStrategyNFT);\n    event HeartChanged(address indexed _newHeart, address _oldHeart);\n\n    event StrategyFactoryEdited(address indexed _strategyFactory, address _oldStrategyFactory);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address _oldPauseGuardian, address _newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(bool _pauseState);\n\n    /// @notice Emitted when an action is paused individually\n    event ActionPausedIndividually(address _address, bool _pauseState);\n\n    /* ============ Modifiers ============ */\n\n    function _onlyGovernanceOrEmergency() internal view {\n        require(msg.sender == owner() || msg.sender == EMERGENCY_OWNER, 'Not enough privileges');\n    }\n\n    /* ============ State Variables ============ */\n\n    // List of enabled Communities\n    address[] public gardens;\n    address[] public reserveAssets;\n    address private uniswapFactory; // do not use\n    address public override gardenValuer;\n    address public override priceOracle;\n    address public override gardenFactory;\n    address public override rewardsDistributor;\n    address public override ishtarGate;\n    address public override strategyFactory;\n    address public override gardenNFT;\n    address public override strategyNFT;\n\n    // Mapping of integration name => integration address\n    mapping(bytes32 => address) private enabledIntegrations; // DEPRECATED\n    // Address of the master swapper used by the protocol\n    address public override masterSwapper;\n    // Mapping of valid operations\n    address[MAX_OPERATIONS] public override enabledOperations;\n\n    // Mappings to check whether address is valid Garden or Reserve Asset\n    mapping(address => bool) public override isGarden;\n    mapping(address => bool) public validReserveAsset;\n\n    // Mapping to check whitelisted assets\n    mapping(address => bool) private assetWhitelist;\n\n    // Mapping to check keepers\n    mapping(address => bool) public keeperList;\n\n    // Mapping of minimum liquidity per reserve asset\n    mapping(address => uint256) public override minLiquidityPerReserve;\n\n    // Recipient of protocol fees\n    address public override treasury;\n\n    // Strategy Profit Sharing\n    uint256 private strategistProfitPercentage; // DEPRECATED\n    uint256 private stewardsProfitPercentage; // DEPRECATED\n    uint256 private lpsProfitPercentage; // DEPRECATED\n\n    // Strategy BABL Rewards Sharing\n    uint256 private strategistBABLPercentage; // DEPRECATED\n    uint256 private stewardsBABLPercentage; // DEPRECATED\n    uint256 private lpsBABLPercentage; // DEPRECATED\n\n    uint256 private gardenCreatorBonus; // DEPRECATED\n\n    // Assets\n\n    // Enable Transfer of ERC20 gardenTokens\n    // Only members can transfer tokens until the protocol is fully decentralized\n    bool public override gardenTokensTransfersEnabled;\n\n    // Enable and starts the BABL Mining program within Rewards Distributor contract\n    bool public override bablMiningProgramEnabled;\n    // Enable public gardens\n    bool public override allowPublicGardens;\n\n    uint256 public override protocolPerformanceFee; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n    uint256 public override protocolManagementFee; // 0.5% (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolDepositGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n    uint256 private protocolWithdrawalGardenTokenFee; // 0 (0.01% = 1e14, 1% = 1e16)\n\n    // Maximum number of contributors per garden\n    uint256 private maxContributorsPerGarden; // DEPRECATED\n\n    // Enable garden creations to be fully open to the public (no need of Ishtar gate anymore)\n    bool public override gardenCreationIsOpen;\n\n    // Pause Guardian\n    address public guardian;\n    mapping(address => bool) public override guardianPaused;\n    bool public override guardianGlobalPaused;\n\n    address public override mardukGate;\n    address public override heart;\n    address public override curveMetaRegistry;\n    mapping(address => bool) public override protocolWantedAssets;\n    mapping(address => uint256) public override gardenAffiliateRates; // 18 decimals\n    mapping(address => uint256) public override affiliateRewards;\n\n    /* ============ Constants ============ */\n\n    address public constant override EMERGENCY_OWNER = 0x97FcC2Ae862D03143b393e9fA73A32b563d57A6e;\n    IWETH public constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant BABL = IERC20(0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74);\n    uint8 public constant MAX_OPERATIONS = 20;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the initial fee recipient on deployment.\n     */\n    function initialize() public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // vars init values has to be set in initialize due to how upgrade proxy pattern works\n        protocolManagementFee = 5e15; // 0.5% (0.01% = 1e14, 1% = 1e16)\n        protocolPerformanceFee = 5e16; // 5% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolDepositGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n        protocolWithdrawalGardenTokenFee = 0; // 0% (0.01% = 1e14, 1% = 1e16) on profits\n\n        maxContributorsPerGarden = 100;\n        gardenCreationIsOpen = false;\n        allowPublicGardens = true;\n        bablMiningProgramEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    // ===========  Garden related Gov Functions ======\n    /**\n     * Creates a Garden smart contract and registers the Garden with the controller.\n     *\n     * If asset is not WETH, the creator needs to approve the controller\n     * @param _reserveAsset                     Reserve asset of the Garden. Initially just weth\n     * @param _name                             Name of the Garden\n     * @param _symbol                           Symbol of the Garden\n     * @param _gardenParams                     Array of numeric garden params\n     * @param _tokenURI                         Garden NFT token URI\n     * @param _seed                             Seed to regenerate the garden NFT\n     * @param _initialContribution              Initial contribution by the gardener\n     * @param _publicGardenStrategistsStewards  Public garden, public strategist rights and public stewards rights\n     * @param _profitSharing                    Custom profit sharing (if any)\n     */\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards,\n        uint256[] memory _profitSharing\n    ) external payable override returns (address) {\n        require(masterSwapper != address(0), 'Need a default trade integration');\n        require(enabledOperations.length > 0, 'Need operations enabled');\n        require(\n            mardukGate != address(0) &&\n                gardenNFT != address(0) &&\n                strategyFactory != address(0) &&\n                gardenValuer != address(0) &&\n                treasury != address(0),\n            'Parameters not initialized'\n        );\n        require(\n            IIshtarGate(mardukGate).canCreate(msg.sender) || gardenCreationIsOpen,\n            'User does not have creation permissions'\n        );\n        address newGarden =\n            IGardenFactory(gardenFactory).createGarden(\n                _reserveAsset,\n                msg.sender,\n                _name,\n                _symbol,\n                _tokenURI,\n                _seed,\n                _gardenParams,\n                _initialContribution,\n                _publicGardenStrategistsStewards\n            );\n        if (_reserveAsset != address(WETH) || msg.value == 0) {\n            IERC20(_reserveAsset).safeTransferFrom(msg.sender, address(this), _initialContribution);\n            IERC20(_reserveAsset).safeApprove(newGarden, _initialContribution);\n        }\n        require(!isGarden[newGarden], 'Garden already exists');\n        isGarden[newGarden] = true;\n        gardens.push(newGarden);\n        IGarden(newGarden).deposit{value: msg.value}(\n            _initialContribution,\n            _initialContribution,\n            msg.sender,\n            address(0)\n        );\n        // Avoid gas cost if default sharing values are provided (0,0,0)\n        if (_profitSharing[0] != 0 || _profitSharing[1] != 0 || _profitSharing[2] != 0) {\n            IRewardsDistributor(rewardsDistributor).setProfitRewards(\n                newGarden,\n                _profitSharing[0],\n                _profitSharing[1],\n                _profitSharing[2]\n            );\n        }\n        emit GardenAdded(newGarden, msg.sender);\n        return newGarden;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a Garden\n     *\n     * @param _garden               Address of the Garden contract to remove\n     */\n    function removeGarden(address _garden) external override onlyOwner {\n        require(isGarden[_garden], 'Garden does not exist');\n        require(IGarden(_garden).getStrategies().length == 0, 'Garden has active strategies!');\n        gardens = gardens.remove(_garden);\n        delete isGarden[_garden];\n\n        emit GardenRemoved(_garden);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 gardenTokens\n     * Can only happen after 2021 is finished.\n     */\n    function enableGardenTokensTransfers() external override onlyOwner {\n        require(block.timestamp > 1641024000, 'Transfers cannot be enabled yet');\n        gardenTokensTransfersEnabled = true;\n    }\n\n    // ===========  Protocol related Gov Functions ======\n\n    /**\n     * PRIVILEGED FUNCTION. Adds a new valid keeper to the list\n     *\n     * @param _keeper Address of the keeper\n     */\n    function addKeeper(address _keeper) external override {\n        _onlyGovernanceOrEmergency();\n        require(!keeperList[_keeper] && _keeper != address(0), 'Incorrect address');\n        keeperList[_keeper] = true;\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Removes a keeper\n     *\n     * @param _keeper Address of the keeper\n     */\n    function removeKeeper(address _keeper) external override {\n        _onlyGovernanceOrEmergency();\n        require(keeperList[_keeper], 'Keeper is whitelisted');\n        delete keeperList[_keeper];\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Adds a list of assets to the whitelist\n     *\n     * @param _keepers List with keeprs of the assets to whitelist\n     */\n    function addKeepers(address[] memory _keepers) external override {\n        _onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _keepers.length; i++) {\n            keeperList[_keepers[i]] = true;\n        }\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Adds a new valid reserve asset for gardens\n     *\n     * @param _reserveAsset Address of the reserve assset\n     */\n    function addReserveAsset(address _reserveAsset) external override {\n        _onlyGovernanceOrEmergency();\n        require(_reserveAsset != address(0) && ERC20(_reserveAsset).decimals() <= 18, 'Incorrect address');\n        require(!validReserveAsset[_reserveAsset], 'Reserve asset already added');\n        validReserveAsset[_reserveAsset] = true;\n        reserveAssets.push(_reserveAsset);\n        emit ReserveAssetAdded(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a reserve asset\n     *\n     * @param _reserveAsset               Address of the reserve asset to remove\n     */\n    function removeReserveAsset(address _reserveAsset) external override {\n        _onlyGovernanceOrEmergency();\n        require(validReserveAsset[_reserveAsset], 'Reserve asset does not exist');\n        reserveAssets = reserveAssets.remove(_reserveAsset);\n        delete validReserveAsset[_reserveAsset];\n        emit ReserveAssetRemoved(_reserveAsset);\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Updates a protocol wanted asset\n     *\n     * @param _wantedAsset  Address of the wanted assset\n     * @param _wanted       True if wanted, false otherwise\n     */\n    function updateProtocolWantedAsset(address _wantedAsset, bool _wanted) external override {\n        _onlyGovernanceOrEmergency();\n        require(_wantedAsset != address(0) && ERC20(_wantedAsset).decimals() <= 18, 'Incorrect address');\n        require(protocolWantedAssets[_wantedAsset] != _wanted, 'Wanted asset already added');\n        protocolWantedAssets[_wantedAsset] = _wanted;\n        emit ProtocolWantedAssetUpdated(_wantedAsset, _wanted);\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Updates the affiliate rate for a garden. 0 if none.\n     *\n     * @param _garden              Address of the garden\n     * @param _affiliateRate       Affiliate rate for this garden\n     */\n    function updateGardenAffiliateRate(address _garden, uint256 _affiliateRate) external override {\n        _onlyGovernanceOrEmergency();\n        require(isGarden[_garden], 'Garden is not valid');\n        require(gardenAffiliateRates[_garden] != _affiliateRate, 'Rate already set');\n        gardenAffiliateRates[_garden] = _affiliateRate;\n        emit GardenAffiliateRateUpdated(_garden, _affiliateRate);\n    }\n\n    /**\n     * PRIVILEGED FUNCTION. Adds the affiliate rewards earned by an user\n     *\n     * Only a garden can call this\n     *\n     * @param _depositor            Address of the user that deposits\n     * @param _referrer             Address of the user that refers\n     * @param _reserveAmount        Amount of reserved deposited by a link of the user\n     */\n    function addAffiliateReward(\n        address _depositor,\n        address _referrer,\n        uint256 _reserveAmount\n    ) external override {\n        require(isGarden[msg.sender], 'Only garden can add rewards');\n        require(_referrer != address(0) && _reserveAmount > 0, 'User and/or amount invalid');\n        if (gardenAffiliateRates[msg.sender] > 0) {\n            uint256 totalReward = _reserveAmount.preciseMul(gardenAffiliateRates[msg.sender]);\n            affiliateRewards[_depositor] = affiliateRewards[_depositor].add(totalReward.div(2));\n            if (_depositor != _referrer) {\n                affiliateRewards[_referrer] = affiliateRewards[_referrer].add(totalReward.div(2));\n            }\n            emit AffiliateRewards(_depositor, _referrer, _reserveAmount, totalReward);\n        }\n    }\n\n    /**\n     * Claims affiliate rewards\n     * Controller needs to hold BABL.\n     */\n    function claimRewards() external override {\n        uint256 rewards = affiliateRewards[msg.sender];\n\n        require(rewards > 0, 'No affiliate rewards');\n        require(BABL.balanceOf(address(this)) >= rewards, 'Not enough BABL balance');\n\n        delete affiliateRewards[msg.sender];\n\n        BABL.transfer(msg.sender, rewards);\n\n        emit AffiliateRewardsClaimed(msg.sender, rewards);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the Marduk Gate Address\n     *\n     * @param _mardukGate               Address of the new Marduk Gate\n     */\n    function editMardukGate(address _mardukGate) external override onlyOwner {\n        require(_mardukGate != mardukGate, 'Marduk Gate already exists');\n\n        require(_mardukGate != address(0), 'Marduk Gate oracle must exist');\n\n        address oldMardukGate = mardukGate;\n        mardukGate = _mardukGate;\n\n        emit MardukGateChanged(_mardukGate, oldMardukGate);\n    }\n\n    function editRewardsDistributor(address _newRewardsDistributor) external override onlyOwner {\n        require(_newRewardsDistributor != address(0), 'Address must not be 0');\n\n        address oldRewardsDistributor = rewardsDistributor;\n        rewardsDistributor = _newRewardsDistributor;\n\n        emit RewardsDistributorChanged(_newRewardsDistributor, oldRewardsDistributor);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol fee recipient\n     *\n     * @param _newTreasury      Address of the new protocol fee recipient\n     */\n    function editTreasury(address _newTreasury) external override onlyOwner {\n        require(_newTreasury != address(0), 'Address must not be 0');\n\n        address oldTreasury = treasury;\n        treasury = _newTreasury;\n\n        emit TreasuryChanged(_newTreasury, oldTreasury);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the heart contract\n     *\n     * @param _newHeart      Address of the new heart\n     */\n    function editHeart(address _newHeart) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newHeart != address(0), 'Address must not be 0');\n\n        address oldHeart = heart;\n        heart = _newHeart;\n\n        emit HeartChanged(_newHeart, oldHeart);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the curve meta registry\n     *\n     * @param _curveMetaRegistry      Address of the new curve meta registry\n     */\n    function editCurveMetaRegistry(address _curveMetaRegistry) external override {\n        _onlyGovernanceOrEmergency();\n        require(_curveMetaRegistry != address(0), 'Address must not be 0');\n\n        curveMetaRegistry = _curveMetaRegistry;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edits the minimum liquidity an asset must have on Uniswap\n     *\n     * @param  _reserve                         Address of the reserve to edit\n     * @param  _newMinLiquidityReserve          Absolute min liquidity of an asset to grab price\n     */\n    function editLiquidityReserve(address _reserve, uint256 _newMinLiquidityReserve) public override onlyOwner {\n        require(_newMinLiquidityReserve > 0, '_minRiskyPairLiquidityEth > 0');\n        require(validReserveAsset[_reserve], 'Needs to be a valid reserve');\n        minLiquidityPerReserve[_reserve] = _newMinLiquidityReserve;\n\n        emit LiquidityMinimumEdited(_reserve, _newMinLiquidityReserve);\n    }\n\n    // Setter that can be changed by the team in case of an emergency\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the price oracle\n     *\n     * @param _priceOracle               Address of the new price oracle\n     */\n    function editPriceOracle(address _priceOracle) external override {\n        _onlyGovernanceOrEmergency();\n        require(_priceOracle != priceOracle, 'Price oracle already exists');\n\n        require(_priceOracle != address(0), 'Price oracle must exist');\n\n        address oldPriceOracle = priceOracle;\n        priceOracle = _priceOracle;\n\n        emit PriceOracleChanged(_priceOracle, oldPriceOracle);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change the garden valuer\n     *\n     * @param _gardenValuer Address of the new garden valuer\n     */\n    function editGardenValuer(address _gardenValuer) external override {\n        _onlyGovernanceOrEmergency();\n        require(_gardenValuer != gardenValuer, 'Garden Valuer already exists');\n\n        require(_gardenValuer != address(0), 'Garden Valuer must exist');\n\n        address oldGardenValuer = gardenValuer;\n        gardenValuer = _gardenValuer;\n\n        emit GardenValuerChanged(_gardenValuer, oldGardenValuer);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden factory\n     *\n     * @param _newGardenFactory      Address of the new garden factory\n     */\n    function editGardenFactory(address _newGardenFactory) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newGardenFactory != address(0), 'Address must not be 0');\n\n        address oldGardenFactory = gardenFactory;\n        gardenFactory = _newGardenFactory;\n\n        emit GardenFactoryChanged(_newGardenFactory, oldGardenFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol garden NFT\n     *\n     * @param _newGardenNFT      Address of the new garden NFT\n     */\n    function editGardenNFT(address _newGardenNFT) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newGardenNFT != address(0), 'Address must not be 0');\n\n        address oldGardenNFT = gardenNFT;\n        gardenNFT = _newGardenNFT;\n\n        emit GardenNFTChanged(_newGardenNFT, oldGardenNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy NFT\n     *\n     * @param _newStrategyNFT      Address of the new strategy NFT\n     */\n    function editStrategyNFT(address _newStrategyNFT) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newStrategyNFT != address(0), 'Address must not be 0');\n\n        address oldStrategyNFT = strategyNFT;\n        strategyNFT = _newStrategyNFT;\n\n        emit StrategyNFTChanged(_newStrategyNFT, oldStrategyNFT);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol strategy factory\n     *\n     * @param _newStrategyFactory      Address of the new strategy factory\n     */\n    function editStrategyFactory(address _newStrategyFactory) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newStrategyFactory != address(0), 'Address must not be 0');\n\n        address oldStrategyFactory = strategyFactory;\n        strategyFactory = _newStrategyFactory;\n\n        emit StrategyFactoryEdited(_newStrategyFactory, oldStrategyFactory);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to edit the protocol default trde integration\n     *\n     * @param _newDefaultMasterSwapper     Address of the new default trade integration\n     */\n    function setMasterSwapper(address _newDefaultMasterSwapper) external override {\n        _onlyGovernanceOrEmergency();\n        require(_newDefaultMasterSwapper != address(0), 'Address must not be 0');\n        require(_newDefaultMasterSwapper != masterSwapper, 'Address must be different');\n        address oldMasterSwapper = masterSwapper;\n        masterSwapper = _newDefaultMasterSwapper;\n\n        emit MasterSwapperChanged(_newDefaultMasterSwapper, oldMasterSwapper);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Edit an existing operation on the registry\n     *\n     * @param  _kind             Operation kind\n     * @param  _operation        Address of the operation contract to set\n     */\n    function setOperation(uint8 _kind, address _operation) public override {\n        _onlyGovernanceOrEmergency();\n        require(_kind < MAX_OPERATIONS, 'Max operations reached');\n        require(enabledOperations[_kind] != _operation, 'Operation already set');\n        require(_operation != address(0), 'Operation address must exist.');\n        enabledOperations[_kind] = _operation;\n\n        emit ControllerOperationSet(_kind, _operation);\n    }\n\n    // ===========  Protocol security related Gov Functions ======\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set-up a pause guardian\n     * @param _guardian               Address of the guardian\n     */\n    function setPauseGuardian(address _guardian) external override {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            'only pause guardian and owner can update pause guardian'\n        );\n        require(msg.sender == owner() || _guardian != address(0), 'Guardian cannot remove himself');\n        // Save current value for inclusion in log\n        address oldPauseGuardian = guardian;\n        // Store pauseGuardian with value newPauseGuardian\n        guardian = _guardian;\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, _guardian);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause the protocol globally in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _state               True to pause, false to unpause.\n     */\n    function setGlobalPause(bool _state) external override returns (bool) {\n        require(\n            msg.sender == guardian || msg.sender == owner() || msg.sender == EMERGENCY_OWNER,\n            'Not enough privileges'\n        );\n        require(!(msg.sender == guardian && _state == false), 'Not enough privileges');\n\n        guardianGlobalPaused = _state;\n\n        emit ActionPaused(_state);\n        return _state;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Pause some smartcontracts in a batch process in case of unexpected issue\n     * Only the governance can unpause it\n     * @param _address             Addresses of protocol smartcontract to be paused\n     * @param _state               Boolean pause state\n     */\n    function setSomePause(address[] memory _address, bool _state) external override returns (bool) {\n        require(\n            msg.sender == guardian || msg.sender == owner() || msg.sender == EMERGENCY_OWNER,\n            'Not enough privileges'\n        );\n        require(!(msg.sender == guardian && _state == false), 'Not enough privileges');\n\n        for (uint256 i = 0; i < _address.length; i++) {\n            guardianPaused[_address[i]] = _state;\n            emit ActionPausedIndividually(_address[i], _state);\n        }\n        return _state;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    function owner() public view override(IBabController, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    function getGardens() external view override returns (address[] memory) {\n        return gardens;\n    }\n\n    function getOperations() external view override returns (address[20] memory) {\n        return enabledOperations;\n    }\n\n    function getReserveAssets() external view override returns (address[] memory) {\n        return reserveAssets;\n    }\n\n    function isValidReserveAsset(address _reserveAsset) external view override returns (bool) {\n        return validReserveAsset[_reserveAsset];\n    }\n\n    function isValidKeeper(address _keeper) external view override returns (bool) {\n        return keeperList[_keeper];\n    }\n\n    /**\n     * Check whether or not there is a global pause or a specific pause of the provided contract address\n     * @param _contract               Smartcontract address to check for a global or specific pause\n     */\n    function isPaused(address _contract) external view override returns (bool) {\n        return guardianGlobalPaused || guardianPaused[_contract];\n    }\n\n    /**\n     * Check if a contract address is a garden or one of the system contracts\n     *\n     * @param  _contractAddress           The contract address to check\n     */\n    function isSystemContract(address _contractAddress) external view override returns (bool) {\n        if (_contractAddress == address(0)) {\n            return false;\n        }\n        return (isGarden[_contractAddress] ||\n            gardenValuer == _contractAddress ||\n            priceOracle == _contractAddress ||\n            gardenFactory == _contractAddress ||\n            masterSwapper == _contractAddress ||\n            strategyFactory == _contractAddress ||\n            rewardsDistributor == _contractAddress ||\n            owner() == _contractAddress ||\n            _contractAddress == address(this) ||\n            _isOperation(_contractAddress) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).strategyMapping(_contractAddress)) ||\n            (isGarden[address(IStrategy(_contractAddress).garden())] &&\n                IGarden(IStrategy(_contractAddress).garden()).isGardenStrategy(_contractAddress)));\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * Hashes the string and returns a bytes32 value\n     */\n    function _nameHash(string memory _name) private pure returns (bytes32) {\n        return keccak256(bytes(_name));\n    }\n\n    function _isOperation(address _address) private view returns (bool) {\n        for (uint8 i = 0; i < MAX_OPERATIONS; i++) {\n            if (_address == enabledOperations[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract BabControllerV17 is BabController {}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {TimeLockedToken} from '../token/TimeLockedToken.sol';\n\n/**\n * @title IRewardsDistributor\n * @author Babylon Finance\n *\n * Interface for the rewards distributor in charge of the BABL Mining Program.\n */\n\ninterface IRewardsDistributor {\n    /* ========== View functions ========== */\n\n    function getStrategyRewards(address _strategy) external view returns (uint256);\n\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view returns (uint256[] memory);\n\n    function getGardenProfitsSharing(address _garden) external view returns (uint256[3] memory);\n\n    function checkMining(uint256 _quarterNum, address _strategy) external view returns (uint256[17] memory);\n\n    function estimateUserRewards(address _strategy, address _contributor) external view returns (uint256[] memory);\n\n    function estimateStrategyRewards(address _strategy) external view returns (uint256);\n\n    function getPriorBalance(\n        address _garden,\n        address _contributor,\n        uint256 _timestamp\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /* ============ External Functions ============ */\n\n    function setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) external;\n\n    function migrateAddressToCheckpoints(address[] memory _garden, bool _toMigrate) external;\n\n    function setBABLMiningParameters(uint256[11] memory _newMiningParams) external;\n\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) external;\n\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _tokenDiff,\n        bool _addOrSubstract\n    ) external;\n\n    function sendBABLToContributor(address _to, uint256 _babl) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGarden.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC1271} from '../interfaces/IERC1271.sol';\n\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IStrategyGarden\n *\n * Interface for functions of the garden\n */\ninterface IStrategyGarden {\n    /* ============ Write ============ */\n\n    function finalizeStrategy(\n        uint256 _profits,\n        int256 _returns,\n        uint256 _burningAmount\n    ) external;\n\n    function allocateCapitalToStrategy(uint256 _capital) external;\n\n    function expireCandidateStrategy(address _strategy) external;\n\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes calldata _opEncodedDatas\n    ) external;\n\n    function updateStrategyRewards(\n        address _strategy,\n        uint256 _newTotalAmount,\n        uint256 _newCapitalReturned\n    ) external;\n\n    function payKeeper(address payable _keeper, uint256 _fee) external;\n}\n\n/**\n * @title IAdminGarden\n *\n * Interface for amdin functions of the Garden\n */\ninterface IAdminGarden {\n    /* ============ Write ============ */\n    function initialize(\n        address _reserveAsset,\n        IBabController _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external payable;\n\n    function makeGardenPublic() external;\n\n    function transferCreatorRights(address _newCreator, uint8 _index) external;\n\n    function addExtraCreators(address[4] memory _newCreators) external;\n\n    function setPublicRights(bool _publicStrategist, bool _publicStewards) external;\n\n    function delegateVotes(address _token, address _address) external;\n\n    function updateCreators(address _newCreator, address[4] memory _newCreators) external;\n\n    function updateGardenParams(uint256[12] memory _newParams) external;\n\n    function verifyGarden(uint256 _verifiedCategory) external;\n\n    function resetHardlock(uint256 _hardlockStartsAt) external;\n}\n\n/**\n * @title IGarden\n *\n * Interface for operating with a Garden.\n */\ninterface ICoreGarden {\n    /* ============ Constructor ============ */\n\n    /* ============ View ============ */\n\n    function privateGarden() external view returns (bool);\n\n    function publicStrategists() external view returns (bool);\n\n    function publicStewards() external view returns (bool);\n\n    function controller() external view returns (IBabController);\n\n    function creator() external view returns (address);\n\n    function isGardenStrategy(address _strategy) external view returns (bool);\n\n    function getContributor(address _contributor)\n        external\n        view\n        returns (\n            uint256 lastDepositAt,\n            uint256 initialDepositAt,\n            uint256 claimedAt,\n            uint256 claimedBABL,\n            uint256 claimedRewards,\n            uint256 withdrawnSince,\n            uint256 totalDeposits,\n            uint256 nonce,\n            uint256 lockedBalance\n        );\n\n    function reserveAsset() external view returns (address);\n\n    function verifiedCategory() external view returns (uint256);\n\n    function canMintNftAfter() external view returns (uint256);\n\n    function hardlockStartsAt() external view returns (uint256);\n\n    function totalContributors() external view returns (uint256);\n\n    function gardenInitializedAt() external view returns (uint256);\n\n    function minContribution() external view returns (uint256);\n\n    function depositHardlock() external view returns (uint256);\n\n    function minLiquidityAsset() external view returns (uint256);\n\n    function minStrategyDuration() external view returns (uint256);\n\n    function maxStrategyDuration() external view returns (uint256);\n\n    function reserveAssetRewardsSetAside() external view returns (uint256);\n\n    function absoluteReturns() external view returns (int256);\n\n    function totalStake() external view returns (uint256);\n\n    function minVotesQuorum() external view returns (uint256);\n\n    function minVoters() external view returns (uint256);\n\n    function maxDepositLimit() external view returns (uint256);\n\n    function strategyCooldownPeriod() external view returns (uint256);\n\n    function getStrategies() external view returns (address[] memory);\n\n    function extraCreators(uint256 index) external view returns (address);\n\n    function getFinalizedStrategies() external view returns (address[] memory);\n\n    function strategyMapping(address _strategy) external view returns (bool);\n\n    function keeperDebt() external view returns (uint256);\n\n    function totalKeeperFees() external view returns (uint256);\n\n    function lastPricePerShare() external view returns (uint256);\n\n    function lastPricePerShareTS() external view returns (uint256);\n\n    function pricePerShareDecayRate() external view returns (uint256);\n\n    function pricePerShareDelta() external view returns (uint256);\n\n    /* ============ Write ============ */\n\n    function deposit(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        address _referrer\n    ) external payable;\n\n    function depositBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        address _to,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _signer,\n        address _referrer,\n        bytes memory signature\n    ) external;\n\n    function withdraw(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external;\n\n    function withdrawBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee,\n        address _signer,\n        bytes memory signature\n    ) external;\n\n    function claimReturns(address[] calldata _finalizedStrategies) external;\n\n    function claimAndStakeReturns(uint256 _minAmountOut, address[] calldata _finalizedStrategies) external;\n\n    function claimRewardsBySig(\n        uint256 _babl,\n        uint256 _profits,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _fee,\n        address signer,\n        bytes memory signature\n    ) external;\n\n    function claimAndStakeRewardsBySig(\n        uint256 _babl,\n        uint256 _profits,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _nonceHeart,\n        uint256 _maxFee,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _signer,\n        bytes memory _signature\n    ) external;\n\n    function stakeBySig(\n        uint256 _amountIn,\n        uint256 _profits,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _nonceHeart,\n        uint256 _maxFee,\n        address _to,\n        uint256 _pricePerShare,\n        address _signer,\n        bytes memory _signature\n    ) external;\n\n    function claimNFT() external;\n}\n\ninterface IERC20Metadata {\n    function name() external view returns (string memory);\n}\n\ninterface IGarden is ICoreGarden, IAdminGarden, IStrategyGarden, IERC20, IERC20Metadata, IERC1271 {\n    struct Contributor {\n        uint256 lastDepositAt;\n        uint256 initialDepositAt;\n        uint256 claimedAt;\n        uint256 claimedBABL;\n        uint256 claimedRewards;\n        uint256 withdrawnSince;\n        uint256 totalDeposits;\n        uint256 nonce;\n        uint256 lockedBalance;\n    }\n}\n"
    },
    "contracts/interfaces/IGardenFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IGardenFactory\n * @author Babylon Finance\n *\n * Interface for the garden factory\n */\ninterface IGardenFactory {\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title IStrategy\n * @author Babylon Finance\n *\n * Interface for strategy\n */\ninterface IStrategy {\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _maxAllocationPercentage,\n        uint256 _maxGasFeePercentage,\n        uint256 _maxTradeSlippagePercentage\n    ) external;\n\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 fee\n    ) external;\n\n    function updateParams(uint256[5] calldata _params) external;\n\n    function sweep(address _token, uint256 _newSlippage) external;\n\n    function updateStrategyRewards(uint256 _newTotalRewards, uint256 _newCapitalReturned) external;\n\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes memory _opEncodedData\n    ) external;\n\n    function executeStrategy(uint256 _capital, uint256 fee) external;\n\n    function getNAV() external view returns (uint256);\n\n    function opEncodedData() external view returns (bytes memory);\n\n    function getOperationsCount() external view returns (uint256);\n\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        returns (\n            uint8,\n            address,\n            bytes memory\n        );\n\n    function finalizeStrategy(\n        uint256 fee,\n        string memory _tokenURI,\n        uint256 _minReserveOut\n    ) external;\n\n    function unwindStrategy(uint256 _amountToUnwind, uint256 _strategyNAV) external;\n\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory);\n\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external;\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external returns (uint256);\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _overrideSlippage\n    ) external returns (uint256);\n\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) external;\n\n    function getStrategyDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        );\n\n    function getStrategyState()\n        external\n        view\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getStrategyRewardsContext()\n        external\n        view\n        returns (\n            address,\n            uint256[] memory,\n            bool[] memory\n        );\n\n    function isStrategyActive() external view returns (bool);\n\n    function getUserVotes(address _address) external view returns (int256);\n\n    function strategist() external view returns (address);\n\n    function enteredAt() external view returns (uint256);\n\n    function enteredCooldownAt() external view returns (uint256);\n\n    function stake() external view returns (uint256);\n\n    function strategyRewards() external view returns (uint256);\n\n    function maxCapitalRequested() external view returns (uint256);\n\n    function maxAllocationPercentage() external view returns (uint256);\n\n    function maxTradeSlippagePercentage() external view returns (uint256);\n\n    function maxGasFeePercentage() external view returns (uint256);\n\n    function expectedReturn() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function totalPositiveVotes() external view returns (uint256);\n\n    function totalNegativeVotes() external view returns (uint256);\n\n    function capitalReturned() external view returns (uint256);\n\n    function capitalAllocated() external view returns (uint256);\n\n    function garden() external view returns (IGarden);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ITokenIdentifier} from './ITokenIdentifier.sol';\n\n/**\n * @title IPriceOracle\n * @author Babylon Finance\n *\n * Interface for interacting with PriceOracle\n */\ninterface IPriceOracle {\n    /* ============ Functions ============ */\n\n    function getPrice(address _assetOne, address _assetTwo) external view returns (uint256);\n\n    function getPriceNAV(address _assetOne, address _assetTwo) external view returns (uint256);\n\n    function updateReserves(address[] memory list) external;\n\n    function updateMaxTwapDeviation(int24 _maxTwapDeviation) external;\n\n    function updateTokenIdentifier(ITokenIdentifier _tokenIdentifier) external;\n\n    function getCompoundExchangeRate(address _asset, address _finalAsset) external view returns (uint256);\n\n    function getCreamExchangeRate(address _asset, address _finalAsset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IIshtarGate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabylonGate} from './IBabylonGate.sol';\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IIshtarGate is IBabylonGate {\n    /* ============ Functions ============ */\n\n    function tokenURI() external view returns (string memory);\n\n    function updateGardenURI(string memory _tokenURI) external;\n}\n"
    },
    "contracts/interfaces/IIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IIntegration\n * @author Babylon Finance\n *\n * Interface for protocol integrations\n */\ninterface IIntegration {\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBabController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IBabController\n * @author Babylon Finance\n *\n * Interface for interacting with BabController\n */\ninterface IBabController {\n    /* ============ Functions ============ */\n\n    function createGarden(\n        address _reserveAsset,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards,\n        uint256[] memory _profitSharing\n    ) external payable returns (address);\n\n    function removeGarden(address _garden) external;\n\n    function addReserveAsset(address _reserveAsset) external;\n\n    function removeReserveAsset(address _reserveAsset) external;\n\n    function updateProtocolWantedAsset(address _wantedAsset, bool _wanted) external;\n\n    function updateGardenAffiliateRate(address _garden, uint256 _affiliateRate) external;\n\n    function addAffiliateReward(\n        address _depositor,\n        address _referrer,\n        uint256 _reserveAmount\n    ) external;\n\n    function claimRewards() external;\n\n    function editPriceOracle(address _priceOracle) external;\n\n    function editMardukGate(address _mardukGate) external;\n\n    function editGardenValuer(address _gardenValuer) external;\n\n    function editTreasury(address _newTreasury) external;\n\n    function editHeart(address _newHeart) external;\n\n    function editRewardsDistributor(address _rewardsDistributor) external;\n\n    function editGardenFactory(address _newGardenFactory) external;\n\n    function editGardenNFT(address _newGardenNFT) external;\n\n    function editCurveMetaRegistry(address _curveMetaRegistry) external;\n\n    function editStrategyNFT(address _newStrategyNFT) external;\n\n    function editStrategyFactory(address _newStrategyFactory) external;\n\n    function setOperation(uint8 _kind, address _operation) external;\n\n    function setMasterSwapper(address _newMasterSwapper) external;\n\n    function addKeeper(address _keeper) external;\n\n    function addKeepers(address[] memory _keepers) external;\n\n    function removeKeeper(address _keeper) external;\n\n    function enableGardenTokensTransfers() external;\n\n    function editLiquidityReserve(address _reserve, uint256 _minRiskyPairLiquidityEth) external;\n\n    function gardenCreationIsOpen() external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function EMERGENCY_OWNER() external view returns (address);\n\n    function guardianGlobalPaused() external view returns (bool);\n\n    function guardianPaused(address _address) external view returns (bool);\n\n    function setPauseGuardian(address _guardian) external;\n\n    function setGlobalPause(bool _state) external returns (bool);\n\n    function setSomePause(address[] memory _address, bool _state) external returns (bool);\n\n    function isPaused(address _contract) external view returns (bool);\n\n    function priceOracle() external view returns (address);\n\n    function gardenValuer() external view returns (address);\n\n    function heart() external view returns (address);\n\n    function gardenNFT() external view returns (address);\n\n    function strategyNFT() external view returns (address);\n\n    function curveMetaRegistry() external view returns (address);\n\n    function rewardsDistributor() external view returns (address);\n\n    function gardenFactory() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function ishtarGate() external view returns (address);\n\n    function mardukGate() external view returns (address);\n\n    function strategyFactory() external view returns (address);\n\n    function masterSwapper() external view returns (address);\n\n    function gardenTokensTransfersEnabled() external view returns (bool);\n\n    function bablMiningProgramEnabled() external view returns (bool);\n\n    function allowPublicGardens() external view returns (bool);\n\n    function enabledOperations(uint256 _kind) external view returns (address);\n\n    function getGardens() external view returns (address[] memory);\n\n    function getReserveAssets() external view returns (address[] memory);\n\n    function getOperations() external view returns (address[20] memory);\n\n    function isGarden(address _garden) external view returns (bool);\n\n    function protocolWantedAssets(address _wantedAsset) external view returns (bool);\n\n    function gardenAffiliateRates(address _wantedAsset) external view returns (uint256);\n\n    function affiliateRewards(address _user) external view returns (uint256);\n\n    function isValidReserveAsset(address _reserveAsset) external view returns (bool);\n\n    function isValidKeeper(address _keeper) external view returns (bool);\n\n    function isSystemContract(address _contractAddress) external view returns (bool);\n\n    function protocolPerformanceFee() external view returns (uint256);\n\n    function protocolManagementFee() external view returns (uint256);\n\n    function minLiquidityPerReserve(address _reserve) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IHypervisor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IHypervisor {\n    // @param deposit0 Amount of token0 transfered from sender to Hypervisor\n    // @param deposit1 Amount of token0 transfered from sender to Hypervisor\n    // @param to Address to which liquidity tokens are minted\n    // @return shares Quantity of liquidity tokens minted as a result of deposit\n    function deposit(\n        uint256 deposit0,\n        uint256 deposit1,\n        address to\n    ) external returns (uint256);\n\n    // @param shares Number of liquidity tokens to redeem as pool assets\n    // @param to Address to which redeemed pool assets are sent\n    // @param from Address from which liquidity tokens are sent\n    // @return amount0 Amount of token0 redeemed by the submitted liquidity tokens\n    // @return amount1 Amount of token1 redeemed by the submitted liquidity tokens\n    function withdraw(\n        uint256 shares,\n        address to,\n        address from\n    ) external returns (uint256, uint256);\n\n    function rebalance(\n        int24 _baseLower,\n        int24 _baseUpper,\n        int24 _limitLower,\n        int24 _limitUpper,\n        address _feeRecipient,\n        int256 swapQuantity\n    ) external;\n\n    function addBaseLiquidity(uint256 amount0, uint256 amount1) external;\n\n    function addLimitLiquidity(uint256 amount0, uint256 amount1) external;\n\n    function pullLiquidity(uint256 shares)\n        external\n        returns (\n            uint256 base0,\n            uint256 base1,\n            uint256 limit0,\n            uint256 limit1\n        );\n\n    function token0() external view returns (IERC20);\n\n    function token1() external view returns (IERC20);\n\n    function pool() external view returns (address);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function approve(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function getTotalAmounts() external view returns (uint256 total0, uint256 total1);\n\n    function pendingFees() external returns (uint256 fees0, uint256 fees1);\n\n    function totalSupply() external view returns (uint256);\n\n    function setMaxTotalSupply(uint256 _maxTotalSupply) external;\n\n    function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external;\n\n    function appendList(address[] memory listed) external;\n\n    function toggleWhitelist() external;\n\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/external/weth/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n */\nlibrary AddressArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Returns true if there are 2 elements that are the same in an array\n     * @param A The input array to search\n     * @return Returns boolean for the first occurrence of a duplicate\n     */\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\n        require(A.length > 0, 'A is empty');\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a) internal pure returns (address[] memory) {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert('Address not in array.');\n        } else {\n            (address[] memory _A, ) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * Removes specified index from array\n     * @param A The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory A, uint256 index) internal pure returns (address[] memory, address) {\n        uint256 length = A.length;\n        require(index < A.length, 'Index must be < A length');\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n\n    /**\n     * Returns the combination of the two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        address[] memory newAddresses = new address[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = 0; j < bLength; j++) {\n            newAddresses[aLength + j] = B[j];\n        }\n        return newAddresses;\n    }\n\n    /*\n      Unfortunately Solidity does not support convertion of the fixed array to dynamic array so these functions are\n      required. This functionality would be supported in the future so these methods can be removed.\n    */\n    function toDynamic(address _one, address _two) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](2);\n        arr[0] = _one;\n        arr[1] = _two;\n        return arr;\n    }\n\n    function toDynamic(\n        address _one,\n        address _two,\n        address _three\n    ) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](3);\n        arr[0] = _one;\n        arr[1] = _two;\n        arr[2] = _three;\n        return arr;\n    }\n\n    function toDynamic(\n        address _one,\n        address _two,\n        address _three,\n        address _four\n    ) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](4);\n        arr[0] = _one;\n        arr[1] = _two;\n        arr[2] = _three;\n        arr[3] = _four;\n        return arr;\n    }\n}\n"
    },
    "contracts/lib/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SafeMath: division by zero');\n        return a / b;\n    }\n}\n"
    },
    "contracts/lib/PreciseUnitMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {LowGasSafeMath} from './LowGasSafeMath.sol';\n\n/**\n * @title PreciseUnitMath\n * @author Set Protocol\n *\n * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n * dYdX's BaseMath library.\n *\n * CHANGELOG:\n * - 9/21/20: Added safePower function\n */\nlibrary PreciseUnitMath {\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // The number One in precise units.\n    uint256 internal constant PRECISE_UNIT = 10**18;\n    int256 internal constant PRECISE_UNIT_INT = 10**18;\n\n    // Max unsigned integer value\n    uint256 internal constant MAX_UINT_256 = type(uint256).max;\n    // Max and min signed integer value\n    int256 internal constant MAX_INT_256 = type(int256).max;\n    int256 internal constant MIN_INT_256 = type(int256).min;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function decimals() internal pure returns (uint256) {\n        return 18;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnitInt() internal pure returns (int256) {\n        return PRECISE_UNIT_INT;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxUint256() internal pure returns (uint256) {\n        return MAX_UINT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function maxInt256() internal pure returns (int256) {\n        return MAX_INT_256;\n    }\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function minInt256() internal pure returns (int256) {\n        return MIN_INT_256;\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n     * significand of a number with 18 decimals precision.\n     */\n    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(b).div(PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n     * of a number with 18 decimals precision.\n     */\n    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down).\n     */\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISE_UNIT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded towards 0).\n     */\n    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return a.mul(PRECISE_UNIT_INT).div(b);\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded up or away from 0).\n     */\n    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, 'Cant divide by 0');\n\n        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n    }\n\n    /**\n     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n     */\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'Cant divide by 0');\n        require(a != MIN_INT_256 || b != -1, 'Invalid input');\n\n        int256 result = a.div(b);\n        if (a ^ b < 0 && a % b != 0) {\n            result -= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Multiplies value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(b), PRECISE_UNIT_INT);\n    }\n\n    /**\n     * @dev Divides value a by value b where rounding is towards the lesser number.\n     * (positive values are rounded towards zero and negative values are rounded away from 0).\n     */\n    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n        return divDown(a.mul(PRECISE_UNIT_INT), b);\n    }\n\n    /**\n     * @dev Performs the power on a specified value, reverts on overflow.\n     */\n    function safePower(uint256 a, uint256 pow) internal pure returns (uint256) {\n        require(a > 0, 'Value must be positive');\n\n        uint256 result = 1;\n        for (uint256 i = 0; i < pow; i++) {\n            uint256 previousResult = result;\n\n            // Using safemath multiplication prevents overflows\n            result = previousResult.mul(a);\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/token/TimeLockedToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {TimeLockRegistry} from './TimeLockRegistry.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {VoteToken} from './VoteToken.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title TimeLockedToken\n * @notice Time Locked ERC20 Token\n * @author Babylon Finance\n * @dev Contract which gives the ability to time-lock tokens specially for vesting purposes usage\n *\n * By overriding the balanceOf() and transfer() functions in ERC20,\n * an account can show its full, post-distribution balance and use it for voting power\n * but only transfer or spend up to an allowed amount\n *\n * A portion of previously non-spendable tokens are allowed to be transferred\n * along the time depending on each vesting conditions, and after all epochs have passed, the full\n * account balance is unlocked. In case on non-completion vesting period, only the Time Lock Registry can cancel\n * the delivery of the pending tokens and only can cancel the remaining locked ones.\n */\n\nabstract contract TimeLockedToken is VoteToken {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new lockout ocurr\n    event NewLockout(\n        address account,\n        uint256 tokenslocked,\n        bool isTeamOrAdvisor,\n        uint256 startingVesting,\n        uint256 endingVesting\n    );\n\n    /// @notice An event that emitted when a new Time Lock is registered\n    event NewTimeLockRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a new Rewards Distributor is registered\n    event NewRewardsDistributorRegistration(address previousAddress, address newAddress);\n\n    /// @notice An event that emitted when a cancellation of Lock tokens is registered\n    event Cancel(address account, uint256 amount);\n\n    /// @notice An event that emitted when a claim of tokens are registered\n    event Claim(address _receiver, uint256 amount);\n\n    /// @notice An event that emitted when a lockedBalance query is done\n    event LockedBalance(address _account, uint256 amount);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyTimeLockRegistry() {\n        require(\n            msg.sender == address(timeLockRegistry),\n            'TimeLockedToken:: onlyTimeLockRegistry: can only be executed by TimeLockRegistry'\n        );\n        _;\n    }\n\n    modifier onlyTimeLockOwner() {\n        if (address(timeLockRegistry) != address(0)) {\n            require(\n                msg.sender == Ownable(timeLockRegistry).owner(),\n                'TimeLockedToken:: onlyTimeLockOwner: can only be executed by the owner of TimeLockRegistry'\n            );\n        }\n        _;\n    }\n    modifier onlyUnpaused() {\n        // Do not execute if Globally or individually paused\n        _require(!IBabController(controller).isPaused(address(this)), Errors.ONLY_UNPAUSED);\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // represents total distribution for locked balances\n    mapping(address => uint256) distribution;\n\n    /// @notice The profile of each token owner under its particular vesting conditions\n    /**\n     * @param team Indicates whether or not is a Team member or Advisor (true = team member/advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct VestedToken {\n        bool teamOrAdvisor;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => VestedToken) public vestedToken;\n\n    // address of Time Lock Registry contract\n    IBabController public controller;\n\n    // address of Time Lock Registry contract\n    TimeLockRegistry public timeLockRegistry;\n\n    // address of Rewards Distriburor contract\n    IRewardsDistributor public rewardsDistributor;\n\n    // Enable Transfer of ERC20 BABL Tokens\n    // Only Minting or transfers from/to TimeLockRegistry and Rewards Distributor can transfer tokens until the protocol is fully decentralized\n    bool private tokenTransfersEnabled;\n    bool private tokenTransfersWereDisabled;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) VoteToken(_name, _symbol) {\n        tokenTransfersEnabled = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disables transfers of ERC20 BABL Tokens\n     */\n    function disableTokensTransfers() external onlyOwner {\n        require(!tokenTransfersWereDisabled, 'BABL must flow');\n        tokenTransfersEnabled = false;\n        tokenTransfersWereDisabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows transfers of ERC20 BABL Tokens\n     * Can only happen after the protocol is fully decentralized.\n     */\n    function enableTokensTransfers() external onlyOwner {\n        tokenTransfersEnabled = true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Time Lock Registry contract to control token vesting conditions\n     *\n     * @notice Set the Time Lock Registry contract to control token vesting conditions\n     * @param newTimeLockRegistry Address of TimeLockRegistry contract\n     */\n    function setTimeLockRegistry(TimeLockRegistry newTimeLockRegistry) external onlyTimeLockOwner returns (bool) {\n        require(address(newTimeLockRegistry) != address(0), 'cannot be zero address');\n        require(address(newTimeLockRegistry) != address(this), 'cannot be this contract');\n        require(address(newTimeLockRegistry) != address(timeLockRegistry), 'must be new TimeLockRegistry');\n        emit NewTimeLockRegistration(address(timeLockRegistry), address(newTimeLockRegistry));\n\n        timeLockRegistry = newTimeLockRegistry;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Set the Rewards Distributor contract to control either BABL Mining or profit rewards\n     *\n     * @notice Set the Rewards Distriburor contract to control both types of rewards (profit and BABL Mining program)\n     * @param newRewardsDistributor Address of Rewards Distributor contract\n     */\n    function setRewardsDistributor(IRewardsDistributor newRewardsDistributor) external onlyOwner returns (bool) {\n        require(address(newRewardsDistributor) != address(0), 'cannot be zero address');\n        require(address(newRewardsDistributor) != address(this), 'cannot be this contract');\n        require(address(newRewardsDistributor) != address(rewardsDistributor), 'must be new Rewards Distributor');\n        emit NewRewardsDistributorRegistration(address(rewardsDistributor), address(newRewardsDistributor));\n\n        rewardsDistributor = newRewardsDistributor;\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Register new token lockup conditions for vested tokens defined only by Time Lock Registry\n     *\n     * @notice Tokens are completely delivered during the registration however lockup conditions apply for vested tokens\n     * locking them according to the distribution epoch periods and the type of recipient (Team, Advisor, Investor)\n     * Emits a transfer event showing a transfer to the recipient\n     * Only the registry can call this function\n     * @param _receiver Address to receive the tokens\n     * @param _amount Tokens to be transferred\n     * @param _profile True if is a Team Member or Advisor\n     * @param _vestingBegin Unix Time when the vesting for that particular address\n     * @param _vestingEnd Unix Time when the vesting for that particular address\n     * @param _lastClaim Unix Time when the claim was done from that particular address\n     *\n     */\n    function registerLockup(\n        address _receiver,\n        uint256 _amount,\n        bool _profile,\n        uint256 _vestingBegin,\n        uint256 _vestingEnd,\n        uint256 _lastClaim\n    ) external onlyTimeLockRegistry returns (bool) {\n        require(balanceOf(msg.sender) >= _amount, 'insufficient balance');\n        require(_receiver != address(0), 'cannot be zero address');\n        require(_receiver != address(this), 'cannot be this contract');\n        require(_receiver != address(timeLockRegistry), 'cannot be the TimeLockRegistry contract itself');\n        require(_receiver != msg.sender, 'the owner cannot lockup itself');\n\n        // update amount of locked distribution\n        distribution[_receiver] = distribution[_receiver].add(_amount);\n\n        VestedToken storage newVestedToken = vestedToken[_receiver];\n\n        newVestedToken.teamOrAdvisor = _profile;\n        newVestedToken.vestingBegin = _vestingBegin;\n        newVestedToken.vestingEnd = _vestingEnd;\n        newVestedToken.lastClaim = _lastClaim;\n\n        // transfer tokens to the recipient\n        _transfer(msg.sender, _receiver, _amount);\n        emit NewLockout(_receiver, _amount, _profile, _vestingBegin, _vestingEnd);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors as it does not apply to investors.\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function cancelVestedTokens(address lockedAccount) external onlyTimeLockRegistry returns (uint256) {\n        return _cancelVestedTokensFromTimeLock(lockedAccount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Each token owner can claim its own specific tokens with its own specific vesting conditions from the Time Lock Registry\n     *\n     * @dev Claim msg.sender tokens (if any available in the registry)\n     */\n    function claimMyTokens() external {\n        // claim msg.sender tokens from timeLockRegistry\n        uint256 amount = timeLockRegistry.claim(msg.sender);\n        // After a proper claim, locked tokens of Team and Advisors profiles are under restricted special vesting conditions so they automatic grant\n        // rights to the Time Lock Registry to only retire locked tokens if non-compliance vesting conditions take places along the vesting periods.\n        // It does not apply to Investors under vesting (their locked tokens cannot be removed).\n        if (vestedToken[msg.sender].teamOrAdvisor == true) {\n            approve(address(timeLockRegistry), amount);\n        }\n        // emit claim event\n        emit Claim(msg.sender, amount);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get unlocked balance for an account\n     *\n     * @notice Get unlocked balance for an account\n     * @param account Account to check\n     * @return Amount that is unlocked and available eg. to transfer\n     */\n    function unlockedBalance(address account) public returns (uint256) {\n        // totalBalance - lockedBalance\n        return balanceOf(account).sub(lockedBalance(account));\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. View the locked balance for an account\n     *\n     * @notice View locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n\n    function viewLockedBalance(address account) public view returns (uint256) {\n        // distribution of locked tokens\n        // get amount from distributions\n\n        uint256 amount = distribution[account];\n        uint256 lockedAmount = amount;\n\n        // Team and investors cannot transfer tokens in the first year\n        if (vestedToken[account].vestingBegin.add(365 days) > block.timestamp && amount != 0) {\n            return lockedAmount;\n        }\n\n        // in case of vesting has passed, all tokens are now available, if no vesting lock is 0 as well\n        if (block.timestamp >= vestedToken[account].vestingEnd || amount == 0) {\n            lockedAmount = 0;\n        } else if (amount != 0) {\n            // in case of still under vesting period, locked tokens are recalculated\n            lockedAmount = amount.mul(vestedToken[account].vestingEnd.sub(block.timestamp)).div(\n                vestedToken[account].vestingEnd.sub(vestedToken[account].vestingBegin)\n            );\n        }\n        return lockedAmount;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get locked balance for an account\n     *\n     * @notice Get locked balance for an account\n     * @param account Account to check\n     * @return Amount locked in the time of checking\n     */\n    function lockedBalance(address account) public returns (uint256) {\n        // get amount from distributions locked tokens (if any)\n        uint256 lockedAmount = viewLockedBalance(account);\n        // in case of vesting has passed, all tokens are now available so we set mapping to 0 only for accounts under vesting\n        if (\n            block.timestamp >= vestedToken[account].vestingEnd &&\n            msg.sender == account &&\n            lockedAmount == 0 &&\n            vestedToken[account].vestingEnd != 0\n        ) {\n            delete distribution[account];\n        }\n        emit LockedBalance(account, lockedAmount);\n        return lockedAmount;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the address of Time Lock Registry\n     *\n     * @notice Get the address of Time Lock Registry\n     * @return Address of the Time Lock Registry\n     */\n    function getTimeLockRegistry() external view returns (address) {\n        return address(timeLockRegistry);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Approval of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Override of \"Approve\" function to allow the `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender` except in the case of spender is Time Lock Registry\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::approve: spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::approve: spender cannot be the msg.sender');\n\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, 'TimeLockedToken::approve: amount exceeds 96 bits');\n        }\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        if ((spender == address(timeLockRegistry)) && (amount < allowance(msg.sender, address(timeLockRegistry)))) {\n            amount = safe96(\n                allowance(msg.sender, address(timeLockRegistry)),\n                'TimeLockedToken::approve: cannot decrease allowance to timelockregistry'\n            );\n        }\n        _approve(msg.sender, spender, amount);\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the Increase of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @dev This is an override with respect to the fulfillment of vesting conditions along the way\n     * However an user can increase allowance many times, it will never be able to transfer locked tokens during vesting period\n     * @return Whether or not the increaseAllowance succeeded\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public override nonReentrant returns (bool) {\n        require(\n            unlockedBalance(msg.sender) >= allowance(msg.sender, spender).add(addedValue) ||\n                spender == address(timeLockRegistry),\n            'TimeLockedToken::increaseAllowance:Not enough unlocked tokens'\n        );\n        require(spender != address(0), 'TimeLockedToken::increaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::increaseAllowance:Spender cannot be the msg.sender');\n        _approve(msg.sender, spender, allowance(msg.sender, spender).add(addedValue));\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the decrease of allowances of ERC20 with special conditions for vesting\n     *\n     * @notice Atomically decrease the allowance granted to `spender` by the caller.\n     *\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an override with respect to the fulfillment of vesting conditions along the way\n     * An user cannot decrease the allowance to the Time Lock Registry who is in charge of vesting conditions\n     * @return Whether or not the decreaseAllowance succeeded\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override nonReentrant returns (bool) {\n        require(spender != address(0), 'TimeLockedToken::decreaseAllowance:Spender cannot be zero address');\n        require(spender != msg.sender, 'TimeLockedToken::decreaseAllowance:Spender cannot be the msg.sender');\n        require(\n            allowance(msg.sender, spender) >= subtractedValue,\n            'TimeLockedToken::decreaseAllowance:Underflow condition'\n        );\n\n        // There is no option to decreaseAllowance to timeLockRegistry in case of vested tokens\n        require(\n            address(spender) != address(timeLockRegistry),\n            'TimeLockedToken::decreaseAllowance:cannot decrease allowance to timeLockRegistry'\n        );\n\n        _approve(msg.sender, spender, allowance(msg.sender, spender).sub(subtractedValue));\n        return true;\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Override the _transfer of ERC20 BABL tokens only allowing the transfer of unlocked tokens\n     *\n     * @dev Transfer function which includes only unlocked tokens\n     * Locked tokens can always be transfered back to the returns address\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal override onlyUnpaused {\n        require(_from != address(0), 'TimeLockedToken:: _transfer: cannot transfer from the zero address');\n        require(_to != address(0), 'TimeLockedToken:: _transfer: cannot transfer to the zero address');\n        require(\n            _to != address(this),\n            'TimeLockedToken:: _transfer: do not transfer tokens to the token contract itself'\n        );\n\n        require(balanceOf(_from) >= _value, 'TimeLockedToken:: _transfer: insufficient balance');\n\n        // check if enough unlocked balance to transfer\n        require(unlockedBalance(_from) >= _value, 'TimeLockedToken:: _transfer: attempting to transfer locked funds');\n        super._transfer(_from, _to, _value);\n        // voting power\n        _moveDelegates(\n            delegates[_from],\n            delegates[_to],\n            safe96(_value, 'TimeLockedToken:: _transfer: uint96 overflow')\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Disable BABL token transfer until certain conditions are met\n     *\n     * @dev Override the _beforeTokenTransfer of ERC20 BABL tokens until certain conditions are met:\n     * Only allowing minting or transfers from Time Lock Registry and Rewards Distributor until transfers are allowed in the controller\n     * Transferring to owner allows re-issuance of funds through registry\n     *\n     * @param _from The address to send tokens from\n     * @param _to The address that will receive the tokens\n     * @param _value The amount of tokens to be transferred\n     */\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _value);\n        _require(\n            _from == address(0) ||\n                _from == address(timeLockRegistry) ||\n                _from == address(rewardsDistributor) ||\n                _to == address(timeLockRegistry) ||\n                tokenTransfersEnabled,\n            Errors.BABL_TRANSFERS_DISABLED\n        );\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel and remove locked tokens due to non-completion of  vesting period\n     * applied only by Time Lock Registry and specifically to Team or Advisors\n     *\n     * @dev Cancel distribution registration\n     * @param lockedAccount that should have its still locked distribution removed due to non-completion of its vesting period\n     */\n    function _cancelVestedTokensFromTimeLock(address lockedAccount) internal onlyTimeLockRegistry returns (uint256) {\n        require(distribution[lockedAccount] != 0, 'TimeLockedToken::cancelTokens:Not registered');\n\n        // get an update on locked amount from distributions at this precise moment\n        uint256 loosingAmount = lockedBalance(lockedAccount);\n\n        require(loosingAmount > 0, 'TimeLockedToken::cancelTokens:There are no more locked tokens');\n        require(\n            vestedToken[lockedAccount].teamOrAdvisor == true,\n            'TimeLockedToken::cancelTokens:cannot cancel locked tokens to Investors'\n        );\n\n        // set distribution mapping to 0\n        delete distribution[lockedAccount];\n\n        // set tokenVested mapping to 0\n        delete vestedToken[lockedAccount];\n\n        // transfer only locked tokens back to TimeLockRegistry Owner (msg.sender)\n        require(\n            transferFrom(lockedAccount, address(timeLockRegistry), loosingAmount),\n            'TimeLockedToken::cancelTokens:Transfer failed'\n        );\n\n        // emit cancel event\n        emit Cancel(lockedAccount, loosingAmount);\n\n        return loosingAmount;\n    }\n}\n"
    },
    "contracts/token/TimeLockRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\n/**\n * @title TimeLockRegistry\n * @notice Register Lockups for TimeLocked ERC20 Token BABL (e.g. vesting)\n * @author Babylon Finance\n * @dev This contract allows owner to register distributions for a TimeLockedToken\n *\n * To register a distribution, register method should be called by the owner.\n * claim() should be called only by the BABL Token smartcontract (modifier onlyBABLToken)\n *  when any account registered to receive tokens make its own claim\n * If case of a mistake, owner can cancel registration before the claim is done by the account\n *\n * Note this contract address must be setup in the TimeLockedToken's contract pointing\n * to interact with (e.g. setTimeLockRegistry() function)\n */\n\ncontract TimeLockRegistry is Ownable {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n\n    event Register(address receiver, uint256 distribution);\n    event Cancel(address receiver, uint256 distribution);\n    event Claim(address account, uint256 distribution);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyBABLToken() {\n        require(msg.sender == address(token), 'only BABL Token');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // time locked token\n    TimeLockedToken public token;\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param receiver Account being registered\n     * @param investorType Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingStarting Date When the vesting begins for such token owner\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    struct Registration {\n        address receiver;\n        uint256 distribution;\n        bool investorType;\n        uint256 vestingStartingDate;\n    }\n\n    /**\n     * @notice The profile of each token owner under vesting conditions and its special conditions\n     * @param team Indicates whether or not is a Team member (true = team member / advisor, false = private investor)\n     * @param vestingBegin When the vesting begins for such token owner\n     * @param vestingEnd When the vesting ends for such token owner\n     * @param lastClaim When the last claim was done\n     */\n    struct TokenVested {\n        bool team;\n        bool cliff;\n        uint256 vestingBegin;\n        uint256 vestingEnd;\n        uint256 lastClaim;\n    }\n\n    /// @notice A record of token owners under vesting conditions for each account, by index\n    mapping(address => TokenVested) public tokenVested;\n\n    // mapping from token owners under vesting conditions to BABL due amount (e.g. SAFT addresses, team members, advisors)\n    mapping(address => uint256) public registeredDistributions;\n\n    // array of all registrations\n    address[] public registrations;\n\n    // total amount of tokens registered\n    uint256 public totalTokens;\n\n    // vesting for Team Members\n    uint256 private constant teamVesting = 365 days * 4;\n\n    // vesting for Investors and Advisors\n    uint256 private constant investorVesting = 365 days * 3;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new Time Lock Registry and gives ownership to sender\n     * @param _token TimeLockedToken contract to use in this registry\n     */\n    constructor(TimeLockedToken _token) {\n        token = _token;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets registrations\n     *\n     * @return  address[]        Returns list of registrations\n     */\n\n    function getRegistrations() external view returns (address[] memory) {\n        return registrations;\n    }\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register multiple investors/team in a batch\n     * @param _registrations Registrations to process\n     */\n    function registerBatch(Registration[] memory _registrations) external onlyOwner {\n        for (uint256 i = 0; i < _registrations.length; i++) {\n            register(\n                _registrations[i].receiver,\n                _registrations[i].distribution,\n                _registrations[i].investorType,\n                _registrations[i].vestingStartingDate\n            );\n        }\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION\n     *\n     * @notice Register new account under vesting conditions (Team, Advisors, Investors e.g. SAFT purchaser)\n     * @param receiver Address belonging vesting conditions\n     * @param distribution Tokens amount that receiver is due to get\n     */\n    function register(\n        address receiver,\n        uint256 distribution,\n        bool investorType,\n        uint256 vestingStartingDate\n    ) public onlyOwner {\n        require(receiver != address(0), 'TimeLockRegistry::register: cannot register the zero address');\n        require(\n            receiver != address(this),\n            'TimeLockRegistry::register: Time Lock Registry contract cannot be an investor'\n        );\n        require(distribution != 0, 'TimeLockRegistry::register: Distribution = 0');\n        require(\n            registeredDistributions[receiver] == 0,\n            'TimeLockRegistry::register:Distribution for this address is already registered'\n        );\n        require(vestingStartingDate >= 1614553200, 'Cannot register earlier than March 2021'); // 1614553200 is UNIX TIME of 2021 March the 1st\n        require(\n            vestingStartingDate <= block.timestamp.add(30 days),\n            'Cannot register more than 30 days ahead in the future'\n        );\n        require(totalTokens.add(distribution) <= IERC20(token).balanceOf(address(this)), 'Not enough tokens');\n\n        totalTokens = totalTokens.add(distribution);\n        // register distribution\n        registeredDistributions[receiver] = distribution;\n        registrations.push(receiver);\n\n        // register token vested conditions\n        TokenVested storage newTokenVested = tokenVested[receiver];\n        newTokenVested.team = investorType;\n        newTokenVested.vestingBegin = vestingStartingDate;\n\n        if (newTokenVested.team == true) {\n            newTokenVested.vestingEnd = vestingStartingDate.add(teamVesting);\n        } else {\n            newTokenVested.vestingEnd = vestingStartingDate.add(investorVesting);\n        }\n        newTokenVested.lastClaim = vestingStartingDate;\n\n        tokenVested[receiver] = newTokenVested;\n\n        // emit register event\n        emit Register(receiver, distribution);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel distribution registration\n     * @dev A claim has not to be done earlier\n     * @param receiver Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelRegistration(address receiver) external onlyOwner returns (bool) {\n        require(registeredDistributions[receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[receiver];\n\n        // set distribution mapping to 0\n        delete registeredDistributions[receiver];\n\n        // set tokenVested mapping to 0\n        delete tokenVested[receiver];\n\n        // remove from the list of all registrations\n        registrations.remove(receiver);\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // emit cancel event\n        emit Cancel(receiver, amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Cancel distribution registration in case of mistake and before a claim is done\n     *\n     * @notice Cancel already delivered tokens. It might only apply when non-completion of vesting period of Team members or Advisors\n     * @dev An automatic override allowance is granted during the claim process\n     * @param account Address that should have it's distribution removed\n     * @return Whether or not it succeeded\n     */\n    function cancelDeliveredTokens(address account) external onlyOwner returns (bool) {\n        uint256 loosingAmount = token.cancelVestedTokens(account);\n\n        // emit cancel event\n        emit Cancel(account, loosingAmount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Recover tokens in Time Lock Registry smartcontract address by the owner\n     *\n     * @notice Send tokens from smartcontract address to the owner.\n     * It might only apply after a cancellation of vested tokens\n     * @param amount Amount to be recovered by the owner of the Time Lock Registry smartcontract from its balance\n     * @return Whether or not it succeeded\n     */\n    function transferToOwner(uint256 amount) external onlyOwner returns (bool) {\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Claim locked tokens by the registered account\n     *\n     * @notice Claim tokens due amount.\n     * @dev Claim is done by the user in the TimeLocked contract and the contract is the only allowed to call\n     * this function on behalf of the user to make the claim\n     * @return The amount of tokens registered and delivered after the claim\n     */\n    function claim(address _receiver) external onlyBABLToken returns (uint256) {\n        require(registeredDistributions[_receiver] != 0, 'Not registered');\n\n        // get amount from distributions\n        uint256 amount = registeredDistributions[_receiver];\n        TokenVested storage claimTokenVested = tokenVested[_receiver];\n\n        claimTokenVested.lastClaim = block.timestamp;\n\n        // set distribution mapping to 0\n        delete registeredDistributions[_receiver];\n\n        // decrease total tokens\n        totalTokens = totalTokens.sub(amount);\n\n        // register lockup in TimeLockedToken\n        // this will transfer funds from this contract and lock them for sender\n        token.registerLockup(\n            _receiver,\n            amount,\n            claimTokenVested.team,\n            claimTokenVested.vestingBegin,\n            claimTokenVested.vestingEnd,\n            claimTokenVested.lastClaim\n        );\n\n        // set tokenVested mapping to 0\n        delete tokenVested[_receiver];\n\n        // emit claim event\n        emit Claim(_receiver, amount);\n\n        return amount;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    function checkVesting(address address_)\n        external\n        view\n        returns (\n            bool team,\n            uint256 start,\n            uint256 end,\n            uint256 last\n        )\n    {\n        TokenVested storage checkTokenVested = tokenVested[address_];\n\n        return (\n            checkTokenVested.team,\n            checkTokenVested.vestingBegin,\n            checkTokenVested.vestingEnd,\n            checkTokenVested.lastClaim\n        );\n    }\n\n    function checkRegisteredDistribution(address address_) external view returns (uint256 amount) {\n        return registeredDistributions[address_];\n    }\n}\n"
    },
    "contracts/token/VoteToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title VoteToken\n * @notice Custom token which tracks voting power for governance\n * @dev This is an abstraction of a fork of the Compound governance contract\n * VoteToken is used by BABL to allow tracking voting power\n * Checkpoints are created every time state is changed which record voting power\n * Inherits standard ERC20 behavior\n */\n\nabstract contract VoteToken is Context, ERC20, Ownable, IVoteToken, ReentrancyGuard {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @dev A record of votes checkpoints for each account, by index\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegating votes from msg.sender to delegatee\n     *\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n\n    function delegate(address delegatee) external override {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Delegate votes using signature to 'delegatee'\n     *\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external override {\n        address signatory;\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        if (prefix) {\n            bytes32 digestHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', digest));\n            signatory = ecrecover(digestHash, v, r, s);\n        } else {\n            signatory = ecrecover(digest, v, r, s);\n        }\n\n        require(balanceOf(signatory) > 0, 'VoteToken::delegateBySig: invalid delegator');\n        require(signatory != address(0), 'VoteToken::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory], 'VoteToken::delegateBySig: invalid nonce');\n        nonces[signatory]++;\n        require(block.timestamp <= expiry, 'VoteToken::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Check Delegate votes using signature to 'delegatee'\n     *\n     * @notice Get current voting power for an account\n     * @param account Account to get voting power for\n     * @return Voting power for an account\n     */\n    function getCurrentVotes(address account) external view virtual override returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Get voting power at a specific block for an account\n     *\n     * @param account Account to get voting power for\n     * @param blockNumber Block to get voting power at\n     * @return Voting power for an account at specific block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view virtual override returns (uint96) {\n        require(blockNumber < block.number, 'BABLToken::getPriorVotes: not yet determined');\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function getMyDelegatee() external view override returns (address) {\n        return delegates[msg.sender];\n    }\n\n    function getDelegatee(address account) external view override returns (address) {\n        return delegates[account];\n    }\n\n    function getCheckpoints(address account, uint32 id)\n        external\n        view\n        override\n        returns (uint32 fromBlock, uint96 votes)\n    {\n        Checkpoint storage getCheckpoint = checkpoints[account][id];\n        return (getCheckpoint.fromBlock, getCheckpoint.votes);\n    }\n\n    function getNumberOfCheckpoints(address account) external view override returns (uint32) {\n        return numCheckpoints[account];\n    }\n\n    /* ============ Internal Only Function ============ */\n\n    /**\n     * GOVERNANCE FUNCTION. Make a delegation\n     *\n     * @dev Internal function to delegate voting power to an account\n     * @param delegator The address of the account delegating votes from\n     * @param delegatee The address to delegate votes to\n     */\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = safe96(_balanceOf(delegator), 'VoteToken::_delegate: uint96 overflow');\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _balanceOf(address account) internal view virtual returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Move the delegates\n     *\n     * @dev Internal function to move delegates between accounts\n     * @param srcRep The address of the account delegating votes from\n     * @param dstRep The address of the account delegating votes to\n     * @param amount The voting power to move\n     */\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            // It must not revert but do nothing in cases of address(0) being part of the move\n            // Sub voting amount to source in case it is not the zero address (e.g. transfers)\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'VoteToken::_moveDelegates: vote amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n            if (dstRep != address(0)) {\n                // Add it to destination in case it is not the zero address (e.g. any transfer of tokens or delegations except a first mint to a specific address)\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'VoteToken::_moveDelegates: vote amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /**\n     * GOVERNANCE FUNCTION. Internal function to write a checkpoint for voting power\n     *\n     * @dev internal function to write a checkpoint for voting power\n     * @param delegatee The address of the account delegating votes to\n     * @param nCheckpoints The num checkpoint\n     * @param oldVotes The previous voting power\n     * @param newVotes The new voting power\n     */\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, 'VoteToken::_writeCheckpoint: block number exceeds 32 bits');\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to get chain ID\n     *\n     * @dev internal function to get chain ID\n     */\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/BabylonErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// solhint-disable\n\n/**\n * @notice Forked from https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/lib/helpers/BalancerErrors.sol\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAB#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAB#\" part is a known constant\n        // (0x42414223): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414223000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Max deposit limit needs to be under the limit\n    uint256 internal constant MAX_DEPOSIT_LIMIT = 0;\n    // Creator needs to deposit\n    uint256 internal constant MIN_CONTRIBUTION = 1;\n    // Min Garden token supply >= 0\n    uint256 internal constant MIN_TOKEN_SUPPLY = 2;\n    // Deposit hardlock needs to be at least 1 block\n    uint256 internal constant DEPOSIT_HARDLOCK = 3;\n    // Needs to be at least the minimum\n    uint256 internal constant MIN_LIQUIDITY = 4;\n    // _reserveAssetQuantity is not equal to msg.value\n    uint256 internal constant MSG_VALUE_DO_NOT_MATCH = 5;\n    // Withdrawal amount has to be equal or less than msg.sender balance\n    uint256 internal constant MSG_SENDER_TOKENS_DO_NOT_MATCH = 6;\n    // Tokens are staked\n    uint256 internal constant TOKENS_STAKED = 7;\n    // Balance too low\n    uint256 internal constant BALANCE_TOO_LOW = 8;\n    // msg.sender doesn't have enough tokens\n    uint256 internal constant MSG_SENDER_TOKENS_TOO_LOW = 9;\n    //  There is an open redemption window already\n    uint256 internal constant REDEMPTION_OPENED_ALREADY = 10;\n    // Cannot request twice in the same window\n    uint256 internal constant ALREADY_REQUESTED = 11;\n    // Rewards and profits already claimed\n    uint256 internal constant ALREADY_CLAIMED = 12;\n    // Value have to be greater than zero\n    uint256 internal constant GREATER_THAN_ZERO = 13;\n    // Must be reserve asset\n    uint256 internal constant MUST_BE_RESERVE_ASSET = 14;\n    // Only contributors allowed\n    uint256 internal constant ONLY_CONTRIBUTOR = 15;\n    // Only controller allowed\n    uint256 internal constant ONLY_CONTROLLER = 16;\n    // Only creator allowed\n    uint256 internal constant ONLY_CREATOR = 17;\n    // Only keeper allowed\n    uint256 internal constant ONLY_KEEPER = 18;\n    // Fee is too high\n    uint256 internal constant FEE_TOO_HIGH = 19;\n    // Only strategy allowed\n    uint256 internal constant ONLY_STRATEGY = 20;\n    // Only active allowed\n    uint256 internal constant ONLY_ACTIVE = 21;\n    // Only inactive allowed\n    uint256 internal constant ONLY_INACTIVE = 22;\n    // Address should be not zero address\n    uint256 internal constant ADDRESS_IS_ZERO = 23;\n    // Not within range\n    uint256 internal constant NOT_IN_RANGE = 24;\n    // Value is too low\n    uint256 internal constant VALUE_TOO_LOW = 25;\n    // Value is too high\n    uint256 internal constant VALUE_TOO_HIGH = 26;\n    // Only strategy or protocol allowed\n    uint256 internal constant ONLY_STRATEGY_OR_CONTROLLER = 27;\n    // Normal withdraw possible\n    uint256 internal constant NORMAL_WITHDRAWAL_POSSIBLE = 28;\n    // User does not have permissions to join garden\n    uint256 internal constant USER_CANNOT_JOIN = 29;\n    // User does not have permissions to add strategies in garden\n    uint256 internal constant USER_CANNOT_ADD_STRATEGIES = 30;\n    // Only Protocol or garden\n    uint256 internal constant ONLY_PROTOCOL_OR_GARDEN = 31;\n    // Only Strategist\n    uint256 internal constant ONLY_STRATEGIST = 32;\n    // Only Integration\n    uint256 internal constant ONLY_INTEGRATION = 33;\n    // Only garden and data not set\n    uint256 internal constant ONLY_GARDEN_AND_DATA_NOT_SET = 34;\n    // Only active garden\n    uint256 internal constant ONLY_ACTIVE_GARDEN = 35;\n    // Contract is not a garden\n    uint256 internal constant NOT_A_GARDEN = 36;\n    // Not enough tokens\n    uint256 internal constant STRATEGIST_TOKENS_TOO_LOW = 37;\n    // Stake is too low\n    uint256 internal constant STAKE_HAS_TO_AT_LEAST_ONE = 38;\n    // Duration must be in range\n    uint256 internal constant DURATION_MUST_BE_IN_RANGE = 39;\n    // Max Capital Requested\n    uint256 internal constant MAX_CAPITAL_REQUESTED = 41;\n    // Votes are already resolved\n    uint256 internal constant VOTES_ALREADY_RESOLVED = 42;\n    // Voting window is closed\n    uint256 internal constant VOTING_WINDOW_IS_OVER = 43;\n    // Strategy needs to be active\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_ACTIVE = 44;\n    // Max capital reached\n    uint256 internal constant MAX_CAPITAL_REACHED = 45;\n    // Capital is less then rebalance\n    uint256 internal constant CAPITAL_IS_LESS_THAN_REBALANCE = 46;\n    // Strategy is in cooldown period\n    uint256 internal constant STRATEGY_IN_COOLDOWN = 47;\n    // Strategy is not executed\n    uint256 internal constant STRATEGY_IS_NOT_EXECUTED = 48;\n    // Strategy is not over yet\n    uint256 internal constant STRATEGY_IS_NOT_OVER_YET = 49;\n    // Strategy is already finalized\n    uint256 internal constant STRATEGY_IS_ALREADY_FINALIZED = 50;\n    // No capital to unwind\n    uint256 internal constant STRATEGY_NO_CAPITAL_TO_UNWIND = 51;\n    // Strategy needs to be inactive\n    uint256 internal constant STRATEGY_NEEDS_TO_BE_INACTIVE = 52;\n    // Duration needs to be less\n    uint256 internal constant DURATION_NEEDS_TO_BE_LESS = 53;\n    // Can't sweep reserve asset\n    uint256 internal constant CANNOT_SWEEP_RESERVE_ASSET = 54;\n    // Voting window is opened\n    uint256 internal constant VOTING_WINDOW_IS_OPENED = 55;\n    // Strategy is executed\n    uint256 internal constant STRATEGY_IS_EXECUTED = 56;\n    // Min Rebalance Capital\n    uint256 internal constant MIN_REBALANCE_CAPITAL = 57;\n    // Not a valid strategy NFT\n    uint256 internal constant NOT_STRATEGY_NFT = 58;\n    // Garden Transfers Disabled\n    uint256 internal constant GARDEN_TRANSFERS_DISABLED = 59;\n    // Tokens are hardlocked\n    uint256 internal constant TOKENS_HARDLOCKED = 60;\n    // Max contributors reached\n    uint256 internal constant MAX_CONTRIBUTORS = 61;\n    // BABL Transfers Disabled\n    uint256 internal constant BABL_TRANSFERS_DISABLED = 62;\n    // Strategy duration range error\n    uint256 internal constant DURATION_RANGE = 63;\n    // Checks the min amount of voters\n    uint256 internal constant MIN_VOTERS_CHECK = 64;\n    // Ge contributor power error\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_WINDOW = 65;\n    // Not enough reserve set aside\n    uint256 internal constant NOT_ENOUGH_RESERVE = 66;\n    // Garden is already public\n    uint256 internal constant GARDEN_ALREADY_PUBLIC = 67;\n    // Withdrawal with penalty\n    uint256 internal constant WITHDRAWAL_WITH_PENALTY = 68;\n    // Withdrawal with penalty\n    uint256 internal constant ONLY_MINING_ACTIVE = 69;\n    // Overflow in supply\n    uint256 internal constant OVERFLOW_IN_SUPPLY = 70;\n    // Overflow in power\n    uint256 internal constant OVERFLOW_IN_POWER = 71;\n    // Not a system contract\n    uint256 internal constant NOT_A_SYSTEM_CONTRACT = 72;\n    // Strategy vs Garden mismatch\n    uint256 internal constant STRATEGY_GARDEN_MISMATCH = 73;\n    // Minimum quarters is 1\n    uint256 internal constant QUARTERS_MIN_1 = 74;\n    // Too many strategy operations\n    uint256 internal constant TOO_MANY_OPS = 75;\n    // Only operations\n    uint256 internal constant ONLY_OPERATION = 76;\n    // Strat params wrong length\n    uint256 internal constant STRAT_PARAMS_LENGTH = 77;\n    // Garden params wrong length\n    uint256 internal constant GARDEN_PARAMS_LENGTH = 78;\n    // Token names too long\n    uint256 internal constant NAME_TOO_LONG = 79;\n    // Contributor power overflows over garden power\n    uint256 internal constant CONTRIBUTOR_POWER_OVERFLOW = 80;\n    // Contributor power window out of bounds\n    uint256 internal constant CONTRIBUTOR_POWER_CHECK_DEPOSITS = 81;\n    // Contributor power window out of bounds\n    uint256 internal constant NO_REWARDS_TO_CLAIM = 82;\n    // Pause guardian paused this operation\n    uint256 internal constant ONLY_UNPAUSED = 83;\n    // Reentrant intent\n    uint256 internal constant REENTRANT_CALL = 84;\n    // Reserve asset not supported\n    uint256 internal constant RESERVE_ASSET_NOT_SUPPORTED = 85;\n    // Withdrawal/Deposit check min amount received\n    uint256 internal constant RECEIVE_MIN_AMOUNT = 86;\n    // Total Votes has to be positive\n    uint256 internal constant TOTAL_VOTES_HAVE_TO_BE_POSITIVE = 87;\n    // Signer has to be valid\n    uint256 internal constant INVALID_SIGNER = 88;\n    // Nonce has to be valid\n    uint256 internal constant INVALID_NONCE = 89;\n    // Garden is not public\n    uint256 internal constant GARDEN_IS_NOT_PUBLIC = 90;\n    // Setting max contributors\n    uint256 internal constant MAX_CONTRIBUTORS_SET = 91;\n    // Profit sharing mismatch for customized gardens\n    uint256 internal constant PROFIT_SHARING_MISMATCH = 92;\n    // Max allocation percentage\n    uint256 internal constant MAX_STRATEGY_ALLOCATION_PERCENTAGE = 93;\n    // new creator must not exist\n    uint256 internal constant NEW_CREATOR_MUST_NOT_EXIST = 94;\n    // only first creator can add\n    uint256 internal constant ONLY_FIRST_CREATOR_CAN_ADD = 95;\n    // invalid address\n    uint256 internal constant INVALID_ADDRESS = 96;\n    // creator can only renounce in some circumstances\n    uint256 internal constant CREATOR_CANNOT_RENOUNCE = 97;\n    // no price for trade\n    uint256 internal constant NO_PRICE_FOR_TRADE = 98;\n    // Max capital requested\n    uint256 internal constant ZERO_CAPITAL_REQUESTED = 99;\n    // Unwind capital above the limit\n    uint256 internal constant INVALID_CAPITAL_TO_UNWIND = 100;\n    // Mining % sharing does not match\n    uint256 internal constant INVALID_MINING_VALUES = 101;\n    // Max trade slippage percentage\n    uint256 internal constant MAX_TRADE_SLIPPAGE_PERCENTAGE = 102;\n    // Max gas fee percentage\n    uint256 internal constant MAX_GAS_FEE_PERCENTAGE = 103;\n    // Mismatch between voters and votes\n    uint256 internal constant INVALID_VOTES_LENGTH = 104;\n    // Only Rewards Distributor\n    uint256 internal constant ONLY_RD = 105;\n    // Fee is too LOW\n    uint256 internal constant FEE_TOO_LOW = 106;\n    // Only governance or emergency\n    uint256 internal constant ONLY_GOVERNANCE_OR_EMERGENCY = 107;\n    // Strategy invalid reserve asset amount\n    uint256 internal constant INVALID_RESERVE_AMOUNT = 108;\n    // Heart only pumps once a week\n    uint256 internal constant HEART_ALREADY_PUMPED = 109;\n    // Heart needs garden votes to pump\n    uint256 internal constant HEART_VOTES_MISSING = 110;\n    // Not enough fees for heart\n    uint256 internal constant HEART_MINIMUM_FEES = 111;\n    // Invalid heart votes length\n    uint256 internal constant HEART_VOTES_LENGTH = 112;\n    // Heart LP tokens not received\n    uint256 internal constant HEART_LP_TOKENS = 113;\n    // Heart invalid asset to lend\n    uint256 internal constant HEART_ASSET_LEND_INVALID = 114;\n    // Heart garden not set\n    uint256 internal constant HEART_GARDEN_NOT_SET = 115;\n    // Heart asset to lend is the same\n    uint256 internal constant HEART_ASSET_LEND_SAME = 116;\n    // Heart invalid ctoken\n    uint256 internal constant HEART_INVALID_CTOKEN = 117;\n    // Price per share is wrong\n    uint256 internal constant PRICE_PER_SHARE_WRONG = 118;\n    // Heart asset to purchase is same\n    uint256 internal constant HEART_ASSET_PURCHASE_INVALID = 119;\n    // Reset hardlock bigger than timestamp\n    uint256 internal constant RESET_HARDLOCK_INVALID = 120;\n    // Invalid referrer\n    uint256 internal constant INVALID_REFERRER = 121;\n    // Only Heart Garden\n    uint256 internal constant ONLY_HEART_GARDEN = 122;\n    // Max BABL Cap to claim by sig\n    uint256 internal constant MAX_BABL_CAP_REACHED = 123;\n    // Not enough BABL\n    uint256 internal constant NOT_ENOUGH_BABL = 124;\n    // Claim garden NFT\n    uint256 internal constant CLAIM_GARDEN_NFT = 125;\n    // Not enough collateral\n    uint256 internal constant NOT_ENOUGH_COLLATERAL = 126;\n    // Amount too low\n    uint256 internal constant AMOUNT_TOO_LOW = 127;\n    // Amount too high\n    uint256 internal constant AMOUNT_TOO_HIGH = 128;\n    // Not enough to repay debt\n    uint256 internal constant SLIPPAGE_TOO_HIH = 129;\n    // Invalid amount\n    uint256 internal constant INVALID_AMOUNT = 130;\n    // Not enough BABL\n    uint256 internal constant NOT_ENOUGH_AMOUNT = 131;\n}\n"
    },
    "contracts/interfaces/IVoteToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IVoteToken {\n    function delegate(address delegatee) external;\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bool prefix\n    ) external;\n\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function getMyDelegatee() external view returns (address);\n\n    function getDelegatee(address account) external view returns (address);\n\n    function getCheckpoints(address account, uint32 id) external view returns (uint32 fromBlock, uint96 votes);\n\n    function getNumberOfCheckpoints(address account) external view returns (uint32);\n}\n\ninterface IVoteTokenWithERC20 is IVoteToken, IERC20 {}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/interfaces/ITokenIdentifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ICurveMetaRegistry} from './ICurveMetaRegistry.sol';\n\n/**\n * @title IPriceOracle\n * @author Babylon Finance\n *\n * Interface for interacting with PriceOracle\n */\ninterface ITokenIdentifier {\n    /* ============ Functions ============ */\n\n    function identifyTokens(\n        address _tokenIn,\n        address _tokenOut,\n        ICurveMetaRegistry _curveMetaRegistry\n    )\n        external\n        view\n        returns (\n            uint8,\n            uint8,\n            address,\n            address\n        );\n\n    function updateYearnVault(address[] calldata _vaults, bool[] calldata _values) external;\n\n    function updateVisor(address[] calldata _vaults, bool[] calldata _values) external;\n\n    function updateSynth(address[] calldata _synths, bool[] calldata _values) external;\n\n    function updateCreamPair(address[] calldata _creamTokens, address[] calldata _underlyings) external;\n\n    function updateAavePair(address[] calldata _aaveTokens, address[] calldata _underlyings) external;\n\n    function updateCompoundPair(address[] calldata _cTokens, address[] calldata _underlyings) external;\n}\n"
    },
    "contracts/interfaces/ICurveMetaRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title ICurveMetaRegistry\n * @author Babylon Finance\n *\n * Interface for interacting with all the curve registries\n */\ninterface ICurveMetaRegistry {\n    /* ============ Functions ============ */\n\n    function updatePoolsList() external;\n\n    function updateCryptoRegistries() external;\n\n    /* ============ View Functions ============ */\n\n    function isPool(address _poolAddress) external view returns (bool);\n\n    function getCoinAddresses(address _pool, bool _getUnderlying) external view returns (address[8] memory);\n\n    function getNCoins(address _pool) external view returns (uint256);\n\n    function getLpToken(address _pool) external view returns (address);\n\n    function getPoolFromLpToken(address _lpToken) external view returns (address);\n\n    function getVirtualPriceFromLpToken(address _pool) external view returns (uint256);\n\n    function isMeta(address _pool) external view returns (bool);\n\n    function getUnderlyingAndRate(address _pool, uint256 _i) external view returns (address, uint256);\n\n    function findPoolForCoins(\n        address _fromToken,\n        address _toToken,\n        uint256 _i\n    ) external view returns (address);\n\n    function getCoinIndices(\n        address _pool,\n        address _fromToken,\n        address _toToken\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        );\n}\n"
    },
    "contracts/interfaces/IBabylonGate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IBabylonGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Guestlists\n */\ninterface IBabylonGate {\n    /* ============ Functions ============ */\n\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external returns (uint256);\n\n    function setCreatorPermissions(address _user, bool _canCreate) external returns (uint256);\n\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external returns (bool);\n\n    function maxNumberOfInvites() external view returns (uint256);\n\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external;\n\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms) external returns (bool);\n\n    function canCreate(address _user) external view returns (bool);\n\n    function canJoinAGarden(address _garden, address _user) external view returns (bool);\n\n    function canVoteInAGarden(address _garden, address _user) external view returns (bool);\n\n    function canAddStrategiesInAGarden(address _garden, address _user) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/viewer/StrategyViewer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IGardenViewer, IStrategyViewer} from '../interfaces/IViewer.sol';\n\n/**\n * @title GardenViewer\n * @author Babylon Finance\n *\n * Class that holds common view functions to retrieve garden information effectively\n */\ncontract StrategyViewer is IStrategyViewer {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using Math for int256;\n    using SafeDecimalMath for uint256;\n\n    IBabController private immutable controller;\n\n    constructor(IBabController _controller) {\n        controller = _controller;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets complete strategy details\n     *\n     * @param _strategy            Address of the strategy to fetch\n     * @return                     All strategy details\n     */\n    function getCompleteStrategy(address _strategy)\n        external\n        view\n        override\n        returns (\n            address,\n            string memory,\n            uint256[16] memory,\n            bool[] memory,\n            uint256[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        bool[] memory status = new bool[](3);\n        uint256[] memory ts = new uint256[](4);\n        // ts[0]: executedAt, ts[1]: exitedAt, ts[2]: updatedAt\n        (, status[0], status[1], status[2], ts[0], ts[1], ts[2]) = strategy.getStrategyState();\n        uint256 rewards =\n            ts[1] != 0 ? IRewardsDistributor(controller.rewardsDistributor()).getStrategyRewards(_strategy) : 0;\n        ts[3] = strategy.enteredCooldownAt();\n        return (\n            strategy.strategist(),\n            IStrategyNFT(controller.strategyNFT()).getStrategyName(_strategy),\n            [\n                strategy.getOperationsCount(),\n                strategy.stake(),\n                strategy.totalPositiveVotes(),\n                strategy.totalNegativeVotes(),\n                strategy.capitalAllocated(),\n                strategy.capitalReturned(),\n                strategy.duration(),\n                strategy.expectedReturn(),\n                strategy.maxCapitalRequested(),\n                strategy.enteredAt(),\n                strategy.getNAV(),\n                rewards,\n                strategy.maxAllocationPercentage(),\n                strategy.maxGasFeePercentage(),\n                strategy.maxTradeSlippagePercentage(),\n                strategy.isStrategyActive()\n                    ? IRewardsDistributor(controller.rewardsDistributor()).estimateStrategyRewards(_strategy)\n                    : 0\n            ],\n            status,\n            ts\n        );\n    }\n\n    function getOperationsStrategy(address _strategy)\n        external\n        view\n        override\n        returns (\n            uint8[] memory,\n            address[] memory,\n            bytes[] memory\n        )\n    {\n        IStrategy strategy = IStrategy(_strategy);\n        uint256 count = strategy.getOperationsCount();\n        uint8[] memory types = new uint8[](count);\n        address[] memory integrations = new address[](count);\n        bytes[] memory datas = new bytes[](count);\n\n        for (uint8 i = 0; i < count; i++) {\n            (types[i], integrations[i], datas[i]) = strategy.getOperationByIndex(i);\n        }\n        return (types, integrations, datas);\n    }\n\n    function getUserStrategyActions(address[] memory _strategies, address _user)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 strategiesCreated;\n        uint256 totalVotes;\n        for (uint8 i = 0; i < _strategies.length; i++) {\n            IStrategy strategy = IStrategy(_strategies[i]);\n            if (strategy.strategist() == _user) {\n                strategiesCreated = strategiesCreated.add(1);\n            }\n            int256 votes = strategy.getUserVotes(_user);\n            if (votes != 0) {\n                totalVotes = totalVotes.add(uint256(Math.abs(votes)));\n            }\n        }\n        return (strategiesCreated, totalVotes);\n    }\n\n    /* ============ Private Functions ============ */\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/lib/SafeDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nlibrary SafeDecimalMath {\n    using LowGasSafeMath for uint256;\n\n    /* Number of decimal places in the representations. */\n    uint8 internal constant decimals = 18;\n\n    /* The number representing 1.0. */\n    uint256 internal constant UNIT = 10**uint256(decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() internal pure returns (uint256) {\n        return UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint256 x,\n        uint256 y,\n        uint256 precisionUnit\n    ) private pure returns (uint256) {\n        uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * Normalizing amount decimals between tokens\n     * @param _from       ERC20 asset address\n     * @param _to     ERC20 asset address\n     * @param _amount Value _to normalize (e.g. capital)\n     */\n    function normalizeAmountTokens(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        uint256 fromDecimals = _isETH(_from) ? 18 : ERC20(_from).decimals();\n        uint256 toDecimals = _isETH(_to) ? 18 : ERC20(_to).decimals();\n\n        if (fromDecimals == toDecimals) {\n            return _amount;\n        }\n        if (toDecimals > fromDecimals) {\n            return _amount.mul(10**(toDecimals - (fromDecimals)));\n        }\n        return _amount.div(10**(fromDecimals - (toDecimals)));\n    }\n\n    function _isETH(address _address) internal pure returns (bool) {\n        return _address == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || _address == address(0);\n    }\n}\n"
    },
    "contracts/lib/Math.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n    Original version by Synthetix.io\n    https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n\n    Adapted by Babylon Finance.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.7.6;\n\n// Libraries\nimport './SafeDecimalMath.sol';\n\n// https://docs.synthetix.io/contracts/source/libraries/math\nlibrary Math {\n    using LowGasSafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /**\n     * @dev Uses \"exponentiation by squaring\" algorithm where cost is 0(logN)\n     * vs 0(N) for naive repeated multiplication.\n     * Calculates x^n with x as fixed-point and n as regular unsigned int.\n     * Calculates to 18 digits of precision with SafeDecimalMath.unit()\n     */\n    function powDecimal(uint256 x, uint256 n) internal pure returns (uint256) {\n        // https://mpark.github.io/programming/2014/08/18/exponentiation-by-squaring/\n\n        uint256 result = SafeDecimalMath.unit();\n        while (n > 0) {\n            if (n % 2 != 0) {\n                result = result.multiplyDecimal(x);\n            }\n            x = x.multiplyDecimal(x);\n            n /= 2;\n        }\n        return result;\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n}\n"
    },
    "contracts/interfaces/IGardenValuer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\ninterface IGardenValuer {\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256);\n\n    function getLossesGarden(address _garden, uint256 _since) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IMardukGate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabylonGate} from './IBabylonGate.sol';\n\n/**\n * @title IMardukGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IMardukGate is IBabylonGate {\n    /* ============ Functions ============ */\n\n    function canAccessBeta(address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IGardenNFT.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IGardenNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Garden NFT.\n */\ninterface IGardenNFT {\n    function grantGardenNFT(address _user) external returns (uint256);\n\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external;\n\n    function gardenTokenURIs(address _garden) external view returns (string memory);\n\n    function gardenSeeds(address _garden) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStrategyNFT.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IBabController} from './IBabController.sol';\n\n/**\n * @title IStrategyNFT\n * @author Babylon Finance\n *\n * Interface for operating with a Strategy NFT.\n */\ninterface IStrategyNFT {\n    struct StratDetail {\n        string name;\n        string symbol;\n        uint256 tokenId;\n    }\n\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI) external returns (uint256);\n\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external;\n\n    function getStrategyTokenURI(address _stratgy) external view returns (string memory);\n\n    function getStrategyName(address _strategy) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IViewer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\n\ninterface IStrategyViewer {\n    function getCompleteStrategy(address _strategy)\n        external\n        view\n        returns (\n            address,\n            string memory,\n            uint256[16] memory,\n            bool[] memory,\n            uint256[] memory\n        );\n\n    function getOperationsStrategy(address _strategy)\n        external\n        view\n        returns (\n            uint8[] memory,\n            address[] memory,\n            bytes[] memory\n        );\n\n    function getUserStrategyActions(address[] memory _strategies, address _user)\n        external\n        view\n        returns (uint256, uint256);\n}\n\ninterface IGardenViewer {\n    struct PartialGardenInfo {\n        address addr;\n        string name;\n        bool publicLP;\n        uint256 verified;\n        uint256 totalContributors;\n        address reserveAsset;\n        uint256 netAssetValue;\n    }\n\n    function getGardenPrincipal(address _garden) external view returns (uint256);\n\n    function getGardenDetails(address _garden)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            address[5] memory,\n            address,\n            bool[4] memory,\n            address[] memory,\n            address[] memory,\n            uint256[13] memory,\n            uint256[10] memory,\n            uint256[3] memory\n        );\n\n    function getGardenPermissions(address _garden, address _user)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        );\n\n    function getGardensUser(address _user, uint256 _offset)\n        external\n        view\n        returns (\n            address[] memory,\n            bool[] memory,\n            PartialGardenInfo[] memory\n        );\n\n    function getGardenUserAvgPricePerShare(IGarden _garden, address _user) external view returns (uint256);\n\n    function getPotentialVotes(address _garden, address[] calldata _members) external view returns (uint256);\n\n    function getContributor(IGarden _garden, address _user) external view returns (uint256[10] memory);\n\n    function getContributionAndRewards(IGarden _garden, address _user)\n        external\n        view\n        returns (\n            uint256[10] memory,\n            uint256[] memory,\n            uint256[] memory\n        );\n\n    function getPriceAndLiquidity(address _tokenIn, address _reserveAsset) external view returns (uint256, uint256);\n\n    function getAllProphets(address _address) external view returns (uint256[] memory);\n}\n\ninterface IHeartViewer {\n    function heart() external view returns (IHeart);\n\n    function getAllHeartDetails()\n        external\n        view\n        returns (\n            address[2] memory, // address of the heart garden\n            uint256[7] memory, // total stats\n            uint256[] memory, // fee weights\n            address[] memory, // voted gardens\n            uint256[] memory, // garden weights\n            uint256[2] memory, // weekly babl reward\n            uint256[2] memory, // dates\n            uint256[2] memory // liquidity\n        );\n\n    function getGovernanceProposals(uint256[] calldata _ids)\n        external\n        view\n        returns (\n            address[] memory, // proposers\n            uint256[] memory, // endBlocks\n            uint256[] memory, // for votes - against votes\n            uint256[] memory // state\n        );\n\n    function getBondDiscounts(address[] calldata _assets) external view returns (uint256[] memory);\n}\n\ninterface IViewer is IGardenViewer, IHeartViewer, IStrategyViewer {}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/IHeart.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {IGarden} from './IGarden.sol';\n\n/**\n * @title IHeart\n * @author Babylon Finance\n *\n * Interface for interacting with the Heart\n */\ninterface IHeart {\n    // View functions\n\n    function getVotedGardens() external view returns (address[] memory);\n\n    function heartGarden() external view returns (IGarden);\n\n    function getGardenWeights() external view returns (uint256[] memory);\n\n    function minAmounts(address _reserve) external view returns (uint256);\n\n    function assetToCToken(address _asset) external view returns (address);\n\n    function bondAssets(address _asset) external view returns (uint256);\n\n    function assetToLend() external view returns (address);\n\n    function assetForPurchases() external view returns (address);\n\n    function lastPumpAt() external view returns (uint256);\n\n    function lastVotesAt() external view returns (uint256);\n\n    function tradeSlippage() external view returns (uint256);\n\n    function weeklyRewardAmount() external view returns (uint256);\n\n    function bablRewardLeft() external view returns (uint256);\n\n    function getFeeDistributionWeights() external view returns (uint256[] memory);\n\n    function getTotalStats() external view returns (uint256[7] memory);\n\n    function votedGardens(uint256 _index) external view returns (address);\n\n    function gardenWeights(uint256 _index) external view returns (uint256);\n\n    function feeDistributionWeights(uint256 _index) external view returns (uint256);\n\n    function totalStats(uint256 _index) external view returns (uint256);\n\n    // Non-view\n\n    function pump() external;\n\n    function voteProposal(uint256 _proposalId, bool _isApprove) external;\n\n    function resolveGardenVotesAndPump(address[] memory _gardens, uint256[] memory _weights) external;\n\n    function resolveGardenVotes(address[] memory _gardens, uint256[] memory _weights) external;\n\n    function updateMarkets() external;\n\n    function setHeartGardenAddress(address _heartGarden) external;\n\n    function updateFeeWeights(uint256[] calldata _feeWeights) external;\n\n    function updateAssetToLend(address _assetToLend) external;\n\n    function updateAssetToPurchase(address _purchaseAsset) external;\n\n    function updateBond(address _assetToBond, uint256 _bondDiscount) external;\n\n    function lendFusePool(address _assetToLend, uint256 _lendAmount) external;\n\n    function borrowFusePool(address _assetToBorrow, uint256 _borrowAmount) external;\n\n    function repayFusePool(address _borrowedAsset, uint256 _amountToRepay) external;\n\n    function protectBABL(\n        uint256 _bablPriceProtectionAt,\n        uint256 _bablPrice,\n        uint256 _pricePurchasingAsset,\n        uint256 _slippage,\n        address _hopToken\n    ) external;\n\n    function trade(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAmount,\n        uint256 _minAmount\n    ) external;\n\n    function sellWantedAssetToHeart(address _assetToSell, uint256 _amountToSell) external;\n\n    function addReward(uint256 _bablAmount, uint256 _weeklyRate) external;\n\n    function setMinTradeAmount(address _asset, uint256 _minAmount) external;\n\n    function setTradeSlippage(uint256 _tradeSlippage) external;\n\n    function bondAsset(\n        address _assetToBond,\n        uint256 _amountToBond,\n        uint256 _minAmountOut,\n        address _referrer\n    ) external;\n\n    function bondAssetBySig(\n        address _assetToBond,\n        uint256 _amountToBond,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _priceInBABL,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _contributor,\n        address _referrer,\n        bytes memory _signature\n    ) external;\n}\n"
    },
    "contracts/viewer/HeartViewer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\nimport {IHypervisor} from '../interfaces/IHypervisor.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IHeartViewer} from '../interfaces/IViewer.sol';\nimport {IGovernor} from '../interfaces/external/oz/IGovernor.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {ControllerLib} from '../lib/ControllerLib.sol';\n\n/**\n * @title HeartViewer\n * @author Babylon Finance\n *\n * Class that holds common view functions to retrieve heart and governance information effectively\n */\ncontract HeartViewer is IHeartViewer {\n    using SafeMath for uint256;\n    using ControllerLib for IBabController;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Variables ============ */\n\n    IBabController public immutable controller;\n    IGovernor public immutable governor;\n    IHeart public immutable override heart;\n    IHypervisor public constant visor = IHypervisor(0xF19F91d7889668A533F14d076aDc187be781a458);\n    IHypervisor public constant visor_full = IHypervisor(0x5e6c481dE496554b66657Dd1CA1F70C61cf11660);\n\n    /* ============ External function  ============ */\n\n    constructor(\n        IBabController _controller,\n        IGovernor _governor,\n        IHeart _heart\n    ) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(address(_governor) != address(0), 'Governor must exist');\n\n        controller = _controller;\n        governor = _governor;\n        heart = _heart;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets all the heart details in one view call\n     */\n    function getAllHeartDetails()\n        external\n        view\n        override\n        returns (\n            address[2] memory, // address of the heart garden\n            uint256[7] memory, // total stats\n            uint256[] memory, // fee weights\n            address[] memory, // voted gardens\n            uint256[] memory, // garden weights\n            uint256[2] memory, // weekly babl reward\n            uint256[2] memory, // dates\n            uint256[2] memory // liquidity\n        )\n    {\n        (uint256 wethAmount, uint256 bablAmount) = visor.getTotalAmounts();\n        (uint256 wethAmountF, uint256 bablAmountF) = visor_full.getTotalAmounts();\n\n        return (\n            [address(heart.heartGarden()), heart.assetToLend()],\n            heart.getTotalStats(),\n            heart.getFeeDistributionWeights(),\n            heart.getVotedGardens(),\n            heart.getGardenWeights(),\n            [heart.bablRewardLeft(), heart.weeklyRewardAmount()],\n            [heart.lastPumpAt(), heart.lastVotesAt()],\n            [wethAmount.add(wethAmountF), bablAmount.add(bablAmountF)]\n        );\n    }\n\n    function getBondDiscounts(address[] calldata _assets) external view override returns (uint256[] memory) {\n        uint256[] memory discounts = new uint256[](_assets.length);\n        for (uint256 i = 0; i < _assets.length; i++) {\n            discounts[i] = heart.bondAssets(_assets[i]);\n        }\n        return discounts;\n    }\n\n    function getGovernanceProposals(uint256[] calldata _ids)\n        external\n        view\n        override\n        returns (\n            address[] memory, // proposers\n            uint256[] memory, // endBlocks\n            uint256[] memory, // for votes - against votes\n            uint256[] memory // state\n        )\n    {\n        address[] memory proposers = new address[](_ids.length);\n        uint256[] memory endBlocks = new uint256[](_ids.length);\n        uint256[] memory votesA = new uint256[](_ids.length);\n        uint256[] memory stateA = new uint256[](_ids.length);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            (address proposer, uint256[3] memory data) = _getProposalInfo(_ids[i]);\n            proposers[i] = proposer;\n            endBlocks[i] = data[0];\n            votesA[i] = data[1];\n            stateA[i] = data[2];\n        }\n        return (proposers, endBlocks, votesA, stateA);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getProposalInfo(uint256 _proposalId) internal view returns (address, uint256[3] memory) {\n        (, address proposer, , , uint256 endBlock, uint256 forVotes, uint256 againstVotes, , , ) =\n            governor.proposals(_proposalId);\n        return (proposer, [endBlock, forVotes.sub(againstVotes), uint256(governor.state(_proposalId))]);\n    }\n}\n"
    },
    "contracts/interfaces/external/oz/IGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/IGovernor.sol)\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernor {\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast.\n     *\n     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    function proposals(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        );\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's\n     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the\n     * beginning of the following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote\n     * during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of blocks, between the vote start and vote ends.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snaphot used for counting vote. This allows to scale the\n     * quroum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n}\n"
    },
    "contracts/lib/ControllerLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabController} from '../interfaces/IBabController.sol';\n\nlibrary ControllerLib {\n    /**\n     * Throws if the sender is not the protocol\n     */\n    function onlyGovernanceOrEmergency(IBabController _controller) internal view {\n        require(\n            msg.sender == _controller.owner() || msg.sender == _controller.EMERGENCY_OWNER(),\n            'Only governance or emergency can call this'\n        );\n    }\n}\n"
    },
    "contracts/TokenIdentifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {ICToken} from './interfaces/external/compound/ICToken.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ITokenIdentifier} from './interfaces/ITokenIdentifier.sol';\nimport {ICurveMetaRegistry} from './interfaces/ICurveMetaRegistry.sol';\nimport {ICurvePoolV3} from './interfaces/external/curve/ICurvePoolV3.sol';\nimport {IMooniswap} from './interfaces/external/1inch/IMooniswap.sol';\nimport {IYearnVault} from './interfaces/external/yearn/IYearnVault.sol';\nimport {IStETH} from './interfaces/external/lido/IStETH.sol';\nimport {IWstETH} from './interfaces/external/lido/IWstETH.sol';\n\nimport {ControllerLib} from './lib/ControllerLib.sol';\n\n/**\n * @title TokenIdentifier\n * @author Babylon Finance Protocol\n *\n * Returns the type of the asset\n */\ncontract TokenIdentifier is ITokenIdentifier {\n    using ControllerLib for IBabController;\n\n    /* ============ Constants ============ */\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IStETH private constant stETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    IWstETH private constant wstETH = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    bytes32 private constant SUSHI_SYMBOL = keccak256(bytes('SLP'));\n    bytes32 private constant UNI_SYMBOL = keccak256(bytes('UNI-V2'));\n\n    // Token Types\n    uint8 private constant COMP_TOKEN = 1;\n    uint8 private constant AAVE_TOKEN = 2;\n    uint8 private constant CREAM_TOKEN = 3;\n    uint8 private constant SYNTH_TOKEN = 4;\n    uint8 private constant CURVE_LP_TOKEN = 5;\n    uint8 private constant YEARN_TOKEN = 6;\n    uint8 private constant LIDO_TOKEN = 7;\n    uint8 private constant SUSHI_LP_TOKEN = 8;\n    uint8 private constant UNIV2_LP_TOKEN = 9;\n    uint8 private constant ONEINCH_LP_TOKEN = 10;\n    uint8 private constant HARVESTV3_LP_TOKEN = 11;\n    uint8 private constant VISOR_LP_TOKEN = 12;\n\n    /* ============ State Variables ============ */\n\n    IBabController public controller;\n    // Mapping of cToken addresses\n    mapping(address => address) public cTokenToAsset;\n    // Mapping of interest bearing aave tokens\n    mapping(address => address) public aTokenToAsset;\n    // Mapping of cream tokens\n    mapping(address => address) public crTokenToAsset;\n    // Mapping of synths\n    mapping(address => bool) public synths;\n    // Mapping of yearn vaults\n    mapping(address => bool) public vaults;\n    // Mapping of gamma visors\n    mapping(address => bool) public visors;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(IBabController _controller) {\n        controller = _controller;\n\n        cTokenToAsset[0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI\n        cTokenToAsset[0x35A18000230DA775CAc24873d00Ff85BccdeD550] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // UNI\n        cTokenToAsset[0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5] = WETH; // ETH\n        cTokenToAsset[0x39AA39c021dfbaE8faC545936693aC917d5E7563] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        cTokenToAsset[0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        cTokenToAsset[0xccF4429DB6322D5C611ee964527D42E5d685DD6a] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC2\n        cTokenToAsset[0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4] = 0xc00e94Cb662C3520282E6f5717214004A7f26888; // COMP\n        cTokenToAsset[0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; // BAT\n        cTokenToAsset[0xFAce851a4921ce59e912d19329929CE6da6EB0c7] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // LINK\n        cTokenToAsset[0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1] = 0x221657776846890989a759BA2973e427DfF5C9bB; // REP\n        cTokenToAsset[0xF5DCe57282A584D2746FaF1593d3121Fcac444dC] = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; // SAI\n        cTokenToAsset[0x12392F67bdf24faE0AF363c24aC620a2f67DAd86] = 0x0000000000085d4780B73119b644AE5ecd22b376; // TUSD\n        cTokenToAsset[0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498; // ZRX\n        cTokenToAsset[0xe65cdB6479BaC1e22340E4E755fAE7E509EcD06c] = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; // aave\n        cTokenToAsset[0x95b4eF2869eBD94BEb4eEE400a99824BF5DC325b] = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2; // MKR\n        cTokenToAsset[0x4B0181102A0112A2ef11AbEE5563bb4a3176c9d7] = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2; // SUSHI\n        cTokenToAsset[0x041171993284df560249B57358F931D9eB7b925D] = 0x8E870D67F660D95d5be530380D0eC0bd388289E1; // USDP\n        cTokenToAsset[0x80a2AE356fc9ef4305676f7a3E2Ed04e12C33946] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e; // YFI\n        cTokenToAsset[0xA6C25548dF506d84Afd237225B5B34F2Feb1aa07] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // fDAI\n        cTokenToAsset[0xA54c548d11792b3d26aD74F5f899e12CDfD64Fd6] = 0x853d955aCEf822Db058eb8505911ED77F175b99e; // fFRAX\n        cTokenToAsset[0x812EeDC9Eba9C428434fD3ce56156b4E23012Ebc] = 0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74; // fBABL\n        cTokenToAsset[0x7DBC3aF9251756561Ce755fcC11c754184Af71F7] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // fWETH\n        cTokenToAsset[0x3a2804ec0Ff521374aF654D8D0daA1d1aE1ee900] = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA; // fFEI\n\n        aTokenToAsset[0xFFC97d72E13E01096502Cb8Eb52dEe56f74DAD7B] = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; // aave\n        aTokenToAsset[0x1E6bb68Acec8fefBD87D192bE09bb274170a0548] = 0xD46bA6D942050d489DBd938a2C909A5d5039A161; // AAMPL\n        aTokenToAsset[0x272F97b7a56a387aE942350bBC7Df5700f8a4576] = 0xba100000625a3754423978a60c9317c58a424e3D; // bal\n        aTokenToAsset[0x05Ec93c0365baAeAbF7AefFb0972ea7ECdD39CF1] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; // bat\n        aTokenToAsset[0xA361718326c15715591c299427c62086F69923D9] = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; // busd\n        aTokenToAsset[0x8dAE6Cb04688C62d939ed9B68d32Bc62e49970b1] = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n        aTokenToAsset[0x028171bCA77440897B824Ca71D1c56caC55b68A3] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // dai\n        aTokenToAsset[0xaC6Df26a590F08dcC95D5a4705ae8abbc88509Ef] = 0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c; // enj\n        aTokenToAsset[0x683923dB55Fead99A79Fa01A27EeC3cB19679cC3] = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA; // fei\n        aTokenToAsset[0xd4937682df3C8aEF4FE912A96A74121C0829E664] = 0x853d955aCEf822Db058eb8505911ED77F175b99e; // frax\n        aTokenToAsset[0xD37EE7e4f452C6638c96536e68090De8cBcdb583] = 0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd; // gusd\n        aTokenToAsset[0x39C6b3e42d6A679d7D776778Fe880BC9487C2EDA] = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200; // knc\n        aTokenToAsset[0xa06bC25B5805d5F8d82847D191Cb4Af5A3e873E0] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // link\n        aTokenToAsset[0xa685a61171bb30d4072B338c80Cb7b2c865c873E] = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942; // mana\n        aTokenToAsset[0xc713e5E149D5D0715DcD1c156a020976e7E56B88] = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2; // mkr\n        aTokenToAsset[0xc9BC48c72154ef3e5425641a3c747242112a46AF] = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919; // rai\n        aTokenToAsset[0xCC12AbE4ff81c9378D670De1b57F8e0Dd228D77a] = 0x408e41876cCCDC0F92210600ef50372656052a38; // ren\n        aTokenToAsset[0x514cd6756CCBe28772d4Cb81bC3156BA9d1744aa] = 0xD5147bc8e386d91Cc5DBE72099DAC6C9b99276F5; // renFIL\n        aTokenToAsset[0x35f6B052C598d933D69A4EEC4D04c73A191fE6c2] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F; // snx\n        aTokenToAsset[0x6C5024Cd4F8A59110119C56f8933403A539555EB] = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51; // susd\n        aTokenToAsset[0x101cc05f4A51C0319f570d5E146a8C625198e636] = 0x0000000000085d4780B73119b644AE5ecd22b376; // tusd\n        aTokenToAsset[0xB9D7CB55f463405CDfBe4E90a6D2Df01C2B92BF1] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // uni\n        aTokenToAsset[0xBcca60bB61934080951369a648Fb03DF4F96263C] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // usdc\n        aTokenToAsset[0x2e8F4bdbE3d47d7d7DE490437AeA9915D930F1A3] = 0x8E870D67F660D95d5be530380D0eC0bd388289E1; // usdp\n        aTokenToAsset[0x3Ed3B47Dd13EC9a98b44e6204A523E766B225811] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // usdt\n        aTokenToAsset[0x9ff58f4fFB29fA2266Ab25e75e2A8b3503311656] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // wbtc\n        aTokenToAsset[0x030bA81f1c18d280636F32af80b9AAd02Cf0854e] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // weth\n        aTokenToAsset[0xF256CC7847E919FAc9B808cC216cAc87CCF2f47a] = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // xsushi\n        aTokenToAsset[0x5165d24277cD063F5ac44Efd447B27025e888f37] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e; // yfi\n        aTokenToAsset[0xDf7FF54aAcAcbFf42dfe29DD6144A69b629f8C9e] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498; // zrx\n\n        crTokenToAsset[0xD06527D5e56A3495252A528C4987003b712860eE] = WETH;\n        crTokenToAsset[0x797AAB1ce7c01eB727ab980762bA88e7133d2157] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        crTokenToAsset[0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        crTokenToAsset[0xCbaE0A83f4f9926997c8339545fb8eE32eDc6b76] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e; // YFI\n        crTokenToAsset[0xcE4Fe9b4b8Ff61949DCfeB7e03bc9FAca59D2Eb3] = 0xba100000625a3754423978a60c9317c58a424e3D; // BAL\n        crTokenToAsset[0x19D1666f543D42ef17F66E376944A22aEa1a8E46] = 0xc00e94Cb662C3520282E6f5717214004A7f26888; // COMP\n        crTokenToAsset[0x9baF8a5236d44AC410c0186Fe39178d5AAD0Bb87] = 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8; // YCRV\n        crTokenToAsset[0x892B14321a4FCba80669aE30Bd0cd99a7ECF6aC0] = 0x2ba592F78dB6436527729929AAf6c908497cB200; // CREAM\n        crTokenToAsset[0x697256CAA3cCaFD62BB6d3Aa1C7C5671786A5fD9] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; // LINK\n        crTokenToAsset[0x8B86e0598616a8d4F1fdAE8b59E55FB5Bc33D0d6] = 0x80fB784B7eD66730e8b1DBd9820aFD29931aab03; // LEND\n        crTokenToAsset[0xc7Fd8Dcee4697ceef5a2fd4608a7BD6A94C77480] = 0xD533a949740bb3306d119CC777fa900bA034cd52; // CRV\n        crTokenToAsset[0x17107f40d70f4470d20CB3f138a052cAE8EbD4bE] = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D; // RENBTC\n        crTokenToAsset[0x1FF8CDB51219a8838b52E9cAc09b71e591BC998e] = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; // BUSD\n        crTokenToAsset[0x3623387773010d9214B10C551d6e7fc375D31F58] = 0xa3BeD4E1c75D00fa6f4E5E6922DB7261B5E9AcD2; // MTA\n        crTokenToAsset[0x4EE15f44c6F0d8d1136c83EfD2e8E4AC768954c6] = 0x4EE15f44c6F0d8d1136c83EfD2e8E4AC768954c6; // YYCRV\n        crTokenToAsset[0x338286C0BC081891A4Bda39C7667ae150bf5D206] = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2; // SUSHI\n        crTokenToAsset[0x10FDBD1e48eE2fD9336a482D746138AE19e649Db] = 0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9; // FTT\n        crTokenToAsset[0x01da76DEa59703578040012357b81ffE62015C2d] = 0xe1237aA7f535b0CC33Fd973D66cBf830354D16c7; // YETH\n        crTokenToAsset[0xef58b2d5A1b8D3cDE67b8aB054dC5C831E9Bc025] = 0x476c5E26a75bd202a9683ffD34359C0CC15be0fF; // SRM\n        crTokenToAsset[0xe89a6D0509faF730BD707bf868d9A2A744a363C7] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; // UNI\n        crTokenToAsset[0xeFF039C3c1D668f408d09dD7B63008622a77532C] = 0x0d438F3b5175Bebc262bF23753C1E53d03432bDE; // WNXM\n        crTokenToAsset[0x22B243B96495C547598D9042B6f94B01C22B2e9E] = 0x87eDfFDe3E14c7a66c9b9724747a1C5696b742e6; // SWAG\n        crTokenToAsset[0x8b3FF1ed4F36C2c2be675AFb13CC3AA5d73685a5] = 0xaaAEBE6Fe48E54f431b0C390CfaF0b017d09D42d; // CEL\n        crTokenToAsset[0x2A537Fa9FFaea8C1A41D3C2B68a9cb791529366D] = 0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b; // DPI\n        crTokenToAsset[0x7ea9C63E216D5565c3940A2B3d150e59C2907Db3] = 0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541; // BBTC\n        crTokenToAsset[0x3225E3C669B39C7c8B3e204a8614bB218c5e31BC] = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; // AAVE\n        crTokenToAsset[0xf55BbE0255f7f4E70f63837Ff72A577fbDDbE924] = 0x0391D2021f89DC339F60Fff84546EA23E337750f; // BOND\n        crTokenToAsset[0x903560b1CcE601794C584F58898dA8a8b789Fc5d] = 0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44; // KP3R\n        crTokenToAsset[0x054B7ed3F45714d3091e82aAd64A1588dC4096Ed] = 0x0316EB71485b0Ab14103307bf65a021042c6d380; // HBTC\n        crTokenToAsset[0xd5103AfcD0B3fA865997Ef2984C66742c51b2a8b] = 0x9AFb950948c2370975fb91a441F36FDC02737cD4; // HFIL\n        crTokenToAsset[0xfd609a03B393F1A1cFcAcEdaBf068CAD09a924E2] = 0xcBc1065255cBc3aB41a6868c22d1f1C573AB89fd; // CRETH2\n        crTokenToAsset[0xD692ac3245bb82319A31068D6B8412796eE85d2c] = 0xdF574c24545E5FfEcb9a659c229253D4111d87e1; // HUSD\n        crTokenToAsset[0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f] = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI\n        crTokenToAsset[0x10a3da2BB0Fae4D591476fd97D6636fd172923a8] = 0x584bC13c7D411c00c01A62e8019472dE68768430; // HEGIC\n        crTokenToAsset[0x3C6C553A95910F9FC81c98784736bd628636D296] = 0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723; // ESD\n        crTokenToAsset[0x85759961b116f1D36fD697855c57A6ae40793D9B] = 0x111111111117dC0aa78b770fA6A738034120C302; // 1INCH\n        crTokenToAsset[0x7Aaa323D7e398be4128c7042d197a2545f0f1fea] = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07; // OMG\n        crTokenToAsset[0x011a014d5e8Eb4771E575bB1000318D509230Afa] = 0xBb2b8038a1640196FbE3e38816F3e67Cba72D940; // UNI-V2-WBTC-ETH\n        crTokenToAsset[0xE6C3120F38F56deb38B69b65cC7dcAF916373963] = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852; // UNI-V2-ETH-USDT\n        crTokenToAsset[0x4Fe11BC316B6d7A345493127fBE298b95AdaAd85] = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc; // UNI-V2-USDC-ETH\n        crTokenToAsset[0xcD22C4110c12AC41aCEfA0091c432ef44efaAFA0] = 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11; // UNI-V2-DAI-ETH\n        crTokenToAsset[0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2] = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // XSUSHI\n        crTokenToAsset[0x73f6cBA38922960b7092175c0aDD22Ab8d0e81fC] = 0xCEfF51756c56CeFFCA006cD410B03FFC46dd3a58; // SLP-WBTC-ETH\n        crTokenToAsset[0x38f27c03d6609a86FF7716ad03038881320BE4Ad] = 0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f; // SLP-DAI-ETH\n        crTokenToAsset[0x5EcaD8A75216CEa7DFF978525B2D523a251eEA92] = 0x397FF1542f962076d0BFE58eA045FfA2d347ACa0; // SLP-USDC-ETH\n        crTokenToAsset[0x5C291bc83d15f71fB37805878161718eA4b6AEe9] = 0x06da0fd433C1A5d7a4faa01111c044910A184553; // SLP-ETH-USDT\n        crTokenToAsset[0x6BA0C66C48641e220CF78177C144323b3838D375] = 0x795065dCc9f64b5614C407a6EFDC400DA6221FB0; // SLP-SUSHI-ETH\n        crTokenToAsset[0xd532944df6DFd5Dd629E8772F03D4fC861873abF] = 0x088ee5007C98a9677165D78dD2109AE4a3D04d0C; // SLP-YFI-ETH\n        crTokenToAsset[0x197070723CE0D3810a0E47F06E935c30a480D4Fc] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC\n        crTokenToAsset[0xC25EAE724f189Ba9030B2556a1533E7c8A732E14] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F; // SNX\n        crTokenToAsset[0x25555933a8246Ab67cbf907CE3d1949884E82B55] = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51; // SUSD\n        crTokenToAsset[0xc68251421eDDa00a10815E273fA4b1191fAC651b] = 0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5; // PICKLE\n        crTokenToAsset[0x65883978aDA0e707c3b2BE2A6825b1C4BDF76A90] = 0x8Ab7404063Ec4DBcfd4598215992DC3F8EC853d7; // AKRO\n        crTokenToAsset[0x8B950f43fCAc4931D408F1fcdA55C6CB6cbF3096] = 0x19D97D8fA813EE2f51aD4B4e04EA08bAf4DFfC28; // BBADGER\n        crTokenToAsset[0x59089279987DD76fC65Bf94Cb40E186b96e03cB3] = 0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26; // OGN\n        crTokenToAsset[0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6] = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2; // AMP\n        crTokenToAsset[0xb092b4601850E23903A42EaCBc9D8A0EeC26A4d5] = 0x853d955aCEf822Db058eb8505911ED77F175b99e; // FRAX\n        crTokenToAsset[0x1d0986Fb43985c88Ffa9aD959CC24e6a087C7e35] = 0xa1faa113cbE53436Df28FF0aEe54275c13B40975; // ALPHA\n        crTokenToAsset[0x51F48b638F82e8765F7a26373A2Cb4CcB10C07af] = 0xa47c8bf37f92aBed4A126BDA807A7b7498661acD; // UST\n        crTokenToAsset[0xc36080892c64821fa8e396bc1bD8678fA3b82b17] = 0x4E15361FD6b4BB609Fa63C81A2be19d873717870; // FTM\n        crTokenToAsset[0x8379BAA817c5c5aB929b03ee8E3c48e45018Ae41] = 0x3155BA85D5F96b2d030a4966AF206230e46849cb; // RUNE\n        crTokenToAsset[0x299e254A8a165bBeB76D9D69305013329Eea3a3B] = 0xbC396689893D065F41bc2C6EcbeE5e0085233447; // PERP\n        crTokenToAsset[0xf8445C529D363cE114148662387eba5E62016e20] = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919; // RAI\n        crTokenToAsset[0x7C3297cFB4c4bbd5f44b450c0872E0ADA5203112] = 0x967da4048cD07aB37855c090aAF366e4ce1b9F48; // OCEAN\n        crTokenToAsset[0x081FE64df6dc6fc70043aedF3713a3ce6F190a21] = 0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF; // RARI\n        crTokenToAsset[0x28526Bb33d7230E65E735dB64296413731C5402e] = 0xb753428af26E81097e7fD17f40c88aaA3E04902c; // SFI\n        crTokenToAsset[0x45406ba53bB84Cd32A58e7098a2D4D1b11B107F6] = 0x27b7b1ad7288079A66d12350c828D3C00A6F07d7; // YVCurve-IB CHECK!\n        crTokenToAsset[0x6d1B9e01aF17Dd08d6DEc08E210dfD5984FF1C20] = 0x986b4AFF588a109c09B50A03f42E4110E29D353F; // YVCurve-sETH\n        crTokenToAsset[0x1F9b4756B008106C806c7E64322d7eD3B72cB284] = 0xdCD90C7f6324cfa40d7169ef80b12031770B4325; // YVCurve-stETH\n        crTokenToAsset[0xab10586C918612BA440482db77549d26B7ABF8f7] = 0x1337DEF16F9B486fAEd0293eb623Dc8395dFE46a; // ARMOR\n        crTokenToAsset[0xdFFf11DFe6436e42a17B86e7F419Ac8292990393] = 0x1337DEF18C680aF1f9f45cBcab6309562975b1dD; // ARNXM\n        crTokenToAsset[0xDbb5e3081dEf4b6cdD8864aC2aeDA4cBf778feCf] = 0xec67005c4E498Ec7f55E092bd1d35cbC47C91892; // MLN\n        crTokenToAsset[0x71cEFCd324B732d4E058AfAcBA040d908c441847] = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421; // VSP\n        crTokenToAsset[0x1A122348B73B58eA39F822A89e6ec67950c2bBD0] = 0xbA4cFE5741b357FA371b506e5db0774aBFeCf8Fc; // VVSP\n        crTokenToAsset[0x523EFFC8bFEfC2948211A05A905F761CBA5E8e9E] = 0x6810e776880C02933D47DB1b9fc05908e5386b96; // GNO\n        crTokenToAsset[0x4202D97E00B9189936EdF37f8D01cfF88BDd81d4] = 0xa9fE4601811213c340e850ea305481afF02f5b28; // YVWETH\n        crTokenToAsset[0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4] = 0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4; // YUSD\n        crTokenToAsset[0x98E329eB5aae2125af273102f3440DE19094b77c] = 0xCC4304A31d09258b0029eA7FE63d032f52e44EFe; // SWAP\n        crTokenToAsset[0x8C3B7a4320ba70f8239F83770c4015B5bc4e6F91] = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA; // FEI\n        crTokenToAsset[0xE585c76573D7593ABF21537B607091F76c996E73] = 0x4691937a7508860F876c9c0a2a617E7d9E945D4B; // WOO\n        crTokenToAsset[0x81E346729723C4D15d0FB1c5679b9f2926Ff13C6] = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; // BNT\n        crTokenToAsset[0xC581b735A1688071A1746c968e0798D642EDE491] = 0xC581b735A1688071A1746c968e0798D642EDE491; // EURT\n        crTokenToAsset[0xD7394428536F63d5659cc869EF69d10f9E66314B] = 0x8E870D67F660D95d5be530380D0eC0bd388289E1; // PAX\n        crTokenToAsset[0x1241B10E7EA55b22f5b2d007e8fECDF73DCff999] = 0x45804880De22913dAFE09f4980848ECE6EcbAf78; // PAXG\n        crTokenToAsset[0x2A867fd776B83e1bd4e13C6611AFd2F6af07EA6D] = 0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541; // BBTC\n        crTokenToAsset[0x250Fb308199FE8C5220509C1bf83D21d60b7f74A] = 0x0000000000095413afC295d19EDeb1Ad7B71c952; // LON\n        crTokenToAsset[0x4112a717edD051F77d834A6703a1eF5e3d73387F] = 0x25f8087EAD173b73D6e8B84329989A8eEA16CF73; // YGG\n        crTokenToAsset[0xF04ce2e71D32D789a259428ddcD02D3C9F97fb4E] = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b; // AXS\n        crTokenToAsset[0x89e42987c39f72e2EAd95a8a5bC92114323d5828] = 0x3845badAde8e6dFF049820680d1F14bD3903a5d0; // SAND\n        crTokenToAsset[0x58DA9c9fC3eb30AbBcbBAb5DDabb1E6e2eF3d2EF] = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942; // MANA\n\n        synths[0x57Ab1ec28D129707052df4dF418D58a2D46d5f51] = true; // ProxyERC20sUSD\n        synths[0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076] = true; // ProxysAAVE\n        synths[0xe36E2D3c7c34281FA3bC737950a68571736880A1] = true; // ProxysADA\n        synths[0xF48e200EAF9906362BB1442fca31e0835773b8B4] = true; // ProxysAUD\n        synths[0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6] = true; // ProxysBTC\n        synths[0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d] = true; // ProxysCHF\n        synths[0xD38aEb759891882e78E957c80656572503D8c1B1] = true; // ProxysCRV\n        synths[0xfE33ae95A9f0DA8A845aF33516EDc240DCD711d6] = true; // ProxysDEFI\n        synths[0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6] = true; // ProxysDOT\n        synths[0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb] = true; // ProxysETH\n        synths[0x104eDF1da359506548BFc7c25bA1E28C16a70235] = true; // ProxysETHBTC\n        synths[0xD71eCFF9342A5Ced620049e616c5035F1dB98620] = true; // ProxysEUR\n        synths[0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F] = true; // ProxysGBP\n        synths[0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d] = true; // ProxysJPY\n        synths[0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B] = true; // ProxysKRW\n        synths[0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6] = true; // ProxysLINK\n\n        // Yearn vaults\n        // https://medium.com/yearn-state-of-the-vaults/the-vaults-at-yearn-9237905ffed3\n        vaults[0xc5bDdf9843308380375a611c18B50Fb9341f502A] = true; // veCRV-DAO yVault\n        vaults[0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a] = true; // Yearn Compounding veCRV yVault\n        vaults[0xdb25cA703181E7484a155DD612b06f57E12Be5F0] = true; // YFI yVault\n        vaults[0xF29AE508698bDeF169B89834F76704C3B205aedf] = true; // SNX yVault\n        vaults[0x873fB544277FD7b977B196a826459a69E27eA4ea] = true; // RAI yVault\n        vaults[0x671a912C10bba0CFA74Cfc2d6Fba9BA1ed9530B2] = true; // LINK yVault\n        vaults[0xa5cA62D95D24A4a350983D5B8ac4EB8638887396] = true; // sUSD yVault\n        vaults[0xB8C3B7A2A618C552C23B1E4701109a9E756Bab67] = true; // 1INCH yVault\n        vaults[0xa258C4606Ca8206D8aA700cE2143D7db854D168c] = true; // WETH yVault\n        vaults[0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9] = true; // USDC yVault\n        vaults[0xdA816459F1AB5631232FE5e97a05BBBb94970c95] = true; // DAI yVault\n        vaults[0xA696a63cc78DfFa1a63E9E50587C197387FF6C7E] = true; // WBTC yVault\n        vaults[0x7Da96a3891Add058AdA2E826306D812C638D87a7] = true; // USDT yVault\n        vaults[0xFBEB78a723b8087fD2ea7Ef1afEc93d35E8Bed42] = true; // UNI yVault\n        vaults[0xd9788f3931Ede4D5018184E198699dC6d66C1915] = true; // AAVE yVault\n        vaults[0x4A3FE75762017DB0eD73a71C9A06db7768DB5e66] = true; // COMP yVault\n        vaults[0x6d765CbE5bC922694afE112C140b8878b9FB0390] = true; // SUSHI yVault\n        vaults[0xFD0877d9095789cAF24c98F7CCe092fa8E120775] = true; // TUSD yVault\n        // Curve yearn vaults\n        vaults[0xE537B5cc158EB71037D4125BDD7538421981E6AA] = true; // Curve 3Crypto Pool yVault\n        vaults[0x6FAfCA7f49B4Fd9dC38117469cd31A1E5aec91F5] = true; // Curve USDM Pool yVault\n        vaults[0x718AbE90777F5B778B52D553a5aBaa148DD0dc5D] = true; // Curve alETH Pool yVault\n        vaults[0x8b9C0c24307344B6D7941ab654b2Aeee25347473] = true; // Curve EURN Pool yVault\n        vaults[0xd8C620991b8E626C099eAaB29B1E3eEa279763bb] = true; // Curve MIM-UST\n        vaults[0x0d4EA8536F9A13e4FBa16042a46c30f092b06aA5] = true; // Curve EURT Pool yVault\n        vaults[0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8] = true; // Curve MIM Pool yVault\n        vaults[0x4560b99C904aAD03027B5178CCa81584744AC01f] = true; // Curve cvxCRV Pool yVault\n        vaults[0x67e019bfbd5a67207755D04467D6A70c0B75bF60] = true; // Curve ibEUR Pool yVault\n        vaults[0x528D50dC9a333f01544177a924893FA1F5b9F748] = true; // Curve ibKRW Pool yVault\n        vaults[0x595a68a8c9D5C230001848B69b1947ee2A607164] = true; // Curve ibGBP Pool yVault\n        vaults[0x1b905331F7dE2748F4D6a0678e1521E20347643F] = true; // Curve ibAUD Pool yVault\n        vaults[0x490bD0886F221A5F79713D3E84404355A9293C50] = true; // Curve ibCHF Pool yVault\n        vaults[0x59518884EeBFb03e90a18ADBAAAB770d4666471e] = true; // Curve ibJPY Pool yVault\n        vaults[0x8cc94ccd0f3841a468184aCA3Cc478D2148E1757] = true; // Curve mUSD Pool yVault\n        vaults[0x625b7DF2fa8aBe21B0A976736CDa4775523aeD1E] = true; // Curve HBTC Pool yVault\n        vaults[0x3D27705c64213A5DcD9D26880c1BcFa72d5b6B0E] = true; // Curve USDK Pool yVault\n        vaults[0x80bbeE2fa460dA291e796B9045e93d19eF948C6A] = true; // Curve Pax Pool yVault\n        vaults[0xC116dF49c02c5fD147DE25Baa105322ebF26Bd97] = true; // Curve RSV Pool yVault\n        vaults[0x28a5b95C101df3Ded0C0d9074DB80C438774B6a9] = true; // Curve USDT Pool yVault\n        vaults[0x3D980E50508CFd41a13837A60149927a11c03731] = true; // Curve triCrypto Pool yVault\n        vaults[0x25212Df29073FfFA7A67399AcEfC2dd75a831A1A] = true; // Curve EURS Pool yVault\n        vaults[0x5a770DbD3Ee6bAF2802D29a901Ef11501C44797A] = true; // Curve sUSD Pool yVault\n        vaults[0x39CAF13a104FF567f71fd2A4c68C026FDB6E740B] = true; // Curve Aave Pool yVault\n        vaults[0x054AF22E1519b020516D72D749221c24756385C9] = true; // Curve HUSD Pool yVault\n        vaults[0x3B96d491f067912D18563d56858Ba7d6EC67a6fa] = true; // Curve USDN Pool yVault\n        vaults[0xBfedbcbe27171C418CDabC2477042554b1904857] = true; // Curve rETH Pool yVault\n        vaults[0x132d8D2C76Db3812403431fAcB00F3453Fc42125] = true; // Curve ankrETH Pool yVault\n        vaults[0xf2db9a7c0ACd427A680D640F02d90f6186E71725] = true; // Curve LINK Pool yVault\n        vaults[0xA74d4B67b3368E83797a35382AFB776bAAE4F5C8] = true; // Curve alUSD Pool yVault\n        vaults[0xC4dAf3b5e2A9e93861c3FBDd25f1e943B8D87417] = true; // Curve USDP Pool yVault\n        vaults[0x1C6a9783F812b3Af3aBbf7de64c3cD7CC7D1af44] = true; // Curve UST Pool yVault\n        vaults[0x30FCf7c6cDfC46eC237783D94Fc78553E79d4E9C] = true; // Curve DUSD Pool yVault\n        vaults[0xf8768814b88281DE4F532a3beEfA5b85B69b9324] = true; // Curve TUSD Pool yVault\n        vaults[0x4B5BfD52124784745c1071dcB244C6688d2533d3] = true; // Curve Y Pool yVault\n        vaults[0x84E13785B5a27879921D6F685f041421C7F482dA] = true; // Curve 3pool yVault\n        vaults[0x2a38B9B0201Ca39B17B460eD2f11e4929559071E] = true; // Curve GUSD Pool yVault\n        vaults[0x27b7b1ad7288079A66d12350c828D3C00A6F07d7] = true; // Curve Iron Bank Pool yVault\n        vaults[0x986b4AFF588a109c09B50A03f42E4110E29D353F] = true; // Curve sETH Pool yVault\n        vaults[0xdCD90C7f6324cfa40d7169ef80b12031770B4325] = true; // Curve stETH Pool yVault\n        vaults[0x8414Db07a7F743dEbaFb402070AB01a4E0d2E45e] = true; // Curve sBTC Pool yVault\n        vaults[0x7047F90229a057C13BF847C0744D646CFb6c9E1A] = true; // Curve renBTC Pool yVault\n        vaults[0xe9Dc63083c464d6EDcCFf23444fF3CFc6886f6FB] = true; // Curve oBTC Pool yVault\n        vaults[0x3c5DF3077BcF800640B5DAE8c91106575a4826E6] = true; // Curve pBTC Pool yVault\n        vaults[0x23D3D0f1c697247d5e0a9efB37d8b0ED0C464f7f] = true; // Curve tBTC Pool yVault\n        vaults[0xB4AdA607B9d6b2c9Ee07A275e9616B84AC560139] = true; // Curve FRAX Pool yVault\n        vaults[0x5fA5B62c8AF877CB37031e0a3B2f34A78e3C56A6] = true; // Curve LUSD Pool yVault\n        vaults[0xb4D1Be44BfF40ad6e506edf43156577a3f8672eC] = true; // Curve SAAVE Pool yVault\n        vaults[0x8fA3A9ecd9EFb07A8CE90A6eb014CF3c0E3B32Ef] = true; // Curve BBTC Pool yVault\n        vaults[0x6Ede7F19df5df6EF23bD5B9CeDb651580Bdf56Ca] = true; // Curve BUSD Pool yVault\n        vaults[0x2994529C0652D127b7842094103715ec5299bBed] = true; // yearn Curve.fi yDAI/yUSDC/yUSDT/yBUSD\n        vaults[0xD6Ea40597Be05c201845c0bFd2e96A60bACde267] = true; // Curve Compound Pool yVault\n\n        visors[0x705b3aCaF102404CfDd5e4A60535E4e70091273C] = true; // BABL-ETH Visor\n        visors[0xf6eeCA73646ea6A5c878814e6508e87facC7927C] = true; // GAMMA-ETH Visor\n        visors[0xc86B1e7FA86834CaC1468937cdd53ba3cCbC1153] = true; // FLOAT-ETH Visor\n    }\n\n    /* ============ External Functions ============ */\n\n    function updateYearnVault(address[] calldata _vaults, bool[] calldata _values) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _vaults.length; i++) {\n            vaults[_vaults[i]] = _values[i];\n        }\n    }\n\n    function updateSynth(address[] calldata _synths, bool[] calldata _values) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _synths.length; i++) {\n            synths[_synths[i]] = _values[i];\n        }\n    }\n\n    function updateCreamPair(address[] calldata _creamTokens, address[] calldata _underlyings) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _creamTokens.length; i++) {\n            crTokenToAsset[_creamTokens[i]] = _underlyings[i];\n        }\n    }\n\n    function updateAavePair(address[] calldata _aaveTokens, address[] calldata _underlyings) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _aaveTokens.length; i++) {\n            aTokenToAsset[_aaveTokens[i]] = _underlyings[i];\n        }\n    }\n\n    function updateCompoundPair(address[] calldata _cTokens, address[] calldata _underlyings) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            cTokenToAsset[_cTokens[i]] = _underlyings[i];\n        }\n    }\n\n    function updateVisor(address[] calldata _visors, bool[] calldata _values) external override {\n        controller.onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _visors.length; i++) {\n            visors[_visors[i]] = _values[i];\n        }\n    }\n\n    /**\n     * Returns the types of the two tokens\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return (uint8,uint8)        Types of both tokens\n     */\n    function identifyTokens(\n        address _tokenIn,\n        address _tokenOut,\n        ICurveMetaRegistry _curveMetaRegistry\n    )\n        external\n        view\n        override\n        returns (\n            uint8,\n            uint8,\n            address,\n            address\n        )\n    {\n        uint8 tokenInType;\n        uint8 tokenOutType;\n        address finalAssetIn;\n        address finalAssetOut;\n        // Comp assets\n        if (cTokenToAsset[_tokenIn] != address(0)) {\n            tokenInType = COMP_TOKEN;\n            finalAssetIn = cTokenToAsset[_tokenIn];\n        }\n        if (cTokenToAsset[_tokenOut] != address(0)) {\n            tokenOutType = COMP_TOKEN;\n            finalAssetOut = cTokenToAsset[_tokenOut];\n        }\n\n        // aave tokens. 1 to 1 with underlying\n        if (aTokenToAsset[_tokenIn] != address(0)) {\n            tokenInType = AAVE_TOKEN;\n            finalAssetIn = aTokenToAsset[_tokenIn];\n        }\n        if (aTokenToAsset[_tokenOut] != address(0)) {\n            tokenOutType = AAVE_TOKEN;\n            finalAssetOut = aTokenToAsset[_tokenOut];\n        }\n\n        // crTokens Cream prices 0xde19f5a7cF029275Be9cEC538E81Aa298E297266\n        // cTkens use same interface as compound\n        if (crTokenToAsset[_tokenIn] != address(0)) {\n            finalAssetIn = crTokenToAsset[_tokenIn];\n            tokenInType = CREAM_TOKEN;\n        }\n        if (crTokenToAsset[_tokenOut] != address(0)) {\n            finalAssetOut = crTokenToAsset[_tokenOut];\n            tokenOutType = CREAM_TOKEN;\n        }\n\n        // Checks synthetix\n        if (synths[_tokenIn]) {\n            tokenInType = SYNTH_TOKEN;\n        }\n\n        if (synths[_tokenOut]) {\n            tokenOutType = SYNTH_TOKEN;\n        }\n\n        // Checks visor\n        if (visors[_tokenIn]) {\n            tokenInType = VISOR_LP_TOKEN;\n        }\n\n        if (visors[_tokenOut]) {\n            tokenOutType = VISOR_LP_TOKEN;\n        }\n\n        // Early exit\n        if (tokenInType > 0 && tokenOutType > 0) {\n            return (tokenInType, tokenOutType, finalAssetIn, finalAssetOut);\n        }\n\n        if (tokenInType == 0) {\n            // Curve LP Token\n            address crvPool = _curveMetaRegistry.getPoolFromLpToken(_tokenIn);\n            if (crvPool != address(0)) {\n                tokenInType = CURVE_LP_TOKEN;\n            }\n        }\n\n        if (tokenOutType == 0) {\n            address crvPool = _curveMetaRegistry.getPoolFromLpToken(_tokenOut);\n            if (crvPool != address(0)) {\n                tokenOutType = CURVE_LP_TOKEN;\n            }\n        }\n\n        // Yearn vaults\n        if (vaults[_tokenIn]) {\n            tokenInType = YEARN_TOKEN;\n        }\n\n        if (vaults[_tokenOut]) {\n            tokenOutType = YEARN_TOKEN;\n        }\n\n        // Checks stETH && wstETH (Lido tokens)\n        if (_tokenIn == address(stETH) || _tokenIn == address(wstETH)) {\n            tokenInType = LIDO_TOKEN;\n        }\n        if (_tokenOut == address(stETH) || _tokenOut == address(wstETH)) {\n            tokenOutType = LIDO_TOKEN;\n        }\n\n        // Early exit\n        if (tokenInType > 0 && tokenOutType > 0) {\n            return (tokenInType, tokenOutType, finalAssetIn, finalAssetOut);\n        }\n\n        // Check sushi pairs (univ2)\n        if (tokenInType == 0) {\n            string memory tokenInSymbol = ERC20(_tokenIn).symbol();\n            if (keccak256(bytes(tokenInSymbol)) == SUSHI_SYMBOL) {\n                tokenInType = SUSHI_LP_TOKEN;\n            }\n            // Checks univ2\n            if (keccak256(bytes(tokenInSymbol)) == UNI_SYMBOL) {\n                tokenInType = UNIV2_LP_TOKEN;\n            }\n        }\n        if (tokenOutType == 0) {\n            string memory tokenOutSymbol = ERC20(_tokenOut).symbol();\n            if (keccak256(bytes(tokenOutSymbol)) == SUSHI_SYMBOL) {\n                tokenOutType = SUSHI_LP_TOKEN;\n            }\n            if (keccak256(bytes(tokenOutSymbol)) == UNI_SYMBOL) {\n                tokenOutType = UNIV2_LP_TOKEN;\n            }\n        }\n\n        // todo: mooniswap\n        // todo: pickle\n        // todo: convex tokens\n        // todo: Harvest v3 lp token\n        // todo: Visor (univ3 lp token)\n\n        return (tokenInType, tokenOutType, finalAssetIn, finalAssetOut);\n    }\n\n    /* ============ Internal Functions ============ */\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface ICToken is IERC20 {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function repayBorrowBehalf(address borrower, uint256 amount) external payable returns (uint256);\n\n    function borrowBalanceCurrent(address account) external view returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePoolV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface ICurvePoolV3 {\n    function coins(uint256 arg0) external view returns (address out);\n\n    function underlying_coins(uint256 arg0) external view returns (address out);\n\n    function underlying_coins(int128 arg0) external view returns (address out);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function balances(uint256 arg0) external view returns (uint256 out);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function lp_price() external view returns (uint256);\n\n    function lp_token() external view returns (address out);\n\n    function token() external view returns (address out);\n\n    function curve() external view returns (address out);\n\n    function pool() external view returns (address out);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IMooniswap is IERC20 {\n    function getTokens() external view returns (address[] memory _tokens);\n\n    function tokens(uint256 i) external view returns (IERC20);\n\n    function mooniswapFactoryGovernance() external view returns (address);\n\n    function getBalanceForAddition(IERC20 token) external view returns (uint256);\n\n    function getBalanceForRemoval(IERC20 token) external view returns (uint256);\n\n    function getReturn(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts)\n        external\n        payable\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function depositFor(\n        uint256[2] memory maxAmounts,\n        uint256[2] memory minAmounts,\n        address target\n    ) external payable returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function withdraw(uint256 amount, uint256[] memory minReturns)\n        external\n        returns (uint256[2] memory withdrawnAmounts);\n\n    function withdrawFor(\n        uint256 amount,\n        uint256[] memory minReturns,\n        address payable target\n    ) external returns (uint256[2] memory withdrawnAmounts);\n\n    function swap(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    ) external payable returns (uint256 result);\n\n    function swapFor(\n        IERC20 src,\n        IERC20 dst,\n        uint256 amount,\n        uint256 minReturn,\n        address referral,\n        address payable receiver\n    ) external payable returns (uint256 result);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function token() external view returns (address);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 shares) external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IStETH is IERC20 {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\n\n    function submit(address _referral) external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH is IERC20 {\n    /**\n     * @notice Exchanges stETH to wstETH\n     * @param _stETHAmount amount of stETH to wrap in exchange for wstETH\n     * @dev Requirements:\n     *  - `_stETHAmount` must be non-zero\n     *  - msg.sender must approve at least `_stETHAmount` stETH to this\n     *    contract.\n     *  - msg.sender must have at least `_stETHAmount` of stETH.\n     * User should first approve _stETHAmount to the WstETH contract\n     * @return Amount of wstETH user receives after wrap\n     */\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n\n    /**\n     * @notice Shortcut to stake ETH and auto-wrap returned stETH\n     */\n    // receive() external payable {\n    //     uint256 shares = stETH.submit{value: msg.value}(address(0));\n    //     _mint(msg.sender, shares);\n    // }\n\n    /**\n     * @notice Get amount of wstETH for a given amount of stETH\n     * @param _stETHAmount amount of stETH\n     * @return Amount of wstETH for a given stETH amount\n     */\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a given amount of wstETH\n     * @param _wstETHAmount amount of wstETH\n     * @return Amount of stETH for a given wstETH amount\n     */\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of wstETH for a 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\n\nimport {IHypervisor} from './interfaces/IHypervisor.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {ICToken} from './interfaces/external/compound/ICToken.sol';\nimport {ITokenIdentifier} from './interfaces/ITokenIdentifier.sol';\nimport {ISnxExchangeRates} from './interfaces/external/synthetix/ISnxExchangeRates.sol';\nimport {ICurveMetaRegistry} from './interfaces/ICurveMetaRegistry.sol';\nimport {ICurvePoolV3} from './interfaces/external/curve/ICurvePoolV3.sol';\nimport {IHarvestUniv3Pool} from './interfaces/external/harvest/IHarvestUniv3Pool.sol';\nimport {ICurvePoolV3DY} from './interfaces/external/curve/ICurvePoolV3DY.sol';\nimport {IUniswapV2Router} from './interfaces/external/uniswap/IUniswapV2Router.sol';\nimport {IUniswapViewer} from './interfaces/external/uniswap-v3/IUniswapViewer.sol';\nimport {IUniVaultStorage} from './interfaces/external/uniswap-v3/IUniVaultStorage.sol';\nimport {INFTPositionManager} from './interfaces/external/uniswap-v3/INFTPositionManager.sol';\nimport {ISnxSynth} from './interfaces/external/synthetix/ISnxSynth.sol';\nimport {ISnxProxy} from './interfaces/external/synthetix/ISnxProxy.sol';\nimport {IYearnRegistry} from './interfaces/external/yearn/IYearnRegistry.sol';\nimport {IYearnVault} from './interfaces/external/yearn/IYearnVault.sol';\nimport {IStETH} from './interfaces/external/lido/IStETH.sol';\nimport {IWstETH} from './interfaces/external/lido/IWstETH.sol';\n\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from './lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\nimport {AddressArrayUtils} from './lib/AddressArrayUtils.sol';\nimport {ControllerLib} from './lib/ControllerLib.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance Protocol\n *\n * Uses Uniswap V3 to get a price of a token pair\n */\ncontract PriceOracle is Ownable, IPriceOracle {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n    using ControllerLib for IBabController;\n\n    /* ============ Constants ============ */\n\n    // Address of Uniswap factory\n    IUniswapV3Factory internal constant factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    ISnxExchangeRates internal constant snxEchangeRates = ISnxExchangeRates(0xd69b189020EF614796578AfE4d10378c5e7e1138);\n    IUniswapV2Router internal constant uniRouterV2 = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IYearnRegistry private constant yearnRegistry = IYearnRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\n    IUniswapViewer private constant uniswapViewer = IUniswapViewer(0x25c81e249F913C94F263923421622bA731E6555b);\n    INFTPositionManager private constant nftPositionManager =\n        INFTPositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n\n    address internal constant ETH_ADD_CURVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant BABL = 0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    IStETH private constant stETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    IWstETH private constant wstETH = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n\n    address private constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n    address private constant palStkAAVE = 0x24E79e946dEa5482212c38aaB2D0782F04cdB0E0;\n    address private constant curvePalStkAave = 0x48536EC5233297C367fd0b6979B75d9270bB6B15;\n\n    // the desired seconds agos array passed to the observe method\n    uint32 private constant SECONDS_GRANULARITY = 30;\n    uint256 private constant CURVE_SLIPPAGE = 6e16;\n\n    uint24 private constant FEE_LOW = 500;\n    uint24 private constant FEE_MEDIUM = 3000;\n    uint24 private constant FEE_HIGH = 10000;\n    int24 private constant baseThreshold = 1000;\n    int24 private constant INITIAL_TWAP_DEVIATION = 1600; // locally for testing. It should be halved in main\n\n    /* ============ State Variables ============ */\n\n    ITokenIdentifier public tokenIdentifier;\n    IBabController public controller;\n    mapping(address => bool) public hopTokens;\n    address[] public hopTokensList;\n    int24 private maxTwapDeviation;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(ITokenIdentifier _tokenIdentifier, IBabController _controller) {\n        tokenIdentifier = _tokenIdentifier;\n        controller = _controller;\n        maxTwapDeviation = INITIAL_TWAP_DEVIATION;\n\n        _updateReserves(AddressArrayUtils.toDynamic(WETH, DAI, USDC, WBTC));\n    }\n\n    /* ============ External Functions ============ */\n\n    function updateTokenIdentifier(ITokenIdentifier _tokenIdentifier) public override {\n        controller.onlyGovernanceOrEmergency();\n        require(address(_tokenIdentifier) != address(0), 'Address needs to exist');\n        tokenIdentifier = _tokenIdentifier;\n    }\n\n    function updateMaxTwapDeviation(int24 _maxTwapDeviation) public override {\n        controller.onlyGovernanceOrEmergency();\n        require(_maxTwapDeviation < 1500, 'Max twap deviation must be within range');\n        maxTwapDeviation = _maxTwapDeviation;\n    }\n\n    function updateReserves(address[] memory list) public override {\n        controller.onlyGovernanceOrEmergency();\n        _updateReserves(list);\n    }\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return price                Price of the pair\n     */\n    function getPriceNAV(address _tokenIn, address _tokenOut) public view override returns (uint256 price) {\n        price = _getPrice(_tokenIn, _tokenOut, true);\n        require(price != 0, 'Price not found');\n        return price;\n    }\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @return price                Price of the pair\n     */\n    function getPrice(address _tokenIn, address _tokenOut) public view virtual override returns (uint256 price) {\n        price = _getPrice(_tokenIn, _tokenOut, false);\n        require(price != 0, 'Price not found');\n        return price;\n    }\n\n    function getCompoundExchangeRate(address _asset, address _underlying) public view override returns (uint256) {\n        uint256 exchangeRateNormalized = ICToken(_asset).exchangeRateStored();\n        return SafeDecimalMath.normalizeAmountTokens(_underlying, _asset, exchangeRateNormalized);\n    }\n\n    function getCreamExchangeRate(address _asset, address _underlying) public view override returns (uint256) {\n        uint256 exchangeRateNormalized = ICToken(_asset).exchangeRateStored();\n        if (ERC20(_underlying).decimals() > 8) {\n            exchangeRateNormalized = exchangeRateNormalized.div(10**(ERC20(_underlying).decimals() - 8));\n        } else {\n            exchangeRateNormalized = exchangeRateNormalized.mul(10**(8 - ERC20(_underlying).decimals()));\n        }\n        return exchangeRateNormalized;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Returns the amount out corresponding to the amount in for a given token\n     * @param _tokenIn              Address of the first token\n     * @param _tokenOut             Address of the second token\n     * @param _forNAV               Whether it is just for display purposes\n     * @return price                Price of the pair\n     */\n    function _getPrice(\n        address _tokenIn,\n        address _tokenOut,\n        bool _forNAV\n    ) private view returns (uint256 price) {\n        // Same asset. Returns base unit\n        if (_tokenIn == _tokenOut) {\n            return 10**18;\n        }\n\n        _tokenIn = _tokenIn == address(0) ? WETH : _tokenIn;\n        _tokenOut = _tokenOut == address(0) ? WETH : _tokenOut;\n\n        ICurveMetaRegistry curveMetaRegistry = ICurveMetaRegistry(controller.curveMetaRegistry());\n        (uint8 tokenInType, uint8 tokenOutType, address _finalAssetIn, address _finalAssetOut) =\n            tokenIdentifier.identifyTokens(_tokenIn, _tokenOut, curveMetaRegistry);\n\n        // Comp assets\n        uint256 exchangeRate;\n        if (tokenInType == 1) {\n            exchangeRate = getCompoundExchangeRate(_tokenIn, _finalAssetIn);\n            return getPrice(_finalAssetIn, _tokenOut).preciseMul(exchangeRate);\n        }\n        if (tokenOutType == 1) {\n            exchangeRate = getCompoundExchangeRate(_tokenOut, _finalAssetOut);\n            return getPrice(_tokenIn, _finalAssetOut).preciseDiv(exchangeRate);\n        }\n\n        // aave tokens. 1 to 1 with underlying\n        if (tokenInType == 2) {\n            return getPrice(_finalAssetIn, _tokenOut);\n        }\n\n        if (tokenOutType == 2) {\n            return getPrice(_tokenIn, _finalAssetOut);\n        }\n\n        // crTokens Cream prices 0xde19f5a7cF029275Be9cEC538E81Aa298E297266\n        // cTkens use same interface as compound\n        if (tokenInType == 3) {\n            exchangeRate = getCreamExchangeRate(_tokenIn, _finalAssetIn);\n            return getPrice(_finalAssetIn, _tokenOut).preciseMul(exchangeRate);\n        }\n        if (tokenOutType == 3) {\n            exchangeRate = getCreamExchangeRate(_tokenOut, _finalAssetOut);\n            return getPrice(_tokenIn, _finalAssetOut).preciseDiv(exchangeRate);\n        }\n\n        // Checks Synthetix\n        if (tokenInType == 4) {\n            address targetImpl = ISnxProxy(_tokenIn).target();\n            exchangeRate = snxEchangeRates.rateForCurrency(ISnxSynth(targetImpl).currencyKey());\n            return getPrice(USDC, _tokenOut).preciseMul(exchangeRate);\n        }\n\n        if (tokenOutType == 4) {\n            address targetImpl = ISnxProxy(_tokenOut).target();\n            exchangeRate = snxEchangeRates.rateForCurrency(ISnxSynth(targetImpl).currencyKey());\n            return getPrice(_tokenIn, USDC).preciseDiv(exchangeRate);\n        }\n\n        if (tokenInType == 5) {\n            address crvPool = curveMetaRegistry.getPoolFromLpToken(_tokenIn);\n            if (crvPool != address(0)) {\n                address denominator = _cleanCurvePoolDenominator(crvPool, curveMetaRegistry);\n                return\n                    curveMetaRegistry.getVirtualPriceFromLpToken(_tokenIn).preciseMul(getPrice(denominator, _tokenOut));\n            }\n        }\n\n        if (tokenOutType == 5) {\n            // Token out is a curve lp\n            address crvPool = curveMetaRegistry.getPoolFromLpToken(_tokenOut);\n            if (crvPool != address(0)) {\n                address denominator = _cleanCurvePoolDenominator(crvPool, curveMetaRegistry);\n                return\n                    getPrice(_tokenIn, denominator).preciseDiv(curveMetaRegistry.getVirtualPriceFromLpToken(_tokenOut));\n            }\n        }\n        // Yearn vaults\n        if (tokenInType == 6) {\n            price = IYearnVault(_tokenIn).pricePerShare().preciseMul(\n                getPrice(IYearnVault(_tokenIn).token(), _tokenOut)\n            );\n            uint256 yvDecimals = ERC20(_tokenIn).decimals();\n            if (yvDecimals < 18) {\n                price = price.mul(10**(18 - yvDecimals));\n            }\n            return price;\n        }\n\n        if (tokenOutType == 6) {\n            address vaultAsset = IYearnVault(_tokenOut).token();\n            price = getPrice(_tokenIn, vaultAsset).preciseDiv(IYearnVault(_tokenOut).pricePerShare());\n\n            uint256 yvDecimals = ERC20(_tokenOut).decimals();\n            if (yvDecimals < 18) {\n                price = price.div(10**(18 - yvDecimals));\n            }\n            return price;\n        }\n\n        // univ2 or sushi or mooniswap\n        if (tokenInType == 8 || tokenInType == 9 || tokenInType == 10) {\n            return _getPriceUniV2LpToken(_tokenIn, WETH).preciseMul(getPrice(WETH, _tokenOut));\n        }\n        if (tokenOutType == 8 || tokenOutType == 9 || tokenInType == 10) {\n            return getPrice(_tokenIn, WETH).preciseDiv(_getPriceUniV2LpToken(_tokenOut, WETH));\n        }\n\n        // Gamma/Visor LP Tokens\n        if (tokenInType == 12) {\n            return _getPriceVisorLPToken(_tokenIn, WETH).preciseMul(getPrice(WETH, _tokenOut));\n        }\n        if (tokenOutType == 12) {\n            return getPrice(_tokenIn, WETH).preciseDiv(_getPriceVisorLPToken(_tokenOut, WETH));\n        }\n\n        // palstkaave (Curve cannot find otherwise weth-palstk)\n        if (_tokenIn == palStkAAVE) {\n            uint256 tokenInPrice = _getPriceThroughCurve(curvePalStkAave, palStkAAVE, AAVE, curveMetaRegistry);\n            if (tokenInPrice != 0) {\n                return tokenInPrice.preciseMul(_getBestPriceUniV3(AAVE, _tokenOut));\n            }\n        }\n\n        if (_tokenOut == palStkAAVE) {\n            uint256 tokenOutPrice = _getPriceThroughCurve(curvePalStkAave, AAVE, palStkAAVE, curveMetaRegistry);\n            if (tokenOutPrice != 0) {\n                return tokenOutPrice.preciseMul(_getBestPriceUniV3(_tokenIn, AAVE));\n            }\n        }\n\n        // Direct curve pair\n        price = _checkPairThroughCurve(_tokenIn, _tokenOut, curveMetaRegistry);\n        if (price != 0) {\n            return price;\n        }\n\n        // Direct UNI3\n        price = _getBestPriceUniV3(_tokenIn, _tokenOut);\n        if (price != 0) {\n            return price;\n        }\n\n        // Curve to UniV3 or UniV3 to Curve via DAI/WETH/WBTC/USDC\n        for (uint256 i = 0; i < hopTokensList.length; i++) {\n            address reserve = hopTokensList[i];\n            if (_tokenIn != reserve && _tokenOut != reserve) {\n                uint256 tokenInPrice = _checkPairThroughCurve(_tokenIn, reserve, curveMetaRegistry);\n                if (tokenInPrice != 0) {\n                    return tokenInPrice.preciseMul(_getBestPriceUniV3(reserve, _tokenOut));\n                }\n                uint256 tokenOutPrice = _checkPairThroughCurve(reserve, _tokenOut, curveMetaRegistry);\n                if (tokenOutPrice != 0) {\n                    return tokenOutPrice.preciseMul(_getBestPriceUniV3(_tokenIn, reserve));\n                }\n            }\n        }\n\n        // Use only univ2 for UI\n        if (_forNAV) {\n            price = _getUNIV2Price(_tokenIn, _tokenOut);\n        }\n        // No valid price\n        return price;\n    }\n\n    function _cleanCurvePoolDenominator(address _pool, ICurveMetaRegistry _curveMetaRegistry)\n        internal\n        view\n        returns (address)\n    {\n        address[8] memory coins = _curveMetaRegistry.getCoinAddresses(_pool, true);\n        if (coins[0] != address(0)) {\n            return coins[0] == ETH_ADD_CURVE ? WETH : coins[0];\n        }\n        if (coins[1] != address(0)) {\n            return coins[1] == ETH_ADD_CURVE ? WETH : coins[1];\n        }\n        if (coins[2] != address(0)) {\n            return coins[2] == ETH_ADD_CURVE ? WETH : coins[2];\n        }\n        return address(0);\n    }\n\n    // Susceptible to flash loans.\n    // Only use for UI and getNAV\n    function _getUNIV2Price(address _tokenIn, address _tokenOut) private view returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = _tokenIn;\n        path[1] = _tokenOut;\n        return uniRouterV2.getAmountsOut(ERC20(_tokenIn).decimals(), path)[1];\n    }\n\n    function _getUNIV3Price(\n        IUniswapV3Pool pool,\n        address _tokenIn,\n        address _tokenOut\n    ) private view returns (uint256) {\n        // Same asset. Returns base unit\n        if (_tokenIn == _tokenOut) {\n            return 10**18;\n        }\n        int24 tick;\n\n        (, tick, , , , , ) = pool.slot0();\n        if (!_checkPrice(tick, pool)) {\n            return 0;\n        }\n        return\n            OracleLibrary\n                .getQuoteAtTick(\n                tick,\n                // because we use 1e18 as a precision unit\n                uint128(uint256(1e18).mul(10**(uint256(18).sub(ERC20(_tokenOut).decimals())))),\n                _tokenIn,\n                _tokenOut\n            )\n                .div(10**(uint256(18).sub(ERC20(_tokenIn).decimals())));\n    }\n\n    function _getUniV3PriceNaive(address _tokenIn, address _tokenOut) private view returns (uint256) {\n        // Same asset. Returns base unit\n        if (_tokenIn == _tokenOut) {\n            return 10**18;\n        }\n        IUniswapV3Pool pool = _getUniswapPoolWithHighestLiquidity(_tokenIn, _tokenOut);\n        if (address(pool) == address(0)) {\n            return 0;\n        }\n        return _getUNIV3Price(pool, _tokenIn, _tokenOut);\n    }\n\n    function _getBestPriceUniV3(address _tokenIn, address _tokenOut) private view returns (uint256) {\n        uint256 price = 1e18;\n        address reservePathIn = _tokenIn;\n        address reservePathOut = _tokenOut;\n        // Go from token in to a reserve (choose best on the the highest liquidity in DAI)\n        if (!hopTokens[_tokenIn]) {\n            (address pathIn, uint256 priceAux) = _getHighestLiquidityPathToReserveUniV3(_tokenIn, true);\n            if (pathIn != address(0)) {\n                reservePathIn = pathIn;\n                price = priceAux;\n            }\n        }\n        // Go from a reserve to token out (choose best on the the highest liquidity in DAI)\n        if (!hopTokens[_tokenOut]) {\n            (address pathOut, uint256 priceAux) = _getHighestLiquidityPathToReserveUniV3(_tokenOut, false);\n            if (pathOut != address(0)) {\n                reservePathOut = pathOut;\n                // If reserves are different\n                if (reservePathIn != reservePathOut) {\n                    price = price.preciseMul(_getUniV3PriceNaive(reservePathIn, reservePathOut));\n                }\n                // Multiply from out reserve path to out token\n                price = price.preciseMul(priceAux);\n                if (price != 0) {\n                    return price;\n                }\n            }\n        }\n        // If reserves are different\n\n        if (reservePathIn != reservePathOut) {\n            price = price.preciseMul(_getUniV3PriceNaive(reservePathIn, reservePathOut));\n        }\n        return price != 0 ? price : _getUniV3PriceNaive(_tokenIn, _tokenOut);\n    }\n\n    function _getHighestLiquidityPathToReserveUniV3(address _token, bool _in) private view returns (address, uint256) {\n        uint256 price;\n        address reserveChosen;\n        IUniswapV3Pool maxpool;\n        uint256 maxLiquidityInDai;\n        for (uint256 i = 0; i < hopTokensList.length; i++) {\n            (address pool, uint256 liquidityInDai) =\n                _getUniswapHighestLiquidityInReserveAsset(_token, hopTokensList[i], DAI);\n            if (liquidityInDai > maxLiquidityInDai) {\n                maxpool = IUniswapV3Pool(pool);\n                maxLiquidityInDai = liquidityInDai;\n                reserveChosen = hopTokensList[i];\n            }\n        }\n        if (maxLiquidityInDai > 0) {\n            if (_in) {\n                price = _getUNIV3Price(maxpool, _token, reserveChosen);\n            } else {\n                price = _getUNIV3Price(maxpool, reserveChosen, _token);\n            }\n        }\n        return (reserveChosen, price);\n    }\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow >= liquidityMedium && liquidityLow >= liquidityHigh) {\n            return poolLow;\n        }\n        if (liquidityMedium >= liquidityLow && liquidityMedium >= liquidityHigh) {\n            return poolMedium;\n        }\n        return poolHigh;\n    }\n\n    function _getUniswapHighestLiquidityInReserveAsset(\n        address _sendToken,\n        address _receiveToken,\n        address _reserveAsset\n    ) private view returns (address, uint256) {\n        IUniswapV3Pool pool = _getUniswapPoolWithHighestLiquidity(_sendToken, _receiveToken);\n        if (address(pool) == address(0)) {\n            return (address(0), 0);\n        }\n        uint256 liquidityInReserve;\n        address denominator;\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n\n        if (hopTokens[token0]) {\n            liquidityInReserve = ERC20(token0).balanceOf(address(pool));\n            denominator = token0;\n        } else {\n            liquidityInReserve = ERC20(token1).balanceOf(address(pool));\n            denominator = token1;\n        }\n        // Normalize to reserve asset\n        if (denominator != _reserveAsset) {\n            uint256 price = _getUniV3PriceNaive(denominator, _reserveAsset);\n            // price is always in 18 decimals\n            // preciseMul returns in the same decimals than liquidityInReserve, so we have to normalize into reserve Asset decimals\n            // normalization into reserveAsset decimals\n            liquidityInReserve = SafeDecimalMath.normalizeAmountTokens(\n                denominator,\n                _reserveAsset,\n                liquidityInReserve.preciseMul(price)\n            );\n        }\n        return (address(pool), liquidityInReserve);\n    }\n\n    /// @dev Revert if current price is too close to min or max ticks allowed\n    /// by Uniswap, or if it deviates too much from the TWAP. Should be called\n    /// whenever base and limit ranges are updated. In practice, prices should\n    /// only become this extreme if there's no liquidity in the Uniswap pool.\n    function _checkPrice(int24 mid, IUniswapV3Pool _pool) private view returns (bool) {\n        int24 tickSpacing = _pool.tickSpacing();\n        // TODO: Add the other param from charm\n        if (mid < TickMath.MIN_TICK + baseThreshold + tickSpacing) {\n            // \"price too low\"\n            return false;\n        }\n        if (mid > TickMath.MAX_TICK - baseThreshold - tickSpacing) {\n            // \"price too high\"\n            return false;\n        }\n\n        // Check TWAP deviation. This check prevents price manipulation before\n        // the rebalance and also avoids rebalancing when price has just spiked.\n        int56 twap = _getTwap(_pool);\n\n        int56 deviation = mid > twap ? mid - twap : twap - mid;\n        // Fail twap check\n        return deviation < maxTwapDeviation;\n    }\n\n    // given the cumulative prices of the start and end of a period, and the length of the period, compute the average\n    function _getTwap(IUniswapV3Pool _pool) private view returns (int56 twap) {\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = SECONDS_GRANULARITY;\n        secondsAgo[1] = 0;\n        // observe fails if the pair has no observations\n        try _pool.observe(secondsAgo) returns (\n            int56[] memory tickCumulatives,\n            uint160[] memory /* secondsPerLiquidityCumulativeX128s */\n        ) {\n            return (tickCumulatives[1] - tickCumulatives[0]) / SECONDS_GRANULARITY;\n        } catch {\n            return 0;\n        }\n    }\n\n    function _getPriceThroughCurve(\n        address _curvePool,\n        address _tokenIn,\n        address _tokenOut,\n        ICurveMetaRegistry _curveMetaRegistry\n    ) private view returns (uint256) {\n        (uint256 i, uint256 j, bool underlying) = _curveMetaRegistry.getCoinIndices(_curvePool, _tokenIn, _tokenOut);\n        uint256 price = 0;\n        uint256 decimalsIn = 10**(_tokenIn == ETH_ADD_CURVE ? 18 : ERC20(_tokenIn).decimals());\n        if (i == j) return 0;\n        if (underlying) {\n            price = _getCurveDYUnderlying(_curvePool, i, j, decimalsIn);\n        } else {\n            price = _getCurveDY(_curvePool, i, j, decimalsIn);\n        }\n        price = price.mul(10**(18 - (_tokenOut == ETH_ADD_CURVE ? 18 : ERC20(_tokenOut).decimals())));\n        uint256 delta = price.preciseMul(CURVE_SLIPPAGE);\n        if (price < uint256(1e18).add(delta) && price > uint256(1e18).sub(delta)) {\n            return price;\n        }\n        return 0;\n    }\n\n    function _getCurveDY(\n        address _curvePool,\n        uint256 i,\n        uint256 j,\n        uint256 decimals\n    ) private view returns (uint256) {\n        try ICurvePoolV3DY(_curvePool).get_dy(i, j, decimals) returns (uint256 price) {\n            return price;\n        } catch {\n            try ICurvePoolV3(_curvePool).get_dy(int128(i), int128(j), decimals) returns (uint256 price2) {\n                return price2;\n            } catch {\n                revert('get dy failed');\n            }\n        }\n    }\n\n    /**\n     * Calculates the value of a univ2 lp token or sushi in denominator asset\n     * @param _pool                      Address of the univ2 style lp token\n     * @param _denominator               Address of the denominator asset\n     */\n    function _getPriceUniV2LpToken(address _pool, address _denominator) internal view returns (uint256) {\n        address[] memory poolTokens = new address[](2);\n        poolTokens[0] = IUniswapV2Pair(_pool).token0();\n        poolTokens[1] = IUniswapV2Pair(_pool).token1();\n        ERC20 lpToken = ERC20(_pool);\n        uint256 result = 0;\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            address asset = _isETH(poolTokens[i]) ? WETH : poolTokens[i];\n            uint256 price = getPrice(_denominator, asset);\n            uint256 balance = !_isETH(poolTokens[i]) ? ERC20(poolTokens[i]).balanceOf(_pool) : _pool.balance;\n            // Special case for weth in some pools\n            if (poolTokens[i] == WETH && balance == 0) {\n                balance = _pool.balance;\n            }\n            if (price != 0 && balance != 0) {\n                result = result.add(\n                    SafeDecimalMath.normalizeAmountTokens(\n                        asset,\n                        _denominator,\n                        balance.preciseDiv(lpToken.totalSupply()).preciseDiv(price)\n                    )\n                );\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the value of a visor univ3 lp token\n     * @param _visor                     Address of the gama visor\n     * @param _reserve                   Address of the reserve to price tokens in\n     */\n    function _getPriceVisorLPToken(address _visor, address _reserve) internal view returns (uint256) {\n        uint256 totalSupply = IHypervisor(_visor).totalSupply();\n        if (totalSupply == 0) {\n            return 0;\n        }\n        (uint256 amount0, uint256 amount1) = IHypervisor(_visor).getTotalAmounts();\n        return _getPriceUniV3Pool(IUniswapV3Pool(IHypervisor(_visor).pool()), _reserve, totalSupply, amount0, amount1);\n    }\n\n    /**\n     * Calculates the price of a Univ3 wrapped ERC-20 based on supply and amounts\n     * @param _pool                      Address of the univ3 pool\n     * @param _reserve                   Address of the reserve to denominate the price in\n     * @param _totalSupply               Total Supply of the ERC-20 wrapper\n     * @param _amount0                   Total Amount of the first token\n     * @param _amount1                   Toatl Amount of the second token\n     */\n    function _getPriceUniV3Pool(\n        IUniswapV3Pool _pool,\n        address _reserve,\n        uint256 _totalSupply,\n        uint256 _amount0,\n        uint256 _amount1\n    ) internal view returns (uint256) {\n        uint256 priceToken0 = _getPrice(_pool.token0(), _reserve, false);\n        uint256 priceToken1 = _getPrice(_pool.token1(), _reserve, false);\n\n        uint256 priceinReserveToken0 =\n            SafeDecimalMath.normalizeAmountTokens(\n                _pool.token0(),\n                _reserve,\n                _amount0.mul(priceToken0).div(_totalSupply)\n            );\n        uint256 priceinReserveToken1 =\n            SafeDecimalMath.normalizeAmountTokens(\n                _pool.token1(),\n                _reserve,\n                _amount1.mul(priceToken1).div(_totalSupply)\n            );\n        return priceinReserveToken0.add(priceinReserveToken1);\n    }\n\n    function _getCurveDYUnderlying(\n        address _curvePool,\n        uint256 i,\n        uint256 j,\n        uint256 decimals\n    ) private view returns (uint256) {\n        try ICurvePoolV3DY(_curvePool).get_dy_underlying(i, j, decimals) returns (uint256 price) {\n            return price;\n        } catch {\n            try ICurvePoolV3(_curvePool).get_dy_underlying(int128(i), int128(j), decimals) returns (uint256 price2) {\n                return price2;\n            } catch {\n                try ICurvePoolV3(_curvePool).get_dy(int128(i), int128(j), decimals) returns (uint256 price3) {\n                    return price3;\n                } catch {\n                    revert('get dy underlying failed');\n                }\n            }\n        }\n    }\n\n    function _checkPairThroughCurve(\n        address _tokenIn,\n        address _tokenOut,\n        ICurveMetaRegistry _curveMetaRegistry\n    ) private view returns (uint256) {\n        address curvePool = _curveMetaRegistry.findPoolForCoins(_tokenIn, _tokenOut, 0);\n        if (_tokenIn == WETH && curvePool == address(0)) {\n            _tokenIn = ETH_ADD_CURVE;\n            curvePool = _curveMetaRegistry.findPoolForCoins(ETH_ADD_CURVE, _tokenOut, 0);\n        }\n        if (_tokenOut == WETH && curvePool == address(0)) {\n            _tokenOut = ETH_ADD_CURVE;\n            curvePool = _curveMetaRegistry.findPoolForCoins(_tokenIn, ETH_ADD_CURVE, 0);\n        }\n        if (curvePool != address(0)) {\n            uint256 price = _getPriceThroughCurve(curvePool, _tokenIn, _tokenOut, _curveMetaRegistry);\n            return price;\n        }\n        return 0;\n    }\n\n    function _updateReserves(address[] memory list) private {\n        for (uint256 i = 0; i < hopTokensList.length; i++) {\n            hopTokens[hopTokensList[i]] = false;\n        }\n        delete hopTokensList;\n        for (uint256 i = 0; i < list.length; i++) {\n            hopTokens[list[i]] = true;\n            hopTokensList.push(list[i]);\n        }\n    }\n\n    function _isETH(address _address) internal pure returns (bool) {\n        return _address == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || _address == address(0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / period);\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % period != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ISnxExchangeRates {\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint256 value);\n\n    function rateForCurrency(bytes32 sourceCurrencyKey) external view returns (uint256 value);\n}\n"
    },
    "contracts/interfaces/external/harvest/IHarvestUniv3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IHarvestUniv3Pool {\n    function deposit(\n        uint256 _amount0,\n        uint256 _amount1,\n        bool _zapFunds,\n        uint256 _sqrtRatioX96,\n        uint256 _tolerance,\n        uint256 _zapAmount0OutMin,\n        uint256 _zapAmount1OutMin,\n        uint160 _zapSqrtPriceLimitX96\n    ) external;\n\n    function withdraw(\n        uint256 _numberOfShares,\n        bool _token0,\n        bool _token1,\n        uint256 _sqrtRatioX96,\n        uint256 _tolerance\n    ) external;\n\n    function approve(address spender, uint256 amount) external;\n\n    function governance() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getSqrtPriceX96() external view returns (uint160);\n\n    function getStorage() external view returns (address);\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePoolV3DY.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface ICurvePoolV3DY {\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/IUniswapViewer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IUniswapViewer {\n    function getAmountsForPosition(uint256 posId) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/IUniVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IUniVaultStorage {\n    function posId() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/INFTPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface INFTPositionManager {\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxSynth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISnxSynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint256);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint256 value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint256 amount) external;\n\n    function issue(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISnxProxy {\n    // Views\n    function target() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearnRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IYearnRegistry {\n    function latestVault(address asset) external view returns (address);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {UniversalERC20} from '../lib/UniversalERC20.sol';\nimport {BytesLib} from '../lib/BytesLib.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {ILendingPool} from '../interfaces/external/aave/ILendingPool.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {ITradeIntegration} from '../interfaces/ITradeIntegration.sol';\nimport {IOperation} from '../interfaces/IOperation.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IMasterSwapper} from '../interfaces/IMasterSwapper.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\n\n/**\n * @title Strategy\n * @author Babylon Finance\n *\n * Base Strategy contract. Belongs to a garden. Abstract.\n * Will be extended from specific strategy contracts.\n */\ncontract Strategy is ReentrancyGuard, IStrategy, Initializable {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for int256;\n    using SafeDecimalMath for uint256;\n    using Math for int256;\n    using Math for uint256;\n    using AddressArrayUtils for address[];\n    using BytesLib for bytes;\n    using BytesLib for address;\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Events ============ */\n    event Invoked(address indexed _target, uint256 indexed _value, bytes _data, bytes _returnValue);\n    event StrategyVoted(\n        address indexed _garden,\n        uint256 totalPositiveVotes,\n        uint256 totalNegativeVotes,\n        uint256 _timestamp\n    );\n    event StrategyExecuted(address indexed _garden, uint256 _capital, uint256 _fee, uint256 timestamp);\n    event StrategyFinalized(address indexed _garden, uint256 _capitalReturned, uint256 _fee, uint256 timestamp);\n    event StrategyReduced(address indexed _garden, uint256 _amountReduced, uint256 timestamp);\n    event StrategyExpired(address indexed _garden, uint256 _timestamp);\n    event StrategyDeleted(address indexed _garden, uint256 _timestamp);\n    event StrategyDurationChanged(uint256 _newDuration, uint256 _oldDuration);\n\n    /* ============ Modifiers ============ */\n\n    function _onlyStrategistOrGovernor() private view {\n        _require(msg.sender == strategist || msg.sender == controller.owner(), Errors.ONLY_STRATEGIST);\n    }\n\n    /**\n     * Throws if the sender is not a Garden's integration or integration not enabled\n     */\n    function _onlyOperation() private view {\n        bool found;\n        for (uint8 i = 0; i < opTypes.length; i++) {\n            found = found || msg.sender == controller.enabledOperations(opTypes[i]);\n        }\n        // Internal function used to reduce bytecode size\n        _require(found, Errors.ONLY_OPERATION);\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     */\n    function _onlyKeeper() private view {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n    }\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     */\n    function _onlyIntegration(address _address) private view {\n        bool isIntegration;\n        for (uint256 i = 0; i < opIntegrations.length; i++) {\n            if (opIntegrations[i] == _address) {\n                isIntegration = true;\n                break;\n            }\n        }\n        IMasterSwapper masterSwapper = IMasterSwapper(IBabController(controller).masterSwapper());\n        _require(\n            isIntegration ||\n                _address == 0xF1392356e22F5b10A2F0eF2a29b7E78ffaBF6F5E || // convex_v2\n                _address == 0x72e27dA102a67767a7a3858D117159418f93617D || // aavelend\n                _address == 0x699118Bd7cda572A25dDda8A04E409719744683E ||\n                _address == 0x048d4c45C5963320f7E1893138Aed34084948242 || // AAVE Borrow\n                masterSwapper.isTradeIntegration(_address),\n            Errors.ONLY_INTEGRATION\n        );\n    }\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(\n            !IBabController(controller).isPaused(address(this)) || msg.sender == controller.owner(),\n            Errors.ONLY_UNPAUSED\n        );\n    }\n\n    /* ============ Constants ============ */\n\n    uint256 private constant DEFAULT_TRADE_SLIPPAGE = 25e15; // 2.5%\n    uint256 private constant HUNDRED_PERCENT = 1e18; // 100%\n    uint256 private constant MAX_CANDIDATE_PERIOD = 7 days;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    // Quadratic penalty for looses\n    uint256 private constant STAKE_QUADRATIC_PENALTY_FOR_LOSSES = 175e16; // 1.75e18\n\n    uint256 private constant LEND_OP = 3;\n    uint256 private constant BORROW_OP = 4;\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Babylon Controller Address\n    IBabController private controller;\n\n    // Type of operation.\n    // 0 = BuyOperation\n    // 1 = LiquidityOperation\n    // 2 = VaultOperation\n    // 3 = LendOperation\n    // 4 = BorrowOperation\n\n    // Asset Status\n    // 0 = Liquid\n    // 1 = Put as collateral\n    // 2 = Borrowed\n    // 3 = staked\n\n    // Types and data for the operations of this strategy\n    uint8[] private opTypes;\n    address[] private opIntegrations;\n    address[] private opDatas; // DEPRECATED\n\n    // Garden that these strategies belong to\n    IGarden public override garden;\n\n    address public override strategist; // Address of the strategist that submitted the bet\n\n    uint256 public override enteredAt; // Timestamp when the strategy was submitted\n    uint256 public override enteredCooldownAt; // Timestamp when the strategy reached quorum\n    uint256 private executedAt; // Timestamp when the strategy was executed\n    uint256 private updatedAt; // Timestamp of last capital allocation update\n    uint256 private exitedAt; // Timestamp when the strategy was submitted\n\n    address[] public voters; // Addresses with the voters\n    uint256 public override totalPositiveVotes; // Total positive votes endorsing the strategy execution\n    uint256 public override totalNegativeVotes; // Total negative votes against the strategy execution\n    bool private finalized; // Flag that indicates whether we exited the strategy\n    bool private active; // Whether the strategy has met the voting quorum\n    bool private dataSet;\n    bool private hasMiningStarted; // DEPRECATED\n\n    uint256 public override duration; // Duration of the bet\n    uint256 public override stake; // Amount of stake by the strategist (in reserve asset) needs to be positive\n    uint256 public override maxCapitalRequested; // Amount of max capital to allocate\n    uint256 public override capitalAllocated; // Current amount of capital allocated\n    uint256 public override expectedReturn; // Expect return by this strategy\n    uint256 public override capitalReturned; // Actual return by this strategy\n    uint256 private startingGardenSupply; // garden token supply when strategy starts\n    address[] private tokensNeeded; // Not used anymore\n    uint256[] private tokenAmountsNeeded; // Not used anymore\n\n    uint256 public override strategyRewards; // Rewards allocated for this strategy updated on finalized\n    uint256 private endingGardenSupply; // garden token supply when strategy ends\n\n    // Voters mapped to their votes.\n    mapping(address => int256) private votes;\n\n    // Strategy opDatas encoded\n    bytes public override opEncodedData; // we use and reserve 64bytes for each operation as consecutives bytes64 word\n\n    // Rewards Distributor address\n    IRewardsDistributor private rewardsDistributor;\n\n    uint256 public override maxAllocationPercentage; //  Relative to garden capital. (1% = 1e16, 10% 1e17)\n\n    uint256 public override maxGasFeePercentage; // Relative to the capital allocated to the strategy (1% = 1e16, 10% 1e17)\n\n    uint256 public override maxTradeSlippagePercentage; // Relative to the capital of the trade (1% = 1e16, 10% 1e17)\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initializes the strategy for a garden\n     *\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _controller                    Address of the controller\n     * @param _maxCapitalRequested           Max Capital requested denominated in the reserve asset (0 to be unlimited)\n     * @param _stake                         Stake with garden participations absolute amounts 1e18\n     * @param _strategyDuration              Strategy duration in seconds\n     * @param _expectedReturn                Expected return\n     * @param _maxAllocationPercentage       Max allocation percentage of garden capital\n     * @param _maxGasFeePercentage           Max gas fee percentage of garden capital\n     * @param _maxTradeSlippagePercentage    Max slippage allowed per trade in % of capital\n     */\n    function initialize(\n        address _strategist,\n        address _garden,\n        address _controller,\n        uint256 _maxCapitalRequested,\n        uint256 _stake,\n        uint256 _strategyDuration,\n        uint256 _expectedReturn,\n        uint256 _maxAllocationPercentage,\n        uint256 _maxGasFeePercentage,\n        uint256 _maxTradeSlippagePercentage\n    ) external override initializer {\n        controller = IBabController(_controller);\n        garden = IGarden(_garden);\n\n        _require(controller.isSystemContract(_garden), Errors.NOT_A_GARDEN);\n        _require(IERC20(address(garden)).balanceOf(_strategist) > 0, Errors.STRATEGIST_TOKENS_TOO_LOW);\n\n        _setMaxCapitalRequested(_maxCapitalRequested);\n        _setStake(_stake, _strategist);\n        _setDuration(_strategyDuration);\n        _setMaxTradeSlippage(_maxTradeSlippagePercentage);\n        _setMaxGasFeePercentage(_maxGasFeePercentage);\n        _setMaxAllocationPercentage(_maxAllocationPercentage);\n\n        strategist = _strategist;\n        enteredAt = block.timestamp;\n\n        rewardsDistributor = IRewardsDistributor(IBabController(controller).rewardsDistributor());\n        expectedReturn = _expectedReturn;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Sets the data for the operations of this strategy\n     * @param _opTypes                    An array with the op types\n     * @param _opIntegrations             Addresses with the integration for each op\n     * @param _opEncodedData              Bytes with the params for the op in the same position in the opTypes array\n     */\n    function setData(\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes memory _opEncodedData\n    ) external override {\n        _require(\n            msg.sender == address(garden) && !dataSet && IBabController(controller).isSystemContract(address(garden)),\n            Errors.ONLY_GARDEN_AND_DATA_NOT_SET\n        );\n        uint256 opEncodedLength = _opEncodedData.length.div(64); // encoded without signature\n        _require(\n            opEncodedLength > 0 &&\n                (_opTypes.length == _opIntegrations.length) &&\n                (_opIntegrations.length == opEncodedLength),\n            Errors.TOO_MANY_OPS\n        );\n        for (uint256 i = 0; i < _opTypes.length; i++) {\n            IOperation(controller.enabledOperations(_opTypes[i])).validateOperation(\n                BytesLib.get64Bytes(_opEncodedData, i),\n                garden,\n                _opIntegrations[i],\n                i\n            );\n        }\n        opTypes = _opTypes;\n        opIntegrations = _opIntegrations;\n        opEncodedData = _opEncodedData;\n        dataSet = true;\n    }\n\n    /**\n     * Adds off-chain voting results on-chain.\n     * @param _voters                  An array of garden member who voted on strategy.\n     * @param _votes                   An array of votes by on strategy by garden members.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     */\n    function resolveVoting(\n        address[] calldata _voters,\n        int256[] calldata _votes,\n        uint256 _fee\n    ) external override {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(_voters.length >= garden.minVoters(), Errors.MIN_VOTERS_CHECK);\n        _require(!active && !finalized, Errors.VOTES_ALREADY_RESOLVED);\n        _require(block.timestamp.sub(enteredAt) <= MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OVER);\n        _require(_voters.length == _votes.length, Errors.INVALID_VOTES_LENGTH);\n        active = true;\n        // set votes to zero expecting keeper to provide correct values\n        totalPositiveVotes = 0;\n        totalNegativeVotes = 0;\n\n        // Set votes data\n        for (uint256 i = 0; i < _voters.length; i++) {\n            votes[_voters[i]] = _votes[i];\n            if (_votes[i] > 0) {\n                totalPositiveVotes = totalPositiveVotes.add(uint256(Math.abs(_votes[i])));\n            } else {\n                totalNegativeVotes = totalNegativeVotes.add(uint256(Math.abs(_votes[i])));\n            }\n        }\n        _require(totalPositiveVotes.sub(totalNegativeVotes) > 0, Errors.TOTAL_VOTES_HAVE_TO_BE_POSITIVE);\n\n        // Keeper will account for strategist vote/stake\n        voters = _voters;\n        // Initializes cooldown\n        enteredCooldownAt = block.timestamp;\n        emit StrategyVoted(address(garden), totalPositiveVotes, totalNegativeVotes, block.timestamp);\n        garden.payKeeper(msg.sender, _fee);\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     */\n    function executeStrategy(uint256 _capital, uint256 _fee) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(_capital > 0, Errors.MIN_REBALANCE_CAPITAL);\n        _executesStrategy(_capital, _fee, msg.sender);\n    }\n\n    /**\n     * Exits from an executed strategy.\n     * Returns balance back to the garden and sets the capital aside for withdrawals in ETH.\n     * Pays the keeper.\n     * Updates the reserve asset position accordingly.\n     * @param _fee                     The fee paid to keeper to compensate the gas cost\n     * @param _tokenURI                URL with the JSON for the strategy\n     * @param _minReserveOut           Minimum reserve asset to get during strategy finalization\n     */\n    function finalizeStrategy(\n        uint256 _fee,\n        string memory _tokenURI,\n        uint256 _minReserveOut\n    ) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(executedAt > 0 && block.timestamp > executedAt.add(duration), Errors.STRATEGY_IS_NOT_OVER_YET);\n        _require(!finalized, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        uint256 reserveAssetReturns = IERC20(garden.reserveAsset()).balanceOf(address(this));\n        // Execute exit operations\n        _exitStrategy(HUNDRED_PERCENT);\n        capitalReturned = IERC20(garden.reserveAsset()).balanceOf(address(this)).sub(reserveAssetReturns);\n        // Mark as finalized\n        finalized = true;\n        active = false;\n        exitedAt = block.timestamp;\n        // Mint NFT\n        IStrategyNFT(IBabController(controller).strategyNFT()).grantStrategyNFT(strategist, _tokenURI);\n        // Pay Keeper Fee\n        garden.payKeeper(msg.sender, _fee);\n        // MinReserveOut security check\n        _require(capitalReturned >= _minReserveOut, Errors.INVALID_RESERVE_AMOUNT);\n        // Transfer rewards\n        _transferStrategyPrincipal();\n        // Send rest to garden if any\n        _sendReserveAssetToGarden();\n        updatedAt = exitedAt;\n        emit StrategyFinalized(address(garden), capitalReturned, _fee, block.timestamp);\n    }\n\n    /**\n     * Partially unwinds an strategy.\n     * Triggered from an immediate withdraw in the Garden.\n     * @param _amountToUnwind  The amount of capital to unwind\n     * @param _strategyNAV     NAV of the strategy to unwind.\n     */\n    function unwindStrategy(uint256 _amountToUnwind, uint256 _strategyNAV) external override nonReentrant {\n        _require(\n            (msg.sender == address(garden) && IBabController(controller).isSystemContract(address(garden))) ||\n                msg.sender == controller.owner(),\n            Errors.ONLY_PROTOCOL_OR_GARDEN\n        );\n        _onlyUnpaused();\n        _require(active && !finalized, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(block.timestamp < executedAt.add(duration), Errors.STRATEGY_IS_ALREADY_FINALIZED);\n        // An unwind should not allow users to remove all capital from a strategy\n        _require(_amountToUnwind < _strategyNAV, Errors.INVALID_CAPITAL_TO_UNWIND);\n        // Exits and enters the strategy\n        _exitStrategy(_amountToUnwind.preciseDiv(_strategyNAV));\n        capitalAllocated = capitalAllocated.sub(_amountToUnwind);\n        // expected return update\n        expectedReturn = _updateExpectedReturn(capitalAllocated, _amountToUnwind, false);\n        _updateProtocolPrincipal(_amountToUnwind, false);\n        // Send the amount back to the garden for the immediate withdrawal\n        // TODO: Transfer the precise value; not entire balance\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n        updatedAt = block.timestamp;\n\n        emit StrategyReduced(address(garden), _amountToUnwind, block.timestamp);\n    }\n\n    /**\n     * Expires a candidate that has spent more than CANDIDATE_PERIOD without\n     * reaching quorum\n     * @param _fee              The keeper fee\n     */\n    function expireStrategy(uint256 _fee) external nonReentrant {\n        _onlyUnpaused();\n        _onlyKeeper();\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n        _require(block.timestamp.sub(enteredAt) > MAX_CANDIDATE_PERIOD, Errors.VOTING_WINDOW_IS_OPENED);\n        // pay keeper before expiring strategy\n        garden.payKeeper(msg.sender, _fee);\n        _deleteCandidateStrategy();\n        emit StrategyExpired(address(garden), block.timestamp);\n    }\n\n    /**\n     * Delete a candidate strategy by the strategist\n     */\n    function deleteCandidateStrategy() external {\n        _onlyStrategistOrGovernor();\n        _deleteCandidateStrategy();\n        emit StrategyDeleted(address(garden), block.timestamp);\n    }\n\n    /**\n     * Emergency fix to change interest rate\n     */\n    function swapInterestRate(uint256 rateMode) external {\n        _onlyStrategistOrGovernor();\n        if (address(this) == 0x371B23eEdb1a5E3822AaCFf906187111A91fAE88) {\n            ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9).swapBorrowRateMode(\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,\n                rateMode\n            );\n        }\n    }\n\n    /**\n     * Allows strategist to update some strategy params\n     * @dev\n     *   _params[0]  duration\n     *   _params[1]  maxGasFeePercentage\n     *   _params[2]  maxTradeSlippagePercentage\n     *   _params[3]  maxAllocationPercentage\n     *   _params[4]  maxCapitalRequested\n     * @param _params  New params\n     */\n    function updateParams(uint256[5] calldata _params) external override {\n        _onlyStrategistOrGovernor();\n        _onlyUnpaused();\n\n        _require(_params[0] <= duration, Errors.STRATEGY_IS_ALREADY_FINALIZED);\n\n        _setDuration(_params[0]);\n        _setMaxGasFeePercentage(_params[1]);\n        _setMaxTradeSlippage(_params[2]);\n        _setMaxAllocationPercentage(_params[3]);\n        _setMaxCapitalRequested(_params[4]);\n\n        emit StrategyDurationChanged(_params[0], duration);\n    }\n\n    /**\n     * Any tokens (other than the target) that are sent here by mistake are recoverable by contributors\n     * Converts it to the reserve asset and sends it to the garden.\n     * @param _token                   Address of the token to sweep\n     * @param _newSlippage             New Slippage to override\n     */\n    function sweep(address _token, uint256 _newSlippage) external override nonReentrant {\n        _onlyUnpaused();\n        _require(!active, Errors.STRATEGY_NEEDS_TO_BE_INACTIVE);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _trade(_token, balance, garden.reserveAsset(), _newSlippage);\n        // Send reserve asset to garden\n        _sendReserveAssetToGarden();\n    }\n\n    /**\n     * Helper to invoke Approve on ERC20 from integrations in the strategy context\n     */\n    function invokeApprove(\n        address _spender,\n        address _asset,\n        uint256 _quantity\n    ) external override {\n        _onlyIntegration(msg.sender);\n        _onlyUnpaused();\n        /**\n          Have to set it to 0 first, because there are some terrible tokens\n          like USDT which will revert on allowance increase from non-zero value\n          https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code\n\n          On the other hand, tokens like hBTC doesn't allow to set value to 0 🤯\n          https://etherscan.io/address/0x0316EB71485b0Ab14103307bf65a021042c6d380#code\n\n          We need to perform a low level call here to ignore reverts returned by some tokens. If approve to 0 fails we\n          assume approve to _quantity will succeed or revert the whole function.\n        */\n        _asset.call(abi.encodeWithSelector(IERC20(_asset).approve.selector, _spender, 0));\n        IERC20(_asset).safeApprove(_spender, _quantity);\n    }\n\n    /**\n     * Helper to invoke a call to an external contract from integrations in the strategy context\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function invokeFromIntegration(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) external override returns (bytes memory) {\n        _onlyIntegration(msg.sender);\n        _onlyUnpaused();\n        return _invoke(_target, _value, _data);\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     * @param _overrideSlippage             Slippage to override\n     */\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _overrideSlippage\n    ) external override returns (uint256) {\n        _onlyOperation();\n        _onlyUnpaused();\n        return _trade(_sendToken, _sendQuantity, _receiveToken, _overrideSlippage);\n    }\n\n    function trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    ) external override returns (uint256) {\n        _onlyOperation();\n        _onlyUnpaused();\n        return _trade(_sendToken, _sendQuantity, _receiveToken, 0);\n    }\n\n    /**\n     * Deposits or withdraws weth from an operation in this context\n     * @param _isDeposit                    Whether is a deposit or withdraw\n     * @param _wethAmount                   Amount to deposit or withdraw\n     */\n    function handleWeth(bool _isDeposit, uint256 _wethAmount) public override {\n        _onlyOperation();\n        _handleWeth(_isDeposit, _wethAmount);\n    }\n\n    /** PRIVILEGE FUNCTION\n     * Update strategy rewards by governance through garden\n     * @param _newTotalRewards   New total rewards\n     */\n    function updateStrategyRewards(uint256 _newTotalRewards, uint256 _newCapitalReturned) external override {\n        _require(msg.sender == address(garden), Errors.STRATEGY_GARDEN_MISMATCH);\n        strategyRewards = _newTotalRewards;\n        capitalReturned = _newCapitalReturned;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Returns whether this strategy is currently active or not\n     */\n    function isStrategyActive() external view override returns (bool) {\n        return executedAt > 0 && exitedAt == 0;\n    }\n\n    /**\n     * Returns the number of operations in this strategy\n     */\n    function getOperationsCount() external view override returns (uint256) {\n        return opTypes.length;\n    }\n\n    /**\n     * Get the non-state related details of a Strategy\n     *\n     */\n    function getStrategyDetails()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            address(this),\n            strategist,\n            opIntegrations.length,\n            stake,\n            totalPositiveVotes,\n            totalNegativeVotes,\n            capitalAllocated,\n            capitalReturned,\n            duration,\n            expectedReturn,\n            maxCapitalRequested,\n            IBabController(controller).strategyNFT(),\n            enteredAt,\n            getNAV()\n        );\n    }\n\n    /**\n     * Get mining context details of a Strategy\n     *\n     */\n    function getStrategyRewardsContext()\n        external\n        view\n        override\n        returns (\n            address,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        uint256[] memory data = new uint256[](15);\n        bool[] memory boolData = new bool[](2);\n        data[0] = executedAt;\n        data[1] = exitedAt;\n        data[2] = updatedAt;\n        data[3] = enteredAt;\n        data[4] = totalPositiveVotes;\n        data[5] = totalNegativeVotes;\n        data[6] = capitalAllocated;\n        data[7] = capitalReturned;\n        data[8] = capitalAllocated.add(capitalAllocated.preciseMul(expectedReturn));\n        data[9] = strategyRewards;\n        boolData[0] = capitalReturned >= capitalAllocated;\n        boolData[1] = capitalReturned >= data[8];\n        data[10] = boolData[0] ? capitalReturned.sub(capitalAllocated) : 0; // no profit\n        data[11] = boolData[1] ? capitalReturned.sub(data[8]) : data[8].sub(capitalReturned);\n        data[12] = startingGardenSupply;\n        data[13] = endingGardenSupply;\n        if (executedAt > 0 && exitedAt == 0) {\n            uint256 endAt = executedAt.add(duration);\n            uint256 remaining =\n                endAt > block.timestamp ? (uint256(1e18).sub(endAt.sub(block.timestamp).preciseDiv(duration))) : 1e18;\n            data[14] = maxTradeSlippagePercentage.preciseMul(remaining).preciseMul(4e17); //40%\n        } else {\n            data[14] = 0;\n        }\n        return (strategist, data, boolData);\n    }\n\n    /**\n     * Get the state of a Strategy\n     *\n     */\n    function getStrategyState()\n        external\n        view\n        override\n        returns (\n            address,\n            bool,\n            bool,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (address(this), active, dataSet, finalized, executedAt, exitedAt, updatedAt);\n    }\n\n    /**\n     * Get the operation params by index\n     *\n     */\n    function getOperationByIndex(uint8 _index)\n        external\n        view\n        override\n        returns (\n            uint8,\n            address,\n            bytes memory\n        )\n    {\n        _require(_index >= 0 && _index < opTypes.length, Errors.NOT_IN_RANGE);\n        // _getOpDecodedData guarantee backward compatibility with OpData\n        return (opTypes[_index], opIntegrations[_index], _getOpDecodedData(_index));\n    }\n\n    /**\n     * Gets the NAV of assets under management.\n     * It is the sum of the NAV of all the operations\n     *\n     * @return _nav           NAV of the strategy\n     */\n    function getNAV() public view override returns (uint256) {\n        uint256 positiveNav;\n        uint256 negativeNav;\n        bytes32[] memory hashedOps = new bytes32[](opTypes.length);\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            uint8 opType = opTypes[i];\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(uint256(opType)));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            bytes memory data = _getOpDecodedData(i);\n            address integration = opIntegrations[i];\n            bytes32 hash = keccak256(abi.encodePacked(opType, data, integration));\n            // for borrow and lend operations we only need to count NAV once\n            if (opType == LEND_OP || opType == BORROW_OP) {\n                // check if NAV has been counted already\n                bool found;\n                for (uint256 j = 0; j < i; j++) {\n                    if (hashedOps[j] == hash) {\n                        found = true;\n                    }\n                }\n                if (found) {\n                    continue;\n                }\n            }\n            try operation.getNAV(data, garden, integration) returns (uint256 opNAV, bool positive) {\n                if (positive) {\n                    positiveNav = positiveNav.add(opNAV);\n                } else {\n                    negativeNav = negativeNav.add(opNAV);\n                }\n                hashedOps[i] = hash;\n            } catch {}\n        }\n        if (negativeNav > positiveNav) {\n            // Underwater, will display using operation NAV\n            return 0;\n        }\n        return positiveNav.sub(negativeNav);\n    }\n\n    /**\n     * Gets the votes casted by the contributor in this strategy\n     *\n     * @param _address           Address of the contributor\n     * @return _votes            Number of votes cast\n     */\n    function getUserVotes(address _address) external view override returns (int256) {\n        return votes[_address];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _setStake(uint256 _stake, address _strategist) internal {\n        (, , , , , , , , uint256 lockedBalance) = garden.getContributor(_strategist);\n        _require(\n            _stake > 0 && IERC20(address(garden)).balanceOf(_strategist).sub(lockedBalance) >= _stake,\n            Errors.TOKENS_STAKED\n        );\n        stake = _stake;\n    }\n\n    function _setMaxAllocationPercentage(uint256 _maxAllocationPercentage) internal {\n        _require(_maxAllocationPercentage <= 1e18, Errors.MAX_STRATEGY_ALLOCATION_PERCENTAGE);\n        maxAllocationPercentage = _maxAllocationPercentage;\n    }\n\n    function _setMaxCapitalRequested(uint256 _maxCapitalRequested) internal {\n        _require(_maxCapitalRequested > 0, Errors.MAX_CAPITAL_REQUESTED);\n        maxCapitalRequested = _maxCapitalRequested;\n    }\n\n    function _setMaxGasFeePercentage(uint256 _maxGasFeePercentage) internal {\n        _require(_maxGasFeePercentage <= 10e16, Errors.MAX_GAS_FEE_PERCENTAGE);\n        maxGasFeePercentage = _maxGasFeePercentage;\n    }\n\n    function _setMaxTradeSlippage(uint256 _maxTradeSlippagePercentage) internal {\n        _require(_maxTradeSlippagePercentage <= 20e16, Errors.MAX_TRADE_SLIPPAGE_PERCENTAGE);\n        maxTradeSlippagePercentage = _maxTradeSlippagePercentage;\n    }\n\n    function _setDuration(uint256 _strategyDuration) internal {\n        _require(\n            _strategyDuration >= garden.minStrategyDuration() && _strategyDuration <= garden.maxStrategyDuration(),\n            Errors.DURATION_MUST_BE_IN_RANGE\n        );\n        duration = _strategyDuration;\n    }\n\n    /**\n     * Executes an strategy that has been activated and gone through the cooldown period.\n     * Keeper will validate that quorum is reached, cacluates all the voting data and push it.\n     * @param _capital                  The capital to allocate to this strategy.\n     * @param _fee                      The fee paid to keeper to compensate the gas cost.\n     * @param _keeper                   The address of the keeper to pay\n     */\n    function _executesStrategy(\n        uint256 _capital,\n        uint256 _fee,\n        address payable _keeper\n    ) private {\n        _require(active, Errors.STRATEGY_NEEDS_TO_BE_ACTIVE);\n        _require(capitalAllocated.add(_capital) <= maxCapitalRequested, Errors.MAX_CAPITAL_REACHED);\n        _require(\n            block.timestamp.sub(enteredCooldownAt) >= garden.strategyCooldownPeriod(),\n            Errors.STRATEGY_IN_COOLDOWN\n        );\n        // Execute enter operation\n        garden.allocateCapitalToStrategy(_capital);\n        capitalAllocated = capitalAllocated.add(_capital);\n        _enterStrategy(_capital);\n        // Sets the executed timestamp on first execution\n        if (executedAt == 0) {\n            executedAt = block.timestamp;\n            // Checkpoint of garden supply at start\n            startingGardenSupply = IERC20(address(garden)).totalSupply();\n        } else {\n            // expected return update\n            expectedReturn = _updateExpectedReturn(capitalAllocated, _capital, true);\n        }\n        _updateProtocolPrincipal(_capital, true);\n        garden.payKeeper(_keeper, _fee);\n        updatedAt = block.timestamp;\n        emit StrategyExecuted(address(garden), _capital, _fee, block.timestamp);\n    }\n\n    /**\n     * Enters the strategy.\n     * Executes all the operations in order\n     * @param _capital  Amount of capital that the strategy receives\n     */\n    function _enterStrategy(uint256 _capital) private {\n        uint256 capitalForNexOperation = _capital;\n        address assetAccumulated = garden.reserveAsset();\n        uint8 assetStatus; // liquid\n        for (uint256 i = 0; i < opTypes.length; i++) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i]));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            (assetAccumulated, capitalForNexOperation, assetStatus) = operation.executeOperation(\n                assetAccumulated,\n                capitalForNexOperation,\n                assetStatus,\n                _getOpDecodedData(i),\n                garden,\n                opIntegrations[i]\n            );\n        }\n    }\n\n    /**\n     * Exits the strategy.\n     * Exists all the operations starting by the end.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function _exitStrategy(uint256 _percentage) private {\n        address assetFinalized = BytesLib.decodeOpDataAddressAssembly(_getOpDecodedData(opTypes.length - 1), 12);\n        uint256 capitalPending;\n        uint8 assetStatus;\n        for (uint256 i = opTypes.length; i > 0; i--) {\n            IOperation operation = IOperation(IBabController(controller).enabledOperations(opTypes[i - 1]));\n            // _getOpDecodedData guarantee backward compatibility with OpData\n            (assetFinalized, capitalPending, assetStatus) = operation.exitOperation(\n                assetFinalized,\n                capitalPending,\n                assetStatus,\n                // should use the percentage only for the first operation because we do not want to take percentage of\n                // the percentage for the subsequent operations\n                i == opTypes.length ? _percentage : HUNDRED_PERCENT,\n                _getOpDecodedData(i - 1),\n                garden,\n                opIntegrations[i - 1]\n            );\n        }\n        // Consolidate to reserve asset if needed\n        if (assetFinalized != garden.reserveAsset() && capitalPending > 0) {\n            if (assetFinalized == address(0)) {\n                _handleWeth(true, capitalPending);\n                assetFinalized = WETH;\n            }\n            if (assetFinalized != garden.reserveAsset()) {\n                _trade(assetFinalized, capitalPending, garden.reserveAsset(), 0);\n            }\n        }\n    }\n\n    /**\n     * Deletes this strategy and returns the stake to the strategist\n     */\n    function _deleteCandidateStrategy() private {\n        _require(executedAt == 0 && !finalized, Errors.STRATEGY_IS_EXECUTED);\n        IGarden(garden).expireCandidateStrategy(address(this));\n    }\n\n    /**\n     * Low level function that allows an integration to make an arbitrary function\n     * call to any contract from the garden (garden as msg.sender).\n     *\n     * @param _target                 Address of the smart contract to call\n     * @param _value                  Quantity of Ether to provide the call (typically 0)\n     * @param _data                   Encoded function selector and arguments\n     * @return _returnValue           Bytes encoded return value\n     */\n    function _invoke(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) private returns (bytes memory _returnValue) {\n        _returnValue = _target.functionCallWithValue(_data, _value, 'no err msg');\n        emit Invoked(_target, _value, _data, _returnValue);\n        return _returnValue;\n    }\n\n    function _sendReserveAssetToGarden() private {\n        // Sends the rest back if any\n        IERC20(garden.reserveAsset()).safeTransfer(\n            address(garden),\n            IERC20(garden.reserveAsset()).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * Function that calculates the price using the oracle and executes a trade.\n     * Must call the exchange to get the price and pass minReceiveQuantity accordingly.\n     * @param _sendToken                    Token to exchange\n     * @param _sendQuantity                 Amount of tokens to send\n     * @param _receiveToken                 Token to receive\n     * @param _overrideSlippage             Override slippage\n     */\n    function _trade(\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _overrideSlippage\n    ) private returns (uint256) {\n        // Uses on chain oracle for all internal strategy operations to avoid attacks\n        uint256 pricePerTokenUnit = _getPrice(_sendToken, _receiveToken);\n        _require(pricePerTokenUnit != 0, Errors.NO_PRICE_FOR_TRADE);\n        // minAmount must have receive token decimals\n        uint256 exactAmount =\n            SafeDecimalMath.normalizeAmountTokens(\n                _sendToken,\n                _receiveToken,\n                _sendQuantity.preciseMul(pricePerTokenUnit)\n            );\n        uint256 slippage =\n            _overrideSlippage != 0 ? _overrideSlippage : maxTradeSlippagePercentage != 0\n                ? maxTradeSlippagePercentage\n                : DEFAULT_TRADE_SLIPPAGE;\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(slippage));\n        ITradeIntegration(IBabController(controller).masterSwapper()).trade(\n            address(this),\n            _sendToken,\n            _sendQuantity,\n            _receiveToken,\n            minAmountExpected\n        );\n        return minAmountExpected;\n    }\n\n    function _transferStrategyPrincipal() private {\n        address reserveAsset = garden.reserveAsset();\n        int256 strategyReturns = capitalReturned.toInt256().sub(capitalAllocated.toInt256());\n        uint256 protocolProfits;\n        uint256 burningAmount;\n        // Strategy returns were positive\n        // in reserve asset, e.g., WETH, USDC, DAI, WBTC\n        uint256 profits = capitalReturned > capitalAllocated ? capitalReturned.sub(capitalAllocated) : 0;\n        if (capitalReturned >= capitalAllocated) {\n            // Send weth performance fee to the protocol\n            protocolProfits = IBabController(controller).protocolPerformanceFee().preciseMul(profits);\n            if (protocolProfits > 0) {\n                // Send profits to the heart\n                IERC20(reserveAsset).safeTransfer(IBabController(controller).heart(), protocolProfits);\n            }\n            strategyReturns = strategyReturns.sub(protocolProfits.toInt256());\n        } else {\n            // Returns were negative so let's burn the strategiest stake\n            burningAmount = (stake.sub(capitalReturned.preciseDiv(capitalAllocated).preciseMul(stake))).multiplyDecimal(\n                STAKE_QUADRATIC_PENALTY_FOR_LOSSES\n            );\n        }\n        // Return the balance back to the garden\n        IERC20(reserveAsset).safeTransfer(address(garden), capitalReturned.sub(protocolProfits));\n        _updateProtocolPrincipal(capitalAllocated, false);\n        // Assign BABL Mining Strategy Rewards\n        strategyRewards = uint256(rewardsDistributor.getStrategyRewards(address(this)));\n        // profitsSharing[0]: strategistProfit %, profitsSharing[1]: stewardsProfit %, profitsSharing[2]: lpProfit %\n        uint256[3] memory profitsSharing = rewardsDistributor.getGardenProfitsSharing(address(garden));\n        // All rewards on Heart Garden are re-compounded (not set aside)\n        // Only LP profits are compounded otherwise (strategist and stewards are set aside)\n        uint256 rewardsToSetAside =\n            (address(garden) != address(IHeart(controller.heart()).heartGarden()))\n                ? profits.sub(profits.preciseMul(profitsSharing[2])).sub(protocolProfits)\n                : 0;\n        // Checkpoint of garden supply (must go before burning tokens if penalty for strategist)\n        endingGardenSupply = IERC20(address(garden)).totalSupply();\n        garden.finalizeStrategy(rewardsToSetAside, strategyReturns, burningAmount);\n    }\n\n    function _updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) internal {\n        rewardsDistributor.updateProtocolPrincipal(_capital, _addOrSubstract);\n    }\n\n    function _getPrice(address _assetOne, address _assetTwo) private view returns (uint256) {\n        try IPriceOracle(IBabController(controller).priceOracle()).getPrice(_assetOne, _assetTwo) returns (\n            uint256 price\n        ) {\n            return price;\n        } catch {\n            return 0;\n        }\n    }\n\n    function _updateExpectedReturn(\n        uint256 _newCapital,\n        uint256 _deltaAmount,\n        bool _addedCapital\n    ) private view returns (uint256) {\n        uint256 capital = _addedCapital ? _newCapital : _newCapital.add(_deltaAmount);\n        uint256 cube = capital.mul(duration);\n        uint256 ratio;\n        if (_addedCapital) {\n            // allocation of new capital\n            ratio = cube.sub(_deltaAmount.mul(block.timestamp.sub(executedAt))).preciseDiv(cube);\n        } else {\n            // Unwind\n            ratio = cube.preciseDiv(cube.sub(_deltaAmount.mul(executedAt.add(duration).sub(block.timestamp))));\n        }\n        return expectedReturn.preciseMul(ratio);\n    }\n\n    // backward compatibility with OpData in case of ongoing strategies with deprecated OpData\n    function _getOpDecodedData(uint256 _index) private view returns (bytes memory) {\n        return\n            opDatas.length > 0 ? abi.encode(opDatas[_index], address(0)) : BytesLib.get64Bytes(opEncodedData, _index);\n    }\n\n    function _handleWeth(bool _isDeposit, uint256 _wethAmount) private {\n        _onlyUnpaused();\n        if (_isDeposit) {\n            IWETH(WETH).deposit{value: _wethAmount}();\n            return;\n        }\n        IWETH(WETH).withdraw(_wethAmount);\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract StrategyV29 is Strategy {}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/lib/UniversalERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n    function universalTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            address(uint160(to)).transfer(amount);\n            return true;\n        } else {\n            token.safeTransfer(to, amount);\n            return true;\n        }\n    }\n\n    function universalTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isETH(token)) {\n            require(from == msg.sender && msg.value >= amount, 'msg.value is zero');\n            if (to != address(this)) {\n                address(uint160(to)).transfer(amount);\n            }\n            if (msg.value > amount) {\n                msg.sender.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n\n    function universalApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (!isETH(token)) {\n            if (amount > 0 && token.allowance(address(this), to) > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, amount);\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function universalDecimals(IERC20 token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return 18;\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 5000}(abi.encodeWithSignature('decimals()'));\n\n        return success ? abi.decode(data, (uint256)) : 18;\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return address(token) == address(ZERO_ADDRESS);\n    }\n}\n"
    },
    "contracts/lib/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * original version by @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n *  Adapted by Babylon Finance.\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity 0.7.6;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n                case 2 {\n                    // Since the new array still fits in the slot, we just need to\n                    // update the contents of the slot.\n                    // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                    sstore(\n                        _preBytes.slot,\n                        // all the modifications to the slot are inside this\n                        // next block\n                        add(\n                            // we can just add to the slot contents because the\n                            // bytes we want to change are the LSBs\n                            fslot,\n                            add(\n                                mul(\n                                    div(\n                                        // load the bytes from memory\n                                        mload(add(_postBytes, 0x20)),\n                                        // zero all bytes to the right\n                                        exp(0x100, sub(32, mlength))\n                                    ),\n                                    // and now shift left the number of bytes to\n                                    // leave space for the length in the slot\n                                    exp(0x100, sub(32, newlength))\n                                ),\n                                // increase length by the double of the memory\n                                // bytes length\n                                mul(mlength, 2)\n                            )\n                        )\n                    )\n                }\n                case 1 {\n                    // The stored value fits in the slot, but the combined value\n                    // will exceed it.\n                    // get the keccak hash to get the contents of the array\n                    mstore(0x0, _preBytes.slot)\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                    // save new length\n                    sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                    // The contents of the _postBytes array start 32 bytes into\n                    // the structure. Our first read should obtain the `submod`\n                    // bytes that can fit into the unused space in the last word\n                    // of the stored array. To get this, we read 32 bytes starting\n                    // from `submod`, so the data we read overlaps with the array\n                    // contents by `submod` bytes. Masking the lowest-order\n                    // `submod` bytes allows us to add that value directly to the\n                    // stored value.\n\n                    let submod := sub(32, slength)\n                    let mc := add(_postBytes, submod)\n                    let end := add(_postBytes, mlength)\n                    let mask := sub(exp(0x100, submod), 1)\n\n                    sstore(\n                        sc,\n                        add(\n                            and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                            and(mload(mc), mask)\n                        )\n                    )\n\n                    for {\n                        mc := add(mc, 0x20)\n                        sc := add(sc, 1)\n                    } lt(mc, end) {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } {\n                        sstore(sc, mload(mc))\n                    }\n\n                    mask := exp(0x100, sub(mc, end))\n\n                    sstore(sc, mul(div(mload(mc), mask), mask))\n                }\n                default {\n                    // get the keccak hash to get the contents of the array\n                    mstore(0x0, _preBytes.slot)\n                    // Start copying to the last used word of the stored array.\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                    // save new length\n                    sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                    // Copy over the first `submod` bytes of the new data as in\n                    // case 1 above.\n                    let slengthmod := mod(slength, 32)\n                    let mlengthmod := mod(mlength, 32)\n                    let submod := sub(32, slengthmod)\n                    let mc := add(_postBytes, submod)\n                    let end := add(_postBytes, mlength)\n                    let mask := sub(exp(0x100, submod), 1)\n\n                    sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                    for {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } lt(mc, end) {\n                        sc := add(sc, 1)\n                        mc := add(mc, 0x20)\n                    } {\n                        sstore(sc, mload(mc))\n                    }\n\n                    mask := exp(0x100, sub(mc, end))\n\n                    sstore(sc, mul(div(mload(mc), mask), mask))\n                }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, 'toUint32_outOfBounds');\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, 'toUint64_outOfBounds');\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, 'toUint96_outOfBounds');\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, 'toUint128_outOfBounds');\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, 'toBytes32_outOfBounds');\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n                case 1 {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                    let cb := 1\n\n                    let mc := add(_preBytes, 0x20)\n                    let end := add(mc, length)\n\n                    for {\n                        let cc := add(_postBytes, 0x20)\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                    } eq(add(lt(mc, end), cb), 2) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        // if any of these checks fails then arrays are not equal\n                        if iszero(eq(mload(mc), mload(cc))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n                case 1 {\n                    // slength can contain both the length and contents of the array\n                    // if length < 32 bytes so let's prepare for that\n                    // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                    if iszero(iszero(slength)) {\n                        switch lt(slength, 32)\n                            case 1 {\n                                // blank the last byte which is the length\n                                fslot := mul(div(fslot, 0x100), 0x100)\n\n                                if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                                    // unsuccess:\n                                    success := 0\n                                }\n                            }\n                            default {\n                                // cb is a circuit breaker in the for loop since there's\n                                //  no said feature for inline assembly loops\n                                // cb = 1 - don't breaker\n                                // cb = 0 - break\n                                let cb := 1\n\n                                // get the keccak hash to get the contents of the array\n                                mstore(0x0, _preBytes.slot)\n                                let sc := keccak256(0x0, 0x20)\n\n                                let mc := add(_postBytes, 0x20)\n                                let end := add(mc, mlength)\n\n                                // the next line is the loop condition:\n                                // while(uint256(mc < end) + cb == 2)\n                                for {\n\n                                } eq(add(lt(mc, end), cb), 2) {\n                                    sc := add(sc, 1)\n                                    mc := add(mc, 0x20)\n                                } {\n                                    if iszero(eq(sload(sc), mload(mc))) {\n                                        // unsuccess:\n                                        success := 0\n                                        cb := 0\n                                    }\n                                }\n                            }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n\n        return success;\n    }\n\n    function get64Bytes(bytes memory _data, uint256 _index) internal pure returns (bytes memory) {\n        return slice(_data, (64 * _index), 64);\n    }\n\n    function decodeOpDataAddressAssembly(bytes memory _data, uint256 _startingByte) internal pure returns (address) {\n        return toAddress(_data, _startingByte);\n    }\n\n    function decodeOpDataAddress(bytes calldata _data) internal pure returns (address) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        return abi.decode(_data, (address));\n    }\n\n    function decodeOpDataAddressAndUint(bytes memory _data) internal pure returns (address, uint256) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        return abi.decode(_data, (address, uint256));\n    }\n\n    function decodeOpDataAsType(\n        bytes memory _data,\n        uint8 _type,\n        uint8 _offset\n    ) internal pure returns (bytes memory) {\n        // Expects no prefix (e.g. signature of bytes4 should be removed before using it)\n        // type: 0 - uint8, 1: uint256, 2: bool, 3: address\n        if (_type == 0 || _type == 2) {\n            // boolean is also 1 byte\n            // returning bytes type\n            return slice(_data, _offset, 1); // to return uint8 type better use toUint8(_data, _offset);\n        } else if (_type == 1) {\n            // returning bytes type\n            return slice(_data, _offset, 32); // to return uint256 type better use toUint256(_data, _offset);\n        } else if (_type == 3) {\n            // returning bytes type\n            return slice(_data, _offset, 20); // to return address type better use toAddress(_data, _offset);\n        }\n        // Default uint\n        return slice(_data, _offset, 1);\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the gardens on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the gardens\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the gardens, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if gardens can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ITradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBaseIntegration} from '../interfaces/IBaseIntegration.sol';\n\n/**\n * @title ITrade\n * @author Babylon Finance\n *\n * Interface for trading protocol integrations\n */\ninterface ITradeIntegration is IBaseIntegration {\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external;\n\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity,\n        address _hopToken\n    ) external;\n}\n"
    },
    "contracts/interfaces/IOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IGarden} from './IGarden.sol';\nimport {IStrategy} from './IStrategy.sol';\n\n/**\n * @title IOperation\n * @author Babylon Finance\n *\n * Interface for an strategy operation\n */\ninterface IOperation {\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view returns (uint256, bool);\n\n    function getName() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IMasterSwapper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ITradeIntegration} from './ITradeIntegration.sol';\n\n/**\n * @title IIshtarGate\n * @author Babylon Finance\n *\n * Interface for interacting with the Gate Guestlist NFT\n */\ninterface IMasterSwapper is ITradeIntegration {\n    /* ============ Functions ============ */\n\n    function isTradeIntegration(address _integration) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/interfaces/external/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/interfaces/IBaseIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\ninterface IBaseIntegration {\n    function name() external view returns (string memory);\n}\n"
    },
    "contracts/token/RewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {TimeLockedToken} from './TimeLockedToken.sol';\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IProphets} from '../interfaces/IProphets.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards\n * of the BABL Mining Program along the time reserved for executed strategies. It implements a supply curve\n * to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared\n * to the whole protocol usage as well as profits of each strategy counts.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses\n * to specific profiles, which are actively contributing to the protocol growth and their communities\n * (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributor is OwnableUpgradeable, IRewardsDistributor {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the call is not from a valid strategy\n     */\n    function _onlyStrategy(address _strategy) private view {\n        address garden = address(IStrategy(_strategy).garden());\n        _isGarden(garden);\n        _isGardenStrategy(garden, _strategy);\n    }\n\n    /**\n     * Throws if the sender is not the controller\n     */\n    function _onlyGovernanceOrEmergency() private view {\n        _require(\n            msg.sender == controller.owner() ||\n                msg.sender == controller.EMERGENCY_OWNER() ||\n                msg.sender == address(controller),\n            Errors.ONLY_GOVERNANCE_OR_EMERGENCY\n        );\n    }\n\n    /**\n     * Throws if Rewards Distributor is paused\n     */\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!controller.isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Throws if not an official Babylon garden\n     */\n    function _isGarden(address _garden) private view {\n        _require(controller.isGarden(_garden), Errors.ONLY_ACTIVE_GARDEN);\n    }\n\n    /**\n     * Throws if not an official Babylon strategy of that garden\n     */\n    function _isGardenStrategy(address _garden, address _strategy) private view {\n        _require(IGarden(_garden).isGardenStrategy(_strategy), Errors.STRATEGY_GARDEN_MISMATCH);\n    }\n\n    /**\n     * Throws if a malicious reentrant call is detected\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        _require(status != ENTERED, Errors.REENTRANT_CALL);\n        // Any calls to nonReentrant after this point will fail\n        status = ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        status = NOT_ENTERED;\n    }\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 private constant Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 private constant DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 private constant EPOCH_DURATION = 90 days;\n    // DAI normalize asset\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Reentrancy guard countermeasure\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    // NFT Prophets\n    IProphets private constant PROPHETS_NFT = IProphets(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43);\n\n    /* ============ State Variables ============ */\n\n    // solhint-disable-next-line\n    uint256 private START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 private strategistBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private strategistProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private profitProtocolFee;\n    // solhint-disable-next-line\n    uint256 private gardenCreatorBonus;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        uint256 principal; // DEPRECATED\n        uint256 time; // DEPRECATED\n        uint256 quarterBelonging; // DEPRECATED\n        uint256 timeListPointer; // DEPRECATED\n        uint256 power; // DEPRECATED\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 quarterNumber; // DEPRECATED\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // DEPRECATED\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 avgGardenBalance; // Checkpoint to keep track on garden supply\n        uint256 lastDepositAt; // Checkpoint timestamps\n        uint256 accGardenPower; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // DEPRECATED, but still needed during beta gardens migration\n        uint256 pid; // DEPRECATED, but still needed during beta gardens migration\n        // Sub-mapping of contributor details, updated info after beta will be only at position [0]\n        mapping(uint256 => TimestampContribution) tsContributions;\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 avgBalance; // User avg balance in each garden along the time\n        uint256 timestamp; // DEPRECATED\n        uint256 timePointer; // DEPRECATED\n        uint256 power; // Contributor power\n    }\n    struct Checkpoints {\n        uint256 fromTime; // checkpoint block timestamp\n        uint256 tokens; // User garden tokens in the checkpoint\n        uint256 supply; // DEPRECATED\n        uint256 prevBalance; // Previous user balance (backward compatibility for beta users)\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController private controller;\n\n    // BABL Token contract\n    TimeLockedToken private babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal)\n    // in all ongoing strategies during mining program.\n    uint256 private miningProtocolPrincipal; // Protocol principal (only related to mining program)\n    mapping(uint256 => ProtocolPerTimestamp) private protocolPerTimestamp; // DEPRECATED\n    uint256[] private timeList; // DEPRECATED\n    uint256 private miningProtocolPower; // Mining protocol power along the time\n\n    // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => ProtocolPerQuarter) private protocolPerQuarter;\n    // Check if the protocol per quarter data has been initialized\n    mapping(uint256 => bool) private isProtocolPerQuarter;\n\n    mapping(address => mapping(uint256 => uint256)) private rewardsPowerOverhead; // DEPRECATED\n    // Contributor power control\n    // Contributor details per garden\n    mapping(address => mapping(address => ContributorPerGarden)) private contributorPerGarden;\n    mapping(address => mapping(address => Checkpoints)) private checkpoints; // DEPRECATED\n    // Garden power control\n    // Garden power details per garden. Updated info after beta will be only at position [0]\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) private gardenPowerByTimestamp;\n    mapping(address => uint256[]) private gardenTimelist; // DEPRECATED, but still needed during beta gardens migration\n    mapping(address => uint256) private gardenPid; // DEPRECATED, but still needed during beta gardens migration\n\n    struct StrategyPerQuarter {\n        // Acumulated strategy power per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 betaInitializedAt; // Only used for beta strategies\n        uint256 quarterPower; //  Accumulated strategy power for each quarter\n        bool initialized; // True if the strategy has checkpoints in that quarter already\n    }\n    struct StrategyPricePerTokenUnit {\n        // Take control over the price per token changes along the time when normalizing into DAI\n        uint256 preallocated; // Strategy capital preallocated before each checkpoint\n        uint256 pricePerTokenUnit; // Last average price per allocated tokens per strategy normalized into DAI\n    }\n    // Acumulated strategy power per each quarter along the time\n    mapping(address => mapping(uint256 => StrategyPerQuarter)) private strategyPerQuarter;\n    // Pro-rata oracle price allowing re-allocations and unwinding of any capital value\n    mapping(address => StrategyPricePerTokenUnit) private strategyPricePerTokenUnit;\n\n    // Reentrancy guard countermeasure\n    uint256 private status;\n\n    // Customized profit sharing (if any)\n    // [0]: _strategistProfit , [1]: _stewardsProfit, [2]: _lpProfit\n    mapping(address => uint256[3]) private gardenProfitSharing;\n    mapping(address => bool) private gardenCustomProfitSharing;\n\n    uint256 private miningUpdatedAt; // Timestamp of last strategy capital update\n    mapping(address => uint256) private strategyPrincipal; // Last known strategy principal normalized into DAI\n\n    // Mapping re-used to trigger governance migrations into checkpoints for an address\n    // Address can be garden or an individual user\n    // Usage:\n    // a) to migrate the whole garden => betaAddressMigrated[_garden][_garden] = true\n    // b) to migrate a user for all gardens at once => betaAddressMigrated[_contributor][_contributor] = true\n    // Note: do not re-use it in the following format => [_garden][_contributor] as it was previously used for another older migration to avoid issues.\n    mapping(address => mapping(address => bool)) private betaAddressMigrated;\n    mapping(address => bool) private betaOldMigrations; // DEPRECATED\n\n    uint256 private bablProfitWeight;\n    uint256 private bablPrincipalWeight;\n\n    // A record of garden token checkpoints for each address of each garden, by index\n    // garden -> address -> index checkpoint -> checkpoint struct data\n    mapping(address => mapping(address => mapping(uint256 => Checkpoints))) private gardenCheckpoints;\n\n    // The number of checkpoints for each address of each garden\n    // garden -> address -> number of checkpoints\n    mapping(address => mapping(address => uint256)) private numCheckpoints;\n    // Benchmark creates up to 3 segments to differentiate between cool strategies and bad strategies\n    // First 2 values benchmark[0] and benchmark[1] represent returned/allocated % min and max thresholds to create 3 segments\n    // benchmark[0] value: Used to define the threshold between very bad strategies and not cool strategies\n    // benchmark[0] = minThreshold default 0 (e.g. 90e16 represents profit of -10 %)\n    // It separates segment 1 (very bad strategies) and segment 2 (not cool strategies)\n    // benchmark[1] value: Used to define the threshold between not good/cool strategies and cool/good strategies\n    // benchmark[1] = maxThreshold default 0 (e.g. 103e16 represents profit of +3 %)\n    // It separates segment 2 (not cool strategies) and segment 3 (cool strategies)\n    // benchmark[2] value: Used to set a penalty (if any) for very bad strategies (segment 1)\n    // benchmark[2] = Segment1 Penalty default 0 (e.g. 50e16 represents 1/2 = 50% = half rewards penalty)\n    // benchmark[3] value: Used to set a penalty (if any) for not cool strategies (segment 2)\n    // benchmark[3] = Segment 2 Penalty/Boost default 0 (e.g. 1e18 represents 1 = 100% = no rewards penalty)\n    // becnhmark[4] value: Used to set a boost (if any) for cool strategies (segment 3)\n    // becnhmark[4] = Segment 3 Boost default 1e18 (e.g. 2e18 represents 2 = 200% = rewards boost x2)\n    uint256[5] private benchmark;\n\n    /* ============ Constructor ============ */\n\n    function initialize(TimeLockedToken _bablToken, IBabController _controller) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        _require(address(_bablToken) != address(0) && address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        babltoken = _bablToken;\n        controller = _controller;\n\n        profitProtocolFee = controller.protocolPerformanceFee();\n\n        strategistProfitPercentage = 10e16; // 10%\n        stewardsProfitPercentage = 5e16; // 5%\n        lpsProfitPercentage = 80e16; // 80%\n\n        strategistBABLPercentage = 10e16; // 10%\n        stewardsBABLPercentage = 10e16; // 10%\n        lpsBABLPercentage = 80e16; // 80%\n        gardenCreatorBonus = 10e16; // 10%\n\n        bablProfitWeight = 65e16; // 65% (BIP-7 will change it into 95%)\n        bablPrincipalWeight = 35e16; // 35% (BIP-7 will change it into 5%)\n\n        status = NOT_ENTERED;\n        // BABL Mining program was started by bip#1\n        START_TIME = block.timestamp;\n        // Benchmark conditions to apply to BABL rewards are initialized as 0\n        // Backward compatibility manages benchmark[4] value that must be always >= 1e18\n        benchmark[4] = 1e18; // default value\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Function that adds/substract the capital received to the total principal of the protocol per timestamp\n     * @param _capital                Amount of capital in any type of asset to be normalized into DAI\n     * @param _addOrSubstract         Whether we are adding or substracting capital\n     */\n    function updateProtocolPrincipal(uint256 _capital, bool _addOrSubstract) external override {\n        _onlyStrategy(msg.sender);\n        // All strategies are now part of the Mining Program\n        _updateProtocolPrincipal(msg.sender, _capital, _addOrSubstract);\n    }\n\n    /**\n     * Function used by each garden to signal each deposit and withdrawal in checkpoints to be used for rewards\n     * @param _garden                Address of the garden\n     * @param _contributor           Address of the contributor\n     * @param _previousBalance       Previous balance of the contributor\n     * @param _tokenDiff             Amount difference in this deposit/withdraw\n     * @param _addOrSubstract        Whether the contributor is adding (true) or withdrawing capital (false)\n     */\n    function updateGardenPowerAndContributor(\n        address _garden,\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _tokenDiff,\n        bool _addOrSubstract\n    ) external override nonReentrant {\n        _isGarden(msg.sender);\n        uint256 newBalance = _addOrSubstract ? _previousBalance.add(_tokenDiff) : _previousBalance.sub(_tokenDiff);\n        // Creates a new user checkpoint\n        _writeCheckpoint(_garden, _contributor, newBalance, _previousBalance);\n    }\n\n    /**\n     * Sending BABL as part of the claim process (either by sig or standard claim)\n     * If it is the Heart Garden, the claim is done by the garden during each strategy finalization\n     * This is due to the Heart Garden is auto-compounding all rewards\n     *\n     */\n    function sendBABLToContributor(address _to, uint256 _babl) external override nonReentrant returns (uint256) {\n        _isGarden(msg.sender);\n        return _sendBABLToAddress(_to, _babl);\n    }\n\n    /** PRIVILEGE FUNCTION\n     * Set customized profit shares for a specific garden by the gardener\n     * @param _garden               Address of the garden\n     * @param _strategistShare      New % of strategistShare\n     * @param _stewardsShare        New % of stewardsShare\n     * @param _lpShare              New % of lpShare\n     */\n    function setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) external override {\n        _onlyGovernanceOrEmergency();\n        _isGarden(_garden);\n        _setProfitRewards(_garden, _strategistShare, _stewardsShare, _lpShare);\n    }\n\n    /** PRIVILEGE FUNCTION\n     * Migrates by governance: (2 options)\n     * a) the whole garden or a user for all gardens into checkpoints deprecating c-power\n     * @param _address              Array of Address to migrate (garden or user)\n     * @param _toMigrate            Bool to migrate (true) or redo (false)\n     */\n    function migrateAddressToCheckpoints(address[] memory _address, bool _toMigrate) external override {\n        _onlyGovernanceOrEmergency();\n        for (uint256 i = 0; i < _address.length; i++) {\n            betaAddressMigrated[_address[i]][_address[i]] = _toMigrate;\n        }\n    }\n\n    /** PRIVILEGE FUNCTION\n     * Change default BABL shares % by the governance\n     * @param _newMiningParams      Array of new mining params to be set by government\n     */\n    function setBABLMiningParameters(uint256[11] memory _newMiningParams) external override {\n        // _newMiningParams[0]: _strategistShare\n        // _newMiningParams[1]: _stewardsShare\n        // _newMiningParams[2]: _lpShare\n        // _newMiningParams[3]: _creatorBonus\n        // _newMiningParams[4]: _profitWeight\n        // _newMiningParams[5]: _principalWeight\n        // _newMiningParams[6]: _benchmark[0] to differentiate from very bad strategies and not cool strategies\n        // _newMiningParams[7]: _benchmark[1] to differentiate from not cool strategies and cool strategies\n        // _newMiningParams[8]: _benchmark[2] penalty to be applied to very bad strategies in benchmark segment 1\n        // _newMiningParams[9]: _benchmark[3] penalty to be applied to not cool strategies in benchmark segment 2\n        // _newMiningParams[10]: _benchmark[4] boost/bonus to be applied to cool strategies in benchmark segment 3\n        _onlyGovernanceOrEmergency();\n        _require(\n            _newMiningParams[0].add(_newMiningParams[1]).add(_newMiningParams[2]) == 1e18 &&\n                _newMiningParams[3] <= 1e18 &&\n                _newMiningParams[4].add(_newMiningParams[5]) == 1e18 &&\n                _newMiningParams[6] <= _newMiningParams[7] &&\n                _newMiningParams[8] <= _newMiningParams[9] &&\n                _newMiningParams[9] <= _newMiningParams[10] &&\n                _newMiningParams[10] >= 1e18,\n            Errors.INVALID_MINING_VALUES\n        );\n        strategistBABLPercentage = _newMiningParams[0];\n        stewardsBABLPercentage = _newMiningParams[1];\n        lpsBABLPercentage = _newMiningParams[2];\n        gardenCreatorBonus = _newMiningParams[3];\n        bablProfitWeight = _newMiningParams[4];\n        bablPrincipalWeight = _newMiningParams[5];\n        benchmark[0] = _newMiningParams[6]; // minThreshold dividing segment 1 and 2 (if any)\n        benchmark[1] = _newMiningParams[7]; // maxThreshold dividing segment 2 and 3 (if any)\n        benchmark[2] = _newMiningParams[8]; // penalty for segment 1\n        benchmark[3] = _newMiningParams[9]; // penalty/boost for segment 2\n        benchmark[4] = _newMiningParams[10]; // boost for segment 3\n    }\n\n    /* ========== View functions ========== */\n\n    /**\n     * Calculates the profits and BABL that a contributor should receive from a series of finalized strategies\n     * @param _garden                   Garden to which the strategies and the user must belong to\n     * @param _contributor              Address of the contributor to check\n     * @param _finalizedStrategies      List of addresses of the finalized strategies to check\n     * @return Array of size 7 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function getRewards(\n        address _garden,\n        address _contributor,\n        address[] calldata _finalizedStrategies\n    ) external view override returns (uint256[] memory) {\n        _isGarden(_garden);\n        uint256[] memory totalRewards = new uint256[](8);\n        if (_garden == address(IHeart(controller.heart()).heartGarden())) {\n            // No claim available at heartGarden as all rewards were auto-compounded\n            // during strategy finalization\n            return totalRewards;\n        }\n        (, , uint256 claimedAt, , , , , , ) = IGarden(_garden).getContributor(_contributor);\n        for (uint256 i = 0; i < _finalizedStrategies.length; i++) {\n            // Security check\n            _isGardenStrategy(_garden, _finalizedStrategies[i]);\n\n            uint256[] memory tempRewards = new uint256[](8);\n\n            tempRewards = _getStrategyProfitsAndBABL(_garden, _finalizedStrategies[i], _contributor, claimedAt);\n            totalRewards[0] = totalRewards[0].add(tempRewards[0]);\n            totalRewards[1] = totalRewards[1].add(tempRewards[1]);\n            totalRewards[2] = totalRewards[2].add(tempRewards[2]);\n            totalRewards[3] = totalRewards[3].add(tempRewards[3]);\n            totalRewards[4] = totalRewards[4].add(tempRewards[4]);\n            totalRewards[5] = totalRewards[5].add(tempRewards[5]);\n            totalRewards[6] = totalRewards[6].add(tempRewards[6]);\n            totalRewards[7] = totalRewards[7].add(tempRewards[7]);\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * Gets the baseline amount of BABL rewards for a given strategy\n     * @param _strategy     Strategy to check\n     */\n    function getStrategyRewards(address _strategy) external view override returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        // ts[0]: executedAt, ts[1]: exitedAt, ts[2]: updatedAt\n        uint256[] memory ts = new uint256[](3);\n        (, , , , ts[0], ts[1], ts[2]) = strategy.getStrategyState();\n        _require(ts[1] != 0, Errors.STRATEGY_IS_NOT_OVER_YET);\n        if (ts[1] >= START_TIME) {\n            // We avoid gas consuming once a strategy got its BABL rewards during its finalization\n            uint256 rewards = strategy.strategyRewards();\n            if (rewards != 0) {\n                return rewards;\n            }\n            // str[0]: capitalAllocated, str[1]: capitalReturned\n            uint256[] memory str = new uint256[](2);\n            (, , , , , , str[0], str[1], , , , , , ) = strategy.getStrategyDetails();\n            // If the calculation was not done earlier we go for it\n            (uint256 numQuarters, uint256 startingQuarter) = _getRewardsWindow(ts[0], ts[1]);\n            uint256 percentage = 1e18;\n            for (uint256 i = 0; i < numQuarters; i++) {\n                // Initialization timestamp at the end of the first slot where the strategy starts its execution\n                uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION));\n                // We calculate each epoch\n                uint256 strategyPower = strategyPerQuarter[_strategy][startingQuarter.add(i)].quarterPower;\n                uint256 protocolPower = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n                _require(strategyPower <= protocolPower, Errors.OVERFLOW_IN_POWER);\n                if (i.add(1) == numQuarters) {\n                    // last quarter - we need to take proportional supply for that timeframe despite\n                    // the epoch has not finished yet\n                    percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                        slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                    );\n                }\n                uint256 rewardsPerQuarter =\n                    strategyPower\n                        .preciseDiv(protocolPower)\n                        .preciseMul(_tokenSupplyPerQuarter(startingQuarter.add(i)))\n                        .preciseMul(percentage);\n                rewards = rewards.add(rewardsPerQuarter);\n            }\n            // Apply rewards weight related to principal and profit and related to benchmark\n            return _getBenchmarkRewards(str[1], str[0], rewards, ts[0]);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Get token power at a specific block for an account\n     *\n     * @param _garden       Address of the garden\n     * @param _address      Address to get prior balance for\n     * @param _blockTime  Block timestamp to get token power at\n     * @return Timestamp initializedAt timestamp (if any)\n     * @return Balance power in garden tokens for an account just prior to a specific blockTime\n     * @return Checkpoint prior checkpoint to a specific blockTime (if any)\n     */\n    function getPriorBalance(\n        address _garden,\n        address _address,\n        uint256 _blockTime\n    )\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // We get the previous (prior) balance to _blockTime timestamp\n        // Actually it also acts as a flashloan protection along the time\n        _blockTime = _blockTime.sub(1);\n        uint256 nCheckpoints = numCheckpoints[_garden][_address];\n        ContributorPerGarden storage contributor = contributorPerGarden[_garden][_address];\n        // beta user if initializedAt > 0\n        uint256 initializedAt = contributor.initialDepositAt;\n        uint256 balance = ERC20(_garden).balanceOf(_address);\n        if (nCheckpoints == 0 && !(initializedAt > 0)) {\n            return (0, 0, 0);\n        } else if (nCheckpoints == 0 && initializedAt > 0) {\n            // Backward compatible for beta users, initial deposit > 0 but still no checkpoints\n            // It also consider burning for bad strategist\n            return (initializedAt, balance, 0);\n        }\n        // There are at least one checkpoint from this point\n        // First check most recent balance\n        if (gardenCheckpoints[_garden][_address][nCheckpoints - 1].fromTime <= _blockTime) {\n            // Burning security protection at userTokens\n            // It only limit the balance in case of burnt tokens and only if using last checkpoint\n            return (\n                gardenCheckpoints[_garden][_address][nCheckpoints - 1].fromTime,\n                gardenCheckpoints[_garden][_address][nCheckpoints - 1].tokens > balance\n                    ? balance\n                    : gardenCheckpoints[_garden][_address][nCheckpoints - 1].tokens,\n                nCheckpoints - 1\n            );\n        }\n        // Next check implicit zero balance\n        if (gardenCheckpoints[_garden][_address][0].fromTime > _blockTime && !(initializedAt > 0)) {\n            // backward compatible\n            return (0, 0, 0);\n        } else if (gardenCheckpoints[_garden][_address][0].fromTime > _blockTime && initializedAt > 0) {\n            // Backward compatible for beta users, initial deposit > 0 but lost initial checkpoints\n            // First checkpoint stored its previous balance so we use it to guess the user past\n            return (initializedAt, gardenCheckpoints[_garden][_address][0].prevBalance, 0);\n        }\n        // It has more checkpoints but the time is between different checkpoints, we look for it\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoints memory cp = gardenCheckpoints[_garden][_address][center];\n            if (cp.fromTime == _blockTime) {\n                return (cp.fromTime, cp.tokens, center);\n            } else if (cp.fromTime < _blockTime) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (\n            gardenCheckpoints[_garden][_address][lower].fromTime,\n            gardenCheckpoints[_garden][_address][lower].tokens,\n            lower\n        );\n    }\n\n    /**\n     * Check the mining program state for a specific quarter and strategy\n     * @param _quarterNum      Number of quarter\n     * @param _strategy        Address of strategy\n     */\n    function checkMining(uint256 _quarterNum, address _strategy)\n        external\n        view\n        override\n        returns (uint256[17] memory miningData)\n    {\n        miningData[0] = START_TIME;\n        miningData[1] = miningUpdatedAt;\n        miningData[2] = miningProtocolPrincipal;\n        miningData[3] = miningProtocolPower;\n        miningData[4] = protocolPerQuarter[_quarterNum].quarterPower;\n        miningData[5] = strategyPrincipal[_strategy];\n        miningData[6] = strategyPricePerTokenUnit[_strategy].preallocated;\n        miningData[7] = strategyPricePerTokenUnit[_strategy].pricePerTokenUnit;\n        miningData[8] = strategyPerQuarter[_strategy][_quarterNum].quarterPower;\n        miningData[9] = _tokenSupplyPerQuarter(_quarterNum);\n        miningData[10] = bablProfitWeight;\n        miningData[11] = bablPrincipalWeight;\n        miningData[12] = benchmark[0];\n        miningData[13] = benchmark[1];\n        miningData[14] = benchmark[2];\n        miningData[15] = benchmark[3];\n        miningData[16] = benchmark[4];\n    }\n\n    /**\n     * Check the garden profit sharing % if different from default\n     * @param _garden     Address of the garden\n     */\n    function getGardenProfitsSharing(address _garden) external view override returns (uint256[3] memory) {\n        if (gardenCustomProfitSharing[_garden]) {\n            // It has customized values\n            return gardenProfitSharing[_garden];\n        } else {\n            return [strategistProfitPercentage, stewardsProfitPercentage, lpsProfitPercentage];\n        }\n    }\n\n    /**\n     * Get an estimation of user rewards for active strategies\n     * @param _strategy        Address of the strategy to estimate BABL rewards\n     * @param _contributor     Address of the garden contributor\n     * @return Array of size 8 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function estimateUserRewards(address _strategy, address _contributor)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // strategyDetails[12]: startingGardenSupply\n        // strategyDetails[13]: endingGardenSupply\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        uint256[] memory rewards = new uint256[](8);\n        if (IStrategy(_strategy).isStrategyActive()) {\n            address garden = address(IStrategy(_strategy).garden());\n            (address strategist, uint256[] memory strategyDetails, bool[] memory profitData) =\n                _estimateStrategyRewards(_strategy);\n            // Get the contributor share % within the strategy window out of the total garden and users\n            uint256 contributorShare = _getSafeUserSharePerStrategy(garden, _contributor, strategyDetails);\n            rewards = _getRewardsPerRole(\n                garden,\n                _strategy,\n                strategist,\n                _contributor,\n                contributorShare,\n                strategyDetails,\n                profitData\n            );\n            // add Prophets NFT bonus if staked in the garden\n            rewards = _boostRewards(garden, _contributor, rewards, strategyDetails);\n        }\n        return rewards;\n    }\n\n    /**\n     * Get a safe user share position within a strategy of a garden\n     * @param _garden          Address of the garden\n     * @param _contributor     Address of the garden contributor\n     * @param _strategy        Address of the strategy\n     * @return % deserved share per user\n     */\n    function getSafeUserSharePerStrategy(\n        address _garden,\n        address _contributor,\n        address _strategy\n    ) external view returns (uint256) {\n        (, uint256[] memory strategyDetails, ) = IStrategy(_strategy).getStrategyRewardsContext();\n        return _getSafeUserSharePerStrategy(_garden, _contributor, strategyDetails);\n    }\n\n    /**\n     * Get an estimation of strategy BABL rewards for active strategies in the mining program\n     * @param _strategy        Address of the strategy to estimate BABL rewards\n     * @return the estimated BABL rewards\n     */\n    function estimateStrategyRewards(address _strategy) external view override returns (uint256) {\n        if (IStrategy(_strategy).isStrategyActive()) {\n            (, uint256[] memory strategyDetails, ) = _estimateStrategyRewards(_strategy);\n            return strategyDetails[9];\n        } else {\n            return 0;\n        }\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev internal function to write a checkpoint for contributor token power\n     * @param _garden        Address of the garden\n     * @param _address       Address for the checkpoint\n     * @param _newBalance    The new token balance\n     * @param _prevBalance   The previous user token balance\n     */\n    function _writeCheckpoint(\n        address _garden,\n        address _address,\n        uint256 _newBalance,\n        uint256 _prevBalance\n    ) internal {\n        uint256 blockTime = block.timestamp;\n        uint256 nCheckpoints = numCheckpoints[_garden][_address];\n        if (nCheckpoints > 0 && gardenCheckpoints[_garden][_address][nCheckpoints - 1].fromTime == blockTime) {\n            gardenCheckpoints[_garden][_address][nCheckpoints - 1].tokens = _newBalance;\n        } else {\n            // We only store previous Balance in case of the first checkpoint\n            // to get backward compatibility for beta addresses\n            if (nCheckpoints == 0) {\n                gardenCheckpoints[_garden][_address][nCheckpoints] = Checkpoints(\n                    blockTime,\n                    _newBalance,\n                    0,\n                    _prevBalance\n                );\n            } else {\n                gardenCheckpoints[_garden][_address][nCheckpoints] = Checkpoints(blockTime, _newBalance, 0, 0);\n            }\n            numCheckpoints[_garden][_address] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * Update the protocol principal checkpoints\n     * @param _strategy         Strategy which is adding/removing principal\n     * @param _capital          Capital to update\n     * @param _addOrSubstract   Adding (true) or removing (false)\n     */\n    function _updateProtocolPrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) internal {\n        address reserveAsset = IGarden(IStrategy(_strategy).garden()).reserveAsset();\n        // To compare strategy power between all strategies we normalize their capital into DAI\n        // Then, we need to take control of getPrice fluctuations along the time\n        uint256 pricePerTokenUnit = _getStrategyPricePerTokenUnit(reserveAsset, _strategy, _capital, _addOrSubstract);\n        _capital = _capital.preciseMul(pricePerTokenUnit).mul(10**uint256(18).sub(ERC20(reserveAsset).decimals()));\n        // Create or/and update the protocol quarter checkpoints if mining program is activated\n        _updateProtocolPowerPerQuarter();\n        // We update the strategy power per quarter normalized in DAI if mining program is activated\n        _updateStrategyPowerPerQuarter(_strategy);\n        // The following function call _updatePrincipal must be always executed\n        // after _updateProtocolPowerPerQuarter and _updateStrategyPowerPerQuarter\n        _updatePrincipal(_strategy, _capital, _addOrSubstract);\n        // The following time set should always be executed at the end\n        miningUpdatedAt = block.timestamp;\n    }\n\n    /**\n     * Update the principal considered part of the mining program either Protocol or Strategies\n     * @param _strategy         Strategy address\n     * @param _capital          Capital normalized into DAI to add or substract for accurate\n     * comparisons between strategies\n     * @param _addOrSubstract   Whether or not we are adding or unwinding capital to the strategy under mining\n     */\n    function _updatePrincipal(\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private {\n        if (!_addOrSubstract) {\n            // Substracting capital\n            // Failsafe condition\n            uint256 amount = _capital > strategyPrincipal[_strategy] ? strategyPrincipal[_strategy] : _capital;\n            miningProtocolPrincipal = miningProtocolPrincipal.sub(amount);\n            strategyPrincipal[_strategy] = strategyPrincipal[_strategy].sub(amount);\n        } else {\n            // Adding capital\n            miningProtocolPrincipal = miningProtocolPrincipal.add(_capital);\n            strategyPrincipal[_strategy] = strategyPrincipal[_strategy].add(_capital);\n        }\n    }\n\n    /**\n     * Add protocol power timestamps for each quarter\n     */\n    function _updateProtocolPowerPerQuarter() private {\n        uint256[] memory data = new uint256[](4);\n        // data[0]: previous quarter, data[1]: current quarter, data[2]: timeDifference, data[3]: debtPower\n        data[0] = miningUpdatedAt == 0 ? 1 : _getQuarter(miningUpdatedAt);\n        data[1] = _getQuarter(block.timestamp);\n        data[2] = block.timestamp.sub(miningUpdatedAt);\n        ProtocolPerQuarter storage protocolCheckpoint = protocolPerQuarter[data[1]];\n        data[3] = miningUpdatedAt == 0 ? 0 : miningProtocolPrincipal.mul(data[2]);\n        if (!isProtocolPerQuarter[data[1]]) {\n            // The quarter is not initialized yet, we then create it\n            if (miningUpdatedAt > 0) {\n                // A new epoch has started with either a new strategy execution or finalization checkpoint\n                if (data[0] == data[1].sub(1)) {\n                    // There were no intermediate epoch without checkpoints, we are in the next epoch\n                    // We need to divide the debtPower between previous epoch and current epoch\n                    // We re-initialize the protocol power in the new epoch adding only the corresponding\n                    // to its duration\n                    protocolCheckpoint.quarterPower = data[3]\n                        .mul(block.timestamp.sub(START_TIME.add(data[1].mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                        .div(data[2]);\n                    // We now update the previous quarter with its proportional pending debtPower\n                    protocolPerQuarter[data[1].sub(1)].quarterPower = protocolPerQuarter[data[1].sub(1)]\n                        .quarterPower\n                        .add(data[3].sub(protocolCheckpoint.quarterPower));\n                } else {\n                    // There were some intermediate epochs without checkpoints - we need to create\n                    // missing checkpoints and update the last (current) one.\n                    // We have to update all the quarters since last update\n                    for (uint256 i = 0; i <= data[1].sub(data[0]); i++) {\n                        ProtocolPerQuarter storage newCheckpoint = protocolPerQuarter[data[0].add(i)];\n                        uint256 slotEnding = START_TIME.add(data[0].add(i).mul(EPOCH_DURATION));\n                        if (i == 0) {\n                            // We are in the first quarter to update (corresponding to miningUpdatedAt timestamp)\n                            // We add the corresponding proportional part\n                            newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                                data[3].mul(slotEnding.sub(miningUpdatedAt)).div(data[2])\n                            );\n                        } else if (i < data[1].sub(data[0])) {\n                            // We are in an intermediate quarter without checkpoints - need to create and update it\n                            newCheckpoint.quarterPower = data[3].mul(EPOCH_DURATION).div(data[2]);\n                        } else {\n                            // We are in the last (current) quarter\n                            // We update its proportional remaining debt power\n                            protocolCheckpoint.quarterPower = data[3]\n                                .mul(\n                                block.timestamp.sub(START_TIME.add(data[1].mul(EPOCH_DURATION).sub(EPOCH_DURATION)))\n                            )\n                                .div(data[2]);\n                        }\n                    }\n                }\n            }\n            isProtocolPerQuarter[data[1]] = true;\n        } else {\n            // Quarter checkpoint already created\n            // We update the power of the quarter by adding the new difference between last quarter\n            // checkpoint and this checkpoint\n            protocolCheckpoint.quarterPower = protocolCheckpoint.quarterPower.add(data[3]);\n            miningProtocolPower = miningProtocolPower.add(data[3]);\n        }\n    }\n\n    /**\n     * Updates the strategy power per quarter for rewards calculations of each strategy out of the whole protocol\n     * @param _strategy    Strategy address\n     */\n    function _updateStrategyPowerPerQuarter(address _strategy) private {\n        uint256[] memory data = new uint256[](5);\n        // data[0]: executedAt, data[1]: updatedAt, data[2]: time difference, data[3]: quarter, data[4]: debtPower\n        (, , , , data[0], , data[1]) = IStrategy(_strategy).getStrategyState();\n        if (data[1] < START_TIME) {\n            // We check the initialization only for beta gardens, quarter = 1\n            StrategyPerQuarter storage betaStrategyCheckpoint = strategyPerQuarter[_strategy][1];\n            if (betaStrategyCheckpoint.betaInitializedAt == 0) {\n                betaStrategyCheckpoint.betaInitializedAt = block.timestamp;\n            }\n            // Only for strategies starting before mining and still executing, get proportional\n            // Exited strategies before the mining starts, are not eligible of this standard setup\n            data[1] = betaStrategyCheckpoint.betaInitializedAt;\n        }\n        data[2] = block.timestamp.sub(data[1]);\n        data[3] = _getQuarter(block.timestamp);\n        StrategyPerQuarter storage strategyCheckpoint = strategyPerQuarter[_strategy][data[3]];\n        // We calculate the debt Power since last checkpoint (if any)\n        data[4] = strategyPrincipal[_strategy].mul(data[2]);\n        if (!strategyCheckpoint.initialized) {\n            // The strategy quarter is not yet initialized then we create it\n            // If it the first checkpoint in the first executing epoch - keep power 0\n            if (data[3] > _getQuarter(data[0])) {\n                // Each time a running strategy has a new checkpoint on a new (different) epoch than\n                // previous checkpoints.\n                // debtPower is the proportional power of the strategy for this quarter from previous checkpoint\n                // We need to iterate since last checkpoint\n                (uint256 numQuarters, uint256 startingQuarter) = _getRewardsWindow(data[1], block.timestamp);\n\n                // There were intermediate epochs without checkpoints - we need to create their corresponding\n                //  checkpoints and update the last one\n                // We have to update all the quarters including where the previous checkpoint is and\n                // the one where we are now\n                for (uint256 i = 0; i < numQuarters; i++) {\n                    StrategyPerQuarter storage newCheckpoint = strategyPerQuarter[_strategy][startingQuarter.add(i)];\n                    uint256 slotEnding = START_TIME.add(startingQuarter.add(i).mul(EPOCH_DURATION));\n                    if (i == 0) {\n                        // We are in the first quarter to update, we add the proportional pending part\n                        newCheckpoint.quarterPower = newCheckpoint.quarterPower.add(\n                            data[4].mul(slotEnding.sub(data[1])).div(data[2])\n                        );\n                    } else if (i > 0 && i.add(1) < numQuarters) {\n                        // We are updating an intermediate quarter\n                        newCheckpoint.quarterPower = data[4].mul(EPOCH_DURATION).div(data[2]);\n                        newCheckpoint.initialized = true;\n                    } else {\n                        // We are updating the current quarter of this strategy checkpoint\n                        newCheckpoint.quarterPower = data[4]\n                            .mul(block.timestamp.sub(START_TIME.add(data[3].mul(EPOCH_DURATION).sub(EPOCH_DURATION))))\n                            .div(data[2]);\n                    }\n                }\n            }\n            strategyCheckpoint.initialized = true;\n        } else {\n            // We are in the same quarter than previous checkpoints for this strategy\n            // We update the power of the quarter by adding the new difference between\n            // last quarter checkpoint and this checkpoint\n            strategyCheckpoint.quarterPower = strategyCheckpoint.quarterPower.add(data[4]);\n        }\n    }\n\n    /**\n     * Sends profits and BABL tokens rewards to an address (contributor or heart garden) after a claim is requested to the protocol.\n     * @param _to        Address to send the BABL tokens to\n     * @param _babl      Amount of BABL to send\n     *\n     */\n    function _sendBABLToAddress(address _to, uint256 _babl) internal returns (uint256) {\n        _onlyUnpaused();\n        uint256 bablBal = babltoken.balanceOf(address(this));\n        uint256 bablToSend = _babl > bablBal ? bablBal : _babl;\n        SafeERC20.safeTransfer(babltoken, _to, bablToSend);\n        return bablToSend;\n    }\n\n    /**\n     * Set a customized profit rewards\n     * @param _garden           Address of the garden\n     * @param _strategistShare  New sharing profit % for strategist\n     * @param _stewardsShare    New sharing profit % for stewards\n     * @param _lpShare          New sharing profit % for lp\n     */\n    function _setProfitRewards(\n        address _garden,\n        uint256 _strategistShare,\n        uint256 _stewardsShare,\n        uint256 _lpShare\n    ) internal {\n        _require(_strategistShare.add(_stewardsShare).add(_lpShare) == 95e16, Errors.PROFIT_SHARING_MISMATCH);\n        // [0]: _strategistProfit , [1]: _stewardsProfit, [2]: _lpProfit\n        if (\n            _strategistShare != strategistProfitPercentage ||\n            _stewardsShare != stewardsProfitPercentage ||\n            _lpShare != lpsProfitPercentage\n        ) {\n            // Different from standard %\n            gardenCustomProfitSharing[_garden] = true;\n            gardenProfitSharing[_garden][0] = _strategistShare;\n            gardenProfitSharing[_garden][1] = _stewardsShare;\n            gardenProfitSharing[_garden][2] = _lpShare;\n        }\n    }\n\n    /* ========== Internal View functions ========== */\n\n    /**\n     * Get the price per token to be used in the adding or substraction normalized to DAI (supports multiple asset)\n     * @param _reserveAsset     Garden reserve asset address\n     * @param _strategy         Strategy address\n     * @param _capital          Capital in reserve asset to add or substract\n     * @param _addOrSubstract   Whether or not we are adding or unwinding capital to the strategy\n     * @return pricePerToken value\n     */\n    function _getStrategyPricePerTokenUnit(\n        address _reserveAsset,\n        address _strategy,\n        uint256 _capital,\n        bool _addOrSubstract\n    ) private returns (uint256) {\n        // Normalizing into DAI\n        IPriceOracle oracle = IPriceOracle(controller.priceOracle());\n        uint256 pricePerTokenUnit = oracle.getPrice(_reserveAsset, DAI);\n        StrategyPricePerTokenUnit storage strPpt = strategyPricePerTokenUnit[_strategy];\n        if (strPpt.preallocated == 0) {\n            // First adding checkpoint\n            strPpt.preallocated = _capital;\n            strPpt.pricePerTokenUnit = pricePerTokenUnit;\n            return pricePerTokenUnit;\n        } else {\n            // We are controlling pair reserveAsset-DAI fluctuations along the time\n            if (_addOrSubstract) {\n                strPpt.pricePerTokenUnit = (\n                    ((strPpt.pricePerTokenUnit.mul(strPpt.preallocated)).add(_capital.mul(pricePerTokenUnit))).div(1e18)\n                )\n                    .preciseDiv(strPpt.preallocated.add(_capital));\n                strPpt.preallocated = strPpt.preallocated.add(_capital);\n            } else {\n                // We use the previous pricePerToken in a substract instead of a new price\n                // (as allocated capital used previous prices not the current one)\n                // Failsafe condition\n                uint256 amount = _capital > strPpt.preallocated ? strPpt.preallocated : _capital;\n                strPpt.preallocated = strPpt.preallocated.sub(amount);\n            }\n            return strPpt.pricePerTokenUnit;\n        }\n    }\n\n    /* ========== Internal View functions ========== */\n\n    /**\n     * Get an estimation of user rewards for active strategies\n     * @param _garden               Address of the garden\n     * @param _strategy             Address of the strategy to estimate rewards\n     * @param _strategist           Address of the strategist\n     * @param _contributor          Address of the garden contributor\n     * @param _contributorShare     Contributor share in a specific time\n     * @param _strategyDetails      Details of the strategy in that specific moment\n     * @param _profitData           Array of profit Data (if profit as well distance)\n     * @return Array of size 8 with the following distribution:\n     * rewards[0]: Strategist BABL\n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: total BABL\n     * rewards[6]: total Profits\n     * rewards[7]: Creator bonus\n     */\n    function _getRewardsPerRole(\n        address _garden,\n        address _strategy,\n        address _strategist,\n        address _contributor,\n        uint256 _contributorShare,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) internal view returns (uint256[] memory) {\n        uint256[] memory rewards = new uint256[](8);\n        // Get strategist BABL rewards in case the contributor is also the strategist of the strategy\n        rewards[0] = _strategist == _contributor ? _getStrategyStrategistBabl(_strategyDetails, _profitData) : 0;\n        // Get strategist profit\n        rewards[1] = (_strategist == _contributor && _profitData[0])\n            ? _getStrategyStrategistProfits(_garden, _strategyDetails[10])\n            : 0;\n        // Get steward rewards\n        rewards[2] = _getStrategyStewardBabl(_strategy, _contributor, _strategyDetails, _profitData);\n        // If not profits _getStrategyStewardsProfits should not execute\n        rewards[3] = _profitData[0]\n            ? _getStrategyStewardProfits(_garden, _strategy, _contributor, _strategyDetails, _profitData)\n            : 0;\n        // Get LP rewards\n        // Contributor share is fluctuating along the way in each new deposit\n        rewards[4] = _getStrategyLPBabl(_strategyDetails[9], _contributorShare);\n        // Total BABL including creator bonus (if any)\n        rewards[5] = _getCreatorBonus(_garden, _contributor, rewards[0].add(rewards[2]).add(rewards[4]));\n        // Total profit\n        rewards[6] = rewards[1].add(rewards[3]);\n        // Creator bonus\n        rewards[7] = rewards[5] > (rewards[0].add(rewards[2]).add(rewards[4]))\n            ? rewards[5].sub(rewards[0].add(rewards[2]).add(rewards[4]))\n            : 0;\n        return rewards;\n    }\n\n    /**\n     * Guess the contributor power in a past timestamp (it is kept for smoother transition)\n     * Will be deprecated soon, kept only for beta users and old strategies not migrated\n     * Still used but only for betaUser && oldStrategy && users not migrated\n     * @param _garden       Address of the garden where the contributor belongs to\n     * @param _contributor  Address of the contributor\n     * @param _time         Timestamp to check power\n     * @return uint256      Contributor power during that period\n     */\n    function _getContributorPower(\n        address _garden,\n        address _contributor,\n        uint256 _time,\n        uint256 _gardenSupply\n    ) internal view returns (uint256) {\n        ContributorPerGarden storage contributor = contributorPerGarden[_garden][_contributor];\n        GardenPowerByTimestamp storage gardenData = gardenPowerByTimestamp[_garden][0];\n        if (contributor.initialDepositAt == 0 || contributor.initialDepositAt > _time) {\n            return 0;\n        } else {\n            (, uint256 balance, ) = getPriorBalance(_garden, _contributor, contributor.lastDepositAt);\n            uint256 supply = _gardenSupply > 0 ? _gardenSupply : ERC20(_garden).totalSupply();\n            // First we need to get an updatedValue of user and garden power since lastDeposits as of block.timestamp\n            uint256 updatedPower =\n                contributor.tsContributions[0].power.add((block.timestamp.sub(contributor.lastDepositAt)).mul(balance));\n            uint256 updatedGardenPower =\n                gardenData.accGardenPower.add((block.timestamp.sub(gardenData.lastDepositAt)).mul(supply));\n            // We then time travel back to when the strategy exitedAt\n            // Calculate the power at \"_time\" timestamp\n            uint256 timeDiff = block.timestamp.sub(_time);\n            uint256 userPowerDiff = contributor.tsContributions[0].avgBalance.mul(timeDiff);\n            uint256 gardenPowerDiff = gardenData.avgGardenBalance.mul(timeDiff);\n            // Avoid underflow conditions 0 at user, 1 at garden\n            updatedPower = updatedPower > userPowerDiff ? updatedPower.sub(userPowerDiff) : 0;\n            updatedGardenPower = updatedGardenPower > gardenPowerDiff ? updatedGardenPower.sub(gardenPowerDiff) : 1;\n            uint256 virtualPower = updatedPower.preciseDiv(updatedGardenPower);\n            if (virtualPower > 1e18) {\n                virtualPower = 1e18; // Overflow limit\n            }\n            return virtualPower;\n        }\n    }\n\n    /**\n     * Get a safe user share position within a strategy of a garden\n     * @param _garden          Address of the garden\n     * @param _contributor     Address of the garden contributor\n     * @param _strategyDetails Strategy details rewards context\n     * @return % deserved share per user\n     */\n    function _getSafeUserSharePerStrategy(\n        address _garden,\n        address _contributor,\n        uint256[] memory _strategyDetails\n    ) internal view returns (uint256) {\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[12]: startingGardenSupply\n        // strategyDetails[13]: endingGardenSupply\n        uint256 endTime = _strategyDetails[1] > 0 ? _strategyDetails[1] : block.timestamp;\n        uint256 cp = numCheckpoints[_garden][_contributor];\n        bool betaUser =\n            !betaAddressMigrated[_contributor][_contributor] &&\n                (cp == 0 || gardenCheckpoints[_garden][_contributor][0].fromTime >= endTime) &&\n                contributorPerGarden[_garden][_contributor].initialDepositAt > 0;\n        bool oldStrategy = _strategyDetails[0] < gardenPowerByTimestamp[_garden][0].lastDepositAt;\n        if (betaUser && oldStrategy && !betaAddressMigrated[_garden][_garden]) {\n            // Backward compatibility for old strategies\n            return _getContributorPower(_garden, _contributor, endTime, _strategyDetails[13]);\n        }\n        // Take the closest position prior to _endTime\n        (uint256 timestamp, uint256 balanceEnd, uint256 cpEnd) = getPriorBalance(_garden, _contributor, endTime);\n        if (balanceEnd < 1e10) {\n            // zero or dust balance\n            // Avoid gas consuming\n            return 0;\n        }\n        uint256 startTime = _strategyDetails[0];\n        uint256 finalSupplyEnd =\n            (_strategyDetails[1] > 0 && _strategyDetails[13] > 0) ? _strategyDetails[13] : ERC20(_garden).totalSupply();\n        // At this point, all strategies must be started or even finished startTime != 0\n        if (timestamp > startTime) {\n            if (cp > 0) {\n                // User has any checkpoint\n                // If the user balance fluctuated during the strategy duration, we take real average balance\n                uint256 avgBalance = _getAvgBalance(_garden, _contributor, startTime, cpEnd, endTime);\n                // Avoid specific malicious attacks\n                balanceEnd = avgBalance > balanceEnd ? balanceEnd : avgBalance;\n            } else {\n                // no checkpoints\n                // if deposited before endTime, take proportional\n                // if deposited after endTime, take nothing\n                balanceEnd = timestamp < endTime\n                    ? balanceEnd.mul(endTime.sub(timestamp)).div(endTime.sub(startTime))\n                    : 0;\n            }\n        }\n        return balanceEnd.preciseDiv(finalSupplyEnd);\n    }\n\n    /**\n     * Get Avg Address Balance in a garden between two points\n     * Address represents any user but it can also be the garden itself\n     * @param _garden           Garden address\n     * @param _address          Address to get avg balance\n     * @param _start            Start timestamp\n     * @param _cpEnd            End time checkpoint number\n     * @param _endTime          End timestamp\n     * @return Avg address token balance within a garden\n     */\n    function _getAvgBalance(\n        address _garden,\n        address _address,\n        uint256 _start,\n        uint256 _cpEnd,\n        uint256 _endTime\n    ) internal view returns (uint256) {\n        (, uint256 prevBalance, uint256 cpStart) = getPriorBalance(_garden, _address, _start);\n        if (_start == _endTime) {\n            // Avoid underflow\n            return prevBalance;\n        } else {\n            uint256 addressPower;\n            uint256 timeDiff;\n            // We calculate the avg balance of an address within a time range\n            // avg balance = addressPower / total period considered\n            // addressPower = sum(balance x time of each period between checkpoints)\n            // Initializing addressPower since the last known checkpoint _endTime\n            // addressPower since _cpEnd checkpoint is \"balance x time difference (endTime - checkpoint timestamp)\"\n            addressPower = gardenCheckpoints[_garden][_address][_cpEnd].tokens.mul(\n                _endTime.sub(gardenCheckpoints[_garden][_address][_cpEnd].fromTime)\n            );\n            // Then, we add addressPower data from periods between all intermediate checkpoints (if any)\n            // periods between starting checkpoint and ending checkpoint (if any)\n            // We go from the newest checkpoint to the oldest\n            for (uint256 i = _cpEnd; i > cpStart; i--) {\n                // We only take proportional addressPower of cpStart checkpoint (from _start onwards)\n                // Usually [cpStart].fromTime <= _start except when cpStart == 0 AND beta addresses\n                // Those cases are handled below to add previous address power happening before the first checkpoint\n                Checkpoints memory userPrevCheckpoint = gardenCheckpoints[_garden][_address][i.sub(1)];\n                timeDiff = gardenCheckpoints[_garden][_address][i].fromTime.sub(\n                    userPrevCheckpoint.fromTime > _start ? userPrevCheckpoint.fromTime : _start\n                );\n                addressPower = addressPower.add(userPrevCheckpoint.tokens.mul(timeDiff));\n            }\n            // We now handle the previous addressPower of beta addresses (if applicable)\n            uint256 fromTimeCp0 = gardenCheckpoints[_garden][_address][0].fromTime;\n            if (cpStart == 0 && fromTimeCp0 > _start) {\n                // Beta address with previous balance before _start\n                addressPower = addressPower.add(prevBalance.mul(fromTimeCp0.sub(_start)));\n            }\n            // avg balance = addressPower / total period of the \"strategy\" considered\n            return addressPower.div(_endTime.sub(_start));\n        }\n    }\n\n    /**\n     * Boost BABL Rewards in case of a staked NFT prophet\n     * It considers a proportional % in case of staking happened after strategy execution\n     * @param _garden           Garden address\n     * @param _contributor      Contributor address\n     * @param _rewards          Precalculated rewards array\n     * @param _strategyDetails  Array with strategy context\n     * @return Rewards array with boosted rewards (if any)\n     */\n    function _boostRewards(\n        address _garden,\n        address _contributor,\n        uint256[] memory _rewards,\n        uint256[] memory _strategyDetails\n    ) internal view returns (uint256[] memory) {\n        // _prophetBonus[0]: NFT id\n        // _prophetBonus[1]: BABL loot\n        // _prophetBonus[2]: strategist NFT bonus\n        // _prophetBonus[3]: steward NFT bonus (voter)\n        // _prophetBonus[4]: LP NFT bonus\n        // _prophetBonus[5]: creator bonus\n        // _prophetBonus[6]: stake NFT ts\n        uint256[7] memory prophetBonus = PROPHETS_NFT.getStakedProphetAttrs(_contributor, _garden);\n        // We calculate the percentage to apply or if any, depending on staking ts\n        uint256 percentage = _getNFTPercentage(prophetBonus[6], _strategyDetails[0], _strategyDetails[1]);\n        if (prophetBonus[0] != 0 && percentage > 0) {\n            // Has staked a prophet in the garden before the strategy finished\n            _rewards[0] = _rewards[0].add(_rewards[0].multiplyDecimal(prophetBonus[2].preciseMul(percentage)));\n            _rewards[2] = _rewards[2].add(_rewards[2].multiplyDecimal(prophetBonus[3].preciseMul(percentage)));\n            _rewards[4] = _rewards[4].add(_rewards[4].multiplyDecimal(prophetBonus[4].preciseMul(percentage)));\n            _rewards[7] = _rewards[7].add(_rewards[7].multiplyDecimal(prophetBonus[5].preciseMul(percentage)));\n            _rewards[5] = _rewards[0].add(_rewards[2]).add(_rewards[4]).add(_rewards[7]);\n        }\n        return _rewards;\n    }\n\n    /**\n     * Get the percentage to apply the NFT prophet bonus, if any depending on staking ts\n     * @param _stakedAt        Timestamp when the NFT was staked (if any)\n     * @param _executedAt      Strategy executedAt timestamp\n     * @param _exitedAt        Strategy exitedAt timestamp (it can be finished or not == 0)\n     * @return the estimated proportional percentage to apply from NFT bonuses\n     */\n    function _getNFTPercentage(\n        uint256 _stakedAt,\n        uint256 _executedAt,\n        uint256 _exitedAt\n    ) internal view returns (uint256) {\n        if (_stakedAt == 0) {\n            // un-staked\n            return 0;\n        } else if (_stakedAt <= _executedAt && _executedAt > 0) {\n            // NFT staked before the strategy was executed\n            // gets 100% of Prophet bonuses\n            return 1e18;\n            // From this point stakeAt > executedAt\n        } else if (_stakedAt < _exitedAt && _exitedAt > 0) {\n            // NFT staked after the strategy was executed + strategy finished\n            // gets proportional\n            return (_exitedAt.sub(_stakedAt)).preciseDiv(_exitedAt.sub(_executedAt));\n        } else if (_stakedAt < block.timestamp && _exitedAt == 0) {\n            // Strategy still live\n            // gets proportional\n            return (block.timestamp.sub(_stakedAt)).preciseDiv(block.timestamp.sub(_executedAt));\n        } else {\n            // Strategy finalized before or in the same block than staking the NFT\n            // NFT is not eligible then for this strategy\n            return 0;\n        }\n    }\n\n    /**\n     * Get the rewards for a specific contributor activately contributing in strategies of a specific garden\n     * @param _garden               Garden address responsible of the strategies to calculate rewards\n     * @param _strategy             Strategy address\n     * @param _contributor          Contributor address\n     * @param _claimedAt            User last claim timestamp\n\n     * @return Array of size 8 with the following distribution:\n     * rewards[0]: Strategist BABL \n     * rewards[1]: Strategist Profit\n     * rewards[2]: Steward BABL\n     * rewards[3]: Steward Profit\n     * rewards[4]: LP BABL\n     * rewards[5]: Total BABL\n     * rewards[6]: Total Profits\n     * rewards[7]: Creator bonus\n     */\n    function _getStrategyProfitsAndBABL(\n        address _garden,\n        address _strategy,\n        address _contributor,\n        uint256 _claimedAt\n    ) private view returns (uint256[] memory) {\n        uint256[] memory rewards = new uint256[](8);\n        (address strategist, uint256[] memory strategyDetails, bool[] memory profitData) =\n            IStrategy(_strategy).getStrategyRewardsContext();\n\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // strategyDetails[12]: startingGardenSupply\n        // strategyDetails[13]: endingGardenSupply\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        // Positive strategies not yet claimed\n        // Users might get BABL rewards if they join the garden before the strategy ends\n        // Contributor power will check their exact contribution (avoiding flashloans)\n        if (strategyDetails[1] > _claimedAt) {\n            // Get the contributor share until the the strategy exit timestamp\n            uint256 contributorShare = _getSafeUserSharePerStrategy(_garden, _contributor, strategyDetails);\n            rewards = _getRewardsPerRole(\n                _garden,\n                _strategy,\n                strategist,\n                _contributor,\n                contributorShare,\n                strategyDetails,\n                profitData\n            );\n            // add Prophets NFT bonus if staked in the garden\n            rewards = _boostRewards(_garden, _contributor, rewards, strategyDetails);\n        }\n        return rewards;\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Steward profile\n     * @param _strategy             Strategy address\n     * @param _contributor          Contributor address\n     * @param _strategyDetails      Strategy details data\n     * @param _profitData           Strategy profit data\n     */\n    function _getStrategyStewardBabl(\n        address _strategy,\n        address _contributor,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) private view returns (uint256) {\n        // Assumptions:\n        // It executes in all cases as non profited strategies can also give BABL rewards to those who voted against\n\n        int256 userVotes = IStrategy(_strategy).getUserVotes(_contributor);\n        uint256 totalVotes = _strategyDetails[4].add(_strategyDetails[5]);\n\n        uint256 bablCap;\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        uint256 babl;\n        if (userVotes > 0 && _profitData[0] && _profitData[1]) {\n            // Voting in favor of the execution of the strategy with profits and positive distance\n            // Negative votes in this case will not receive BABL so we divide only by positive votes\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(userVotes).preciseDiv(_strategyDetails[4])\n            );\n        } else if (userVotes > 0 && _profitData[0] && !_profitData[1]) {\n            // Voting in favor positive profits but below expected return\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(userVotes).preciseDiv(totalVotes)\n            );\n            // We discount the error of expected return vs real returns\n            babl = babl.sub(babl.preciseMul(_strategyDetails[11].preciseDiv(_strategyDetails[8])));\n        } else if (userVotes > 0 && !_profitData[0]) {\n            // Voting in favor of a non profitable strategy get nothing\n            babl = 0;\n        } else if (userVotes < 0 && !_profitData[1]) {\n            // Voting against a strategy that got results below expected return provides rewards\n            // to the voter (helping the protocol to only have good strategies)\n            // If no profit at all, the whole steward benefit goes to those voting against\n            uint256 votesAccounting = _profitData[0] ? totalVotes : _strategyDetails[5];\n            babl = _strategyDetails[9].multiplyDecimal(stewardsBABLPercentage).preciseMul(\n                uint256(Math.abs(userVotes)).preciseDiv(votesAccounting)\n            );\n\n            bablCap = babl.mul(2); // Max cap\n            // We add a bonus inverse to the error of expected return vs real returns\n            babl = babl.add(babl.preciseMul(_strategyDetails[11].preciseDiv(_strategyDetails[8])));\n            if (babl > bablCap) {\n                // We limit 2x by a Cap\n                babl = bablCap;\n            }\n        } else if (userVotes < 0 && _profitData[1]) {\n            babl = 0;\n        }\n        return babl;\n    }\n\n    /**\n     * Get the rewards for a Steward profile\n     * @param _garden           Garden address\n     * @param _strategy         Strategy address\n     * @param _contributor      Contributor address\n     * @param _strategyDetails  Strategy details data\n     * @param _profitData       Strategy profit data\n     */\n    function _getStrategyStewardProfits(\n        address _garden,\n        address _strategy,\n        address _contributor,\n        uint256[] memory _strategyDetails,\n        bool[] memory _profitData\n    ) private view returns (uint256 stewardBabl) {\n        // Assumptions:\n        // Assumption that the strategy got profits. Should not execute otherwise.\n        // Get proportional voter (stewards) rewards in case the contributor was also a steward of the strategy\n        int256 userVotes = IStrategy(_strategy).getUserVotes(_contributor);\n        uint256 totalVotes = _strategyDetails[4].add(_strategyDetails[5]);\n\n        uint256 profitShare =\n            gardenCustomProfitSharing[_garden] ? gardenProfitSharing[_garden][1] : stewardsProfitPercentage;\n        if (userVotes > 0) {\n            // If the strategy got profits equal or above expected return only positive votes counts,\n            // so we divide by only positive\n            // Otherwise, we divide by all total votes as also voters against will get some profits\n            // if the strategy returned less than expected\n            uint256 accountingVotes = _profitData[1] ? _strategyDetails[4] : totalVotes;\n            stewardBabl = _strategyDetails[10].multiplyDecimal(profitShare).preciseMul(uint256(userVotes)).preciseDiv(\n                accountingVotes\n            );\n        } else if ((userVotes < 0) && !_profitData[1]) {\n            stewardBabl = _strategyDetails[10]\n                .multiplyDecimal(profitShare)\n                .preciseMul(uint256(Math.abs(userVotes)))\n                .preciseDiv(totalVotes);\n        } else if ((userVotes < 0) && _profitData[1]) {\n            // Voted against a very profit strategy above expected returns, get no profit at all\n            stewardBabl = 0;\n        }\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a Strategist profile\n     * @param _strategyDetails          Strategy details data\n     * @param _profitData               Strategy details data\n     */\n    function _getStrategyStrategistBabl(uint256[] memory _strategyDetails, bool[] memory _profitData)\n        private\n        view\n        returns (uint256)\n    {\n        // Assumptions:\n        // We assume that the contributor is the strategist. Should not execute this function otherwise.\n        uint256 babl;\n        babl = _strategyDetails[9].multiplyDecimal(strategistBABLPercentage); // Standard calculation to be ponderated\n        if (_profitData[0] && _profitData[1]) {\n            uint256 bablCap = babl.mul(2); // Cap x2\n            // Strategist get a bonus based on the profits with a max cap of x2\n            babl = babl.preciseMul(_strategyDetails[7].preciseDiv(_strategyDetails[6]));\n            if (babl > bablCap) {\n                babl = bablCap;\n            }\n            return babl;\n        } else if (_profitData[0] && !_profitData[1]) {\n            // under expectations\n            // The more the results are close to the expected the less penalization it might have\n            return babl.sub(babl.sub(babl.preciseMul(_strategyDetails[7].preciseDiv(_strategyDetails[8]))));\n        } else {\n            // No positive profit, no BABL assigned to the strategist role\n            return 0;\n        }\n    }\n\n    /**\n     * Get the rewards for a Strategist profile\n     * @param _garden           Garden address\n     * @param _profitValue      Strategy profit value\n     */\n    function _getStrategyStrategistProfits(address _garden, uint256 _profitValue) private view returns (uint256) {\n        // Assumptions:\n        // Only executes if the contributor was the strategist of the strategy\n        // AND the strategy had profits\n        uint256 profitShare =\n            gardenCustomProfitSharing[_garden] ? gardenProfitSharing[_garden][0] : strategistProfitPercentage;\n        return _profitValue.multiplyDecimal(profitShare);\n    }\n\n    /**\n     * Get the BABL rewards (Mining program) for a LP profile\n     * @param _strategyRewards      Strategy rewards\n     * @param _contributorShare     Contributor share in the period\n     */\n    function _getStrategyLPBabl(uint256 _strategyRewards, uint256 _contributorShare) private view returns (uint256) {\n        uint256 babl;\n        // All params must have 18 decimals precision\n        babl = _strategyRewards.multiplyDecimal(lpsBABLPercentage).preciseMul(_contributorShare);\n        return babl;\n    }\n\n    /**\n     * Calculates the BABL rewards supply for each quarter\n     * @param _quarter      Number of the epoch (quarter)\n     */\n    function _tokenSupplyPerQuarter(uint256 _quarter) internal pure returns (uint256) {\n        _require(_quarter >= 1, Errors.QUARTERS_MIN_1);\n        if (_quarter >= 513) {\n            return 0; // Avoid math overflow\n        } else {\n            uint256 firstFactor = (SafeDecimalMath.unit().add(DECAY_RATE)).powDecimal(_quarter.sub(1));\n            return Q1_REWARDS.divideDecimal(firstFactor);\n        }\n    }\n\n    /**\n     * Calculates the quarter number for a specific time since START_TIME\n     * @param _now      Timestamp to calculate its quarter\n     */\n    function _getQuarter(uint256 _now) internal view returns (uint256) {\n        // Avoid underflow for active strategies during mining activation\n        uint256 quarter = _now >= START_TIME ? (_now.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18) : 0;\n        return quarter.add(1);\n    }\n\n    /**\n     * Calculates the range (starting quarter and ending quarter since START_TIME)\n     * @param _from   Starting timestamp\n     * @param _to     Ending timestamp\n     */\n    function _getRewardsWindow(uint256 _from, uint256 _to) internal view returns (uint256, uint256) {\n        // Avoid underflow for active strategies during mining activation\n        if (_from < START_TIME) {\n            _from = START_TIME;\n        }\n        uint256 quarters = (_to.sub(_from).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        uint256 startingQuarter = (_from.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n        uint256 endingQuarter = (_to.sub(START_TIME).preciseDivCeil(EPOCH_DURATION)).div(1e18);\n\n        if (\n            startingQuarter != endingQuarter &&\n            endingQuarter == startingQuarter.add(1) &&\n            _to.sub(_from) < EPOCH_DURATION\n        ) {\n            quarters = quarters.add(1);\n        }\n        return (quarters.add(1), startingQuarter.add(1));\n    }\n\n    /**\n     * Gives creator bonus to the user and returns original + bonus\n     * @param _garden               Address of the garden\n     * @param _contributor          Address of the contributor\n     * @param _contributorBABL      BABL obtained in the strategy\n     */\n    function _getCreatorBonus(\n        address _garden,\n        address _contributor,\n        uint256 _contributorBABL\n    ) private view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        bool isCreator = garden.creator() == _contributor;\n        uint8 creatorCount = garden.creator() != address(0) ? 1 : 0;\n        for (uint8 i = 0; i < 4; i++) {\n            address _extraCreator = garden.extraCreators(i);\n            if (_extraCreator != address(0)) {\n                creatorCount++;\n                isCreator = isCreator || _extraCreator == _contributor;\n            }\n        }\n        // Get a multiplier bonus in case the contributor is the garden creator\n        if (creatorCount == 0) {\n            // If there is no creator divide the creator bonus across al members\n            return\n                _contributorBABL.add(\n                    _contributorBABL.multiplyDecimal(gardenCreatorBonus).div(IGarden(_garden).totalContributors())\n                );\n        } else {\n            if (isCreator) {\n                // Check other creators and divide by number of creators or members if creator address is 0\n                return _contributorBABL.add(_contributorBABL.multiplyDecimal(gardenCreatorBonus).div(creatorCount));\n            }\n        }\n        return _contributorBABL;\n    }\n\n    /**\n     * Get an estimation of strategy BABL rewards for active strategies in the mining program\n     * @param _strategy        Address of the strategy to estimate BABL rewards\n     * Returns the strategist, strategyDetails needed as well as profit data\n     */\n    function _estimateStrategyRewards(address _strategy)\n        internal\n        view\n        returns (\n            address strategist,\n            uint256[] memory strategyDetails,\n            bool[] memory profitData\n        )\n    {\n        // strategyDetails array mapping:\n        // strategyDetails[0]: executedAt\n        // strategyDetails[1]: exitedAt\n        // strategyDetails[2]: updatedAt\n        // strategyDetails[3]: enteredAt\n        // strategyDetails[4]: totalPositiveVotes\n        // strategyDetails[5]: totalNegativeVotes\n        // strategyDetails[6]: capitalAllocated\n        // strategyDetails[7]: capitalReturned\n        // strategyDetails[8]: expectedReturn\n        // strategyDetails[9]: strategyRewards\n        // strategyDetails[10]: profitValue\n        // strategyDetails[11]: distanceValue\n        // strategyDetails[12]: startingGardenSupply\n        // strategyDetails[13]: endingGardenSupply\n        // strategyDetails[14]: maxTradeSlippagePercentage\n        // profitData array mapping:\n        // profitData[0]: profit\n        // profitData[1]: distance\n\n        (strategist, strategyDetails, profitData) = IStrategy(_strategy).getStrategyRewardsContext();\n        if (strategyDetails[9] != 0 || strategyDetails[0] == 0) {\n            // Already finished and got rewards or not executed yet (not active)\n            return (strategist, strategyDetails, profitData);\n        }\n        // Strategy has not finished yet, lets try to estimate its mining rewards\n        // As the strategy has not ended we replace the capital returned value by the NAV\n        uint256 strategyNav = IStrategy(_strategy).getNAV();\n        // We estimate final returns substracting slippage\n        strategyDetails[7] = strategyNav.sub(strategyNav.preciseMul(strategyDetails[14]));\n        profitData[0] = strategyDetails[7] >= strategyDetails[6];\n        profitData[1] = strategyDetails[7] >= strategyDetails[8];\n        strategyDetails[10] = profitData[0] ? strategyDetails[7].sub(strategyDetails[6]) : 0; // no profit\n        // We consider that it potentially will have profits so the protocol will take profitFee\n        // If 0 it does nothing\n        strategyDetails[11] = profitData[1]\n            ? strategyDetails[7].sub(strategyDetails[8])\n            : strategyDetails[8].sub(strategyDetails[7]);\n        // We take care about beta live strategies as they have a different start mining time != executedAt\n        (uint256 numQuarters, uint256 startingQuarter) =\n            _getRewardsWindow(\n                (\n                    (strategyDetails[0] > START_TIME)\n                        ? strategyDetails[0]\n                        : strategyPerQuarter[_strategy][1].betaInitializedAt\n                ),\n                block.timestamp\n            );\n        // We create an array of quarters since the begining of the strategy\n        // We then fill with known + unknown data that has to be figured out\n        uint256[] memory strategyPower = new uint256[](numQuarters);\n        uint256[] memory protocolPower = new uint256[](numQuarters);\n        for (uint256 i = 0; i < numQuarters; i++) {\n            // We take the info of each epoch from current checkpoints\n            // array[0] for the first quarter power checkpoint of the strategy\n            strategyPower[i] = strategyPerQuarter[_strategy][startingQuarter.add(i)].quarterPower;\n            protocolPower[i] = protocolPerQuarter[startingQuarter.add(i)].quarterPower;\n            _require(strategyPower[i] <= protocolPower[i], Errors.OVERFLOW_IN_POWER);\n        }\n        strategyPower = _updatePendingPower(\n            strategyPower,\n            numQuarters,\n            startingQuarter,\n            strategyDetails[2],\n            strategyPrincipal[_strategy]\n        );\n        protocolPower = _updatePendingPower(\n            protocolPower,\n            numQuarters,\n            startingQuarter,\n            miningUpdatedAt,\n            miningProtocolPrincipal\n        );\n        strategyDetails[9] = _getBenchmarkRewards(\n            strategyDetails[7],\n            strategyDetails[6],\n            _harvestStrategyRewards(strategyPower, protocolPower, startingQuarter, numQuarters),\n            strategyDetails[0]\n        );\n    }\n\n    /**\n     * Harvest rewards of all epochs during estimation for each strategy\n     * @param _strategyPower        Accumulated strategy power per epoch\n     * @param _protocolPower        Accumulated protocol power per epoch\n     * @param _startingQuarter      Starting quarter for calculations\n     * @param _numQuarters          Total number of quarters for the calculation\n     * @return the baseline estimated rewards for the strategy\n     */\n    function _harvestStrategyRewards(\n        uint256[] memory _strategyPower,\n        uint256[] memory _protocolPower,\n        uint256 _startingQuarter,\n        uint256 _numQuarters\n    ) internal view returns (uint256) {\n        uint256 strategyRewards;\n        uint256 percentage = 1e18;\n        for (uint256 i = 0; i < _numQuarters; i++) {\n            if (i.add(1) == _numQuarters) {\n                // last quarter - we need to take proportional supply for that timeframe despite\n                // the epoch has not finished yet\n                uint256 slotEnding = START_TIME.add(_startingQuarter.add(i).mul(EPOCH_DURATION));\n                percentage = block.timestamp.sub(slotEnding.sub(EPOCH_DURATION)).preciseDiv(\n                    slotEnding.sub(slotEnding.sub(EPOCH_DURATION))\n                );\n            }\n            uint256 rewardsPerQuarter =\n                _strategyPower[i]\n                    .preciseDiv(_protocolPower[i] == 0 ? 1 : _protocolPower[i])\n                    .preciseMul(_tokenSupplyPerQuarter(_startingQuarter.add(i)))\n                    .preciseMul(percentage);\n            strategyRewards = strategyRewards.add(rewardsPerQuarter);\n        }\n        return strategyRewards;\n    }\n\n    /**\n     * Apply specific BABL mining weights to baseline BABL mining rewards based on mining benchmark params\n     * Benchmark creates 3 different segments to differentiate between bad, break even or good strategies\n     * @param _returned           Strategy capital returned\n     * @param _allocated          Strategy capital allocated\n     * @param _rewards            Strategy baseline BABL rewards\n     * @param _executedAt         Strategy timestamp of initial execution\n     */\n    function _getBenchmarkRewards(\n        uint256 _returned,\n        uint256 _allocated,\n        uint256 _rewards,\n        uint256 _executedAt\n    ) private view returns (uint256) {\n        // We categorize the strategy APY profits into one of the 3 segments (very bad, regular and cool strategies)\n        // Bad and regular will be penalized from bigger penalization to lower\n        // Cool strategies will be boosted\n        // As we get real time profit (returned / allocated) we need to annualize the strategy profits (APY)\n        // Real time profit\n        uint256 percentageProfit = _returned.preciseDiv(_allocated);\n        // Time weighted profit if > 1e18 duration less than 1 year, < 1e18 longer than 1 year\n        uint256 timedAPY =\n            uint256(365 days).preciseDiv(block.timestamp > _executedAt ? block.timestamp.sub(_executedAt) : 1);\n        uint256 returnedAPY; // initialization for absolute return APY (in reserve asset decimals)\n        uint256 rewardsFactor;\n        if (percentageProfit >= 1e18) {\n            // Strategy is on positive profit\n            // We calculate expected absolute returns in reserve asset decimals\n            // If strategy is less than 1 year, APY earnings will be higher\n            // else, APY earnings will be lower than today (we need to estimate annualized earnings)\n            returnedAPY = _allocated.add(_returned.sub(_allocated).preciseMul(timedAPY));\n        } else {\n            // Strategy is in loss\n            // We calculate expected absolute returns in reserve asset decimals\n            // If strategy is less than 1 year, APY loses will be higher\n            // else, APY loses will be lower than today (we need to estimate annualized loses)\n            returnedAPY = _allocated.sub(_returned).preciseMul(timedAPY);\n            returnedAPY = returnedAPY < _allocated ? _allocated.sub(returnedAPY) : 0;\n        }\n        // Now we normalize into 18 decimals the estimated APY profit percentage using expected return APY\n        uint256 profitAPY = returnedAPY.preciseDiv(_allocated);\n        // TODO: Replace _allocated by avgCapitalAllocated to handle adding or removing capital from strategy\n        // with lower impact along the time\n        if (profitAPY < benchmark[0]) {\n            // Segment 1:\n            // Bad strategy, usually gets penalty by benchmark[2] factor\n            rewardsFactor = benchmark[2];\n        } else if (profitAPY < benchmark[1]) {\n            // Segment 2:\n            // Not a cool strategy, can get penalty by benchmark[3] factor\n            rewardsFactor = benchmark[3];\n        } else {\n            // Segment 3:\n            // A real cool strategy, can get boost by benchmark[4] factor. Must be always >= 1e18\n            rewardsFactor = benchmark[4];\n        }\n        return\n            _rewards.preciseMul(bablPrincipalWeight).add(\n                _rewards.preciseMul(bablProfitWeight).preciseMul(percentageProfit).preciseMul(rewardsFactor)\n            );\n    }\n\n    /**\n     * Update pending power for each strategy and epoch during estimation\n     * @param _powerToUpdate        Current power to be updated per epoch (power is principal x time)\n     * @param _numQuarters          Total number of quarters for the calculation\n     * @param _startingQuarter      Starting quarter (epoch)\n     * @param _updatedAt            Updated timestamp\n     * @param _principal            Principal of the strategy or protocol to update power\n     * @return the updating power\n     */\n    function _updatePendingPower(\n        uint256[] memory _powerToUpdate,\n        uint256 _numQuarters,\n        uint256 _startingQuarter,\n        uint256 _updatedAt,\n        uint256 _principal\n    ) internal view returns (uint256[] memory) {\n        uint256 lastQuarter = _getQuarter(_updatedAt); // quarter of last update\n        uint256 currentQuarter = _getQuarter(block.timestamp); // current quarter\n        uint256 timeDiff = block.timestamp.sub(_updatedAt); // 1sec to avoid division by zero\n        // We check the pending power to be accounted until now, since last update for protocol and strategy\n        uint256 powerDebt = _principal.mul(timeDiff);\n        if (powerDebt > 0) {\n            for (uint256 i = 0; i < _numQuarters; i++) {\n                uint256 slotEnding = START_TIME.add(_startingQuarter.add(i).mul(EPOCH_DURATION));\n                if (i == 0 && lastQuarter == _startingQuarter && lastQuarter < currentQuarter) {\n                    // We are in the first quarter to update, we add the proportional pending part\n                    _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt.mul(slotEnding.sub(_updatedAt)).div(timeDiff));\n                } else if (i > 0 && i.add(1) < _numQuarters && lastQuarter <= _startingQuarter.add(i)) {\n                    // We are updating an intermediate quarter\n                    // Should have 0 inside before updating\n                    _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt.mul(EPOCH_DURATION).div(timeDiff));\n                } else if (_startingQuarter.add(i) == currentQuarter) {\n                    // We are updating the current quarter of this strategy checkpoint or the last to update\n                    // It can be a multiple quarter strategy or the only one that need proportional time\n                    if (lastQuarter == currentQuarter) {\n                        // Just add the powerDebt being in the same epoch, no need to get proportional\n                        _powerToUpdate[i] = _powerToUpdate[i].add(powerDebt);\n                    } else {\n                        // should have 0 inside before updating in case of different epoch since last update\n                        _powerToUpdate[i] = _powerToUpdate[i].add(\n                            powerDebt.mul(block.timestamp.sub(slotEnding.sub(EPOCH_DURATION))).div(timeDiff)\n                        );\n                    }\n                }\n            }\n        }\n        return _powerToUpdate;\n    }\n}\n\ncontract RewardsDistributorV16 is RewardsDistributor {}\n"
    },
    "contracts/interfaces/IProphets.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title IProphets\n * @author Babylon Finance\n *\n * Interface for interacting with the Prophets NFT\n */\ninterface IProphets is IERC721 {\n    /* ============ Functions ============ */\n\n    function getStakedProphetAttrs(address _owner, address _stakedAt) external view returns (uint256[7] memory);\n\n    function stake(uint256 _id, address _target) external;\n}\n"
    },
    "contracts/mocks/RewardsDistributorV2Mock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {TimeLockedToken} from '../token/TimeLockedToken.sol';\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/proxy/ProxyAdmin.sol';\n\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {Safe3296} from '../lib/Safe3296.sol';\nimport {Errors, _require} from '../lib/BabylonErrors.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IProphets} from '../interfaces/IProphets.sol';\n\n/**\n * @title Rewards Distributor implementing the BABL Mining Program and other Rewards to Strategists and Stewards\n * @author Babylon Finance\n * Rewards Distributor contract is a smart contract used to calculate and distribute all the BABL rewards of the BABL Mining Program\n * along the time reserved for executed strategies. It implements a supply curve to distribute 500K BABL along the time.\n * The supply curve is designed to optimize the long-term sustainability of the protocol.\n * The rewards are front-loaded but they last for more than 10 years, slowly decreasing quarter by quarter.\n * For that, it houses the state of the protocol power along the time as each strategy power is compared to the whole protocol usage.\n * Rewards Distributor also is responsible for the calculation and delivery of other rewards as bonuses to specific profiles\n * which are actively contributing to the protocol growth and their communities (Garden creators, Strategists and Stewards).\n */\ncontract RewardsDistributorV2Mock is OwnableUpgradeable {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for uint256;\n    using SafeDecimalMath for int256;\n    using Math for uint256;\n    using Math for int256;\n    using Safe3296 for uint256;\n    using Safe3296 for int256;\n    using Safe3296 for uint96;\n    using Safe3296 for uint32;\n\n    /* ========== Events ========== */\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constants ============ */\n    // 500K BABL allocated to this BABL Mining Program, the first quarter is Q1_REWARDS\n    // and the following quarters will follow the supply curve using a decay rate\n    uint256 private constant Q1_REWARDS = 53_571_428_571_428_600e6; // First quarter (epoch) BABL rewards\n    // 12% quarterly decay rate (each 90 days)\n    // (Rewards on Q1 = 1,12 * Rewards on Q2) being Q1= Quarter 1, Q2 = Quarter 2\n    uint256 private constant DECAY_RATE = 12e16;\n    // Duration of its EPOCH in days  // BABL & profits split from the protocol\n    uint256 private constant EPOCH_DURATION = 90 days;\n    // DAI normalize asset\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Reentrancy guard countermeasure\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    // NFT Prophets\n    IProphets private constant PROPHETS_NFT = IProphets(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43);\n\n    /* ============ State Variables ============ */\n\n    // solhint-disable-next-line\n    uint256 private START_TIME; // Starting time of the rewards distribution\n\n    // solhint-disable-next-line\n    uint256 private strategistBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsBABLPercentage;\n    // solhint-disable-next-line\n    uint256 private strategistProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private stewardsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private lpsProfitPercentage;\n    // solhint-disable-next-line\n    uint256 private profitProtocolFee;\n    // solhint-disable-next-line\n    uint256 private gardenCreatorBonus;\n\n    /* ============ Structs ============ */\n\n    struct ProtocolPerTimestamp {\n        uint256 principal; // DEPRECATED\n        uint256 time; // DEPRECATED\n        uint256 quarterBelonging; // DEPRECATED\n        uint256 timeListPointer; // DEPRECATED\n        uint256 power; // DEPRECATED\n    }\n\n    struct ProtocolPerQuarter {\n        // Protocol allocation checkpoints per timestamp per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 quarterNumber; // DEPRECATED\n        uint256 quarterPower; //  Accumulated Protocol power for each quarter\n        uint96 supplyPerQuarter; // DEPRECATED\n    }\n\n    struct GardenPowerByTimestamp {\n        // Garden allocation checkpoints per timestamp per each garden\n        uint256 avgGardenBalance; // Checkpoint to keep track on garden supply\n        uint256 lastDepositAt; // Checkpoint timestamps\n        uint256 accGardenPower; // Garden power checkpoint (power is proportional to = principal * duration)\n    }\n    struct ContributorPerGarden {\n        // Checkpoints to keep track on the evolution of each contributor vs. each garden\n        uint256 lastDepositAt; // Last deposit timestamp of each contributor in each garden\n        uint256 initialDepositAt; // Checkpoint of the initial deposit\n        uint256[] timeListPointer; // DEPRECATED, but still needed during beta gardens migration\n        uint256 pid; // DEPRECATED, but still needed during beta gardens migration\n        // Sub-mapping of contributor details, updated info after beta will be only at position [0]\n        mapping(uint256 => TimestampContribution) tsContributions;\n    }\n\n    struct TimestampContribution {\n        // Sub-mapping with all checkpoints for deposits and withdrawals of garden users\n        uint256 avgBalance; // User avg balance in each garden along the time\n        uint256 timestamp; // DEPRECATED\n        uint256 timePointer; // DEPRECATED\n        uint256 power; // Contributor power\n    }\n    struct Checkpoints {\n        uint256 fromTime; // checkpoint block timestamp\n        uint256 tokens; // User garden tokens in the checkpoint\n        uint256 supply; // DEPRECATED\n        uint256 prevBalance; // Previous user balance (backward compatibility for beta users)\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    IBabController private controller;\n\n    // BABL Token contract\n    TimeLockedToken private babltoken;\n\n    // Protocol total allocation points. Must be the sum of all allocation points (strategyPrincipal)\n    // in all ongoing strategies during mining program.\n    uint256 private miningProtocolPrincipal; // Protocol principal (only related to mining program)\n    mapping(uint256 => ProtocolPerTimestamp) private protocolPerTimestamp; // DEPRECATED\n    uint256[] private timeList; // DEPRECATED\n    uint256 private miningProtocolPower; // Mining protocol power along the time\n\n    // Mapping of the accumulated protocol per each active quarter\n    mapping(uint256 => ProtocolPerQuarter) private protocolPerQuarter;\n    // Check if the protocol per quarter data has been initialized\n    mapping(uint256 => bool) private isProtocolPerQuarter;\n\n    mapping(address => mapping(uint256 => uint256)) private rewardsPowerOverhead; // DEPRECATED\n    // Contributor power control\n    // Contributor details per garden\n    mapping(address => mapping(address => ContributorPerGarden)) private contributorPerGarden;\n    mapping(address => mapping(address => Checkpoints)) private checkpoints; // DEPRECATED\n    // Garden power control\n    // Garden power details per garden. Updated info after beta will be only at position [0]\n    mapping(address => mapping(uint256 => GardenPowerByTimestamp)) private gardenPowerByTimestamp;\n    mapping(address => uint256[]) private gardenTimelist; // DEPRECATED, but still needed during beta gardens migration\n    mapping(address => uint256) private gardenPid; // DEPRECATED, but still needed during beta gardens migration\n\n    struct StrategyPerQuarter {\n        // Acumulated strategy power per each quarter along the time\n        uint256 quarterPrincipal; // DEPRECATED\n        uint256 betaInitializedAt; // Only used for beta strategies\n        uint256 quarterPower; //  Accumulated strategy power for each quarter\n        bool initialized; // True if the strategy has checkpoints in that quarter already\n    }\n    struct StrategyPricePerTokenUnit {\n        // Take control over the price per token changes along the time when normalizing into DAI\n        uint256 preallocated; // Strategy capital preallocated before each checkpoint\n        uint256 pricePerTokenUnit; // Last average price per allocated tokens per strategy normalized into DAI\n    }\n    // Acumulated strategy power per each quarter along the time\n    mapping(address => mapping(uint256 => StrategyPerQuarter)) private strategyPerQuarter;\n    // Pro-rata oracle price allowing re-allocations and unwinding of any capital value\n    mapping(address => StrategyPricePerTokenUnit) private strategyPricePerTokenUnit;\n\n    // Reentrancy guard countermeasure\n    uint256 private status;\n\n    // Customized profit sharing (if any)\n    // [0]: _strategistProfit , [1]: _stewardsProfit, [2]: _lpProfit\n    mapping(address => uint256[3]) private gardenProfitSharing;\n    mapping(address => bool) private gardenCustomProfitSharing;\n\n    uint256 private miningUpdatedAt; // Timestamp of last strategy capital update\n    mapping(address => uint256) private strategyPrincipal; // Last known strategy principal normalized into DAI\n\n    // Only for beta gardens and users as they need migration into new gas-optimized data structure\n    // Boolean check to control users and garden migration into to new mapping architecture without checkpoints\n    mapping(address => mapping(address => bool)) private betaAddressMigrated;\n    mapping(address => bool) private betaGardenMigrated; // DEPRECATED\n\n    uint256 private bablProfitWeight;\n    uint256 private bablPrincipalWeight;\n\n    // A record of garden token checkpoints for each address of each garden, by index\n    // garden -> address -> index checkpoint -> checkpoint struct data\n    mapping(address => mapping(address => mapping(uint256 => Checkpoints))) private gardenCheckpoints;\n\n    // The number of checkpoints for each address of each garden\n    // garden -> address -> number of checkpoints\n    mapping(address => mapping(address => uint256)) private numCheckpoints;\n\n    /* ============ Constructor ============ */\n\n    function initialize(TimeLockedToken _bablToken, IBabController _controller) public {\n        OwnableUpgradeable.__Ownable_init();\n        _require(address(_bablToken) != address(0) && address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        babltoken = _bablToken;\n        controller = _controller;\n\n        profitProtocolFee = controller.protocolPerformanceFee();\n\n        strategistProfitPercentage = 10e16; // 10%\n        stewardsProfitPercentage = 5e16; // 5%\n        lpsProfitPercentage = 80e16; // 80%\n\n        strategistBABLPercentage = 10e16; // 10%\n        stewardsBABLPercentage = 10e16; // 10%\n        lpsBABLPercentage = 80e16; // 80%\n        gardenCreatorBonus = 10e16; // 10%\n\n        bablProfitWeight = 65e16; // 65%\n        bablPrincipalWeight = 35e16; // 35%\n\n        status = NOT_ENTERED;\n        // BABL Mining program was started by bip#1\n        START_TIME = block.timestamp;\n    }\n\n    /* ============ External Functions ============ */\n\n    function newMethod() public pure returns (string memory) {\n        return 'foobar';\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../access/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/lib/Safe3296.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\n\nlibrary Safe3296 {\n    using LowGasSafeMath for uint256;\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint32\n     *\n     * @dev internal function to convert from uint256 to uint32\n     */\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to convert from uint256 to uint96\n     *\n     * @dev internal function to convert from uint256 to uint96\n     */\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to add two uint96 numbers\n     *\n     * @dev internal safe math function to add two uint96 numbers\n     */\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    /**\n     * INTERNAL FUNCTION. Internal function to subtract two uint96 numbers\n     *\n     * @dev internal safe math function to subtract two uint96 numbers\n     */\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/viewer/GardenViewer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IGardenViewer} from '../interfaces/IViewer.sol';\n\n/**\n * @title GardenViewer\n * @author Babylon Finance\n *\n * Class that holds common view functions to retrieve garden information effectively\n */\ncontract GardenViewer {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using Math for int256;\n    using SafeDecimalMath for uint256;\n\n    IBabController private immutable controller;\n    uint24 internal constant FEE_LOW = 500;\n    uint24 internal constant FEE_MEDIUM = 3000;\n    uint24 internal constant FEE_HIGH = 10000;\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    constructor(IBabController _controller) {\n        controller = _controller;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets garden principal\n     *\n     * @param _garden            Address of the garden to fetch\n     * @return                   Garden principal\n     */\n    function getGardenPrincipal(address _garden) public view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        IERC20 reserveAsset = IERC20(garden.reserveAsset());\n        uint256 principal = reserveAsset.balanceOf(address(garden)).sub(garden.reserveAssetRewardsSetAside());\n        uint256 protocolMgmtFee = IBabController(controller).protocolManagementFee();\n        address[] memory strategies = garden.getStrategies();\n        for (uint256 i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            principal = principal.add(strategy.capitalAllocated()).add(\n                protocolMgmtFee.preciseMul(strategy.capitalAllocated())\n            );\n        }\n        address[] memory finalizedStrategies = garden.getFinalizedStrategies();\n        for (uint256 i = 0; i < finalizedStrategies.length; i++) {\n            IStrategy strategy = IStrategy(finalizedStrategies[i]);\n            principal = principal.add(protocolMgmtFee.preciseMul(strategy.capitalAllocated()));\n        }\n        principal = principal.add(garden.totalKeeperFees());\n        int256 absoluteReturns = garden.absoluteReturns();\n        if (absoluteReturns > 0) {\n            principal = principal > uint256(absoluteReturns) ? principal.sub(uint256(absoluteReturns)) : 0;\n        } else {\n            principal = principal.add(uint256(-absoluteReturns));\n        }\n        return principal;\n    }\n\n    /**\n     * Gets garden details\n     *\n     * @param _garden            Address of the garden to fetch\n     * @return                   Garden complete details\n     */\n    function getGardenDetails(address _garden)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            address[5] memory,\n            address,\n            bool[4] memory,\n            address[] memory,\n            address[] memory,\n            uint256[13] memory,\n            uint256[10] memory,\n            uint256[3] memory\n        )\n    {\n        IGarden garden = IGarden(_garden);\n        uint256 principal = getGardenPrincipal(_garden);\n        uint256[] memory totalSupplyValuationAndSeed = new uint256[](4);\n        totalSupplyValuationAndSeed[0] = IERC20(_garden).totalSupply();\n        totalSupplyValuationAndSeed[1] = totalSupplyValuationAndSeed[0] > 0\n            ? IGardenValuer(controller.gardenValuer()).calculateGardenValuation(_garden, garden.reserveAsset())\n            : 0;\n        totalSupplyValuationAndSeed[2] = _getGardenSeed(_garden);\n        totalSupplyValuationAndSeed[3] = ERC20(garden.reserveAsset()).balanceOf(address(garden));\n        if (totalSupplyValuationAndSeed[3] > garden.keeperDebt()) {\n            totalSupplyValuationAndSeed[3] = totalSupplyValuationAndSeed[3].sub(garden.keeperDebt());\n        }\n        if (totalSupplyValuationAndSeed[3] > garden.reserveAssetRewardsSetAside()) {\n            totalSupplyValuationAndSeed[3] = totalSupplyValuationAndSeed[3].sub(garden.reserveAssetRewardsSetAside());\n        } else {\n            totalSupplyValuationAndSeed[3] = 0;\n        }\n\n        uint256[3] memory profits = _getGardenProfitSharing(_garden);\n        return (\n            ERC20(_garden).name(),\n            ERC20(_garden).symbol(),\n            [\n                garden.creator(),\n                garden.extraCreators(0),\n                garden.extraCreators(1),\n                garden.extraCreators(2),\n                garden.extraCreators(3)\n            ],\n            garden.reserveAsset(),\n            [true, garden.privateGarden(), garden.publicStrategists(), garden.publicStewards()],\n            garden.getStrategies(),\n            garden.getFinalizedStrategies(),\n            [\n                garden.depositHardlock(),\n                garden.minVotesQuorum(),\n                garden.maxDepositLimit(),\n                garden.minVoters(),\n                garden.minStrategyDuration(),\n                garden.maxStrategyDuration(),\n                garden.strategyCooldownPeriod(),\n                garden.minContribution(),\n                garden.minLiquidityAsset(),\n                garden.totalKeeperFees().add(garden.keeperDebt()),\n                garden.pricePerShareDecayRate(),\n                garden.pricePerShareDelta(),\n                garden.verifiedCategory()\n            ],\n            [\n                principal,\n                garden.reserveAssetRewardsSetAside(),\n                uint256(garden.absoluteReturns()),\n                garden.gardenInitializedAt(),\n                garden.totalContributors(),\n                garden.totalStake(),\n                totalSupplyValuationAndSeed[1] > 0\n                    ? totalSupplyValuationAndSeed[0].preciseMul(totalSupplyValuationAndSeed[1])\n                    : 0,\n                totalSupplyValuationAndSeed[0],\n                totalSupplyValuationAndSeed[2],\n                totalSupplyValuationAndSeed[3]\n            ],\n            profits\n        );\n    }\n\n    function getGardenPermissions(address _garden, address _user)\n        public\n        view\n        returns (\n            bool,\n            bool,\n            bool\n        )\n    {\n        IMardukGate gate = IMardukGate(controller.mardukGate());\n        bool isZero = _user == address(0);\n        return (\n            !IGarden(_garden).privateGarden() || (!isZero && gate.canJoinAGarden(_garden, _user)),\n            IGarden(_garden).publicStewards() || (!isZero && gate.canVoteInAGarden(_garden, _user)),\n            IGarden(_garden).publicStrategists() || (!isZero && gate.canAddStrategiesInAGarden(_garden, _user))\n        );\n    }\n\n    function getGardensUser(address _user, uint256 _offset)\n        external\n        view\n        returns (\n            address[] memory,\n            bool[] memory,\n            IGardenViewer.PartialGardenInfo[] memory\n        )\n    {\n        address[] memory gardens = controller.getGardens();\n        address[] memory userGardens = new address[](50);\n        bool[] memory hasUserDeposited = new bool[](50);\n        IGardenViewer.PartialGardenInfo[] memory info = new IGardenViewer.PartialGardenInfo[](50);\n        uint256 limit = gardens.length <= 50 ? gardens.length : _offset.add(50);\n        limit = limit < gardens.length ? limit : gardens.length;\n        uint8 resultIndex;\n        for (uint256 i = _offset; i < limit; i++) {\n            (bool depositPermission, , ) = getGardenPermissions(gardens[i], _user);\n            if (depositPermission) {\n                userGardens[resultIndex] = gardens[i];\n                hasUserDeposited[resultIndex] = _user != address(0) ? IERC20(gardens[i]).balanceOf(_user) > 0 : false;\n                IGarden garden = IGarden(gardens[i]);\n                info[resultIndex] = IGardenViewer.PartialGardenInfo(\n                    gardens[i],\n                    garden.name(),\n                    !garden.privateGarden(),\n                    garden.verifiedCategory(),\n                    garden.totalContributors(),\n                    garden.reserveAsset(),\n                    garden.totalSupply().mul(garden.lastPricePerShare()).div(1e18)\n                );\n                resultIndex = resultIndex + 1;\n            }\n        }\n        return (userGardens, hasUserDeposited, info);\n    }\n\n    function getGardenUserAvgPricePerShare(IGarden _garden, address _user) public view returns (uint256) {\n        (, , , , , , uint256 totalDeposits, , ) = _garden.getContributor(_user);\n\n        // Avg price per user share = deposits / garden tokens\n        // contributor[0] -> Deposits (ERC20 reserveAsset with X decimals)\n        // contributor[1] -> Balance (Garden tokens) with 18 decimals\n        return totalDeposits > 0 ? totalDeposits.preciseDiv(_garden.balanceOf(_user)) : 0;\n    }\n\n    /**\n     * Gets the number of tokens that can vote in this garden\n     *\n     * @param _garden  Garden to retrieve votes for\n     * @param _members All members of a garden\n     * @return uint256 Total number of tokens that can vote\n     */\n    function getPotentialVotes(address _garden, address[] calldata _members) external view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        if (garden.publicStewards()) {\n            return IERC20(_garden).totalSupply();\n        }\n        uint256 total = 0;\n        for (uint256 i = 0; i < _members.length; i++) {\n            (bool canDeposit, bool canVote, ) = getGardenPermissions(_garden, _members[i]);\n            if (canDeposit && canVote) {\n                total = total.add(IERC20(_garden).balanceOf(_members[i]));\n            }\n        }\n        return total;\n    }\n\n    function getContributor(IGarden _garden, address _user) internal view returns (uint256[10] memory) {\n        (\n            uint256 lastDepositAt,\n            uint256 initialDepositAt,\n            uint256 claimedAt,\n            uint256 claimedBABL,\n            uint256 claimedRewards,\n            uint256 withdrawnSince,\n            uint256 totalDeposits,\n            ,\n            uint256 lockedBalance\n        ) = _garden.getContributor(_user);\n        return [\n            lastDepositAt,\n            initialDepositAt,\n            claimedAt,\n            claimedBABL,\n            claimedRewards,\n            totalDeposits > withdrawnSince ? totalDeposits.sub(withdrawnSince) : 0,\n            _garden.balanceOf(_user),\n            lockedBalance,\n            0,\n            getGardenUserAvgPricePerShare(_garden, _user)\n        ];\n    }\n\n    function getContributionAndRewards(IGarden _garden, address _user)\n        external\n        view\n        returns (\n            uint256[10] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        return (\n            getContributor(_garden, _user),\n            IRewardsDistributor(controller.rewardsDistributor()).getRewards(\n                address(_garden),\n                _user,\n                _garden.getFinalizedStrategies()\n            ),\n            _estimateUserRewards(_user, _garden.getStrategies())\n        );\n    }\n\n    function getPriceAndLiquidity(address _tokenIn, address _reserveAsset) external view returns (uint256, uint256) {\n        return (\n            IPriceOracle(controller.priceOracle()).getPrice(_tokenIn, _reserveAsset),\n            _getUniswapHighestLiquidity(_tokenIn, _reserveAsset)\n        );\n    }\n\n    function getAllProphets(address _address) external view returns (uint256[] memory) {\n        IERC721Enumerable prophets = IERC721Enumerable(0x26231A65EF80706307BbE71F032dc1e5Bf28ce43);\n        uint256 prophetsNumber = prophets.balanceOf(_address);\n        uint256[] memory prophetIds = new uint256[](prophetsNumber);\n        for (uint256 i = 0; i < prophetsNumber; i++) {\n            prophetIds[i] = prophets.tokenOfOwnerByIndex(_address, i);\n        }\n        return prophetIds;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getGardenSeed(address _garden) private view returns (uint256) {\n        return IGardenNFT(controller.gardenNFT()).gardenSeeds(_garden);\n    }\n\n    function _getGardenProfitSharing(address _garden) private view returns (uint256[3] memory) {\n        return IRewardsDistributor(controller.rewardsDistributor()).getGardenProfitsSharing(_garden);\n    }\n\n    function _getGardenUserAvgPricePerShare(address _garden, address _user) private view returns (uint256) {\n        IGarden garden = IGarden(_garden);\n        (, , , , , , uint256 totalDeposits, , ) = garden.getContributor(_user);\n\n        // Avg price per user share = deposits / garden tokens\n        return totalDeposits > 0 ? totalDeposits.preciseDiv(garden.balanceOf(_user)) : 0;\n    }\n\n    function _getUniswapHighestLiquidity(address _sendToken, address _reserveAsset) private view returns (uint256) {\n        // Exit if going to same asset\n        if (_sendToken == _reserveAsset) {\n            return 1e30;\n        }\n        (IUniswapV3Pool pool, ) = _getUniswapPoolWithHighestLiquidity(_sendToken, _reserveAsset);\n        if (address(pool) == address(0)) {\n            return 0;\n        }\n        uint256 poolLiquidity = uint256(pool.liquidity());\n        uint256 liquidityInReserve;\n        address denominator;\n\n        if (pool.token0() == _reserveAsset) {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token1()).balanceOf(address(pool)));\n            denominator = pool.token0();\n        } else {\n            liquidityInReserve = poolLiquidity.mul(poolLiquidity).div(ERC20(pool.token0()).balanceOf(address(pool)));\n            denominator = pool.token1();\n        }\n        // Normalize to reserve asset\n        if (denominator != _reserveAsset) {\n            IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n            uint256 price = oracle.getPrice(denominator, _reserveAsset);\n            // price is always in 18 decimals\n            // preciseMul returns in the same decimals than liquidityInReserve, so we have to normalize into reserve Asset decimals\n            // normalization into reserveAsset decimals\n            liquidityInReserve = SafeDecimalMath.normalizeAmountTokens(\n                denominator,\n                _reserveAsset,\n                liquidityInReserve.preciseMul(price)\n            );\n        }\n        return liquidityInReserve;\n    }\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool, uint24 fee)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow > liquidityMedium && liquidityLow >= liquidityHigh) {\n            return (poolLow, FEE_LOW);\n        }\n        if (liquidityMedium > liquidityLow && liquidityMedium >= liquidityHigh) {\n            return (poolMedium, FEE_MEDIUM);\n        }\n        return (poolHigh, FEE_HIGH);\n    }\n\n    /**\n     * returns the estimated accrued BABL for a user related to one strategy\n     */\n    function _estimateUserRewards(address _contributor, address[] memory _strategies)\n        private\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory totalRewards = new uint256[](8);\n        address rewardsDistributor = address(controller.rewardsDistributor());\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            uint256[] memory tempRewards = new uint256[](8);\n            if (!IStrategy(_strategies[i]).isStrategyActive()) {\n                continue;\n            }\n            tempRewards = IRewardsDistributor(rewardsDistributor).estimateUserRewards(_strategies[i], _contributor);\n            for (uint256 j = 0; j < 8; j++) {\n                totalRewards[j] = totalRewards[j].add(tempRewards[j]);\n            }\n        }\n        return totalRewards;\n    }\n}\n"
    },
    "contracts/strategies/StrategyNFT.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\n\n/**\n * @title StrategyNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Strategy\n */\ncontract StrategyNFT is ERC721, IStrategyNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event StrategyNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy {\n        IStrategy strategy = IStrategy(msg.sender);\n        require(\n            IGarden(strategy.garden()).strategyMapping(msg.sender) && controller.isSystemContract(msg.sender),\n            'Only the strategy can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    mapping(address => StratDetail) public stratDetails;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(bytes(_name).length < 50, 'Strategy Name is too long');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user                           Address of the user\n     * @param _strategyTokenURI               Strategy token URI\n     */\n    function grantStrategyNFT(address _user, string memory _strategyTokenURI)\n        external\n        override\n        onlyStrategy\n        returns (uint256)\n    {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, _strategyTokenURI);\n        stratDetails[msg.sender].tokenId = newItemId;\n        emit StrategyNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the name an symbol for a new created strategy\n     *\n     * @param _strategy               Address of the strategy\n     * @param _name                   Strategy Name\n     * @param _symbol                 Strategy Symbol\n     */\n    function saveStrategyNameAndSymbol(\n        address _strategy,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        StratDetail storage stratDetail = stratDetails[_strategy];\n        stratDetail.name = _name;\n        stratDetail.symbol = _symbol;\n    }\n\n    function getStrategyTokenURI(address _strategy) external view override returns (string memory) {\n        return tokenURI(stratDetails[_strategy].tokenId);\n    }\n\n    function getStrategyName(address _strategy) external view override returns (string memory) {\n        return stratDetails[_strategy].name;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "contracts/strategies/StrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IStrategyNFT} from '../interfaces/IStrategyNFT.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\n\n/**\n * @title StrategyFactory\n * @author Babylon Finance\n *\n * Factory to create investment strategy contracts\n */\ncontract StrategyFactory is IStrategyFactory {\n    modifier onlyGarden {\n        require(\n            controller.isGarden(msg.sender) && IGarden(msg.sender).controller() == controller,\n            'Only the garden can create strategies'\n        );\n        _;\n    }\n\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a new investment strategy using minimal proxies\n     *\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _strategist                    Address of the strategist\n     * @param _garden                        Address of the garden\n     * @param _stratParams                   Strat Params\n     */\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external override onlyGarden returns (address) {\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IStrategy.initialize.selector,\n                        _strategist,\n                        _garden,\n                        controller,\n                        _stratParams[0],\n                        _stratParams[1],\n                        _stratParams[2],\n                        _stratParams[3],\n                        _stratParams[4],\n                        _stratParams[5],\n                        _stratParams[6]\n                    )\n                )\n            );\n        IStrategyNFT(controller.strategyNFT()).saveStrategyNameAndSymbol(proxy, _name, _symbol);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../access/Ownable.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) public {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "contracts/proxy/SafeBeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/BeaconProxy.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to create garden contracts\n */\ncontract SafeBeaconProxy is BeaconProxy {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable BeaconProxy(beacon, data) {}\n\n    /**\n     * @dev Accepts all ETH transfers but does not proxy calls to the implementation.\n     *\n     * Due to EIP-2929 the proxy overhead gas cost is higher than 2300 gas which is the stipend used by address.transfer.\n     * This results to a `out of gas` error for proxy calls initiated by code `address.transfer`.\n     * A notable example is WETH https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\n     * A downside of this approach is that a proxy implementation contract can not handle receiving pure ETH.\n     * In a scope of Babylon project this is acceptable but should be kept in mind at all times.\n     *\n     */\n    receive() external payable override {}\n}\n"
    },
    "contracts/interfaces/IStrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IIntegration} from './IIntegration.sol';\n\n/**\n * @title IStrategyFactory\n * @author Babylon Finance\n *\n * Interface for the strategy factory\n */\ninterface IStrategyFactory {\n    function createStrategy(\n        string memory _name,\n        string memory _symbol,\n        address _strategist,\n        address _garden,\n        uint256[] calldata _stratParams\n    ) external returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\nimport \"./IBeacon.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) public payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).implementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}\n"
    },
    "contracts/strategies/operations/LendOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title LendOperation\n * @author Babylon Finance\n *\n * Executes a lend operation\n */\ncontract LendOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the lend operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {}\n\n    /**\n     * Executes the lend operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _data               OpData e.g. Address of the asset to lend\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = BytesLib.decodeOpDataAddress(_data); // We just use the first 20 bytes from the whole opEncodedData\n        if (assetToken != _asset) {\n            // Trade to WETH if is 0x0 (eth in compound)\n            if (assetToken != address(0) || _asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, _capital, assetToken == address(0) ? WETH : assetToken);\n            }\n        }\n        uint256 numTokensToSupply;\n        if (assetToken == address(0)) {\n            // change it to plain eth for compound\n            IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            numTokensToSupply = address(msg.sender).balance;\n        } else {\n            numTokensToSupply = IERC20(assetToken).balanceOf(msg.sender);\n        }\n        uint256 exactAmount = ILendIntegration(_integration).getExpectedShares(assetToken, numTokensToSupply);\n        uint256 minAmountExpected = exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n        ILendIntegration(_integration).supplyTokens(msg.sender, assetToken, numTokensToSupply, minAmountExpected);\n        return (assetToken, numTokensToSupply, 1); // put as collateral\n    }\n\n    /**\n     * Exits the lend operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address _borrowToken,\n        uint256 _debt,\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes memory _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address assetToken = BytesLib.decodeOpDataAddressAssembly(_data, 12);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        _redeemTokens(_borrowToken, _debt, _percentage, msg.sender, _integration, assetToken);\n        // Change to weth if needed\n        if (assetToken == address(0)) {\n            assetToken = WETH;\n            IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n        }\n        address rewardsToken = _getRewardToken(_integration);\n        // Only sell rewards when the strategy finalizes\n        if (rewardsToken != address(0) && _percentage == HUNDRED_PERCENT) {\n            uint256 rewardsBalance = IERC20(rewardsToken).balanceOf(msg.sender);\n            // Add rewards\n            if (rewardsBalance > 1e16) {\n                IStrategy(msg.sender).trade(rewardsToken, rewardsBalance, assetToken, 70e15);\n            }\n        }\n        // Liquidations\n        _tradeLiquidationsToAsset(_borrowToken, assetToken);\n        return (assetToken, IERC20(assetToken).balanceOf(msg.sender), 0);\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset lent\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        address lendToken = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 assetTokenAmount = ILendIntegration(_integration).getInvestmentTokenAmount(msg.sender, lendToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), lendToken);\n        uint256 NAV =\n            SafeDecimalMath.normalizeAmountTokens(lendToken, _garden.reserveAsset(), assetTokenAmount).preciseDiv(\n                price\n            );\n        address rewardsToken = _getRewardToken(_integration);\n        // Replace FuseLend\n        if (_integration == 0x3D0160388eC9196ceA4fA57E020E11ae446b3c13) {\n            _integration = 0x68BE39E4357408f8c504ae1c25380bF132bd5555;\n        }\n        if (rewardsToken != address(0)) {\n            uint256 rewardsAmount = ILendIntegration(_integration).getRewardsAccrued(msg.sender);\n            if (rewardsAmount > 0) {\n                uint256 priceRewards = _getPrice(_garden.reserveAsset(), rewardsToken);\n                // We add rewards\n                if (priceRewards != 0) {\n                    NAV = NAV.add(\n                        SafeDecimalMath\n                            .normalizeAmountTokens(rewardsToken, _garden.reserveAsset(), rewardsAmount)\n                            .preciseDiv(priceRewards)\n                    );\n                }\n            }\n        }\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    function _redeemTokens(\n        address _borrowToken,\n        uint256 _debt,\n        uint256 _percentage,\n        address _sender,\n        address _integration,\n        address _assetToken\n    ) internal {\n        // Normalize to underlying asset if any (ctokens for compound)\n        uint256 numTokensToRedeem = ILendIntegration(_integration).getInvestmentTokenAmount(_sender, _assetToken);\n\n        uint256 exchangeRate = ILendIntegration(_integration).getExchangeRatePerToken(_assetToken);\n        // replace old aave\n        if (_integration == 0x9b468eb07082bE767895eA7A9019619c3Db3BC89) {\n            _integration = 0x72e27dA102a67767a7a3858D117159418f93617D;\n        }\n        // backwards compatability\n        uint256 healthFactor = 0;\n        try ILendIntegration(_integration).getHealthFactor(msg.sender) returns (uint256 factor) {\n            healthFactor = factor;\n        } catch {}\n        if (healthFactor > 0) {\n            numTokensToRedeem = healthFactor != type(uint256).max\n                ? numTokensToRedeem.preciseMul(healthFactor.sub(1e18).preciseDiv(healthFactor))\n                : numTokensToRedeem;\n        } else {\n            // Compound does not support health factor which makes things\n            // complicated. Do not create strategies which have the last\n            // operation CompoundLend and debt. Such strategies would fail to\n            // finalize due to _debt being zero and no health factor.\n            if (_debt > 0) {\n                uint256 debtInCollateral =\n                    SafeDecimalMath.normalizeAmountTokens(\n                        _borrowToken,\n                        _assetToken,\n                        _debt.preciseMul(_getPrice(_borrowToken, _assetToken))\n                    );\n                // Update amount so we can exit if there is debt\n                try ILendIntegration(_integration).getCollateralFactor(_assetToken) returns (uint256 collateralPctg) {\n                    numTokensToRedeem = numTokensToRedeem.sub(\n                        debtInCollateral.preciseDiv(collateralPctg).mul(105).div(100)\n                    ); // add a bit extra 5% just in case\n                } catch {\n                    numTokensToRedeem = numTokensToRedeem.sub(debtInCollateral.mul(140).div(100));\n                }\n            }\n        }\n        // Apply percentage\n        numTokensToRedeem = numTokensToRedeem.preciseMul(_percentage);\n        // sometimes dust is left\n        if (numTokensToRedeem > 1000) {\n            ILendIntegration(_integration).redeemTokens(\n                msg.sender,\n                _assetToken,\n                numTokensToRedeem,\n                exchangeRate.mul(numTokensToRedeem.sub(numTokensToRedeem.preciseMul(SLIPPAGE_ALLOWED.mul(2))))\n            );\n        }\n    }\n\n    function _tradeLiquidationsToAsset(address _borrowToken, address _assetToken) private {\n        // Change to weth if needed\n        if (_borrowToken == address(0)) {\n            if (address(msg.sender).balance > 0) {\n                IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n            }\n            _borrowToken = WETH;\n        }\n        // Trade borrow token (from liquidations)\n        if (IERC20(_borrowToken).balanceOf(msg.sender) > 1e6) {\n            IStrategy(msg.sender).trade(_borrowToken, IERC20(_borrowToken).balanceOf(msg.sender), _assetToken);\n        }\n    }\n\n    function _getRewardToken(address _integration) private view returns (address) {\n        try ILendIntegration(_integration).getRewardToken() returns (address rewardsToken) {\n            return rewardsToken;\n        } catch {\n            return address(0);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILendIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title ILendIntegration\n * @author Babylon Finance\n *\n * Interface for lending integrations such as Compound, Aave.\n */\ninterface ILendIntegration {\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external;\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external;\n\n    function getHealthFactor(address _strategy) external view returns (uint256);\n\n    function getRewardToken() external view returns (address);\n\n    function getCollateralFactor(address _assetToken) external view returns (uint256);\n\n    function getRewardsAccrued(address _strategy) external view returns (uint256);\n\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply) external view returns (uint256);\n\n    function getExchangeRatePerToken(address _assetToken) external view returns (uint256);\n\n    function getInvestmentToken(address _assetToken) external view returns (address);\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/operations/Operation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IOperation} from '../../interfaces/IOperation.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IHarvestUniv3Pool} from '../../interfaces/external/harvest/IHarvestUniv3Pool.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\n/**\n * @title LongStrategy\n * @author Babylon Finance\n *\n * Holds the data for a long strategy\n */\nabstract contract Operation is IOperation {\n    using SafeMath for uint256;\n    using BytesLib for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyStrategy() {\n        IStrategy strategy = IStrategy(msg.sender);\n        IGarden garden = strategy.garden();\n        require(IBabController(controller).isSystemContract(address(garden)), 'Only a garden can call this');\n        require(garden.strategyMapping(msg.sender), 'Sender must be a strategy');\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    uint256 internal constant MIN_TRADE_AMOUNT = 1000;\n    uint256 internal constant SLIPPAGE_ALLOWED = 1e16; // 1%\n    uint256 internal constant HUNDRED_PERCENT = 1e18; // 100%\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Address of the controller\n    address public controller;\n    // Name of the operation\n    string public name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) {\n        require(_controller != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ Virtual External Functions ============ */\n\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration,\n        uint256 _index\n    ) external view virtual override;\n\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function exitOperation(\n        address _asset,\n        uint256 _remaining,\n        uint8 _assetStatus,\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            uint8\n        );\n\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view virtual override returns (uint256, bool);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Returns the name of the operation\n     */\n    function getName() external view override returns (string memory) {\n        return name;\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle\n     */\n    function _getPrice(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        try\n            oracle.getPrice(_assetOne == address(0) ? WETH : _assetOne, _assetTwo == address(0) ? WETH : _assetTwo)\n        returns (uint256 price) {\n            return price;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns the price of the pair through the price oracle including univ2\n     */\n    function _getPriceNAV(address _assetOne, address _assetTwo) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        return\n            oracle.getPriceNAV(_assetOne == address(0) ? WETH : _assetOne, _assetTwo == address(0) ? WETH : _assetTwo);\n    }\n}\n"
    },
    "contracts/strategies/operations/DepositVaultOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {ConvexStakeIntegration} from '../../integrations/passive/ConvexStakeIntegration.sol';\nimport {IBooster} from '../../interfaces/external/convex/IBooster.sol';\nimport {IBasicRewards} from '../../interfaces/external/convex/IBasicRewards.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title DepositVaultOperation/Stake Operation\n * @author Babylon Finance\n *\n * Executes a stake (deposit vault) operation\n */\ncontract DepositVaultOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    IBooster private constant booster = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant LDO = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32; // lDO\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the deposit vault operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(BytesLib.decodeOpDataAddress(_data) != address(0), 'Incorrect vault address!');\n    }\n\n    /**\n     * Executes the deposit vault operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus         Status of the asset amount\n     * @param _data               OpData e.g. Address of the vault to enter\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        _integration = _patchConvexIntegration(_integration);\n        address yieldVault = BytesLib.decodeOpDataAddress(_data);\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        if (vaultAsset != _asset) {\n            // get ETH if it's needed\n            if (vaultAsset == address(0)) {\n                if (_asset != WETH) {\n                    IStrategy(msg.sender).trade(_asset, _capital, WETH);\n                }\n                IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            } else {\n                IStrategy(msg.sender).trade(_asset, _capital, vaultAsset);\n            }\n        }\n        uint256 minAmountExpected = _getMinAmountExpected(yieldVault, _capital, _integration);\n        IPassiveIntegration(_integration).enterInvestment(\n            msg.sender,\n            yieldVault,\n            minAmountExpected,\n            vaultAsset,\n            vaultAsset == address(0) ? address(msg.sender).balance : IERC20(vaultAsset).balanceOf(msg.sender)\n        );\n        vaultAsset = _getResultAsset(_integration, yieldVault);\n        return (vaultAsset, IERC20(vaultAsset).balanceOf(msg.sender), 0); // liquid\n    }\n\n    function _getMinAmountExpected(\n        address _yieldVault,\n        uint256 _capital,\n        address _integration\n    ) internal view returns (uint256) {\n        uint256 exactAmount = IPassiveIntegration(_integration).getExpectedShares(_yieldVault, _capital);\n        return exactAmount.sub(exactAmount.preciseMul(SLIPPAGE_ALLOWED));\n    }\n\n    /**\n     * Exits the deposit vault operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        _integration = _patchConvexIntegration(_integration);\n\n        // Patch stakewise\n        if (_integration == 0x8E4796f9E2612AFF12f9AE37a7091Dfd4253A5C1) {\n            _integration = 0x699118Bd7cda572A25dDda8A04E409719744683E;\n        }\n        address yieldVault = BytesLib.decodeOpDataAddress(_data);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(yieldVault);\n        uint256 amountVault =\n            IERC20(_getResultAsset(_integration, yieldVault)).balanceOf(msg.sender).preciseMul(_percentage);\n        if (amountVault > 0) {\n            uint256 minAmount =\n                amountVault.sub(amountVault.preciseMul(SLIPPAGE_ALLOWED)).preciseDiv(\n                    IPassiveIntegration(_integration).getPricePerShare(yieldVault).mul(\n                        10**PreciseUnitMath.decimals().sub(vaultAsset == address(0) ? 18 : ERC20(vaultAsset).decimals())\n                    )\n                );\n            IPassiveIntegration(_integration).exitInvestment(\n                msg.sender,\n                yieldVault,\n                amountVault,\n                vaultAsset,\n                minAmount\n            );\n        }\n        return (\n            vaultAsset,\n            vaultAsset != address(0) ? IERC20(vaultAsset).balanceOf(msg.sender) : address(msg.sender).balance,\n            0\n        );\n    }\n\n    /**\n     * Gets the NAV of the deposit vault op in the reserve asset\n     *\n     * @param _data               OpData e.g. Vault\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        _integration = _patchConvexIntegration(_integration);\n        address vault = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address vaultAsset = IPassiveIntegration(_integration).getInvestmentAsset(vault); // USDC, DAI, WETH\n        uint256 balance = IERC20(_getResultAsset(_integration, vault)).balanceOf(msg.sender);\n        // try to get price of an investment token from Oracle\n        // markets sometimes price assets differently than\n        // their underlying protocols, e.g., stETH/Lido\n        uint256 price = _getPrice(_garden.reserveAsset(), vaultAsset);\n        // If vault asset cannot be priced\n        require(price != 0, 'Vault asset cannot be priced');\n        uint256 pricePerShare = _getPrice(vault, vaultAsset);\n        // if failed to fetch price from Oracle get it from the underlying protocol\n        if (pricePerShare == 0) {\n            pricePerShare = IPassiveIntegration(_integration).getPricePerShare(vault);\n            // Normalization of pricePerShare\n            pricePerShare = pricePerShare.mul(\n                10**PreciseUnitMath.decimals().sub(vaultAsset == address(0) ? 18 : ERC20(vaultAsset).decimals())\n            );\n        }\n        uint256 NAV;\n        //Balance normalization\n        balance = SafeDecimalMath.normalizeAmountTokens(vaultAsset, _garden.reserveAsset(), balance);\n        NAV = pricePerShare.preciseMul(balance).preciseDiv(price);\n        // Get value of pending rewards\n        NAV = NAV.add(_getRewardsNAV(_integration, vault, _garden.reserveAsset()));\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    // Function to provide backward compatibility\n    function _getResultAsset(address _integration, address _yieldVault) private view returns (address) {\n        try IPassiveIntegration(_integration).getResultAsset(_yieldVault) returns (address _resultAsset) {\n            return _resultAsset;\n        } catch {\n            return _yieldVault;\n        }\n    }\n\n    function _getRewardsNAV(\n        address _integration,\n        address _yieldVault,\n        address _reserveAsset\n    ) private view returns (uint256) {\n        // Patching old convex stETH.\n        if (\n            address(msg.sender) == 0x3FeaD42999D537477CE39335aA7b4951e8e78233 ||\n            address(msg.sender) == 0x4f85dD417d19058cA81564f41572fb90D2F7e935\n        ) {\n            uint256 nav =\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x0A760466E1B4621579a82a39CB56Dda2F4E70f03).earned(msg.sender).mul(2)\n                );\n            nav = nav.add(\n                _getPrice(LDO, _reserveAsset).preciseMul(\n                    IBasicRewards(0x008aEa5036b819B4FEAEd10b2190FBb3954981E8).earned(msg.sender)\n                )\n            );\n            return nav;\n        }\n        // Patching 3Pool\n        if (address(msg.sender) == 0x9D78319EDA31663B487204F0CA88A046e742eE16) {\n            return\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x689440f2Ff927E1f24c72F1087E1FAF471eCe1c8).earned(msg.sender).mul(2)\n                );\n        }\n        // Patching IB\n        if (_yieldVault == 0x912EC00eaEbf3820a9B0AC7a5E15F381A1C91f22) {\n            return\n                _getPrice(CRV, _reserveAsset).preciseMul(\n                    IBasicRewards(0x3E03fFF82F77073cc590b656D42FceB12E4910A8).earned(msg.sender).mul(2)\n                );\n        }\n        try IPassiveIntegration(_integration).getRewards(msg.sender, _yieldVault) returns (\n            address rewardToken,\n            uint256 amount\n        ) {\n            if (rewardToken != address(0) && amount > 0) {\n                uint256 normalizedBalance = SafeDecimalMath.normalizeAmountTokens(rewardToken, _reserveAsset, amount);\n                uint256 price = _getPrice(rewardToken, _reserveAsset);\n                return\n                    price != 0\n                        ? price.preciseMul(normalizedBalance)\n                        : _getPrice(rewardToken, _yieldVault)\n                            .preciseMul(_getPrice(_yieldVault, _reserveAsset))\n                            .preciseMul(normalizedBalance);\n            }\n            return 0;\n        } catch {\n            return 0;\n        }\n    }\n\n    function _patchConvexIntegration(address _integration) private pure returns (address) {\n        if (\n            _integration == 0xFe06f1d501f417e6E87531aB7618c65D42735995 || // ConvexV1\n            _integration == 0xee919d9E48289e0A2900BA4b6aF9464459E428CD || // ConvexV2\n            _integration == 0x27725Cd03f82e9Af5811940da6cB27bc6A51CEDC || // ConvexV3\n            _integration == 0xDcCDf2D78239aBB788aD728D63ac45d90dEfe24A || // ConvexV4\n            _integration == 0x22619F6710C7D82D7b7FE31449D351B61373D63D || // ConvexV5\n            _integration == 0xccE114848A694152Ba45a8caff440Fcb12f73862 || // ConvexV6\n            _integration == 0x1831143e7AbB7b13F68c07Cfb14424bE5b8f0eb6 // ConvexV7\n        ) {\n            _integration = 0xF1392356e22F5b10A2F0eF2a29b7E78ffaBF6F5E; // ConvexV8\n        }\n        return _integration;\n    }\n}\n"
    },
    "contracts/interfaces/IPassiveIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IPassiveIntegration\n * @author Babylon Finance\n *\n * Interface for passive investments protocol integrations\n */\ninterface IPassiveIntegration {\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external;\n\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external;\n\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount) external view returns (uint256);\n\n    function getPricePerShare(address _investmentAddress) external view returns (uint256);\n\n    function getInvestmentAsset(address _investmentAddress) external view returns (address);\n\n    function getResultAsset(address _investmentAddress) external view returns (address);\n\n    function getRewards(address _strategy, address _investmentAddress) external view returns (address, uint256);\n}\n"
    },
    "contracts/integrations/passive/ConvexStakeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IBooster} from '../../interfaces/external/convex/IBooster.sol';\nimport {IBasicRewards} from '../../interfaces/external/convex/IBasicRewards.sol';\n\n/**\n * @title ConvexStakeIntegration\n * @author Babylon Finance Protocol\n *\n * Lido Integration\n */\ncontract ConvexStakeIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IBooster private constant booster = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B; // cvx\n\n    mapping(address => uint256) private cacheConvexTokenToPid;\n    uint256 private elementsCached = 0;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('convex_v2', _controller) {\n        _updateCache();\n    }\n\n    /**\n     * Gets the PID in convex of a convex lp token\n     * @param _asset                         Address of the convex lp token\n     * @return uint256                       Pid of the pool in convex\n     */\n    function getPid(address _asset) public view returns (bool, uint256) {\n        if (cacheConvexTokenToPid[_asset] > 0) {\n            return (true, cacheConvexTokenToPid[_asset] - 1);\n        }\n        uint256 poolLength = booster.poolLength();\n        if (elementsCached >= poolLength) {\n            return (false, 0);\n        }\n        for (uint256 i = elementsCached; i < poolLength; i++) {\n            (, address token, , , , ) = booster.poolInfo(i);\n            if (token == _asset) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _updateCache() public {\n        uint256 poolLength = booster.poolLength();\n        if (elementsCached >= poolLength) {\n            return;\n        }\n        for (uint256 i = elementsCached; i < poolLength; i++) {\n            (, address token, , , , ) = booster.poolInfo(i);\n            cacheConvexTokenToPid[token] = i + 1;\n        }\n        elementsCached = poolLength;\n    }\n\n    function _getSpender(address _asset, uint8 _op) internal view override returns (address) {\n        if (_op == 0) {\n            return address(booster);\n        }\n        // Reward pool\n        return _getRewardPool(_asset);\n    }\n\n    function _getExpectedShares(\n        address, /* _asset */\n        uint256 _amount\n    ) internal pure override returns (uint256) {\n        return _amount;\n    }\n\n    function _getPricePerShare(\n        address /* _asset */\n    ) internal pure override returns (uint256) {\n        return 1e18;\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address lptoken) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (lptoken, , , , , ) = booster.poolInfo(pid);\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Convex pool does not exist');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('deposit(uint256,uint256,bool)', pid, _maxAmountIn, true);\n        return (address(booster), 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Withdraw all and claim\n        bytes memory methodData = abi.encodeWithSignature('withdrawAndUnwrap(uint256,bool)', _investmentTokensIn, true);\n        // Go through the reward pool instead of the booster\n        return (_getRewardPool(_asset), 0, methodData);\n    }\n\n    function _getRewardPool(address _asset) private view returns (address reward) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (, , , reward, , ) = booster.poolInfo(pid);\n    }\n\n    function _getResultAsset(address _investment) internal view virtual override returns (address) {\n        return _getRewardPool(_investment);\n    }\n\n    function _getConvexLPToken(address _asset) private view returns (address token) {\n        (bool found, uint256 pid) = getPid(_asset);\n        require(found, 'Pid not found');\n        (, token, , , , ) = booster.poolInfo(pid);\n    }\n\n    function _getRewards(address _strategy, address _asset)\n        internal\n        view\n        override\n        returns (address token, uint256 balance)\n    {\n        IBasicRewards rewards = IBasicRewards(_getRewardPool(_asset));\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        uint256 totalAmount = rewards.earned(_strategy).mul(2); // * 2 accounts roughly for CVX\n        // add extra rewards and convert to reward token\n        uint256 extraRewardsLength = rewards.extraRewardsLength();\n        if (extraRewardsLength > 0) {\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                IBasicRewards extraRewards = IBasicRewards(rewards.extraRewards(i));\n                uint256 extraAmount = extraRewards.earned(_strategy);\n                if (extraAmount > 0) {\n                    try oracle.getPrice(rewards.extraRewards(i), extraRewards.rewardToken()) returns (\n                        uint256 priceExtraReward\n                    ) {\n                        totalAmount = totalAmount.add(priceExtraReward.preciseMul(extraAmount));\n                    } catch {}\n                }\n            }\n        }\n        return (rewards.rewardToken(), totalAmount);\n    }\n}\n"
    },
    "contracts/interfaces/external/convex/IBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface IBooster {\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            bool\n        );\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    function poolLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/convex/IBasicRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface IBasicRewards {\n    function getReward(address _account, bool _claimExtras) external;\n\n    function getReward(address _account) external;\n\n    function stakeFor(address, uint256) external;\n\n    function earned(address _account) external view returns (uint256);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function extraRewards(uint256 _index) external view returns (address);\n}\n"
    },
    "contracts/integrations/passive/PassiveIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IPassiveIntegration} from '../../interfaces/IPassiveIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title PassiveIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with passive investments like Yearn, Indexed\n */\nabstract contract PassiveIntegration is BaseIntegration, ReentrancyGuard, IPassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address investment; // Investment address\n        uint256 totalSupply; // Total Supply of the investment\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event InvestmentEntered(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        address tokenIn,\n        uint256 investmentTokensOut\n    );\n\n    event InvestmentExited(\n        address indexed garden,\n        address indexed strategy,\n        address indexed investment,\n        uint256 investmentTokensOut\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits tokens into an investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to join\n     * @param _investmentTokensOut        Min amount of investment tokens to receive\n     * @param _tokenIn                    Token address to deposit\n     * @param _maxAmountIn                Max amount of the token to deposit\n     */\n    function enterInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokensOut,\n        address _tokenIn,\n        uint256 _maxAmountIn\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_investmentAddress, _maxAmountIn, 0, _strategy);\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        // Approve spending of the token\n        if (_tokenIn != address(0)) {\n            investmentInfo.strategy.invokeApprove(_getSpender(_investmentAddress, 0), _tokenIn, _maxAmountIn);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getEnterInvestmentCalldata(_strategy, _investmentAddress, _investmentTokensOut, _tokenIn, _maxAmountIn);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit InvestmentEntered(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _investmentAddress,\n            _tokenIn,\n            _investmentTokensOut\n        );\n    }\n\n    /**\n     * Exits an outside passive investment\n     *\n     * @param _strategy                   Address of the strategy\n     * @param _investmentAddress          Address of the investment token to exit\n     * @param _investmentTokenIn          Quantity of investment tokens to return\n     * @param _tokenOut                   Token address to withdraw\n     * @param _minAmountOut               Min token quantities to receive from the investment\n     */\n    function exitInvestment(\n        address _strategy,\n        address _investmentAddress,\n        uint256 _investmentTokenIn,\n        address _tokenOut,\n        uint256 _minAmountOut\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        _validatePreExitInvestmentData(investmentInfo);\n\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_investmentAddress, _investmentTokenIn, 1, _strategy);\n\n        if (targetAddressP != address(0)) {\n            // Approve spending of the pre action token\n            address approvalAsset = _preActionNeedsApproval();\n            if (approvalAsset != address(0)) {\n                investmentInfo.strategy.invokeApprove(\n                    _getSpender(_investmentAddress, 1),\n                    approvalAsset,\n                    IERC20(approvalAsset).balanceOf(_strategy)\n                );\n            }\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n            _investmentAddress = _getAssetAfterExitPreAction(_investmentAddress);\n            // BUG: Does not respect _investmentTokenIn/percentage\n            _investmentTokenIn = IERC20(_investmentAddress).balanceOf(_strategy);\n        }\n\n        // Approve spending of the investment token\n        investmentInfo.strategy.invokeApprove(\n            _getSpender(_investmentAddress, 1),\n            _investmentAddress,\n            _investmentTokenIn\n        );\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getExitInvestmentCalldata(_strategy, _investmentAddress, _investmentTokenIn, _tokenOut, _minAmountOut);\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n\n        // Pre actions\n        (targetAddressP, callValueP, methodDataP) = _getPostActionCallData(_investmentAddress, _investmentTokenIn, 1);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit InvestmentExited(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            investmentInfo.investment,\n            _investmentTokenIn\n        );\n    }\n\n    /**\n     * Gets the amount of shares expected to get after depositing _ethAmount\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @param _ethAmount                         Amount of eth to invest\n     * @return uint256                           Amount of investment shares to receive\n     */\n    function getExpectedShares(address _investmentAddress, uint256 _ethAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_investmentAddress, _ethAmount);\n    }\n\n    /**\n     * Gets how much eth one unit of the investment is worth\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return uint256                           Returns the price in ETH of an investment share\n     */\n    function getPricePerShare(address _investmentAddress) external view override returns (uint256) {\n        return _getPricePerShare(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset needed to enter the investment\n     *\n     * @return address                           Returns the asset that this investment needs\n     */\n    function getInvestmentAsset(address _investmentAddress) external view override returns (address) {\n        return _getInvestmentAsset(_investmentAddress);\n    }\n\n    /**\n     * Gets the asset you obtained after entering the investment\n     *\n     * @return address                            Returns the asset that this investment obtains\n     */\n    function getResultAsset(address _investmentAddress) external view override returns (address) {\n        return _getResultAsset(_investmentAddress);\n    }\n\n    /**\n     * Gets the rewards and the token that they are denominated in\n     *\n     * @param _strategy                           Address of the strategy\n     * @param _investmentAddress                  Address of the investment\n     * @return address                            Returns the address with the token of extra rewards\n     * @return uint256                            Extra rewards received so far\n     */\n    function getRewards(address _strategy, address _investmentAddress)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        return _getRewards(_strategy, _investmentAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * @param _strategy                                 Address of the strategy\n     * @param _investment                               Address of the investment\n     * @param _investmentTokensInTransaction            Number of investment tokens involved\n     * hparam _tokenIn                                  Addresseses of the deposit token\n     * @param _limitDepositToken                        Limit quantity of the deposit/withdrawal token\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _investment,\n        uint256 _investmentTokensInTransaction,\n        address, /*_tokenIn*/\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.investment = _getResultAsset(_investment);\n        investmentInfo.totalSupply = IERC20(_investment).totalSupply();\n        investmentInfo.investmentTokensInGarden = IERC20(investmentInfo.investment).balanceOf(_strategy);\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal pure {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal pure {\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The strategy does not have enough investment tokens'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            (IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) >\n                _investmentInfo.investmentTokensInGarden),\n            'The strategy did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            IERC20(_investmentInfo.investment).balanceOf(address(_investmentInfo.strategy)) <=\n                (_investmentInfo.investmentTokensInGarden - _investmentInfo.investmentTokensInTransaction) + 100,\n            'The strategy did not return the investment tokens'\n        );\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                       Addresses of tokens to send to the investment\n     * hparam  _maxAmountIn                   Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _investmentAddress */\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 /* _maxAmountIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                 Type of Passive op\n     * hparam  _strategy                 Address of the strategy\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256, /* _borrowOp */\n        address /* _strategy */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _passiveOp                 Type of op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _passiveOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _investmentAddress              Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of token to receive\n     * hparam  _minAmountOut                   Amount of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /*_strategy */\n        address, /*_investmentAddress */\n        uint256, /*_investmentTokensIn */\n        address, /*_tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getExpectedShares(\n        address, //_investmentAddress\n        uint256 // _ethAmount\n    ) internal view virtual returns (uint256);\n\n    function _getPricePerShare(\n        address //_investmentAddress\n    ) internal view virtual returns (uint256);\n\n    function _getInvestmentAsset(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getSpender(\n        address, //_investmentAddress,\n        uint8 // op\n    ) internal view virtual returns (address);\n\n    function _getRewards(\n        address, // _strategy\n        address //_investmentAddress\n    ) internal view virtual returns (address, uint256) {\n        return (address(0), 0);\n    }\n\n    function _preActionNeedsApproval() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function _getAssetAfterExitPreAction(address _asset) internal view virtual returns (address) {\n        return _asset;\n    }\n\n    function _getResultAsset(address _investment) internal view virtual returns (address) {\n        return _investment;\n    }\n}\n"
    },
    "contracts/integrations/BaseIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\n\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IIntegration} from '../interfaces/IIntegration.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IBaseIntegration} from '../interfaces/IBaseIntegration.sol';\n\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\n\n/**\n * @title BaseIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses common Integration-related state and functions.\n */\nabstract contract BaseIntegration is IBaseIntegration {\n    using SafeCast for int256;\n    using LowGasSafeMath for uint256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySystemContract() {\n        require(controller.isSystemContract(msg.sender), 'Only system can call this');\n        _;\n    }\n\n    /* ============ Constants ============ */\n\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address internal constant ETH_ADD_CURVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address internal constant sETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\n    address internal constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n    address internal constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n\n    /* ============ State Variables ============ */\n\n    // Address of the controller\n    IBabController public immutable controller;\n\n    // Name of the integration\n    string public override name;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n\n    constructor(string memory _name, IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller must be defined');\n        name = _name;\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    function _getTokenOrETHBalance(address _strategy, address _token) internal view returns (uint256) {\n        if (_token == address(0) || _token == ETH_ADD_CURVE) {\n            return _strategy.balance;\n        }\n        return ERC20(_token).balanceOf(_strategy);\n    }\n\n    function _getDurationStrategy(address _strategy) internal view returns (uint256) {\n        IStrategy strategy = IStrategy(_strategy);\n        (, , , , uint256 executedAt, , ) = strategy.getStrategyState();\n        return block.timestamp.sub(executedAt);\n    }\n}\n"
    },
    "contracts/strategies/operations/BuyOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {Operation} from './Operation.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\n\n/**\n * @title BuyOperation\n * @author Babylon Finance\n *\n * Executes a buy operation\n */\ncontract BuyOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the buy operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden _garden,\n        address, /* _integration */\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        address asset = BytesLib.decodeOpDataAddress(_data);\n        require(asset != address(0), 'Incorrect asset address');\n        require(asset != _garden.reserveAsset(), 'Receive token must be different');\n    }\n\n    /**\n     * Executes the buy operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _data               OpData e.g. Address of the token to buy\n     * param _garden             Garden of the strategy\n     * param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address /* _integration */\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address token = BytesLib.decodeOpDataAddress(_data);\n        // Replace old AXS with new AXS\n        if (token == 0xF5D669627376EBd411E34b98F19C868c8ABA5ADA) {\n            token = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b;\n        }\n        IStrategy(msg.sender).trade(_asset, _capital, token);\n        return (token, ERC20(token).balanceOf(address(msg.sender)), 0); // liquid\n    }\n\n    /**\n     * Exits the buy operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address _asset,\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata, /*_data */\n        IGarden, /*_garden */\n        address /* _integration */\n    )\n        external\n        view\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        uint256 balance = ERC20(_asset).balanceOf(address(msg.sender)).preciseMul(_percentage);\n        return (_asset, balance, 0);\n    }\n\n    /**\n     * Gets the NAV of the buy op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset bought\n     * @param _garden             Garden the strategy belongs to\n     * param _integration         Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address /* _integration */\n    ) external view override returns (uint256, bool) {\n        address token = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        // Replace old AXS with new AXS\n        if (token == 0xF5D669627376EBd411E34b98F19C868c8ABA5ADA) {\n            token = 0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b;\n        }\n        uint256 price = _getPriceNAV(_garden.reserveAsset(), token);\n        uint256 NAV =\n            SafeDecimalMath\n                .normalizeAmountTokens(token, _garden.reserveAsset(), ERC20(token).balanceOf(msg.sender))\n                .preciseDiv(price);\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n}\n"
    },
    "contracts/integrations/trade/MasterSwapper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\nimport {ICurveAddressProvider} from '../../interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from '../../interfaces/external/curve/ICurveRegistry.sol';\nimport {ISynthetix} from '../../interfaces/external/synthetix/ISynthetix.sol';\nimport {ISnxProxy} from '../../interfaces/external/synthetix/ISnxProxy.sol';\nimport {ISnxSynth} from '../../interfaces/external/synthetix/ISnxSynth.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {String} from '../../lib/String.sol';\nimport {DeFiUtils} from '../../lib/DeFiUtils.sol';\nimport {AddressArrayUtils} from '../../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {ControllerLib} from '../../lib/ControllerLib.sol';\n\n/**\n * @title MasterSwapper\n * @author Babylon Finance Protocol\n *\n * Master class for integration with trading protocols\n */\n\n// - MasterSwapper\n//   * Uni V2 TWAP\n//   * Synthetix Contract. Exchange\n//     Support proxy or no proxy between synths\n//     - Only between pairs of synths. Great for bigger trades\n//\ncontract MasterSwapper is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for uint256;\n    using String for address;\n    using String for bytes;\n    using DeFiUtils for address[];\n    using ControllerLib for IBabController;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constants ============ */\n\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n    address private constant palStkAAVE = 0x24E79e946dEa5482212c38aaB2D0782F04cdB0E0;\n\n    /* ============ State Variables ============ */\n\n    ITradeIntegration public univ2;\n    ITradeIntegration public univ3;\n    ITradeIntegration public curve;\n    ITradeIntegration public synthetix;\n    ITradeIntegration public heartTradeIntegration;\n    ITradeIntegration public paladinTradeIntegration;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the master swapper\n     *\n     * @param _controller             Address of the controller\n     * @param _curve                  Address of curve trade integration\n     * @param _univ3                  Address of univ3 trade integration\n     * @param _synthetix              Address of synthetix trade integration\n     * @param _univ2                  Address of univ2 trade integration\n     * @param _hearttrade             Address of heart trade integration\n     * @param _paladinTrade           Address of paladin trade integration\n     */\n    constructor(\n        IBabController _controller,\n        ITradeIntegration _curve,\n        ITradeIntegration _univ3,\n        ITradeIntegration _synthetix,\n        ITradeIntegration _univ2,\n        ITradeIntegration _hearttrade,\n        ITradeIntegration _paladinTrade\n    ) BaseIntegration('master_swapper_v3', _controller) {\n        curve = _curve;\n        univ3 = _univ3;\n        synthetix = _synthetix;\n        univ2 = _univ2;\n        heartTradeIntegration = _hearttrade;\n        paladinTradeIntegration = _paladinTrade;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade choosing the appropriate protocol for it\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) public override nonReentrant {\n        _trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity);\n    }\n\n    /**\n     * @dev\n     *   Should be never called. Only implemented to satisfy ITradeIntegration\n     */\n    function trade(\n        address,\n        address,\n        uint256,\n        address,\n        uint256,\n        address\n    ) public override nonReentrant {\n        revert('no impl');\n    }\n\n    /**\n     * Function to update the internal mappings of the swapper\n     * @param _index                   Index to update\n     * @param _newAddress              New address\n     */\n    function updateTradeAddress(uint256 _index, address _newAddress) external {\n        controller.onlyGovernanceOrEmergency();\n        require(_newAddress != address(0), 'New address i not valid');\n        if (_index == 0) {\n            curve = ITradeIntegration(_newAddress);\n        }\n        if (_index == 1) {\n            univ3 = ITradeIntegration(_newAddress);\n        }\n        if (_index == 2) {\n            synthetix = ITradeIntegration(_newAddress);\n        }\n        if (_index == 3) {\n            univ2 = ITradeIntegration(_newAddress);\n        }\n        if (_index == 4) {\n            heartTradeIntegration = ITradeIntegration(_newAddress);\n        }\n        if (_index == 5) {\n            paladinTradeIntegration = ITradeIntegration(_newAddress);\n        }\n    }\n\n    function isTradeIntegration(address _integration) external view returns (bool) {\n        return\n            _integration == address(curve) ||\n            _integration == address(univ3) ||\n            _integration == address(synthetix) ||\n            _integration == address(univ2) ||\n            _integration == address(heartTradeIntegration) ||\n            _integration == address(paladinTradeIntegration);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) private {\n        if (_sendToken == _receiveToken) {\n            return;\n        }\n\n        string memory error;\n        bool success;\n\n        // Palstake AAVE\n        if (_receiveToken == palStkAAVE) {\n            uint256 aaveBalance;\n            if (_sendToken != AAVE) {\n                aaveBalance = ERC20(AAVE).balanceOf(_strategy);\n                ITradeIntegration(univ3).trade(_strategy, _sendToken, _sendQuantity, AAVE, 1);\n                aaveBalance = ERC20(AAVE).balanceOf(_strategy).sub(aaveBalance);\n            } else {\n                aaveBalance = _sendQuantity;\n            }\n            try\n                ITradeIntegration(paladinTradeIntegration).trade(\n                    _strategy,\n                    AAVE,\n                    aaveBalance,\n                    palStkAAVE,\n                    _minReceiveQuantity\n                )\n            {\n                return;\n            } catch Error(string memory _err) {\n                error = _formatError(error, _err, 'Paladin Trade Integration ', _sendToken, palStkAAVE);\n            }\n        }\n\n        // Heart Direct\n        if (controller.protocolWantedAssets(_sendToken)) {\n            uint256 wethBalance = ERC20(WETH).balanceOf(_strategy);\n            // If the heart wants it go through the heart and get WETH\n            try ITradeIntegration(heartTradeIntegration).trade(_strategy, _sendToken, _sendQuantity, WETH, 1) {\n                _sendToken = WETH;\n                _sendQuantity = ERC20(WETH).balanceOf(_strategy).sub(wethBalance);\n                if (_receiveToken == WETH) {\n                    return;\n                }\n            } catch Error(string memory _err) {\n                error = _formatError(error, _err, 'Heart Trade Integration ', _sendToken, WETH);\n            }\n        }\n\n        // Synthetix Direct\n        string memory err;\n        (err, success) = _swapSynt(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity);\n        if (success) {\n            return;\n        } else {\n            error = string(abi.encodePacked(error, err));\n        }\n\n        // Curve Direct\n        try ITradeIntegration(curve).trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity) {\n            return;\n        } catch Error(string memory _err) {\n            error = _formatError(error, _err, 'Curve ', _sendToken, _receiveToken);\n        }\n\n        // Go through UNIv3 first via WETH\n        try\n            ITradeIntegration(univ3).trade(\n                _strategy,\n                _sendToken,\n                _sendQuantity,\n                _receiveToken,\n                _minReceiveQuantity,\n                WETH\n            )\n        {\n            return;\n        } catch Error(string memory _err) {\n            error = _formatError(error, _err, 'UniV3 ', _sendToken, WETH, _receiveToken);\n        }\n\n        // Try Curve through reserve assets\n        (error, success) = _swapCurveUni(\n            _strategy,\n            _sendToken,\n            _sendQuantity,\n            _receiveToken,\n            _minReceiveQuantity,\n            error\n        );\n        if (success) {\n            return;\n        }\n\n        // Try Univ3 through DAI, USDC, WBTC, USDT\n        address[4] memory reserves = [DAI, USDC, WBTC, USDT];\n        for (uint256 i = 0; i < reserves.length; i++) {\n            try\n                ITradeIntegration(univ3).trade(\n                    _strategy,\n                    _sendToken,\n                    _sendQuantity,\n                    _receiveToken,\n                    _minReceiveQuantity,\n                    reserves[i]\n                )\n            {\n                return;\n            } catch Error(string memory _err) {\n                error = _formatError(error, _err, 'UniV3 ', _sendToken, reserves[i], _receiveToken);\n            }\n        }\n\n        if (_minReceiveQuantity > 1) {\n            // Try on UniV2 through WETH\n            try\n                ITradeIntegration(univ2).trade(\n                    _strategy,\n                    _sendToken,\n                    _sendQuantity,\n                    _receiveToken,\n                    _minReceiveQuantity,\n                    WETH\n                )\n            {\n                return;\n            } catch Error(string memory _err) {\n                error = _formatError(error, _err, 'UniV2 ', _sendToken, WETH, _receiveToken);\n            }\n        }\n\n        revert(string(abi.encodePacked('MasterSwapper:', error)));\n    }\n\n    function swapSwap(\n        ITradeIntegration _one,\n        ITradeIntegration _two,\n        address _reserve,\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external {\n        require(msg.sender == address(this), 'Nope');\n\n        uint256 reserveBalance = _getTokenOrETHBalance(_strategy, _reserve);\n        ITradeIntegration(_one).trade(_strategy, _sendToken, _sendQuantity, _reserve, 1);\n        ITradeIntegration(_two).trade(\n            _strategy,\n            _reserve,\n            _getTokenOrETHBalance(_strategy, _reserve).sub(reserveBalance),\n            _receiveToken,\n            _minReceiveQuantity\n        );\n    }\n\n    function _swapSynt(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) internal returns (string memory, bool) {\n        address _sendTokenSynth = _getSynth(_sendToken);\n        address _receiveTokenSynth = _getSynth(_receiveToken);\n        if (\n            (_sendTokenSynth != address(0) && _receiveTokenSynth != address(0)) ||\n            (_sendTokenSynth != address(0) && (_receiveToken == DAI || _receiveToken == USDC)) ||\n            (_receiveToken != address(0) && (_sendTokenSynth == DAI || _sendTokenSynth == USDC))\n        ) {\n            try\n                ITradeIntegration(synthetix).trade(\n                    _strategy,\n                    _sendToken,\n                    _sendQuantity,\n                    _receiveToken,\n                    _minReceiveQuantity\n                )\n            {\n                return ('', true);\n            } catch Error(string memory _err) {\n                return (_formatError('', _err, 'Synt ', _sendToken, _receiveToken), false);\n            }\n        }\n\n        // Abstract Synths out\n        if (_sendTokenSynth != address(0)) {\n            uint256 reserveBalance = _getTokenOrETHBalance(_strategy, DAI);\n            // Trade to DAI through sUSD\n            try ITradeIntegration(synthetix).trade(_strategy, _sendToken, _sendQuantity, DAI, 1) {\n                // Change DAI to receive token\n                _trade(\n                    _strategy,\n                    DAI,\n                    _getTokenOrETHBalance(_strategy, DAI).sub(reserveBalance),\n                    _receiveToken,\n                    _minReceiveQuantity\n                );\n                return ('', true);\n            } catch Error(string memory _err) {\n                return (_formatError('', _err, 'Synt ', _sendToken, DAI, _receiveToken), false);\n            }\n        }\n        // Trade to DAI and then do DAI to synh\n        if (_receiveTokenSynth != address(0)) {\n            uint256 reserveBalance = _getTokenOrETHBalance(_strategy, DAI);\n\n            if (_sendToken != DAI) {\n                _trade(_strategy, _sendToken, _sendQuantity, DAI, 1);\n                reserveBalance = _getTokenOrETHBalance(_strategy, DAI).sub(reserveBalance);\n            }\n            try ITradeIntegration(synthetix).trade(_strategy, DAI, reserveBalance, _receiveToken, _minReceiveQuantity) {\n                return ('', true);\n            } catch Error(string memory _err) {\n                revert(string(abi.encodePacked('Failed midway in out synth', _err, ';')));\n            }\n        }\n        return ('', false);\n    }\n\n    function _swapCurveUni(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity,\n        string memory error\n    ) internal returns (string memory, bool) {\n        address[4] memory reserves = [DAI, WETH, WBTC, AAVE];\n        for (uint256 i = 0; i < reserves.length; i++) {\n            if (_sendToken != reserves[i] && _receiveToken != reserves[i]) {\n                // Going through Curve but switching first to reserve\n                try\n                    this.swapSwap(\n                        univ3,\n                        curve,\n                        reserves[i],\n                        _strategy,\n                        _sendToken,\n                        _sendQuantity,\n                        _receiveToken,\n                        _minReceiveQuantity\n                    )\n                {\n                    return ('', true);\n                } catch Error(string memory _err) {\n                    error = _formatError(error, _err, 'Uni-Curve ', _sendToken, reserves[i], _receiveToken);\n                }\n                // Going through Curve to reserve asset and\n                // then receive asset via Uni to reserve asset\n                try\n                    this.swapSwap(\n                        curve,\n                        univ3,\n                        reserves[i],\n                        _strategy,\n                        _sendToken,\n                        _sendQuantity,\n                        _receiveToken,\n                        _minReceiveQuantity\n                    )\n                {\n                    return ('', true);\n                } catch Error(string memory _err) {\n                    error = _formatError(error, _err, 'Curve-Uni ', _sendToken, reserves[i], _receiveToken);\n                }\n            }\n        }\n        return (error, false);\n    }\n\n    function _swap(\n        ITradeIntegration _integration,\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity,\n        address _hop,\n        string memory error\n    ) internal returns (string memory, bool) {\n        try\n            ITradeIntegration(_integration).trade(\n                _strategy,\n                _sendToken,\n                _sendQuantity,\n                _receiveToken,\n                _minReceiveQuantity,\n                _hop\n            )\n        {\n            return ('', true);\n        } catch Error(string memory _err) {\n            return (_formatError(error, _err, _integration.name(), _sendToken, _hop, _receiveToken), false);\n        }\n    }\n\n    function _getSynth(address _token) private view returns (address) {\n        ISynthetix snx = ISynthetix(ISnxProxy(SNX).target());\n        try snx.synths(stringToBytes32(ERC20(_token).symbol())) returns (ISnxSynth _synth) {\n            return address(_synth);\n        } catch {\n            return address(0);\n        }\n    }\n\n    function _formatError(\n        string memory _blob,\n        string memory _err,\n        string memory _name,\n        address _send,\n        address _receive\n    ) internal view returns (string memory) {\n        return _formatError(_blob, _err, _name, _send, address(0), _receive);\n    }\n\n    function _formatError(\n        string memory _blob,\n        string memory _err,\n        string memory _name,\n        address _send,\n        address _hop,\n        address _receive\n    ) internal view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    _blob,\n                    _name,\n                    (\n                        _hop == address(0)\n                            ? AddressArrayUtils.toDynamic(_send, _receive)\n                            : AddressArrayUtils.toDynamic(_send, _hop, _receive)\n                    )\n                        .toTradePathString(),\n                    ':',\n                    _err,\n                    ';'\n                )\n            );\n    }\n\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 _id) external view returns (address);\n\n    function max_id() external view returns (uint256);\n\n    function get_id_info(uint256 _id)\n        external\n        view\n        returns (\n            address,\n            bool,\n            uint256,\n            uint256,\n            string calldata\n        );\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICurveRegistry {\n    function get_pool_from_lp_token(address _lpToken) external view returns (address);\n\n    function get_lp_token(address _pool) external view returns (address);\n\n    function find_pool_for_coins(\n        address _from,\n        address _to,\n        uint256 _i\n    ) external view returns (address);\n\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\n\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\n\n    function get_rates(address _pool) external view returns (uint256[8] memory);\n\n    function get_virtual_price_from_lp_token(address _lpToken) external view returns (uint256);\n\n    function is_meta(address _pool) external view returns (bool);\n\n    function pool_count() external view returns (uint256);\n\n    function pool_list(uint256 i) external view returns (address);\n\n    function get_pool_name(address _pool) external view returns (string memory);\n\n    function get_A(address _pool) external view returns (uint256);\n\n    function get_coins(address _pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address _pool) external view returns (address[8] memory);\n\n    function get_coin_indices(\n        address _pool,\n        address _from,\n        address _to\n    )\n        external\n        view\n        returns (\n            int128,\n            int128,\n            bool\n        );\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\nimport './ISnxSynth.sol';\n\ninterface ISynthetix {\n    // Views\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint256);\n\n    function collateral(address account) external view returns (uint256);\n\n    function collateralisationRatio(address issuer) external view returns (uint256);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint256);\n\n    function debtBalanceOfAndTotalDebt(address issuer, bytes32 currencyKey)\n        external\n        view\n        returns (uint256 debtBalance, uint256 totalSystemValue);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint256 maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint256 maxIssuable,\n            uint256 alreadyIssued,\n            uint256 totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISnxSynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint256);\n\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint256);\n\n    function transferableSynthetix(address account) external view returns (uint256);\n\n    // Mutative Functions\n    function burnSynths(uint256 amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint256 amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint256 amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint256 amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint256 reclaimed,\n            uint256 refunded,\n            uint256 numEntries\n        );\n\n    function liquidateDelinquentAccount(address account, uint256 susdAmount) external returns (bool);\n}\n"
    },
    "contracts/lib/String.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nlibrary String {\n    function toString(address account) internal pure returns (string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(bytes32 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = '0123456789abcdef';\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n}\n"
    },
    "contracts/lib/DeFiUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nlibrary DeFiUtils {\n    function toTradePathString(address[] memory _tokens) internal view returns (string memory) {\n        string memory result;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            result = string(abi.encodePacked(result, ERC20(_tokens[i]).symbol(), i != _tokens.length - 1 ? '->' : ''));\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/token/BABLToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {TimeLockedToken} from './TimeLockedToken.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title BABL Token\n * @dev The BABLToken contract is ERC20 using 18 decimals as a standard\n * Is Ownable to transfer ownership to Governor Alpha for Decentralized Governance\n * It overrides the mint and maximum supply to control the timing and maximum cap allowed along the time.\n */\n\ncontract BABLToken is TimeLockedToken {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    /* ============ Events ============ */\n\n    /// @notice An event that emitted when a new mint ocurr\n    event MintedNewTokens(address account, uint256 tokensminted);\n\n    /// @notice An event thats emitted when maxSupplyAllowed changes\n    event MaxSupplyChanged(uint256 previousMaxValue, uint256 newMaxValue);\n\n    /// @notice An event that emitted when maxSupplyAllowedAfter changes\n    event MaxSupplyAllowedAfterChanged(uint256 previousAllowedAfterValue, uint256 newAllowedAfterValue);\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /// @dev EIP-20 token name for this token\n    string private constant NAME = 'Babylon.Finance';\n\n    /// @dev EIP-20 token symbol for this token\n    string private constant SYMBOL = 'BABL';\n\n    /// @dev Maximum number of tokens in circulation of 1 million for the first 8 years (using 18 decimals as ERC20 standard)\n    uint256 public maxSupplyAllowed = 1_000_000e18; //\n\n    /// @notice The timestamp after which a change on maxSupplyAllowed may occur\n    uint256 public maxSupplyAllowedAfter;\n\n    /// @notice Cap on the percentage of maxSupplyAllowed that can be increased per year after maxSupplyAllowedAfter\n    uint8 public constant MAX_SUPPLY_CAP = 5;\n\n    /// @notice Cap on the percentage of totalSupply that can be minted at each mint after the initial 1 Million BABL\n    uint8 public constant MINT_CAP = 2;\n\n    /// @notice The timestamp after which minting may occur after FIRST_EPOCH_MINT (8 years)\n    uint256 public mintingAllowedAfter;\n\n    /// @notice The timestamp of BABL Token deployment\n    uint256 public BABLTokenDeploymentTimestamp;\n\n    /// @dev First Epoch Mint where no more than 1 Million BABL can be minted (>= 8 Years)\n    uint32 private constant FIRST_EPOCH_MINT = 365 days * 8;\n\n    /// @dev Minimum time between mints after\n    uint32 private constant MIN_TIME_BETWEEN_MINTS = 365 days;\n\n    /* ============ Functions ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Construct a new BABL token and gives ownership to sender\n     */\n    constructor(IBabController newController) TimeLockedToken(NAME, SYMBOL) {\n        // Timestamp of contract deployment\n        BABLTokenDeploymentTimestamp = block.timestamp;\n\n        // Set-up the minimum time of 8 years to wait until the maxSupplyAllowed can be changed (it will also include a max cap)\n        maxSupplyAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        //Starting with a maxSupplyAllowed of 1 million for the first 8 years\n        _mint(msg.sender, 1_000_000e18);\n\n        //Set-up the minimum time of 8 years for additional mints\n        mintingAllowedAfter = block.timestamp.add(FIRST_EPOCH_MINT);\n\n        // Set the Babylon Controller\n        controller = newController;\n    }\n\n    /* ============ External Functions ============ */\n\n    /* ===========  Token related Gov Functions ====== */\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows to mint new tokens\n     *\n     * @notice Mint new BABL tokens. Initial 1 Million BABL. After 8 years new BABL could be minted by governance decision\n     * @dev MINT_CAP The new maximum limit, limited by a 2% cap of totalSupply for each new mint and always limited by maxSupplyAllowed.\n     * mintingAllowedAfter Defines the next time allowed for a new mint\n     * @param _to The address of the destination account that will receive the new BABL tokens\n     * @param _amount The number of tokens to be minted\n     * @return Whether or not the mint succeeded\n     */\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        require(totalSupply().add(_amount) <= maxSupplyAllowed, 'BABLToken::mint: max supply exceeded');\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::mint: minting not allowed after the FIRST_EPOCH_MINT has passed >= 8 years'\n        );\n        require(_amount > 0, 'BABLToken::mint: mint should be higher than zero');\n        require(\n            block.timestamp >= mintingAllowedAfter,\n            'BABLToken::mint: minting not allowed yet because mintingAllowedAfter'\n        );\n        require(_to != address(0), 'BABLToken::mint: cannot transfer to the zero address');\n        require(_to != address(this), 'BABLToken::mint: cannot mint to the address of this contract');\n\n        // set-up the new time where a new (the next) mint can be allowed\n        mintingAllowedAfter = block.timestamp.add(MIN_TIME_BETWEEN_MINTS);\n\n        // mint the amount\n        uint96 amount = safe96(_amount, 'BABLToken::mint: amount exceeds 96 bits');\n\n        // After FIRST_EPOCH_MINT (8 years) a MINT_CAP applies\n        require(\n            amount <= totalSupply().mul(MINT_CAP).div(100),\n            'BABLToken::mint: exceeded mint cap of 2% of total supply'\n        );\n        _mint(_to, amount);\n\n        emit MintedNewTokens(_to, amount);\n\n        // move delegates to add voting power to the destination\n        _moveDelegates(address(0), delegates[_to], amount);\n\n        return true;\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to change maxSupplyAllowed\n     *\n     * @notice Set-up a greater maxSupplyAllowed value to allow more tokens to be minted\n     * @param newMaxSupply The new maximum limit, limited by a maximum of 5% cap per year\n     * @param newMaxSupplyAllowedAfter The new waiting period to change the maxSupplyAllowed limited for a minimum of 1 year\n     * @return Whether or not the changeMaxSupply succeeded\n     */\n    function changeMaxSupply(uint256 newMaxSupply, uint256 newMaxSupplyAllowedAfter) external onlyOwner returns (bool) {\n        require(\n            block.timestamp >= BABLTokenDeploymentTimestamp.add(FIRST_EPOCH_MINT),\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed until 8 years after deployment'\n        );\n        require(\n            block.timestamp >= maxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: a change on maxSupplyAllowed not allowed yet'\n        );\n\n        // update the amount\n        require(\n            newMaxSupply > maxSupplyAllowed,\n            'BABLToken::changeMaxSupply: changeMaxSupply should be higher than previous value'\n        );\n        uint256 limitedNewSupply = maxSupplyAllowed.add(maxSupplyAllowed.mul(MAX_SUPPLY_CAP).div(100));\n        require(newMaxSupply <= limitedNewSupply, 'BABLToken::changeMaxSupply: exceeded of allowed 5% cap');\n        emit MaxSupplyChanged(maxSupplyAllowed, newMaxSupply);\n        maxSupplyAllowed = safe96(newMaxSupply, 'BABLToken::changeMaxSupply: potential max amount exceeds 96 bits');\n\n        // update the new waiting time until a new change could be done >= 1 year since this change\n        uint256 futureTime = block.timestamp.add(365 days);\n        require(\n            newMaxSupplyAllowedAfter >= futureTime,\n            'BABLToken::changeMaxSupply: the newMaxSupplyAllowedAfter should be at least 1 year in the future'\n        );\n        emit MaxSupplyAllowedAfterChanged(maxSupplyAllowedAfter, newMaxSupplyAllowedAfter);\n        maxSupplyAllowedAfter = safe96(\n            newMaxSupplyAllowedAfter,\n            'BABLToken::changeMaxSupply: new newMaxSupplyAllowedAfter exceeds 96 bits'\n        );\n\n        return true;\n    }\n\n    /**\n     * PUBLIC FUNCTION. Get the value of maxSupplyAllowed\n     *\n     * @return Returns the value of maxSupplyAllowed at the time\n     */\n    function maxSupply() external view returns (uint96, uint256) {\n        uint96 safeMaxSupply =\n            safe96(maxSupplyAllowed, 'BABLToken::maxSupplyAllowed: maxSupplyAllowed exceeds 96 bits'); // Overflow check\n        return (safeMaxSupply, maxSupplyAllowedAfter);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\n\n/**\n * @title Treasury\n * @author Babylon Finance\n *\n * Contract that will receive the fees earned by the protocol.\n * Governance will be able to send funds from the treasury.\n */\ncontract Treasury is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    /* ============ Events ============ */\n\n    event TreasuryFundsSent(address _asset, uint256 _amount, address _to);\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /* ============ External Functions ============ */\n\n    /**\n     * GOVERNANCE FUNCTION: Send an asset amount to an address\n     *\n     * @param _asset            Address of the asset to send\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryFunds(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external onlyOwner nonReentrant {\n        require(_asset != address(0), 'Asset must exist');\n        require(_to != address(0), 'Target address must exist');\n\n        IERC20(_asset).safeTransfer(_to, _amount);\n\n        emit TreasuryFundsSent(_asset, _amount, _to);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Send an ETH amount to an address\n     *\n     * @param _amount           Amount to send of the asset\n     * @param _to               Address to send the assets to\n     */\n    function sendTreasuryETH(uint256 _amount, address payable _to) external onlyOwner nonReentrant {\n        require(_to != address(0), 'Target address must exist');\n        require(address(this).balance >= _amount, 'Not enough funds in treasury');\n\n        Address.sendValue(_to, _amount);\n\n        emit TreasuryFundsSent(address(0), _amount, _to);\n    }\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n"
    },
    "contracts/integrations/trade/TradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ITradeIntegration} from '../../interfaces/ITradeIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\n\n/**\n * @title TradeIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with trading protocols\n */\nabstract contract TradeIntegration is BaseIntegration, ReentrancyGuard, ITradeIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct TradeInfo {\n        IGarden garden; // Garden\n        IStrategy strategy; // Strategy\n        string exchangeName; // Which exchange to use\n        address sendToken; // Address of token being sold\n        address receiveToken; // Address of token being bought\n        uint256 gardenTotalSupply; // Total supply of Garden in Precise Units (10^18)\n        uint256 totalSendQuantity; // Total quantity of sold tokens\n        uint256 totalMinReceiveQuantity; // Total minimum quantity of token to receive back\n        uint256 preTradeSendTokenBalance; // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance; // Total initial balance of token being bought\n    }\n\n    /* ============ Events ============ */\n\n    /* ============ Constants ============ */\n\n    uint24 internal constant FEE_LOW = 500;\n    uint24 internal constant FEE_MEDIUM = 3000;\n    uint24 internal constant FEE_HIGH = 10000;\n    IUniswapV3Factory internal constant uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity,\n        address _hopToken\n    ) public override nonReentrant onlySystemContract {\n        _trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity, _hopToken);\n    }\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity\n    ) external override nonReentrant onlySystemContract {\n        _trade(_strategy, _sendToken, _sendQuantity, _receiveToken, _minReceiveQuantity, address(0));\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes a trade on a supported DEX.\n     * @dev\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _minReceiveQuantity   Min units of wanted token to be received from the exchange\n     */\n    function _trade(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        uint256 _minReceiveQuantity,\n        address _hopToken\n    ) internal {\n        TradeInfo memory tradeInfo =\n            _createTradeInfo(_strategy, name, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity);\n        _validatePreTradeData(tradeInfo, _sendQuantity);\n        // Pre actions\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_sendToken, _receiveToken, _sendQuantity);\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            if (_getPreApprovalSpender(targetAddressP) != address(0)) {\n                tradeInfo.strategy.invokeApprove(\n                    _getPreApprovalSpender(targetAddressP),\n                    tradeInfo.sendToken,\n                    tradeInfo.totalSendQuantity\n                );\n            }\n            tradeInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n        // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n        (address targetExchange, uint256 callValue, bytes memory methodData) =\n            _hopToken != address(0)\n                ? _getTradeCallData(\n                    _strategy,\n                    tradeInfo.sendToken,\n                    tradeInfo.totalSendQuantity,\n                    tradeInfo.receiveToken,\n                    _hopToken\n                )\n                : _getTradeCallData(\n                    _strategy,\n                    tradeInfo.sendToken,\n                    tradeInfo.totalSendQuantity,\n                    tradeInfo.receiveToken\n                );\n        if (targetExchange != address(0)) {\n            // Get spender address from exchange adapter and invoke approve for exact amount on sendToken\n            tradeInfo.strategy.invokeApprove(\n                _getSpender(targetExchange),\n                tradeInfo.sendToken,\n                tradeInfo.totalSendQuantity\n            );\n            tradeInfo.strategy.invokeFromIntegration(targetExchange, callValue, methodData);\n        }\n        // Post actions\n        uint256 receiveTokenAmount = _getTokenOrETHBalance(address(_strategy), _getPostActionToken(_receiveToken));\n        (targetAddressP, callValueP, methodDataP) = _getPostActionCallData(\n            _sendToken,\n            _receiveToken,\n            receiveTokenAmount\n        );\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            if (_getPostApprovalSpender(targetAddressP) != address(0)) {\n                tradeInfo.strategy.invokeApprove(\n                    _getPostApprovalSpender(targetAddressP),\n                    _getPostActionToken(_receiveToken),\n                    receiveTokenAmount\n                );\n            }\n            // Invoke protocol specific call\n            tradeInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        _validatePostTrade(tradeInfo);\n    }\n\n    /**\n     * Create and return TradeInfo struct\n     *\n     * @param _strategy             Address of the strategy\n     * @param _exchangeName         Human readable name of the exchange in the integrations registry\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _sendQuantity         Units of token in SetToken sent to the exchange\n     * @param _minReceiveQuantity   Min units of token in SetToken to be received from the exchange\n     *\n     * return TradeInfo             Struct containing data for trade\n     */\n    function _createTradeInfo(\n        address _strategy,\n        string memory _exchangeName,\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity,\n        uint256 _minReceiveQuantity\n    ) internal view returns (TradeInfo memory) {\n        TradeInfo memory tradeInfo;\n\n        tradeInfo.strategy = IStrategy(_strategy);\n        tradeInfo.garden = tradeInfo.strategy.garden();\n\n        tradeInfo.exchangeName = _exchangeName;\n\n        tradeInfo.sendToken = _sendToken;\n        tradeInfo.receiveToken = _receiveToken;\n\n        tradeInfo.gardenTotalSupply = ERC20(address(tradeInfo.strategy.garden())).totalSupply();\n\n        tradeInfo.totalSendQuantity = _sendQuantity;\n\n        tradeInfo.totalMinReceiveQuantity = _minReceiveQuantity;\n        tradeInfo.preTradeSendTokenBalance = ERC20(_sendToken).balanceOf(_strategy);\n        tradeInfo.preTradeReceiveTokenBalance = ERC20(_receiveToken).balanceOf(_strategy);\n        return tradeInfo;\n    }\n\n    /**\n     * Validate pre trade data. Check exchange is valid, token quantity is valid.\n     *\n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     * @param _sendQuantity         Amount of tokens sent\n     */\n    function _validatePreTradeData(TradeInfo memory _tradeInfo, uint256 _sendQuantity) internal view {\n        require(_tradeInfo.totalSendQuantity > 0, 'Token to sell must be nonzero');\n        require(\n            ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy)) >= _sendQuantity,\n            'Strategy needs to have enough liquid tokens'\n        );\n    }\n\n    /**\n     * Validate post trade data.\n     *\n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @return uint256                  Total quantity of receive token that was exchanged\n     */\n    function _validatePostTrade(TradeInfo memory _tradeInfo) internal view returns (uint256) {\n        uint256 exchangedQuantity =\n            ERC20(_tradeInfo.receiveToken).balanceOf(address(_tradeInfo.strategy)).sub(\n                _tradeInfo.preTradeReceiveTokenBalance\n            );\n        uint256 sendTokenBalance = ERC20(_tradeInfo.sendToken).balanceOf(address(_tradeInfo.strategy));\n        uint256 realUsed = _tradeInfo.preTradeSendTokenBalance.sub(sendTokenBalance);\n        // Uses at least 90% of the send token (disallow partial liquidity trades)\n        require(realUsed >= _tradeInfo.totalSendQuantity.preciseMul(9e17), 'Partial trade not allowed');\n        require(exchangedQuantity >= _tradeInfo.totalMinReceiveQuantity, 'Slippage greater than allowed');\n        return exchangedQuantity;\n    }\n\n    /**\n     * Return exchange calldata which is already generated from the exchange API\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the exchange\n     * hparam _sendQuantity         Units of reserve asset token sent to the exchange\n     * hparam _receiveToken         Address of the token that will be received from the exchange\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken */\n        uint256, /* _sendQuantity */\n        address, /* _receiveToken */\n        address /* _hopToken */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exchange calldata which is already generated from the exchange API\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the exchange\n     * hparam _sendQuantity         Units of reserve asset token sent to the exchange\n     * hparam _receiveToken         Address of the token that will be received from the exchange\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken */\n        uint256, /*_sendQuantity */\n        address /* _receiveToken */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * hparam  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _sendToken */\n        address, /* _receiveToken */\n        uint256 /* _sendQuantity */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * hparam  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address, /* _sendToken */\n        address, /* _receiveToken */\n        uint256 /* _sendQuantity */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @param _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal view virtual returns (address);\n\n    /**\n     * Returns the address to approve the pre action. This is the TokenTaker address\n     *\n     * hparam _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getPreApprovalSpender(\n        address /* _swapTarget */\n    ) internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * Returns the address to approve the post action. This is the TokenTaker address\n     *\n     * hparam _swapTarget      Address of the contracts that executes the swap\n     * @return address         Address of the contract to approve tokens to\n     */\n    function _getPostApprovalSpender(\n        address /* _swapTarget */\n    ) internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function _getPostActionToken(address _receiveToken) internal view virtual returns (address) {\n        return _receiveToken;\n    }\n}\n"
    },
    "contracts/integrations/trade/UniswapV3TradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {ISwapRouter} from '../../interfaces/external/uniswap-v3/ISwapRouter.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\n/**\n * @title UniswapV3TradeIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapV3 trade integration\n */\ncontract UniswapV3TradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    // Address of Uniswap V3 SwapRouter contract\n    address private constant swapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('univ3_3', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through UniswapV3.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _hopToken             Address of the routing token for multi-hop, i.e., sendToken->hopToken->receiveToken\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        address _hopToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        bytes memory path;\n        if (_hopToken == address(0) || _sendToken == _hopToken || _receiveToken == _hopToken) {\n            (, uint24 fee) = _getUniswapPoolWithHighestLiquidity(_sendToken, _receiveToken);\n            path = abi.encodePacked(_sendToken, fee, _receiveToken);\n        } else {\n            (, uint24 fee0) = _getUniswapPoolWithHighestLiquidity(_sendToken, _hopToken);\n            (, uint24 fee1) = _getUniswapPoolWithHighestLiquidity(_receiveToken, _hopToken);\n            path = abi.encodePacked(_sendToken, fee0, _hopToken, fee1, _receiveToken);\n        }\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(\n                path,\n                _strategy,\n                block.timestamp,\n                _sendQuantity,\n                1 // we check for amountOutMinimum in the post trade check\n            );\n\n        bytes memory callData = abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n        return (swapRouter, 0, callData);\n    }\n\n    /**\n     * Executes the trade through UniswapV3.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return _getTradeCallData(_strategy, _sendToken, _sendQuantity, _receiveToken, WETH);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _swapTarget */\n    ) internal pure override returns (address) {\n        return address(swapRouter);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getUniswapPoolWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (IUniswapV3Pool pool, uint24 fee)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(uniswapFactory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow > liquidityMedium && liquidityLow >= liquidityHigh) {\n            return (poolLow, FEE_LOW);\n        }\n        if (liquidityMedium > liquidityLow && liquidityMedium >= liquidityHigh) {\n            return (poolMedium, FEE_MEDIUM);\n        }\n        return (poolHigh, FEE_HIGH);\n    }\n\n    function _getReserveAsWeth(address _token, address _reserveAsset) internal pure returns (address) {\n        return _reserveAsset == _token ? WETH : _token;\n    }\n}\n"
    },
    "contracts/interfaces/external/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/strategies/operations/BorrowOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {Errors, _require} from '../../lib/BabylonErrors.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\n\nimport {Operation} from './Operation.sol';\n\n/**\n * @title BorrowOperation\n * @author Babylon Finance\n *\n * Executes a borrow operation\n */\ncontract BorrowOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n    using UniversalERC20 for IERC20;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the borrow operation\n     *\n     * param _data                   Operation data\n     * param _garden                 Garden\n     * param _integration            Integration used\n     * @param _index                  Index of this operation\n     */\n    function validateOperation(\n        bytes calldata, /* _data */\n        IGarden, /* _garden */\n        address, /* _integration */\n        uint256 _index\n    ) external view override onlyStrategy {\n        require(_index > 0, 'The operation cannot be the first. Needs to be a lend first');\n    }\n\n    /**\n     * Executes the borrow operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * @param _assetStatus        Status of the asset amount\n     * @param _data               Operation data (e.g. Token to borrow)\n     * param _garden              Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8 _assetStatus,\n        bytes memory _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        _integration = _patchIntegration(_integration);\n        (address borrowToken, uint256 rate) = BytesLib.decodeOpDataAddressAndUint(_data);\n        require(_capital > 0 && _assetStatus == 1 && _asset != borrowToken, 'There is no collateral locked');\n\n        uint256 normalizedAmount = _getBorrowAmount(_asset, borrowToken, _capital, _integration, rate);\n\n        IBorrowIntegration(_integration).borrow(msg.sender, borrowToken, normalizedAmount);\n        // if borrowToken is ETH wrap it to WETH\n        if (borrowToken == address(0)) {\n            IStrategy(msg.sender).handleWeth(true, normalizedAmount);\n            borrowToken = WETH;\n        }\n        return (borrowToken, normalizedAmount, 0); // borrowings are liquid\n    }\n\n    function _getBorrowAmount(\n        address _asset,\n        address _borrowToken,\n        uint256 _capital,\n        address _integration,\n        uint256 _rate\n    ) internal view returns (uint256) {\n        // Because we are not using AAVE/Compound price oracles there is a price\n        // difference between our price and AAVE/Compound price which may result\n        // in borrow amount being to high. That is why we decrease the price by\n        // 0.1%\n        uint256 price = _getPrice(_asset, _borrowToken).mul(999).div(1000);\n        // % of the total collateral value in the borrow token\n        // Use the % max we can borrow (maxCollateral)\n        // Use the % of the collateral asset\n        uint256 amountToBorrow =\n            _capital\n                .preciseMul(price)\n                .preciseMul(_rate != 0 ? _rate : IBorrowIntegration(_integration).maxCollateralFactor())\n                .preciseMul(IBorrowIntegration(_integration).getCollateralFactor(_asset));\n        return SafeDecimalMath.normalizeAmountTokens(_asset, _borrowToken, amountToBorrow);\n    }\n\n    /**\n     * Exits the borrow operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address _asset,\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        _integration = _patchIntegration(_integration);\n        (address assetToken, ) = BytesLib.decodeOpDataAddressAndUint(_data);\n        require(_percentage <= HUNDRED_PERCENT, 'Unwind Percentage <= 100%');\n        uint256 debtAmount = IBorrowIntegration(_integration).getBorrowBalance(msg.sender, assetToken);\n        // if debt token is different than the token received\n        _asset = _asset == address(0) ? WETH : _asset;\n        _tradeToDebtToken(_asset, assetToken, debtAmount);\n\n        uint256 debtTokenBalance = IERC20(assetToken).universalBalanceOf(address(msg.sender));\n\n        uint256 amountToRepay =\n            debtAmount > debtTokenBalance\n                ? debtTokenBalance.preciseMul(_percentage)\n                : debtAmount.preciseMul(_percentage);\n        // if 0 that mean all the debt is repaid already\n        if (amountToRepay > 0) {\n            IBorrowIntegration(_integration).repay(\n                msg.sender,\n                assetToken,\n                amountToRepay // We repay the percentage of all that we can\n            );\n        }\n\n        return (assetToken, IBorrowIntegration(_integration).getBorrowBalance(msg.sender, assetToken), 2);\n    }\n\n    /**\n     * Gets the NAV of the lend op in the reserve asset\n     *\n     * @param _data               OpData e.g. Asset borrowed\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override onlyStrategy returns (uint256, bool) {\n        _integration = _patchIntegration(_integration);\n        address borrowToken = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        uint256 tokensOwed = IBorrowIntegration(_integration).getBorrowBalance(msg.sender, borrowToken);\n        uint256 price = _getPrice(_garden.reserveAsset(), borrowToken);\n        // if there are liquidations or it is the last op (borrowings not used)\n        uint256 borrowTokenBalance = IERC20(borrowToken == address(0) ? WETH : borrowToken).balanceOf(msg.sender);\n        if (borrowTokenBalance > 0) {\n            tokensOwed = tokensOwed >= borrowTokenBalance ? tokensOwed.sub(borrowTokenBalance) : 0;\n        }\n        uint256 NAV =\n            tokensOwed == 0\n                ? 0\n                : SafeDecimalMath.normalizeAmountTokens(borrowToken, _garden.reserveAsset(), tokensOwed).preciseDiv(\n                    price\n                );\n\n        return (NAV, false);\n    }\n\n    function _tradeToDebtToken(\n        address _asset,\n        address _assetToken,\n        uint256 _debtAmount\n    ) private {\n        uint256 debtTokenBalance = IERC20(_assetToken).universalBalanceOf(address(msg.sender));\n        if (_asset != _assetToken && debtTokenBalance < _debtAmount) {\n            if (_asset == address(0)) {\n                IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n                _asset = WETH;\n            }\n            if (_assetToken != address(0)) {\n                IStrategy(msg.sender).trade(_asset, IERC20(_asset).balanceOf(msg.sender), _assetToken);\n            } else {\n                if (_asset != WETH) {\n                    IStrategy(msg.sender).trade(_asset, IERC20(_asset).balanceOf(msg.sender), WETH);\n                }\n                IStrategy(msg.sender).handleWeth(false, IERC20(WETH).balanceOf(msg.sender));\n            }\n        }\n    }\n\n    function _patchIntegration(address _integration) private pure returns (address) {\n        if (\n            _integration == 0x48CcAE7adDf90eeaCe202b298D30F4Eb26Bdc03B //AAVE Borrow\n        ) {\n            _integration = 0x048d4c45C5963320f7E1893138Aed34084948242; // AAVE Borrow\n        }\n        return _integration;\n    }\n}\n"
    },
    "contracts/interfaces/IBorrowIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IBorrowIntegration\n * @author Babylon Finance\n *\n * Interface for borrow integrations\n */\ninterface IBorrowIntegration {\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 borrowAmount\n    ) external;\n\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external;\n\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor) external;\n\n    function maxCollateralFactor() external view returns (uint256);\n\n    function getCollateralFactor(address _asset) external view returns (uint256);\n\n    function getBorrowBalance(address _strategy, address _asset) external view returns (uint256);\n\n    function getCollateralBalance(address _strategy, address asset) external view returns (uint256);\n\n    function getRemainingLiquidity(address _strategy) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/lend/CompoundLendIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\nimport {ControllerLib} from '../../lib/ControllerLib.sol';\n\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title CompoundLendIntegration\n * @author Babylon Finance Protocol\n *\n * Compound lend integration.\n */\ncontract CompoundLendIntegration is LendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using UniversalERC20 for IERC20;\n    using ControllerLib for IBabController;\n\n    /* ============ Constant ============ */\n\n    IComptroller internal immutable comptroller;\n\n    address private constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     * @param _comptroller            Address of the compound comptroller\n     */\n    constructor(\n        string memory _name,\n        IBabController _controller,\n        IComptroller _comptroller\n    ) LendIntegration(_name, _controller) {\n        comptroller = _comptroller;\n        _overrideMappings(_comptroller);\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function overrideMappings() external {\n        controller.onlyGovernanceOrEmergency();\n        _overrideMappings(comptroller);\n    }\n\n    // Governance function\n    function updateCTokenMapping(address _assetAddress, address _cTokenAddress) external {\n        controller.onlyGovernanceOrEmergency();\n        assetToCToken[_assetAddress] = _cTokenAddress;\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        ICToken ctoken = ICToken(_getInvestmentToken(_assetToken));\n        return ctoken.balanceOf(_address).mul(ctoken.exchangeRateStored()).div(10**18);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getHealthFactor(\n        address /* _strategy */\n    ) internal view override returns (uint256) {\n        // Compound architecture makes it almost impossible to implement this\n        // method\n        return 0;\n    }\n\n    function _overrideMappings(IComptroller _comptroller) private {\n        address[] memory markets = _comptroller.getAllMarkets();\n        for (uint256 i = 0; i < markets.length; i++) {\n            address underlying = address(0);\n            // Skip cEther\n            if (markets[i] != 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) {\n                underlying = ICToken(markets[i]).underlying();\n            }\n            assetToCToken[underlying] = markets[i];\n        }\n    }\n\n    function _getRewardToken() internal view virtual override returns (address) {\n        return COMP;\n    }\n\n    function _getCollateralFactor(address _assetToken) internal view virtual override returns (uint256) {\n        ICToken ctoken = ICToken(_getInvestmentToken(_assetToken));\n        (, uint256 collateral) = IComptroller(comptroller).markets(address(ctoken));\n        return collateral;\n    }\n\n    function _getRewardsAccrued(address _strategy) internal view virtual override returns (uint256) {\n        return IComptroller(comptroller).compAccrued(_strategy);\n    }\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        return assetToCToken[_assetToken] != address(0);\n    }\n\n    function _getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        uint256 oneCTokenInUderlying = _getExchangeRatePerToken(_assetToken);\n        return oneCTokenInUderlying.mul(_numTokensToSupply).div(10**18);\n    }\n\n    // TODO: Test this\n    function _getExchangeRatePerToken(address _assetToken) internal view override returns (uint256) {\n        address cToken = assetToCToken[_assetToken];\n        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateStored();\n        uint256 assetDecimals = IERC20(_assetToken).universalDecimals();\n        // cTokens always have 8 decimals.\n        if (assetDecimals < 8) {\n            uint256 mantissa = 8 - assetDecimals;\n            return exchangeRateCurrent.mul(10**mantissa);\n        } else {\n            uint256 mantissa = assetDecimals - 8;\n            return exchangeRateCurrent.div(10**mantissa);\n        }\n    }\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToReedem\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('redeemUnderlying(uint256)', _numTokensToReedem);\n\n        return (assetToCToken[_assetToken], 0, methodData);\n    }\n\n    function _claimRewardsCallData(address _strategy)\n        internal\n        view\n        virtual\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('claimComp(address)', _strategy);\n\n        return (address(comptroller), 0, methodData);\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (_assetToken == address(0)) {\n            methodData = abi.encodeWithSignature('mint()');\n        } else {\n            methodData = abi.encodeWithSignature('mint(uint256)', _numTokensToSupply);\n        }\n        // If it is ETH, send the value\n        return (assetToCToken[_assetToken], _assetToken == address(0) ? _numTokensToSupply : 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (address(comptroller), 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getSpender(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        return assetToCToken[_assetToken];\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IComptroller {\n    /**\n     * @notice Marker function used for light validation when updating the comptroller of a market\n     * @dev Implementations should simply return true.\n     * @return true\n     */\n    function isComptroller() external view returns (bool);\n\n    function markets(address _cToken) external view returns (bool, uint256);\n\n    function getRewardsDistributors() external view returns (address[] memory);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    function getAllMarkets() external view returns (address[] memory);\n\n    function _borrowGuardianPaused() external view returns (bool);\n\n    function borrowGuardianPaused(address _asset) external view returns (bool);\n\n    function borrowCaps(address _asset) external view returns (uint256);\n\n    function compAccrued(address holder) external view returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getAssetsIn(address account) external view returns (address[] memory);\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/integrations/lend/LendIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ILendIntegration} from '../../interfaces/ILendIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title LendIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with lending protocols\n */\nabstract contract LendIntegration is BaseIntegration, ReentrancyGuard, ILendIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Struct ============ */\n    struct InvestmentInfo {\n        IStrategy strategy; // Strategy address\n        IGarden garden; // Garden address\n        address assetToken;\n        address investment; // Investment address\n        uint256 investmentTokensInTransaction; // Investment tokens affected by this transaction\n        uint256 investmentTokensInGarden; // Investment tokens garden balance\n        uint256 underlyingTokensInGarden; // Underlying tokens garden balance\n        uint256 limitDepositTokenQuantity; // Limit deposit/withdrawal token amount\n    }\n\n    /* ============ Events ============ */\n\n    event TokensSupplied(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToSupply\n    );\n\n    event TokensRedeemed(\n        address indexed garden,\n        address indexed strategy,\n        address indexed assetToken,\n        uint256 numTokensToRedeem,\n        uint256 protocolFee\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n    function getInvestmentToken(address _assetToken) external view override returns (address) {\n        return _getInvestmentToken(_assetToken);\n    }\n\n    function getCollateralFactor(address _assetToken) external view override returns (uint256) {\n        return _getCollateralFactor(_assetToken);\n    }\n\n    function getHealthFactor(address _strategy) external view override returns (uint256) {\n        return _getHealthFactor(_strategy);\n    }\n\n    /**\n     * Returns the reward token\n     *\n     * @return address       Address of the reward token\n     */\n    function getRewardToken() external view override returns (address) {\n        return _getRewardToken();\n    }\n\n    /**\n     * Returns the number of reward tokens accrued\n     *\n     * @param _strategy      Address of the strategy\n     * @return address       Address of the reward token\n     */\n    function getRewardsAccrued(address _strategy) external view override returns (uint256) {\n        return _getRewardsAccrued(_strategy);\n    }\n\n    /**\n     * Checks whether an investment address is valid\n     *\n     * @param _investmentAddress                 Investment address to check\n     * @return bool                              True if the address is a investment\n     */\n    function isInvestment(address _investmentAddress) external view returns (bool) {\n        return _isInvestment(_investmentAddress);\n    }\n\n    function getInvestmentTokenAmount(address _address, address _assetToken)\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    function supplyTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToSupply,\n                _minAmountExpected\n            );\n\n        _validatePreJoinInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToSupply, 0);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        // not needed for ETH\n        if (_assetToken != address(0)) {\n            investmentInfo.strategy.invokeApprove(_getSpender(_assetToken), _assetToken, _numTokensToSupply);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getSupplyCalldata(_strategy, _assetToken, _numTokensToSupply);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n        _validatePostEnterInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToSupply\n        );\n    }\n\n    function redeemTokens(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToRedeem,\n        uint256 _minAmountExpected\n    ) external override nonReentrant onlySystemContract {\n        InvestmentInfo memory investmentInfo =\n            _createInvestmentInfo(\n                _strategy,\n                _assetToken,\n                _getInvestmentToken(_assetToken),\n                _numTokensToRedeem,\n                _minAmountExpected\n            );\n\n        _validatePreExitInvestmentData(investmentInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(_assetToken, _numTokensToRedeem, 1);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetInvestment, uint256 callValue, bytes memory methodData) =\n            _getRedeemCalldata(_strategy, _assetToken, _numTokensToRedeem);\n\n        investmentInfo.strategy.invokeFromIntegration(targetInvestment, callValue, methodData);\n\n        // Claim rewards\n        (address targetAddressR, uint256 callValueR, bytes memory methodDataR) = _claimRewardsCallData(_strategy);\n        if (targetAddressR != address(0)) {\n            // Invoke protocol specific call\n            investmentInfo.strategy.invokeFromIntegration(targetAddressR, callValueR, methodDataR);\n        }\n\n        _validatePostExitInvestmentData(investmentInfo);\n\n        emit TokensSupplied(\n            address(investmentInfo.garden),\n            address(investmentInfo.strategy),\n            _assetToken,\n            _numTokensToRedeem\n        );\n    }\n\n    function getExchangeRatePerToken(address _assetToken) external view override returns (uint256) {\n        return _getExchangeRatePerToken(_assetToken);\n    }\n\n    /**\n     * Gets the amount of cTokens expected to get after depositing ERC20 asset.\n     *\n     * @param _numTokensToSupply                 Amount of ERC20 tokens to supply\n     * @return uint256                           Amount of supply tokens to receive\n     */\n    function getExpectedShares(address _assetToken, uint256 _numTokensToSupply)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getExpectedShares(_assetToken, _numTokensToSupply);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Validate pre investment join data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreJoinInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Min investment tokens to receive must be greater than 0'\n        );\n    }\n\n    /**\n     * Validate post enter investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostEnterInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(\n            getInvestmentTokenAmount(address(_investmentInfo.strategy), _investmentInfo.assetToken) >\n                _investmentInfo.investmentTokensInGarden,\n            'The garden did not receive the investment tokens'\n        );\n    }\n\n    /**\n     * Validate post exit investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePostExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        uint256 balance =\n            _investmentInfo.assetToken == address(0)\n                ? address(_investmentInfo.strategy).balance\n                : IERC20(_investmentInfo.assetToken).balanceOf(address(_investmentInfo.strategy));\n        require(balance > _investmentInfo.underlyingTokensInGarden, 'The garden did not return the investment tokens');\n    }\n\n    /**\n     * Validate pre investment data. Check investment is valid, token quantity is valid.\n     *\n     * @param _investmentInfo               Struct containing investment information used in internal functions\n     */\n    function _validatePreExitInvestmentData(InvestmentInfo memory _investmentInfo) internal view {\n        require(_isInvestment(_investmentInfo.assetToken), 'The investment address is not valid');\n        require(\n            _investmentInfo.investmentTokensInTransaction > 0,\n            'Investment tokens to exchange must be greater than 0'\n        );\n        require(\n            _investmentInfo.investmentTokensInGarden >= _investmentInfo.investmentTokensInTransaction,\n            'The garden does not have enough investment tokens'\n        );\n    }\n\n    function _isInvestment(\n        address //_investmentAddress\n    ) internal view virtual returns (bool);\n\n    /**\n     * Create and return InvestmentInfo struct\n     *\n     * return InvestmentInfo                            Struct containing data for the investment\n     */\n    function _createInvestmentInfo(\n        address _strategy,\n        address _assetToken,\n        address _investmentToken,\n        uint256 _investmentTokensInTransaction,\n        uint256 _limitDepositToken\n    ) internal view returns (InvestmentInfo memory) {\n        InvestmentInfo memory investmentInfo;\n        investmentInfo.strategy = IStrategy(_strategy);\n        investmentInfo.garden = IGarden(investmentInfo.strategy.garden());\n        investmentInfo.assetToken = _assetToken;\n        investmentInfo.investment = _investmentToken;\n        investmentInfo.investmentTokensInGarden = getInvestmentTokenAmount(_strategy, _assetToken);\n        investmentInfo.underlyingTokensInGarden = _assetToken == address(0)\n            ? address(_strategy).balance\n            : IERC20(_assetToken).balanceOf(address(_strategy));\n        investmentInfo.investmentTokensInTransaction = _investmentTokensInTransaction;\n        investmentInfo.limitDepositTokenQuantity = _limitDepositToken;\n\n        return investmentInfo;\n    }\n\n    function _getExpectedShares(address, uint256) internal view virtual returns (uint256);\n\n    function _getExchangeRatePerToken(address) internal view virtual returns (uint256);\n\n    function _getRedeemCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * hparam  _strategy                Address of the strat\n     * hparam  _assetToken              Address of the token\n     * hparam  _numTokensToSupply       Number of tokens\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address, /* _strategy */\n        address, /* _assetToken */\n        uint256 /* _numTokensToSupply */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return claim rewards action call data\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _claimRewardsCallData(\n        address /*_strategy */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _getSpender(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n\n    function _getHealthFactor(address _strategy) internal view virtual returns (uint256);\n\n    function _getRewardToken() internal view virtual returns (address);\n\n    function _getCollateralFactor(address _asset) internal view virtual returns (uint256);\n\n    function _getRewardsAccrued(address _strategy) internal view virtual returns (uint256);\n\n    function _getInvestmentToken(\n        address //_investmentAddress\n    ) internal view virtual returns (address);\n}\n"
    },
    "contracts/integrations/lend/FuseLendIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.7.0 <0.9.0;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {ILensPool} from '../../interfaces/external/rari/ILensPool.sol';\nimport {IRewardsDistributor} from '../../interfaces/external/compound/IRewardsDistributor.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {CompoundLendIntegration} from './CompoundLendIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title FuseLendIntegration\n * @author Babylon Finance\n *\n * Class that houses Fuse lending logic.\n */\ncontract FuseLendIntegration is CompoundLendIntegration {\n    using PreciseUnitMath for uint256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    address private constant FUSE_LENS_ADDRESS = 0xc76190E04012f26A364228Cfc41690429C44165d;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _comptroller            Address of the fuse pool comptroller\n     */\n    constructor(IBabController _controller, IComptroller _comptroller)\n        CompoundLendIntegration('fuselend', _controller, _comptroller)\n    {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getRewardToken() internal view override returns (address) {\n        address[] memory rewards = IComptroller(comptroller).getRewardsDistributors();\n        if (rewards.length > 0) {\n            return IRewardsDistributor(rewards[0]).rewardToken();\n        }\n        return address(0);\n    }\n\n    function _getRewardsAccrued(address _strategy) internal view override returns (uint256) {\n        address[] memory distributors = IComptroller(comptroller).getRewardsDistributors();\n        uint256 totalRewards;\n        if (distributors.length > 0) {\n            address[] memory markets = IComptroller(comptroller).getAllMarkets();\n            uint256 nblocks = _getDurationStrategy(_strategy).div(14); // assuming 14 secs per block\n            for (uint256 i = 0; i < markets.length; i++) {\n                uint256 balanceCToken = IERC20(markets[i]).balanceOf(_strategy);\n                uint256 rewardPerBlock;\n                uint256 divisor;\n                // If there is balance, strategy supplied\n                if (balanceCToken > 0) {\n                    (\n                        ,\n                        // err\n                        uint256 cTokenBalance, // borrow balance\n                        ,\n                        uint256 exchangeRateMantissa\n                    ) = ICToken(markets[i]).getAccountSnapshot(_strategy);\n                    balanceCToken = cTokenBalance.preciseMul(exchangeRateMantissa);\n                    rewardPerBlock = IRewardsDistributor(distributors[0]).compSupplySpeeds(markets[i]);\n                    divisor = ICToken(markets[i]).getCash();\n                } else {\n                    // Check if borrow enabled\n                    if (ICToken(markets[i]).borrowRatePerBlock() > 0) {\n                        (, , balanceCToken, ) = ICToken(markets[i]).getAccountSnapshot(_strategy);\n                        // If there is borrow balance, strategy borrowed from this market\n                        if (balanceCToken > 0) {\n                            rewardPerBlock = IRewardsDistributor(distributors[0]).compBorrowSpeeds(markets[i]);\n                            divisor = ICToken(markets[i]).totalBorrows();\n                        }\n                    }\n                }\n                if (balanceCToken > 0 && rewardPerBlock > 0 && divisor > 0) {\n                    totalRewards = totalRewards.add(\n                        rewardPerBlock.preciseMul(balanceCToken.preciseDiv(divisor)).mul(nblocks)\n                    );\n                }\n            }\n        }\n        return totalRewards;\n    }\n\n    function _claimRewardsCallData(address _strategy)\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address[] memory rewards = IComptroller(comptroller).getRewardsDistributors();\n        if (rewards.length > 0) {\n            return (rewards[0], 0, abi.encodeWithSignature('claimRewards(address)', _strategy));\n        }\n        return (address(0), 0, bytes(''));\n    }\n}\n"
    },
    "contracts/interfaces/external/rari/ILensPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\npragma abicoder v2;\n\ninterface ILensPool {\n    function getUnclaimedRewardsByDistributors(address _account, address[] memory _rds)\n        external\n        view\n        returns (\n            address[] memory,\n            uint256[] memory,\n            address[][] memory,\n            uint256[2][][] memory,\n            uint256[] memory\n        );\n}\n"
    },
    "contracts/interfaces/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IRewardsDistributor {\n    function rewardToken() external view returns (address);\n\n    function compAccrued(address _holder) external view returns (uint256);\n\n    function claimRewards(address _holder) external;\n\n    function compBorrowSpeeds(address _ctoken) external view returns (uint256);\n\n    function compSupplySpeeds(address _ctoken) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/borrow/FuseBorrowIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {CompoundBorrowIntegration} from './CompoundBorrowIntegration.sol';\n\n/**\n * @title FuseBorrowIntegration\n * @author Babylon Finance\n *\n * Class that houses fuse borrowing logic.\n */\ncontract FuseBorrowIntegration is CompoundBorrowIntegration {\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     * @param _comptroller            Address of the fuse pool comptroller\n     */\n    constructor(\n        IBabController _controller,\n        uint256 _maxCollateralFactor,\n        IComptroller _comptroller\n    ) CompoundBorrowIntegration('fuseborrow', _controller, _maxCollateralFactor, _comptroller) {}\n}\n"
    },
    "contracts/integrations/borrow/CompoundBorrowIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport {ICToken} from '../../interfaces/external/compound/ICToken.sol';\nimport {ICEther} from '../../interfaces/external/compound/ICEther.sol';\nimport {ICompoundPriceOracle} from '../../interfaces/external/compound/ICompoundPriceOracle.sol';\nimport {IComptroller} from '../../interfaces/external/compound/IComptroller.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {UniversalERC20} from '../../lib/UniversalERC20.sol';\nimport {ControllerLib} from '../../lib/ControllerLib.sol';\n\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title CompoundBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses Compound borrowing logic.\n */\ncontract CompoundBorrowIntegration is BorrowIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using UniversalERC20 for IERC20;\n    using ControllerLib for IBabController;\n\n    /* ============ State Variables ============ */\n\n    IComptroller internal immutable comptroller;\n\n    // Mapping of asset addresses to cToken addresses\n    mapping(address => address) public assetToCToken;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     * @param _comptroller            Address of the controller\n     */\n    constructor(\n        string memory _name,\n        IBabController _controller,\n        uint256 _maxCollateralFactor,\n        IComptroller _comptroller\n    ) BorrowIntegration(_name, _controller, _maxCollateralFactor) {\n        comptroller = _comptroller;\n        _overrideMappings(_comptroller);\n    }\n\n    /* ============ External Functions ============ */\n\n    // Governance function\n    function overrideMappings() external {\n        controller.onlyGovernanceOrEmergency();\n        _overrideMappings(comptroller);\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view virtual override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            ,\n            // err\n            // cTokenBalance\n            uint256 borrowBalance,\n\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        return borrowBalance;\n    }\n\n    /**\n     * Get the amount of collateral depposited\n     * @param asset   The collateral to check\n     *\n     */\n    function getCollateralBalance(address _strategy, address asset) external view override returns (uint256) {\n        address cToken = assetToCToken[asset];\n        (\n            ,\n            // err\n            uint256 cTokenBalance, // borrow balance\n            ,\n            uint256 exchangeRateMantissa\n        ) = ICToken(cToken).getAccountSnapshot(_strategy);\n        uint256 decimals = IERC20(asset).universalDecimals();\n        // Source: balanceOfUnderlying from any ctoken\n        return cTokenBalance.mul(exchangeRateMantissa).div(10**decimals);\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        (\n            ,\n            /* error */\n            uint256 liquidity, /* shortfall */\n\n        ) = IComptroller(comptroller).getAccountLiquidity(_strategy);\n        return liquidity;\n    }\n\n    function _getCollateralFactor(address _assetToken) internal view virtual override returns (uint256) {\n        ICToken ctoken = ICToken(assetToCToken[_assetToken]);\n        (, uint256 collateral) = IComptroller(comptroller).markets(address(ctoken));\n        return collateral;\n    }\n\n    /* ============ Overriden Functions ============ */\n\n    function _overrideMappings(IComptroller _comptroller) private {\n        address[] memory markets = _comptroller.getAllMarkets();\n        for (uint256 i = 0; i < markets.length; i++) {\n            address underlying = address(0);\n            // Skip cEther\n            if (markets[i] != 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) {\n                underlying = ICToken(markets[i]).underlying();\n            }\n            assetToCToken[underlying] = markets[i];\n        }\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256, /* _amount */\n        uint256 _borrowOp\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_borrowOp == 0) {\n            // Encode method data for Garden to invoke\n            address[] memory markets = new address[](1);\n            markets[0] = assetToCToken[_asset];\n            bytes memory methodData = abi.encodeWithSignature('enterMarkets(address[])', markets);\n            return (address(comptroller), 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('borrow(uint256)', _amount);\n\n        return (assetToCToken[_asset], 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (_asset == address(0)) {\n            methodData = abi.encodeWithSignature('repayBorrow()');\n        } else {\n            methodData = abi.encodeWithSignature('repayBorrow(uint256)', _amount);\n        }\n        return (assetToCToken[_asset], _asset == address(0) ? _amount : 0, methodData);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getCollateralAsset(\n        address _asset,\n        uint8 /* _borrowOp */\n    ) internal view override returns (address) {\n        // TODO: check this\n        return assetToCToken[_asset];\n    }\n\n    function _getSpender(address _asset) internal view override returns (address) {\n        return assetToCToken[_asset];\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICEther {\n    function mint() external payable;\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function repayBorrow() external payable;\n\n    function getCash() external view returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function supplyRatePerBlock() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/ICompoundPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICompoundPriceOracle {\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/borrow/BorrowIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IBorrowIntegration} from '../../interfaces/IBorrowIntegration.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\n\n/**\n * @title BorrowIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with borrowing protocols\n */\nabstract contract BorrowIntegration is BaseIntegration, ReentrancyGuard, IBorrowIntegration {\n    using LowGasSafeMath for uint256;\n\n    /* ============ Struct ============ */\n\n    struct DebtInfo {\n        IStrategy strategy; // Idea address\n        IGarden garden; // Garden address\n        address asset; // Asset involved in the operation\n        uint256 amount; // Amount involved in the operation\n        uint256 debt; // Amount of debt at the start of the operation\n        uint8 borrowOp; // Borrow operation type\n    }\n\n    uint8 constant BORROW_OPERATION_BORROW = 0;\n    uint8 constant BORROW_OPERATION_REPAY = 1;\n\n    /* ============ Events ============ */\n\n    event AmountBorrowed(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    event AmountRepaid(IStrategy indexed strategy, IGarden indexed garden, address asset, uint256 amount);\n\n    /* ============ State Variables ============ */\n    uint256 public override maxCollateralFactor;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed\n     */\n    constructor(\n        string memory _name,\n        IBabController _controller,\n        uint256 _maxCollateralFactor\n    ) BaseIntegration(_name, _controller) {\n        maxCollateralFactor = _maxCollateralFactor;\n    }\n\n    /* ============ External Functions ============ */\n    // Governance function\n    // Max Borrow Factor\n    function updateMaxCollateralFactor(uint256 _newMaxCollateralFactor)\n        external\n        override\n        nonReentrant\n        onlySystemContract\n    {\n        maxCollateralFactor = _newMaxCollateralFactor;\n    }\n\n    /**\n     * Returns the collateral factor of an asset\n     * @param _assetToken Asset to get the collateral factor\n     */\n    function getCollateralFactor(address _assetToken) external view override returns (uint256) {\n        return _getCollateralFactor(_assetToken);\n    }\n\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * hparam asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(\n        address, /* strategy */\n        address /* asset */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address, /* strategy */\n        address /* asset */\n    ) external view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(\n        address /* strategy */\n    ) public view virtual override returns (uint256) {\n        require(false, 'This method must be overriden');\n        return 0;\n    }\n\n    /**\n     * Borrows an asset\n     * @param asset The asset to be borrowed\n     * @param amount The amount to borrow\n     */\n    function borrow(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_BORROW);\n\n        _validatePreBorrow(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_BORROW);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getBorrowCalldata(_strategy, asset, amount);\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostBorrow(debtInfo);\n        emit AmountBorrowed(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /**\n     * Repays a borrowed asset debt\n     * @param asset The asset to be repaid\n     * @param amount The amount to repay\n     */\n    function repay(\n        address _strategy,\n        address asset,\n        uint256 amount\n    ) external override nonReentrant onlySystemContract {\n        DebtInfo memory debtInfo = _createDebtInfo(_strategy, asset, amount, BORROW_OPERATION_REPAY);\n\n        _validatePreRepay(debtInfo);\n\n        // Pre actions (enter markets for compound)\n        (address targetAddressP, uint256 callValueP, bytes memory methodDataP) =\n            _getPreActionCallData(asset, amount, BORROW_OPERATION_REPAY);\n\n        if (targetAddressP != address(0)) {\n            // Invoke protocol specific call\n            debtInfo.strategy.invokeFromIntegration(targetAddressP, callValueP, methodDataP);\n        }\n        if (asset != address(0)) {\n            // Approves the repayment contract to take the tokens\n            debtInfo.strategy.invokeApprove(_getSpender(asset), asset, amount);\n        }\n\n        (address targetAddress, uint256 callValue, bytes memory methodData) =\n            _getRepayCalldata(_strategy, asset, amount);\n\n        // Invoke protocol specific call\n        debtInfo.strategy.invokeFromIntegration(targetAddress, callValue, methodData);\n        // Validate borrow\n        _validatePostRepay(debtInfo);\n\n        emit AmountRepaid(debtInfo.strategy, debtInfo.garden, asset, amount);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return DebtInfo struct\n     *\n     * @param _strategy            The strategy executing this integration\n     * @param _asset               The asset involved in the op\n     * @param _amount              The amount involved in the op\n     * @param _borrowOp            Type of borrow operation\n     * return DebtInfo             Struct containing data for the debt position\n     */\n    function _createDebtInfo(\n        address _strategy,\n        address _asset,\n        uint256 _amount,\n        uint8 _borrowOp\n    ) internal view returns (DebtInfo memory) {\n        DebtInfo memory debtInfo;\n        debtInfo.strategy = IStrategy(_strategy);\n        debtInfo.garden = IGarden(debtInfo.strategy.garden());\n        debtInfo.asset = _asset;\n        debtInfo.debt = getBorrowBalance(_strategy, debtInfo.asset);\n        debtInfo.amount = _amount;\n        debtInfo.borrowOp = _borrowOp;\n\n        return debtInfo;\n    }\n\n    /**\n     * Validate pre borrow.\n     *\n     * hparam _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreBorrow(DebtInfo memory _debtInfo) internal view {\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate post borrow.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostBorrow(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'Did not receive the borrowed asset');\n        require(getRemainingLiquidity(address(_debtInfo.strategy)) > 0, 'Not enough liquidity');\n    }\n\n    /**\n     * Validate pre repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePreRepay(DebtInfo memory _debtInfo) internal view {\n        uint256 balance =\n            address(0) == _debtInfo.asset\n                ? address(_debtInfo.strategy).balance\n                : IERC20(_debtInfo.asset).balanceOf(address(_debtInfo.strategy));\n        require(balance >= _debtInfo.amount, 'We do not have enough to repay debt');\n    }\n\n    /**\n     * Validate post repaid.\n     *\n     * @param _debtInfo               Struct containing debt information used in internal functions\n     */\n    function _validatePostRepay(DebtInfo memory _debtInfo) internal view {\n        // debt is paid\n        require(getBorrowBalance(address(_debtInfo.strategy), _debtInfo.asset) < _debtInfo.debt, 'Debt was not repaid');\n    }\n\n    /* ============ Virtual Functions ============ */\n\n    /**\n     * Return borrow token calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * hparam  _strategy                 Address of the strategy executing it\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 /* _amount */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(false, 'This needs to be overriden');\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getCollateralAsset(\n        address, /* _asset */\n        uint8 /* _borrowOp */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n\n    function _getCollateralFactor(address _asset) internal view virtual returns (uint256);\n\n    function _getSpender(\n        address /* asset */\n    ) internal view virtual returns (address) {\n        require(false, 'This method must be overriden');\n        return address(0);\n    }\n}\n"
    },
    "contracts/integrations/pool/PoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {AddressArrayUtils} from '../../lib/AddressArrayUtils.sol';\n\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\n\nimport {BaseIntegration} from '../BaseIntegration.sol';\n\n/**\n * @title PoolIntegration\n * @author Babylon Finance Protocol\n *\n * Base class for integration with pool protocols\n */\nabstract contract PoolIntegration is BaseIntegration, ReentrancyGuard, IPoolIntegration {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Struct ============ */\n\n    struct PoolInfo {\n        IGarden garden; // Garden address\n        IStrategy strategy; // Strategy address\n        bytes pool; // OpData 64 bytes each OpData\n        address lpToken; // LP address\n        uint256 totalSupply; // Total Supply of the pool\n        uint256 poolTokensInTransaction; // Pool tokens affected by this transaction\n        uint256 poolTokensInStrategy; // Pool tokens strategy balance\n        uint256[] limitPoolTokenQuantities;\n    }\n\n    /* ============ Events ============ */\n\n    event PoolEntered(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensOut);\n\n    event PoolExited(address indexed _strategy, address indexed _garden, address _pool, uint256 _poolTokensIn);\n\n    /* ============ Constants ============ */\n\n    uint256 internal constant SLIPPAGE_ALLOWED = 5e16; // 5%\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, IBabController _controller) BaseIntegration(_name, _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Joins a pool\n     *\n     * @param _strategy             Address of the strategy\n     * @param _pool                 OpData e.g. Address of the pool token to join\n     * @param _poolTokensOut        Min amount of pool tokens to receive\n     * @param _tokensIn             Array of token addresses to deposit\n     * @param _maxAmountsIn         Array of max token quantities to pull out from the garden\n     */\n    function joinPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) external override nonReentrant onlySystemContract {\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _pool, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        _validatePreJoinPoolData(poolInfo);\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Approve spending of the tokens\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            // No need to approve ETH\n            if (_tokensIn[i] != address(0) && _tokensIn[i] != ETH_ADD_CURVE && _maxAmountsIn[i] > 0) {\n                poolInfo.strategy.invokeApprove(_getSpender(_pool, 0), _tokensIn[i], _maxAmountsIn[i]);\n            }\n        }\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getJoinPoolCalldata(_strategy, _pool, _poolTokensOut, _tokensIn, _maxAmountsIn);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        poolInfo.poolTokensInTransaction = IERC20(poolInfo.lpToken).balanceOf(address(poolInfo.strategy)).sub(\n            poolInfo.poolTokensInStrategy\n        );\n        _validatePostJoinPoolData(poolInfo);\n        emit PoolEntered(address(poolInfo.strategy), address(poolInfo.garden), poolAddress, _poolTokensOut);\n    }\n\n    /**\n     * Exits a liquidity pool. Accrue protocol fee (if any)\n     *\n     * @param _strategy               Address of the strategy\n     * @param _pool                   Pool info e.g. PoolId or Address of the pool token to join + metadata\n     * @param _poolTokensIn           Pool tokens to exchange for the underlying tokens\n     * @param _tokensOut              Array of token addresses to withdraw\n     * @param _minAmountsOut          Array of min token quantities to receive from the pool\n     */\n    function exitPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    ) external override nonReentrant onlySystemContract {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        PoolInfo memory poolInfo = _createPoolInfo(_strategy, _pool, _poolTokensIn, _tokensOut, _minAmountsOut);\n        _validatePreExitPoolData(poolInfo);\n        // Approve spending of the pool token\n        poolInfo.strategy.invokeApprove(_getSpender(_pool, 1), poolInfo.lpToken, _poolTokensIn);\n\n        (address targetPool, uint256 callValue, bytes memory methodData) =\n            _getExitPoolCalldata(_strategy, _pool, _poolTokensIn, _tokensOut, _minAmountsOut);\n        poolInfo.strategy.invokeFromIntegration(targetPool, callValue, methodData);\n        _validatePostExitPoolData(poolInfo);\n\n        emit PoolExited(address(poolInfo.strategy), address(poolInfo.garden), poolAddress, _poolTokensIn);\n    }\n\n    /**\n     * Checks whether a pool address is valid\n     *\n     * @param _pool                 OpData e.g. Pool address to check\n     * @return bool                 True if the address is a pool\n     */\n    function isPool(bytes memory _pool) external view override returns (bool) {\n        return _isPool(_pool);\n    }\n\n    /**\n     * Returns the actual address of the LP token. Different for curve.\n     * @param _pool                    Address of the pool\n     * @return address                 Address of the LP token\n     */\n    function getLPToken(address _pool) external view override returns (address) {\n        return _getLpToken(_pool);\n    }\n\n    /**\n     * Gets the underlying pool that holds the internal tokens. Different for curve.\n     * @param _pool                    Address of the maybe pool\n     * @return address                 Address of the pool itself\n     */\n    function getPool(address _pool) external view override returns (address) {\n        return _getPool(_pool);\n    }\n\n    /**\n     * Returns the total supply of the pool tokens\n     * @param _pool                    Address of the pool\n     * @return address                 Total supply of the token\n     */\n    function totalSupply(address _pool) external view override returns (uint256) {\n        return _totalSupply(_pool);\n    }\n\n    /**\n     * Returns the underlying coin\n     * @param _pool                    Address of the pool\n     * @param _i                       Index of coin in the pool\n     * @return address                 Underlying coin\n     * @return uint256                 Rate from coin to underlying\n     */\n    function getUnderlyingAndRate(bytes calldata _pool, uint256 _i) external view override returns (address, uint256) {\n        return _getUnderlyingAndRate(_pool, _i);\n    }\n\n    function getPricePerShare(bytes calldata _pool) external view virtual override returns (uint256) {\n        return _getPricePerShare(_pool);\n    }\n\n    function poolWeightsByPrice(\n        bytes calldata /* _pool */\n    ) external view virtual override returns (bool) {\n        return false;\n    }\n\n    function getPoolTokens(\n        bytes calldata, /* _pool */\n        bool /* forNAV */\n    ) public view virtual override returns (address[] memory);\n\n    function getPoolWeights(\n        bytes calldata /*_pool */\n    ) external view virtual override returns (uint256[] memory);\n\n    function getRewardTokens(bytes calldata _pool) external view virtual override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return _getRewardTokens(poolAddress);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Create and return PoolInfo struct\n     *\n     * @param _strategy                      Address of the strategy\n     * @param _pool                          Pool info e.g. Address of the pool + metadata\n     * @param _poolTokensInTransaction       Number of pool tokens involved\n     * hparam _poolTokens                    Addresseses of the pool tokens\n     * @param _limitPoolTokenQuantities      Limit quantity of the pool tokens\n     *\n     * return PoolInfo             Struct containing data for pool\n     */\n    function _createPoolInfo(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensInTransaction,\n        address[] calldata, /* _poolTokens */\n        uint256[] calldata _limitPoolTokenQuantities\n    ) internal view returns (PoolInfo memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        PoolInfo memory poolInfo;\n        poolInfo.lpToken = _getLpToken(poolAddress);\n        poolInfo.strategy = IStrategy(_strategy);\n        poolInfo.garden = IGarden(poolInfo.strategy.garden());\n        poolInfo.pool = _pool;\n        poolInfo.poolTokensInStrategy = IERC20(poolInfo.lpToken).balanceOf(_strategy);\n        poolInfo.poolTokensInTransaction = _poolTokensInTransaction;\n        poolInfo.limitPoolTokenQuantities = _limitPoolTokenQuantities;\n\n        return poolInfo;\n    }\n\n    /**\n     * Validate pre pool join data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Min pool tokens to receive must be greater than 0');\n    }\n\n    /**\n     * Validate pre pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePreExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(_isPool(_poolInfo.pool), 'The pool address is not valid');\n        require(_poolInfo.poolTokensInTransaction > 0, 'Pool tokens to exchange must be greater than 0');\n        require(\n            _poolInfo.poolTokensInStrategy >= _poolInfo.poolTokensInTransaction,\n            'The strategy does not have enough pool tokens'\n        );\n    }\n\n    /**\n     * Validate post join pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostJoinPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            (IERC20(_poolInfo.lpToken).balanceOf(address(_poolInfo.strategy)) > _poolInfo.poolTokensInStrategy),\n            'The strategy did not receive the pool tokens'\n        );\n    }\n\n    /**\n     * Validate post exit pool data. Check pool is valid, token quantity is valid.\n     *\n     * @param _poolInfo               Struct containing pool information used in internal functions\n     */\n    function _validatePostExitPoolData(PoolInfo memory _poolInfo) internal view {\n        require(\n            IERC20(_poolInfo.lpToken).balanceOf(address(_poolInfo.strategy)) ==\n                _poolInfo.poolTokensInStrategy - _poolInfo.poolTokensInTransaction,\n            'The strategy did not return the pool tokens'\n        );\n        // TODO: validate individual tokens received\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * hparam  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata, /* _pool */\n        uint256, /* _poolTokensOut */\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata /* _maxAmountsIn */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * hparam  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory, /* _pool */\n        uint256, /* _poolTokensIn */\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata /* _minAmountsOut */\n    )\n        internal\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            bytes memory\n        );\n\n    function _isPool(bytes memory _pool) internal view virtual returns (bool);\n\n    function _getPricePerShare(\n        bytes calldata /* _pool */\n    ) internal pure virtual returns (uint256) {\n        return 0;\n    }\n\n    function _totalSupply(address _pool) internal view virtual returns (uint256) {\n        return IERC20(_pool).totalSupply();\n    }\n\n    function _getUnderlyingAndRate(bytes calldata _pool, uint256 _i) internal view virtual returns (address, uint256) {\n        return (getPoolTokens(_pool, false)[_i], 1e18);\n    }\n\n    function _getSpender(\n        bytes calldata, /* _pool */\n        uint8 /* _opType */\n    ) internal view virtual returns (address);\n\n    function _getLpToken(address _pool) internal view virtual returns (address) {\n        return _pool;\n    }\n\n    function _getPool(address _pool) internal view virtual returns (address) {\n        return _pool;\n    }\n\n    function _getRewardTokens(\n        address /* _pool */\n    ) internal view virtual returns (address[] memory) {\n        return new address[](1);\n    }\n}\n"
    },
    "contracts/interfaces/IPoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n/**\n * @title IPoolIntegration\n * @author Babylon Finance\n *\n * Interface for liquiditypool protocol integrations\n */\ninterface IPoolIntegration {\n    function joinPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] memory _poolTokens,\n        uint256[] memory _maxAmountsIn\n    ) external;\n\n    function exitPool(\n        address _strategy,\n        bytes calldata _pool,\n        uint256 _poolTokensIn,\n        address[] memory _poolTokens,\n        uint256[] memory _minAmountsOut\n    ) external;\n\n    function getPoolTokens(bytes calldata _pool, bool forNAV) external view returns (address[] memory);\n\n    function getPoolWeights(bytes calldata _pool) external view returns (uint256[] memory);\n\n    function getPricePerShare(bytes calldata _pool) external view returns (uint256);\n\n    function getLPToken(address _pool) external view returns (address);\n\n    function getPool(address _pool) external view returns (address);\n\n    function totalSupply(address _pool) external view returns (uint256);\n\n    function getUnderlyingAndRate(bytes calldata _pool, uint256 _i) external view returns (address, uint256);\n\n    function getPoolTokensOut(\n        bytes calldata _pool,\n        address _tokenAddress,\n        uint256 _maxAmountsIn\n    ) external view returns (uint256);\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _poolTokenAmount)\n        external\n        view\n        returns (uint256[] memory _minAmountsOut);\n\n    function isPool(bytes calldata _pool) external view returns (bool);\n\n    function poolWeightsByPrice(bytes calldata _pool) external view returns (bool);\n\n    function getRewardTokens(bytes calldata _pool) external view returns (address[] memory);\n}\n"
    },
    "contracts/integrations/pool/UniswapPoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IUniswapV2Router} from '../../interfaces/external/uniswap/IUniswapV2Router.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapPoolIntegration protocol integration\n */\ncontract UniswapPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IUniswapV2Router public uniRouter;\n\n    /* ============ Constants ============ */\n\n    uint8 public immutable MAX_DELTA_BLOCKS = 5;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _uniswapRouterAddress         Address of Uniswap router\n     */\n    constructor(IBabController _controller, address _uniswapRouterAddress)\n        PoolIntegration('uniswap_pool', _controller)\n    {\n        require(address(_controller) != address(0) && _uniswapRouterAddress != address(0), 'invalid address');\n        uniRouter = IUniswapV2Router(_uniswapRouterAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory result = new address[](2);\n        result[0] = IUniswapV2Pair(poolAddress).token0();\n        result[1] = IUniswapV2Pair(poolAddress).token1();\n        return result;\n    }\n\n    function getPoolWeights(\n        bytes calldata /* _pool */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 totalSupply = IUniswapV2Pair(poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        result[0] = IERC20(IUniswapV2Pair(poolAddress).token0())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = IERC20(IUniswapV2Pair(poolAddress).token1())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal pure override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IUniswapV2Pair(poolAddress).MINIMUM_LIQUIDITY() > 0;\n    }\n\n    function _getSpender(\n        bytes calldata, /* _pool */\n        uint8 /* _opType */\n    ) internal view override returns (address) {\n        return address(uniRouter);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address _strategy,\n        bytes calldata, /* _pool */\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        return (address(uniRouter), 0, _getMethodData(_strategy, _tokensIn, _maxAmountsIn));\n    }\n\n    function _getMethodData(\n        address _strategy,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    ) private view returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                'addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)',\n                _tokensIn[0],\n                _tokensIn[1],\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED)),\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * @param  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address _strategy,\n        bytes memory, /* _pool */\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)',\n                _tokensOut[0],\n                _tokensOut[1],\n                _poolTokensIn,\n                _minAmountsOut[0],\n                _minAmountsOut[1],\n                _strategy,\n                block.timestamp.add(MAX_DELTA_BLOCKS)\n            );\n\n        return (address(uniRouter), 0, methodData);\n    }\n}\n"
    },
    "contracts/integrations/pool/OneInchPoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IMooniswapFactory} from '../../interfaces/external/1inch/IMooniswapFactory.sol';\nimport {IMooniswap} from '../../interfaces/external/1inch/IMooniswap.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * OneInchPoolIntegration protocol trade integration\n */\ncontract OneInchPoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V2 Router\n    IMooniswapFactory public mooniswapFactory;\n\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _mooniswapFactoryAddress         Address of the Mooniswap factory\n     */\n    constructor(IBabController _controller, address _mooniswapFactoryAddress)\n        PoolIntegration('oneinch_pool', _controller)\n    {\n        require(address(_controller) != address(0) && _mooniswapFactoryAddress != address(0), 'invalid address');\n        mooniswapFactory = IMooniswapFactory(_mooniswapFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return IMooniswap(poolAddress).getTokens();\n    }\n\n    function getPoolWeights(\n        bytes calldata /* _pool */\n    ) external pure override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](2);\n        result[0] = 5e17; // 50%\n        result[1] = 5e17; // 50%\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory tokens = IMooniswap(poolAddress).getTokens();\n        uint256 totalSupply = IMooniswap(poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        uint256 token0Balance =\n            (tokens[0] != address(0) ? IERC20(tokens[0]).balanceOf(poolAddress) : poolAddress.balance);\n        uint256 token1Balance =\n            (tokens[1] != address(0) ? IERC20(tokens[1]).balanceOf(poolAddress) : poolAddress.balance);\n        result[0] = token0Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = token1Balance.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IMooniswapFactory(mooniswapFactory).isPool(IMooniswap(poolAddress));\n    }\n\n    function _getSpender(\n        bytes calldata _pool,\n        uint8 /* _opType */\n    ) internal pure override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * hparam  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(uint256[2],uint256[2])',\n                _maxAmountsIn[0],\n                _maxAmountsIn[1],\n                _maxAmountsIn[0].sub(_maxAmountsIn[0].preciseMul(SLIPPAGE_ALLOWED * 2)),\n                _maxAmountsIn[1].sub(_maxAmountsIn[1].preciseMul(SLIPPAGE_ALLOWED * 2))\n            );\n        uint256 value = 0;\n        // Add ETH if one of the tokens\n        if (_tokensIn[0] == address(0)) {\n            value = _maxAmountsIn[0];\n        }\n        if (_tokensIn[1] == address(0)) {\n            value = _maxAmountsIn[1];\n        }\n\n        return (poolAddress, value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './IMooniswap.sol';\nimport './IMooniswapFactoryGovernance.sol';\n\ninterface IMooniswapFactory is IMooniswapFactoryGovernance {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n\n    function isPool(IMooniswap mooniswap) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/1inch/IMooniswapFactoryGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IMooniswapFactoryGovernance {\n    function shareParameters()\n        external\n        view\n        returns (\n            uint256 _referralShare,\n            uint256 _governanceShare,\n            address _governanceWallet,\n            address _referralFeeReceiver\n        );\n\n    function defaults()\n        external\n        view\n        returns (\n            uint256 _defaultFee,\n            uint256 _defaultSlippageFee,\n            uint256 _defaultDecayPeriod\n        );\n\n    function defaultFee() external view returns (uint256);\n\n    function defaultSlippageFee() external view returns (uint256);\n\n    function defaultDecayPeriod() external view returns (uint256);\n\n    function virtualDefaultFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultSlippageFee()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function virtualDefaultDecayPeriod()\n        external\n        view\n        returns (\n            uint104,\n            uint104,\n            uint48\n        );\n\n    function referralShare() external view returns (uint256);\n\n    function governanceShare() external view returns (uint256);\n\n    function governanceWallet() external view returns (address);\n\n    function feeCollector() external view returns (address);\n\n    function isFeeCollector(address) external view returns (bool);\n\n    function isActive() external view returns (bool);\n}\n"
    },
    "contracts/strategies/operations/AddLiquidityOperation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {IPoolIntegration} from '../../interfaces/IPoolIntegration.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {Operation} from './Operation.sol';\n\n/**\n * @title AddLiquidityOperation\n * @author Babylon Finance\n *\n * Executes an add liquidity operation\n */\ncontract AddLiquidityOperation is Operation {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n    using BytesLib for bytes;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _name                   Name of the integration\n     * @param _controller             Address of the controller\n     */\n    constructor(string memory _name, address _controller) Operation(_name, _controller) {}\n\n    /**\n     * Sets operation data for the add liquidity operation\n     *\n     * @param _data                   Operation data\n     */\n    function validateOperation(\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration,\n        uint256 /* _index */\n    ) external view override onlyStrategy {\n        require(IPoolIntegration(_integration).isPool(_data), 'Not a valid pool');\n    }\n\n    /**\n     * Executes the add liquidity operation\n     * @param _asset              Asset to receive into this operation\n     * @param _capital            Amount of asset received\n     * param _assetStatus        Status of the asset amount\n     * @param _data               OpData e.g. Address of the pool to enter\n     * @param _garden             Garden of the strategy\n     * @param _integration        Address of the integration to execute\n     */\n    function executeOperation(\n        address _asset,\n        uint256 _capital,\n        uint8, /* _assetStatus */\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_data, false);\n        uint256[] memory _poolWeights = IPoolIntegration(_integration).getPoolWeights(_data);\n        // if the weights need to be adjusted by price, do so\n        try IPoolIntegration(_integration).poolWeightsByPrice(_data) returns (bool priceWeights) {\n            if (priceWeights) {\n                uint256 poolTotal = 0;\n                for (uint256 i = 0; i < poolTokens.length; i++) {\n                    _poolWeights[i] = SafeDecimalMath.normalizeAmountTokens(\n                        poolTokens[i],\n                        poolTokens[poolTokens.length - 1],\n                        _poolWeights[i].preciseMul(_getPrice(poolTokens[i], poolTokens[poolTokens.length - 1]))\n                    );\n                    poolTotal = poolTotal.add(_poolWeights[i]);\n                }\n                for (uint256 i = 0; i < poolTokens.length; i++) {\n                    _poolWeights[i] = _poolWeights[i].mul(1e18).div(poolTotal);\n                }\n            }\n        } catch {}\n        // Get the tokens needed to enter the pool\n        uint256[] memory maxAmountsIn = _maxAmountsIn(_asset, _capital, _garden, _poolWeights, poolTokens);\n        uint256 poolTokensOut = IPoolIntegration(_integration).getPoolTokensOut(_data, poolTokens[0], maxAmountsIn[0]);\n        IPoolIntegration(_integration).joinPool(\n            msg.sender,\n            _data,\n            poolTokensOut.sub(poolTokensOut.preciseMul(SLIPPAGE_ALLOWED)),\n            poolTokens,\n            maxAmountsIn\n        );\n        return (\n            _getLPTokenFromBytes(_integration, _data),\n            IERC20(_getLPTokenFromBytes(_integration, _data)).balanceOf(msg.sender),\n            0\n        ); // liquid\n    }\n\n    /**\n     * Exits the add liquidity operation.\n     * @param _percentage of capital to exit from the strategy\n     */\n    function exitOperation(\n        address, /* _asset */\n        uint256, /* _remaining */\n        uint8, /* _assetStatus */\n        uint256 _percentage,\n        bytes calldata _data,\n        IGarden, /* _garden */\n        address _integration\n    )\n        external\n        override\n        onlyStrategy\n        returns (\n            address,\n            uint256,\n            uint8\n        )\n    {\n        require(_percentage <= 1e18, 'Unwind Percentage <= 100%');\n        address pool = BytesLib.decodeOpDataAddress(_data);\n        address[] memory poolTokens = IPoolIntegration(_integration).getPoolTokens(_data, false);\n        uint256 lpTokens =\n            IERC20(IPoolIntegration(_integration).getLPToken(pool)).balanceOf(msg.sender).preciseMul(_percentage); // Sell all pool tokens\n        uint256[] memory _minAmountsOut = IPoolIntegration(_integration).getPoolMinAmountsOut(_data, lpTokens);\n        IPoolIntegration(_integration).exitPool(\n            msg.sender,\n            _data,\n            lpTokens, // Sell all pool tokens\n            poolTokens,\n            _minAmountsOut\n        );\n        // Exit Pool tokens to a consolidated asset\n        address reserveAsset = WETH;\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] != reserveAsset) {\n                if (_isETH(poolTokens[i]) && address(msg.sender).balance > MIN_TRADE_AMOUNT) {\n                    IStrategy(msg.sender).handleWeth(true, address(msg.sender).balance);\n                    poolTokens[i] = WETH;\n                }\n                if (poolTokens[i] != reserveAsset) {\n                    if (IERC20(poolTokens[i]).balanceOf(msg.sender) > MIN_TRADE_AMOUNT) {\n                        IStrategy(msg.sender).trade(\n                            poolTokens[i],\n                            IERC20(poolTokens[i]).balanceOf(msg.sender),\n                            reserveAsset\n                        );\n                    }\n                }\n            }\n        }\n        // Only claim and sell rewards on final exit\n        if (_percentage == HUNDRED_PERCENT) {\n            _sellRewardTokens(_integration, _data, reserveAsset);\n        }\n        // BUG: Should respect percentage and not return all the capital\n        return (reserveAsset, IERC20(reserveAsset).balanceOf(msg.sender), 0);\n    }\n\n    /**\n     * Gets the NAV of the add liquidity op in the reserve asset\n     *\n     * @param _data               OpData e.g. PoolId or asset address\n     * @param _garden             Garden the strategy belongs to\n     * @param _integration        Status of the asset amount\n     * @return _nav               NAV of the strategy\n     */\n    function getNAV(\n        bytes calldata _data,\n        IGarden _garden,\n        address _integration\n    ) external view override returns (uint256, bool) {\n        if (!IStrategy(msg.sender).isStrategyActive()) {\n            return (0, true);\n        }\n        address pool = BytesLib.decodeOpDataAddress(_data); // 64 bytes (w/o signature prefix bytes4)\n        pool = IPoolIntegration(_integration).getPool(pool);\n        IERC20 lpToken = IERC20(IPoolIntegration(_integration).getLPToken(pool));\n        // Get price multiplier if needed (harvestv3)\n        uint256 price = _getPrice(address(lpToken), _garden.reserveAsset());\n        require(price != 0, 'Could not price lp token');\n        try IPoolIntegration(_integration).getPricePerShare(_data) returns (uint256 pricePerShare) {\n            if (pricePerShare != 0) {\n                price = pricePerShare.preciseMul(price);\n            }\n        } catch {}\n        uint256 NAV;\n        // Price lp token through price oracle\n        NAV = NAV.add(\n            SafeDecimalMath.normalizeAmountTokens(\n                address(lpToken),\n                _garden.reserveAsset(),\n                lpToken.balanceOf(msg.sender).preciseMul(price)\n            )\n        );\n        // get rewards if hanging around\n        try IPoolIntegration(_integration).getRewardTokens(_data) returns (address[] memory rewards) {\n            for (uint256 i = 0; i < rewards.length; i++) {\n                if (rewards[i] != address(0) && IERC20(rewards[i]).balanceOf(msg.sender) > MIN_TRADE_AMOUNT) {\n                    price = _getPrice(_garden.reserveAsset(), rewards[i]);\n                    if (price > 0) {\n                        NAV += SafeDecimalMath.normalizeAmountTokens(\n                            rewards[i],\n                            _garden.reserveAsset(),\n                            IERC20(rewards[i]).balanceOf(msg.sender)\n                        );\n                    }\n                }\n            }\n        } catch {}\n        require(NAV != 0, 'NAV has to be bigger 0');\n        return (NAV, true);\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getMaxAmountTokenPool(\n        address _asset,\n        uint256 _capital,\n        IGarden, /* _garden */\n        uint256 _poolWeight,\n        address _poolToken\n    ) private returns (uint256) {\n        uint256 normalizedAssetAmount = _capital.preciseMul(_poolWeight);\n        uint256 price = _getPrice(_asset, _isETH(_poolToken) ? WETH : _poolToken);\n        uint256 normalizedTokenAmount =\n            SafeDecimalMath.normalizeAmountTokens(_asset, _poolToken, normalizedAssetAmount.preciseMul(price));\n        if (_poolToken != _asset && !_isETH(_poolToken)) {\n            IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, _poolToken);\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(_poolToken).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(_poolToken).balanceOf(msg.sender);\n            return normalizedTokenAmount;\n        }\n        if (_isETH(_poolToken)) {\n            if (_asset != WETH) {\n                IStrategy(msg.sender).trade(_asset, normalizedAssetAmount, WETH); // normalized amount in original asset decimals\n            }\n            // Convert WETH to ETH\n            // We consider the slippage in the trade\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(WETH).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(WETH).balanceOf(msg.sender);\n            IStrategy(msg.sender).handleWeth(false, normalizedTokenAmount); // normalized WETH/ETH amount with 18 decimals\n        } else {\n            // Reserve asset\n            normalizedTokenAmount = normalizedTokenAmount <= IERC20(_poolToken).balanceOf(msg.sender)\n                ? normalizedTokenAmount\n                : IERC20(_poolToken).balanceOf(msg.sender);\n        }\n        return normalizedTokenAmount;\n    }\n\n    function _maxAmountsIn(\n        address _asset,\n        uint256 _capital,\n        IGarden _garden,\n        uint256[] memory _poolWeights,\n        address[] memory poolTokens\n    ) internal returns (uint256[] memory) {\n        uint256[] memory maxAmountsIn = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (_poolWeights[i] > 0) {\n                maxAmountsIn[i] = _getMaxAmountTokenPool(_asset, _capital, _garden, _poolWeights[i], poolTokens[i]);\n            }\n        }\n        return maxAmountsIn;\n    }\n\n    function _getLPTokenFromBytes(address _integration, bytes calldata _data) internal view returns (address) {\n        return IPoolIntegration(_integration).getLPToken(BytesLib.decodeOpDataAddress(_data));\n    }\n\n    function _isETH(address _address) internal pure returns (bool) {\n        return _address == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || _address == address(0);\n    }\n\n    /**\n     * Sells the reward tokens obtained.\n     * @param _integration                    Address of the integration\n     * @param _data                           Calldata\n     * @param _reserveAsset                   Reserve Asset\n     */\n    function _sellRewardTokens(\n        address _integration,\n        bytes calldata _data,\n        address _reserveAsset\n    ) internal {\n        try IPoolIntegration(_integration).getRewardTokens(_data) returns (address[] memory rewards) {\n            for (uint256 i = 0; i < rewards.length; i++) {\n                if (rewards[i] != address(0) && IERC20(rewards[i]).balanceOf(msg.sender) > MIN_TRADE_AMOUNT) {\n                    try\n                        IStrategy(msg.sender).trade(\n                            rewards[i],\n                            IERC20(rewards[i]).balanceOf(msg.sender),\n                            _reserveAsset,\n                            70e15\n                        )\n                    {} catch {}\n                }\n            }\n        } catch {}\n    }\n}\n"
    },
    "contracts/integrations/trade/PaladinTradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {IPaladinZap} from '../../interfaces/external/paladin/IPaladinZap.sol';\n\n/**\n * @title PaladinTradeIntegration\n * @author Babylon Finance Protocol\n *\n * PaladinTradeIntegration\n */\ncontract PaladinTradeIntegration is TradeIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IERC20 private constant aave = IERC20(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);\n    IERC20 private constant stkAave = IERC20(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n\n    IPaladinZap private constant paladinZap = IPaladinZap(0xe0fb13edC73FE156A636bc532FC2e56F9d54AA62);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('paladin_trade', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        return address(paladinZap);\n    }\n\n    /**\n     * Executes the trade through paladin.\n     *\n     * hparam _strategy             Address of the strategy\n     * hparam _sendToken            Address of the token to be sent to the heart\n     * @param _sendQuantity         Units of reserve asset token sent to the heart\n     * hparam _receiveToken         Address of the token that will be received from the heart\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address, /* _sendToken, */\n        uint256 _sendQuantity,\n        address /* _receiveToken */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Strategy to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'zapDeposit(address,address,address,uint256,address,address,bytes)',\n                aave,\n                stkAave,\n                0xCDc3DD86C99b58749de0F697dfc1ABE4bE22216d,\n                _sendQuantity,\n                0xDef1C0ded9bec7F1a1670819833240f027b25EfF,\n                address(0),\n                bytes('')\n            );\n        return (address(paladinZap), 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/paladin/IPaladinZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity ^0.7.6;\n\ninterface IPaladinZap {\n    function zapDeposit(\n        address _fromTokenAddress,\n        address _toTokenAddress,\n        address _poolAddress,\n        uint256 _amount,\n        address _swapTarget,\n        address _allowanceTarget,\n        bytes memory _swapData\n    ) external payable returns (uint256);\n}\n"
    },
    "contracts/integrations/pool/HarvestPoolV3Integration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IUniVaultStorage} from '../../interfaces/external/uniswap-v3/IUniVaultStorage.sol';\nimport {IUniswapViewer} from '../../interfaces/external/uniswap-v3/IUniswapViewer.sol';\nimport {IHarvestUniv3Pool} from '../../interfaces/external/harvest/IHarvestUniv3Pool.sol';\n\n/**\n * @title Harvest Uni V3 Pool Integration\n * @author Babylon Finance Protocol\n *\n * HarvestUniV3 protocol integration\n */\ncontract HarvestPoolV3Integration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    uint256 private constant TOLERANCE = 150;\n    IUniswapViewer private constant uniswapViewer = IUniswapViewer(0x25c81e249F913C94F263923421622bA731E6555b);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PoolIntegration('harvest_univ3', _controller) {\n        require(address(_controller) != address(0), 'invalid address');\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory result = new address[](2);\n        result[0] = IHarvestUniv3Pool(poolAddress).token0();\n        result[1] = IHarvestUniv3Pool(poolAddress).token1();\n        return result;\n    }\n\n    function poolWeightsByPrice(\n        bytes calldata /* _pool */\n    ) external pure override returns (bool) {\n        return true;\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256[] memory result = new uint256[](2);\n        uint256 uniswapPosId = IUniVaultStorage(IHarvestUniv3Pool(poolAddress).getStorage()).posId();\n        (result[0], result[1]) = uniswapViewer.getAmountsForPosition(uniswapPosId);\n        return result;\n    }\n\n    function getPricePerShare(bytes calldata _pool) external view override returns (uint256) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return IHarvestUniv3Pool(poolAddress).getPricePerFullShare();\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 totalSupply = IHarvestUniv3Pool(poolAddress).totalSupply();\n        uint256[] memory result = new uint256[](2);\n        result[0] = IERC20(IHarvestUniv3Pool(poolAddress).token0())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = IERC20(IHarvestUniv3Pool(poolAddress).token1())\n            .balanceOf(poolAddress)\n            .mul(_liquidity)\n            .div(totalSupply)\n            .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IHarvestUniv3Pool(poolAddress).totalSupply() > 0;\n    }\n\n    function _getSpender(\n        bytes calldata _pool,\n        uint8 /* _opType */\n    ) internal pure override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 sqrtPriceX96 = IHarvestUniv3Pool(poolAddress).getSqrtPriceX96();\n        return (poolAddress, 0, _getMethodData(sqrtPriceX96, _maxAmountsIn));\n    }\n\n    function _getMethodData(uint256 sqrtPriceX96, uint256[] calldata _maxAmountsIn)\n        private\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSignature(\n                'deposit(uint256,uint256,bool,uint256,uint256,uint256,uint256,uint160)',\n                _maxAmountsIn[0], //amount0\n                _maxAmountsIn[1], // amount1\n                false, // zap\n                sqrtPriceX96, // sqrtRatioX96\n                TOLERANCE, //tolerance\n                0, // maxamountzap0\n                0, // maxamountzap1\n                uint160(sqrtPriceX96) // maxprice\n            );\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        uint256 sqrtPriceX96 = IHarvestUniv3Pool(poolAddress).getSqrtPriceX96();\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'withdraw(uint256,bool,bool,uint256,uint256)',\n                _poolTokensIn,\n                true,\n                true,\n                sqrtPriceX96,\n                TOLERANCE\n            );\n\n        return (poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/integrations/pool/GammaIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IGammaDeposit} from '../../interfaces/external/gamma/IGammaDeposit.sol';\nimport {IHypervisor} from '../../interfaces/IHypervisor.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/**\n * @title Gamma Uni V3 Pool Integration\n * @author Babylon Finance Protocol\n *\n * Gamma protocol integration\n */\ncontract GammaIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    IGammaDeposit private constant depositProxy = IGammaDeposit(0x96a4F484915523553272A9f64FD9848859F799fa);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PoolIntegration('gamma', _controller) {\n        require(address(_controller) != address(0), 'invalid address');\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory result = new address[](2);\n        result[0] = IUniswapV3Pool(poolAddress).token0();\n        result[1] = IUniswapV3Pool(poolAddress).token1();\n        return result;\n    }\n\n    function poolWeightsByPrice(\n        bytes calldata /* _pool */\n    ) external pure override returns (bool) {\n        return true;\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address visorAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256[] memory result = new uint256[](2);\n        (result[0], result[1]) = IHypervisor(visorAddress).getTotalAmounts();\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address visorAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 totalSupply = IHypervisor(visorAddress).totalSupply();\n        (uint256 amount0, uint256 amount1) = IHypervisor(visorAddress).getTotalAmounts();\n        uint256[] memory result = new uint256[](2);\n        result[0] = amount0.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        result[1] = amount1.mul(_liquidity).div(totalSupply).preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address visorAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return IHypervisor(visorAddress).totalSupply() > 0;\n    }\n\n    function _getSpender(\n        bytes calldata _pool,\n        uint8 /* _opType */\n    ) internal pure override returns (address) {\n        address visor = BytesLib.decodeOpDataAddress(_pool);\n        return visor;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * hparam  _poolTokensOut            Amount of pool tokens to send\n     * @param  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address _strategy,\n        bytes calldata _pool,\n        uint256, /* _poolTokensOut */\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        require(_tokensIn.length == 2, 'Two tokens required');\n        require(_maxAmountsIn.length == 2, 'Two amounts required');\n        address visorAddress = BytesLib.decodeOpDataAddress(_pool);\n\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(uint256,uint256,address,address)',\n                _maxAmountsIn[0], //amount0\n                _maxAmountsIn[1], // amount1\n                _strategy,\n                visorAddress\n            );\n        return (address(depositProxy), 0, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to liquidate\n     * @param  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address _strategy,\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata _tokensOut,\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address visorAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        require(_tokensOut.length == 2, 'Two tokens required');\n        require(_minAmountsOut.length == 2, 'Two amounts required');\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (\n            visorAddress == 0xf6eeCA73646ea6A5c878814e6508e87facC7927C ||\n            visorAddress == 0xc86B1e7FA86834CaC1468937cdd53ba3cCbC1153\n        ) {\n            methodData = abi.encodeWithSignature(\n                'withdraw(uint256,address,address)',\n                _poolTokensIn,\n                _strategy,\n                _strategy\n            );\n        } else if (visorAddress == 0x705b3aCaF102404CfDd5e4A60535E4e70091273C) {\n            methodData = abi.encodeWithSignature(\n                'withdraw(uint256,address,address,uint256,uint256)',\n                _poolTokensIn,\n                _strategy,\n                _strategy,\n                0,\n                0\n            );\n        } else {\n            methodData = abi.encodeWithSignature(\n                'withdraw(uint256,address,address,uint256[4])',\n                _poolTokensIn,\n                _strategy,\n                _strategy,\n                [0, 0, 0, 0]\n            );\n        }\n\n        return (visorAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/gamma/IGammaDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IGammaDeposit {\n    function deposit(\n        uint256 _amount0,\n        uint256 _amount1,\n        address _to,\n        address _visor\n    ) external;\n}\n"
    },
    "contracts/integrations/trade/HeartTradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {ISwapRouter} from '../../interfaces/external/uniswap-v3/ISwapRouter.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\n/**\n * @title Heart Trade Integration\n * @author Babylon Finance Protocol\n *\n * Heart trade integration. Heart buys protocol wanted assets\n */\ncontract HeartTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('heart_trade', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through the heart.\n     *\n     * hparam _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the heart\n     * @param _sendQuantity         Units of reserve asset token sent to the heart\n     * hparam _receiveToken         Address of the token that will be received from the heart\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address _sendToken,\n        uint256 _sendQuantity,\n        address /* _receiveToken */\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        bytes memory callData =\n            abi.encodeWithSignature('sellWantedAssetToHeart(address,uint256)', _sendToken, _sendQuantity);\n        return (controller.heart(), 0, callData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _asset */\n    ) internal view override returns (address) {\n        return address(controller.heart());\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n// mock class using ERC20\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) payable ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/integrations/trade/UniswapV2TradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {TradeIntegration} from './TradeIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\n\n/**\n * @title UniswapV2TradeIntegration\n * @author Babylon Finance Protocol\n *\n * UniswapV3 trade integration\n */\ncontract UniswapV2TradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using PreciseUnitMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n    // Address of Uniswap V2 SwapRouter contract\n    address private constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('univ2', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through UniswapV2.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     * @param _hopToken             Address of the routing token for multi-hop, i.e., sendToken->hopToken->receiveToken\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken,\n        address _hopToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address[] memory path;\n        if (_hopToken == address(0) || _sendToken == _hopToken || _receiveToken == _hopToken) {\n            path = new address[](2);\n            path[0] = _sendToken;\n            path[1] = _receiveToken;\n        } else {\n            path = new address[](3);\n            path[0] = _sendToken;\n            path[1] = _hopToken;\n            path[2] = _receiveToken;\n        }\n        bytes memory callData =\n            abi.encodeWithSignature(\n                'swapExactTokensForTokens(uint256,uint256,address[],address,uint256)',\n                _sendQuantity,\n                1,\n                path,\n                _strategy,\n                block.timestamp\n            );\n        return (router, 0, callData);\n    }\n\n    /**\n     * Executes the trade through UniswapV2.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return _getTradeCallData(_strategy, _sendToken, _sendQuantity, _receiveToken, WETH);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(\n        address /* _swapTarget */\n    ) internal pure override returns (address) {\n        return router;\n    }\n\n    /* ============ Private Functions ============ */\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/integrations/trade/SynthetixTradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ISynthetix} from '../../interfaces/external/synthetix/ISynthetix.sol';\nimport {ISnxProxy} from '../../interfaces/external/synthetix/ISnxProxy.sol';\nimport {ISnxSynth} from '../../interfaces/external/synthetix/ISnxSynth.sol';\nimport {ISnxEtherWrapper} from '../../interfaces/external/synthetix/ISnxEtherWrapper.sol';\nimport {ISnxDepot} from '../../interfaces/external/synthetix/ISnxDepot.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\n\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title SynthetixTradeIntegration\n * @author Babylon Finance Protocol\n *\n * Synthethix trade integration\n */\ncontract SynthetixTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n    /* ============ Constants ============ */\n\n    address private constant curvesUSD = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) TradeIntegration('synthetix_trade', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through synthetix.\n     *\n     * @param _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address _strategy,\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (address sendTokenImpl, address receiveTokenImpl, uint256 realSendAmount) =\n            _getTokens(_sendToken, _receiveToken, _sendQuantity, _strategy);\n        require(sendTokenImpl != address(0) && receiveTokenImpl != address(0), 'Syntetix needs synth or DAI or USDC');\n        if (sendTokenImpl == receiveTokenImpl) {\n            return (address(0), 0, bytes(''));\n        }\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'exchange(bytes32,uint256,bytes32)',\n                ISnxSynth(sendTokenImpl).currencyKey(),\n                realSendAmount,\n                ISnxSynth(receiveTokenImpl).currencyKey()\n            );\n        return (ISnxProxy(SNX).target(), 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _sendToken,\n        address, /* _receiveToken */\n        uint256 _sendQuantity\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_sendToken == DAI) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 0, 3, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        if (_sendToken == USDC) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 0, 1, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return post action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * @param  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address, /* _sendToken */\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Burn sETH to WETH if needed\n        if (_receiveToken == DAI) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 3, 0, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        if (_receiveToken == USDC) {\n            bytes memory methodData =\n                abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 1, 0, _sendQuantity, 1);\n            return (curvesUSD, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Returns the address to approve the pre action. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getPreApprovalSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Returns the address to approve the post action. This is the TokenTaker address\n     *\n     * @param _swapTarget          Address of the contract that will execute the swap\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getPostApprovalSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    function _getPostActionToken(address _receiveToken) internal pure override returns (address) {\n        if (_receiveToken == DAI || _receiveToken == USDC) {\n            return sUSD;\n        }\n        return _receiveToken;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getTokens(\n        address _sendToken,\n        address _receiveToken,\n        uint256, /* _sendQuantity */\n        address _strategy\n    )\n        private\n        view\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        ISynthetix synthetix = ISynthetix(ISnxProxy(SNX).target());\n        if (_sendToken == DAI || _sendToken == USDC) {\n            _sendToken = sUSD;\n        }\n        if (_receiveToken == DAI || _receiveToken == USDC) {\n            _receiveToken = sUSD;\n        }\n        address sendTokenImpl;\n        address receiveTokenImpl;\n        try synthetix.synths(stringToBytes32(ERC20(_sendToken).symbol())) returns (ISnxSynth _synth) {\n            sendTokenImpl = address(_synth);\n        } catch {\n            sendTokenImpl = address(0);\n        }\n        try synthetix.synths(stringToBytes32(ERC20(_receiveToken).symbol())) returns (ISnxSynth _synth) {\n            receiveTokenImpl = address(_synth);\n        } catch {\n            receiveTokenImpl = address(0);\n        }\n        return (sendTokenImpl, receiveTokenImpl, ERC20(_sendToken).balanceOf(_strategy));\n    }\n\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxEtherWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/idepot\ninterface ISnxEtherWrapper {\n    // Mints sEth. WETH -> sETH. Needs approval\n    function mint(uint256 _amount) external;\n\n    // Burns sETH. sETH -> WETH\n    function burn(uint256 _amount) external;\n\n    function capacity() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/synthetix/ISnxDepot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/idepot\ninterface ISnxDepot {\n    // Views\n    function fundsWallet() external view returns (address payable);\n\n    function maxEthPurchase() external view returns (uint256);\n\n    function minimumDepositAmount() external view returns (uint256);\n\n    function synthsReceivedForEther(uint256 amount) external view returns (uint256);\n\n    function totalSellableDeposits() external view returns (uint256);\n\n    // Mutative functions\n    function depositSynths(uint256 amount) external;\n\n    function exchangeEtherForSynths() external payable returns (uint256);\n\n    function exchangeEtherForSynthsAtRate(uint256 guaranteedRate) external payable returns (uint256);\n\n    function withdrawMyDepositedSynths() external;\n\n    // Note: On mainnet no SNX has been deposited. The following functions are kept alive for testnet SNX faucets.\n    function exchangeEtherForSNX() external payable returns (uint256);\n\n    function exchangeEtherForSNXAtRate(uint256 guaranteedRate, uint256 guaranteedSynthetixRate)\n        external\n        payable\n        returns (uint256);\n\n    function exchangeSynthsForSNX(uint256 synthAmount) external returns (uint256);\n\n    function synthetixReceivedForEther(uint256 amount) external view returns (uint256);\n\n    function synthetixReceivedForSynths(uint256 amount) external view returns (uint256);\n\n    function withdrawSynthetix(uint256 amount) external;\n}\n"
    },
    "contracts/integrations/passive/YearnVaultIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IYearnRegistry} from '../../interfaces/external/yearn/IYearnRegistry.sol';\nimport {IYearnVault} from '../../interfaces/external/yearn/IYearnVault.sol';\n\n/**\n * @title YearnIntegration\n * @author Babylon Finance Protocol\n *\n * Yearn v2 Vault Integration\n */\ncontract YearnVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IYearnRegistry private constant registry = IYearnRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('yearnvaultsv2', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(\n        address _asset,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _asset;\n    }\n\n    function _getExpectedShares(address _asset, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Yearn\n        return\n            _amount.preciseDiv(IYearnVault(_asset).pricePerShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_asset).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _asset) internal view override returns (uint256) {\n        return IYearnVault(_asset).pricePerShare();\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address) {\n        return IYearnVault(_asset).token();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.deposit.selector, _maxAmountIn);\n\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IYearnVault.withdraw.selector, _investmentTokensIn);\n\n        return (_asset, 0, methodData);\n    }\n}\n"
    },
    "contracts/integrations/passive/StakewiseIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IrETH2} from '../../interfaces/external/stakewise/IrETH2.sol';\n\n/**\n * @title StakewiseIntegration\n * @author Babylon Finance Protocol\n *\n * StakewiseIntegration\n */\ncontract StakewiseIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IERC20 private constant sETH2 = IERC20(0xFe2e637202056d30016725477c5da089Ab0A043A);\n    IrETH2 private constant rETH2 = IrETH2(0x20BC832ca081b91433ff6c17f85701B6e92486c5);\n    // uint256 private constant INSTANT_LIMIT = 321e18; // 32 ETH\n    // address private constant stakeWisePool = 0xc874b064f465bdd6411d45734b56fac750cda29a;\n\n    uint24 private constant FEE_LOW = 500;\n    uint24 private constant FEE_MEDIUM = 3000;\n\n    // Address of Uniswap V3 SwapRouter contract\n    address private constant swapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('stakewise', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(\n        address, /* _asset */\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return swapRouter;\n    }\n\n    function _getExpectedShares(\n        address, /* _asset */\n        uint256 _amount\n    ) internal pure override returns (uint256) {\n        return _amount;\n    }\n\n    function _getPricePerShare(\n        address /* _asset */\n    ) internal pure override returns (uint256) {\n        return 1e18;\n    }\n\n    function _getInvestmentAsset(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        return WETH;\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * @param  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the vault\n     * @param  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address _strategy,\n        address, /* _asset */\n        uint256 _investmentTokensOut,\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Buy on univ3 directly\n        bytes memory path = abi.encodePacked(WETH, FEE_MEDIUM, address(sETH2));\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(path, _strategy, block.timestamp, _maxAmountIn, _investmentTokensOut);\n\n        // Buy sETH2 on univ3\n        bytes memory methodData =\n            abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n        return (swapRouter, 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * @param  _op                       Type of op\n     * @param  _strategy                 Address of the strategy\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 _op,\n        address _strategy\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Sell rETH2 on exit\n        if (_op == 1) {\n            bytes memory path = abi.encodePacked(address(rETH2), FEE_LOW, address(sETH2));\n            uint256 rewardsBalance = rETH2.balanceOf(_strategy);\n            // Enough rewards\n            if (rewardsBalance > 2e16) {\n                ISwapRouter.ExactInputParams memory params =\n                    ISwapRouter.ExactInputParams(\n                        path,\n                        _strategy,\n                        block.timestamp,\n                        rewardsBalance,\n                        rewardsBalance.preciseMul(98e16) // 2% slippage\n                    );\n\n                // Sell rETH2 on univ3\n                bytes memory methodData =\n                    abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n                return (swapRouter, 0, methodData);\n            }\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address _strategy,\n        address, /* _asset */\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 _minAmountOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        bytes memory path = abi.encodePacked(address(sETH2), FEE_MEDIUM, WETH);\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(path, _strategy, block.timestamp, _investmentTokensIn, _minAmountOut);\n\n        // Sell sETH2 on univ3\n        bytes memory methodData =\n            abi.encodeWithSignature('exactInput((bytes,address,uint256,uint256,uint256))', params);\n        return (swapRouter, 0, methodData);\n    }\n\n    function _preActionNeedsApproval() internal pure override returns (address) {\n        return address(rETH2);\n    }\n\n    function _getRewards(\n        address _strategy,\n        address //_investmentAddress\n    ) internal view override returns (address, uint256) {\n        return (address(rETH2), rETH2.balanceOf(_strategy));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/external/stakewise/IrETH2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\n\n/**\n * @dev Interface of the RewardEthToken contract.\n */\ninterface IrETH2 is IERC20Upgradeable {\n    /**\n     * @dev Structure for storing information about user reward checkpoint.\n     * @param rewardPerToken - user reward per token.\n     * @param reward - user reward checkpoint.\n     */\n    struct Checkpoint {\n        uint128 reward;\n        uint128 rewardPerToken;\n    }\n\n    /**\n     * @dev Event for tracking updated protocol fee recipient.\n     * @param recipient - address of the new fee recipient.\n     */\n    event ProtocolFeeRecipientUpdated(address recipient);\n\n    /**\n     * @dev Event for tracking updated protocol fee.\n     * @param protocolFee - new protocol fee.\n     */\n    event ProtocolFeeUpdated(uint256 protocolFee);\n\n    /**\n     * @dev Event for tracking whether rewards distribution through merkle distributor is enabled/disabled.\n     * @param account - address of the account.\n     * @param isDisabled - whether rewards distribution is disabled.\n     */\n    event RewardsToggled(address indexed account, bool isDisabled);\n\n    /**\n     * @dev Event for tracking rewards update by oracles.\n     * @param periodRewards - rewards since the last update.\n     * @param totalRewards - total amount of rewards.\n     * @param rewardPerToken - calculated reward per token for account reward calculation.\n     * @param distributorReward - distributor reward.\n     * @param protocolReward - protocol reward.\n     */\n    event RewardsUpdated(\n        uint256 periodRewards,\n        uint256 totalRewards,\n        uint256 rewardPerToken,\n        uint256 distributorReward,\n        uint256 protocolReward\n    );\n\n    /**\n     * @dev Function for upgrading the RewardEthToken contract. The `initialize` function must be defined\n     * if deploying contract for the first time that will initialize the state variables above.\n     * @param _oracles - address of the Oracles contract.\n     */\n    function upgrade(address _oracles) external;\n\n    /**\n     * @dev Function for getting the address of the merkle distributor.\n     */\n    function merkleDistributor() external view returns (address);\n\n    /**\n     * @dev Function for getting the address of the protocol fee recipient.\n     */\n    function protocolFeeRecipient() external view returns (address);\n\n    /**\n     * @dev Function for changing the protocol fee recipient's address.\n     * @param recipient - new protocol fee recipient's address.\n     */\n    function setProtocolFeeRecipient(address recipient) external;\n\n    /**\n     * @dev Function for getting protocol fee. The percentage fee users pay from their reward for using the pool service.\n     */\n    function protocolFee() external view returns (uint256);\n\n    /**\n     * @dev Function for changing the protocol fee.\n     * @param _protocolFee - new protocol fee. Must be less than 10000 (100.00%).\n     */\n    function setProtocolFee(uint256 _protocolFee) external;\n\n    /**\n     * @dev Function for retrieving the total rewards amount.\n     */\n    function totalRewards() external view returns (uint128);\n\n    /**\n     * @dev Function for retrieving the last total rewards update block number.\n     */\n    function lastUpdateBlockNumber() external view returns (uint256);\n\n    /**\n     * @dev Function for retrieving current reward per token used for account reward calculation.\n     */\n    function rewardPerToken() external view returns (uint128);\n\n    /**\n     * @dev Function for setting whether rewards are disabled for the account.\n     * Can only be called by the `StakedEthToken` contract.\n     * @param account - address of the account to disable rewards for.\n     * @param isDisabled - whether the rewards will be disabled.\n     */\n    function setRewardsDisabled(address account, bool isDisabled) external;\n\n    /**\n     * @dev Function for retrieving account's current checkpoint.\n     * @param account - address of the account to retrieve the checkpoint for.\n     */\n    function checkpoints(address account) external view returns (uint128, uint128);\n\n    /**\n     * @dev Function for checking whether account's reward will be distributed through the merkle distributor.\n     * @param account - address of the account.\n     */\n    function rewardsDisabled(address account) external view returns (bool);\n\n    /**\n     * @dev Function for updating account's reward checkpoint.\n     * @param account - address of the account to update the reward checkpoint for.\n     */\n    function updateRewardCheckpoint(address account) external returns (bool);\n\n    /**\n     * @dev Function for updating reward checkpoints for two accounts simultaneously (for gas savings).\n     * @param account1 - address of the first account to update the reward checkpoint for.\n     * @param account2 - address of the second account to update the reward checkpoint for.\n     */\n    function updateRewardCheckpoints(address account1, address account2) external returns (bool, bool);\n\n    /**\n     * @dev Function for updating validators total rewards.\n     * Can only be called by Oracles contract.\n     * @param newTotalRewards - new total rewards.\n     */\n    function updateTotalRewards(uint256 newTotalRewards) external;\n\n    /**\n     * @dev Function for claiming rETH2 from the merkle distribution.\n     * Can only be called by MerkleDistributor contract.\n     * @param account - address of the account the tokens will be assigned to.\n     * @param amount - amount of tokens to assign to the account.\n     */\n    function claim(address account, uint256 amount) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/gardens/StrategyGardenModule.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IStrategyGarden} from '../interfaces/IGarden.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\n\nimport {VTableBeaconProxy} from '../proxy/VTableBeaconProxy.sol';\nimport {VTableBeacon} from '../proxy/VTableBeacon.sol';\n\nimport {BaseGardenModule} from './BaseGardenModule.sol';\nimport {ControllerLib} from '../lib/ControllerLib.sol';\n\n/**\n * @title StrategyGardenModule\n *\n * Strategy related functions of the Garden contract\n */\ncontract StrategyGardenModule is BaseGardenModule, IStrategyGarden {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n    using ControllerLib for IBabController;\n\n    /* ============ Events ============ */\n    event AddStrategy(address indexed _strategy, string _name, uint256 _expectedReturn);\n\n    /* ============ Constants ============ */\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // Strategy cooldown period\n    uint256 private constant MIN_COOLDOWN_PERIOD = 60 seconds;\n    uint256 private constant MAX_COOLDOWN_PERIOD = 7 days;\n    uint256 private constant MAX_TOTAL_STRATEGIES = 20; // Max number of strategies\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Modifiers ============ */\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!controller.isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Throws if the sender is not an strategy of this garden\n     */\n    function _onlyStrategy() private view {\n        _require(strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n    }\n\n    /* ============ Constructor ============ */\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice\n     *  When strategy ends puts saves returns, rewards and marks strategy as\n     *  finalized.\n     *\n     * @param _rewards        Amount of Reserve Asset to set aside forever\n     * @param _returns        Profits or losses that the strategy received\n     * @param _burningAmount  The amount of strategist stake to burn in case of\n     *                        strategy losses.\n     */\n    function finalizeStrategy(\n        uint256 _rewards,\n        int256 _returns,\n        uint256 _burningAmount\n    ) external override nonReentrant {\n        _onlyUnpaused();\n        _onlyStrategy();\n\n        // burn stategist stake\n        address strategist = IStrategy(msg.sender).strategist();\n        if (_burningAmount > 0) {\n            if (_burningAmount >= balanceOf(strategist)) {\n                // Avoid underflow condition\n                _burningAmount = balanceOf(strategist);\n            }\n            _burn(strategist, _burningAmount);\n        }\n        uint256 stake = IStrategy(msg.sender).stake();\n        uint256 lockedBalance = contributors[strategist].lockedBalance;\n        contributors[strategist].lockedBalance = lockedBalance > stake ? lockedBalance.sub(stake) : 0;\n\n        reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.add(_rewards);\n\n        // Mark strategy as finalized\n        absoluteReturns = absoluteReturns.add(_returns);\n        strategies = strategies.remove(msg.sender);\n        finalizedStrategies.push(msg.sender);\n        strategyMapping[msg.sender] = false;\n        if (address(this) == address(IHeart(controller.heart()).heartGarden())) {\n            // BABL Rewards are sent to the heart Garden during finalization, no claim option afterwards for users\n            // _rewards (set aside) must also be zero in this case\n            rewardsDistributor.sendBABLToContributor(address(this), IStrategy(msg.sender).strategyRewards());\n        }\n    }\n\n    /**\n     * PRIVILEGE FUNCTION to update Garden Strategy Rewards\n     * To be used by Governance or Emergency only.\n     *\n     * @param _strategy   Address of the strategy to patch\n     * @param _newTotalAmount  The new BABL rewards\n     */\n    function updateStrategyRewards(\n        address _strategy,\n        uint256 _newTotalAmount,\n        uint256 _newCapitalReturned\n    ) external override {\n        controller.onlyGovernanceOrEmergency();\n        _require(isGardenStrategy[_strategy] && !strategyMapping[_strategy], Errors.STRATEGY_GARDEN_MISMATCH);\n        uint256 oldRewards = IStrategy(_strategy).strategyRewards();\n        if (address(this) == address(IHeart(controller.heart()).heartGarden()) && oldRewards < _newTotalAmount) {\n            // Send difference if Heart Garden Strategy got less rewards\n            rewardsDistributor.sendBABLToContributor(address(this), _newTotalAmount.sub(oldRewards));\n        }\n        // update profit returns\n        int256 diff = int256(_newCapitalReturned).sub(int256(IStrategy(_strategy).capitalReturned()));\n        absoluteReturns = absoluteReturns.add(diff);\n        // update BABL Mining strategy rewards\n        IStrategy(_strategy).updateStrategyRewards(_newTotalAmount, _newCapitalReturned);\n    }\n\n    /**\n     * @notice\n     *   Pays gas costs back to the keeper from executing transactions\n     *   including the past debt\n     * @dev\n     *   We assume that calling keeper functions should be less expensive than 2000 DAI.\n     * @param _keeper  Keeper that executed the transaction\n     * @param _fee     The fee paid to keeper to compensate the gas cost\n     */\n    function payKeeper(address payable _keeper, uint256 _fee) public override nonReentrant {\n        _onlyUnpaused();\n        _require(msg.sender == address(this) || strategyMapping[msg.sender], Errors.ONLY_STRATEGY);\n        _require(controller.isValidKeeper(_keeper), Errors.ONLY_KEEPER);\n\n        uint256 pricePerTokenUnitInDAI = IPriceOracle(controller.priceOracle()).getPrice(reserveAsset, DAI);\n        uint256 feeInDAI =\n            pricePerTokenUnitInDAI.preciseMul(_fee).mul(\n                10**(uint256(18).sub(ERC20Upgradeable(reserveAsset).decimals()))\n            );\n\n        _require(feeInDAI <= 2000 * 1e18, Errors.FEE_TOO_HIGH);\n\n        keeperDebt = keeperDebt.add(_fee);\n        uint256 liquidReserve = _liquidReserve();\n        // Pay Keeper in Reserve Asset\n        if (keeperDebt > 0 && liquidReserve > 0) {\n            uint256 toPay = liquidReserve > keeperDebt ? keeperDebt : liquidReserve;\n            IERC20(reserveAsset).safeTransfer(_keeper, toPay);\n            totalKeeperFees = totalKeeperFees.add(toPay);\n            keeperDebt = keeperDebt.sub(toPay);\n        }\n    }\n\n    /**\n     * Creates a new strategy calling the factory and adds it to the array\n     * @param _name                          Name of the strategy\n     * @param _symbol                        Symbol of the strategy\n     * @param _stratParams                   Num params for the strategy\n     * @param _opTypes                      Type for every operation in the strategy\n     * @param _opIntegrations               Integration to use for every operation\n     * @param _opEncodedDatas               Param for every operation in the strategy\n     */\n    function addStrategy(\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _stratParams,\n        uint8[] calldata _opTypes,\n        address[] calldata _opIntegrations,\n        bytes calldata _opEncodedDatas\n    ) external override {\n        _onlyUnpaused();\n        _require(balanceOf(msg.sender) > 0, Errors.ONLY_CONTRIBUTOR);\n        bool canCreateStrategy =\n            publicStrategists ||\n                IMardukGate(controller.mardukGate()).canAddStrategiesInAGarden(address(this), msg.sender);\n        _require(canCreateStrategy, Errors.USER_CANNOT_ADD_STRATEGIES);\n        _require(strategies.length < MAX_TOTAL_STRATEGIES, Errors.VALUE_TOO_HIGH);\n        address strategy =\n            IStrategyFactory(controller.strategyFactory()).createStrategy(\n                _name,\n                _symbol,\n                msg.sender,\n                address(this),\n                _stratParams\n            );\n        strategyMapping[strategy] = true;\n        totalStake = totalStake.add(_stratParams[1]);\n        contributors[msg.sender].lockedBalance = contributors[msg.sender].lockedBalance.add(_stratParams[1]);\n        strategies.push(strategy);\n        IStrategy(strategy).setData(_opTypes, _opIntegrations, _opEncodedDatas);\n        isGardenStrategy[strategy] = true;\n        emit AddStrategy(strategy, _name, _stratParams[3]);\n    }\n\n    /**\n     * Allocates garden capital to an strategy\n     *\n     * @param _capital        Amount of capital to allocate to the strategy\n     */\n    function allocateCapitalToStrategy(uint256 _capital) external override {\n        _onlyStrategy();\n\n        uint256 protocolMgmtFee = controller.protocolManagementFee().preciseMul(_capital);\n        _require(_capital.add(protocolMgmtFee) <= _liquidReserve(), Errors.MIN_LIQUIDITY);\n\n        // Take protocol mgmt fee to the heart\n        IERC20(reserveAsset).safeTransfer(controller.heart(), protocolMgmtFee);\n\n        // Send Capital to strategy\n        IERC20(reserveAsset).safeTransfer(msg.sender, _capital);\n    }\n\n    /*\n     * Remove an expire candidate from the strategy Array\n     * @param _strategy      Strategy to remove\n     */\n    function expireCandidateStrategy(address _strategy) external override {\n        _onlyStrategy();\n        strategies = strategies.remove(_strategy);\n        strategyMapping[_strategy] = false;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gets liquid reserve available for to Garden.\n     */\n    function _liquidReserve() private view returns (uint256) {\n        uint256 reserve = IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetRewardsSetAside);\n        return reserve > keeperDebt ? reserve.sub(keeperDebt) : 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/proxy/VTableBeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/proxy/Proxy.sol';\n\nimport './VTableBeacon.sol';\n\n/**\n * @title VTableBeaconProxy\n */\ncontract VTableBeaconProxy is Proxy {\n    VTableBeacon public immutable beacon;\n\n    constructor(VTableBeacon _beacon) {\n        beacon = _beacon;\n    }\n\n    function _implementation() internal view virtual override returns (address module) {\n        return beacon.implementation(msg.sig);\n    }\n}\n"
    },
    "contracts/proxy/VTableBeacon.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n/**\n * @title VTableBeacon\n * @notice Redirects calls to an implementation based on the method signature\n */\ncontract VTableBeacon is Ownable {\n    struct ModuleDefinition {\n        address implementation;\n        bytes4[] selectors;\n    }\n\n    bytes4 private constant _FALLBACK_SIGN = 0xffffffff;\n\n    // Mapping of methods signatures to their implementations\n    mapping(bytes4 => address) public delegates;\n\n    event VTableUpdate(bytes4 indexed selector, address oldImplementation, address newImplementation);\n\n    function implementation(bytes4 _selector) external view virtual returns (address module) {\n        module = delegates[_selector];\n        if (module != address(0)) return module;\n\n        module = delegates[_FALLBACK_SIGN];\n        if (module != address(0)) return module;\n\n        revert('VTableBeacon: No implementation found');\n    }\n\n    /**\n     * @dev Updates the vtable\n     */\n    function updateVTable(ModuleDefinition[] calldata modules) external onlyOwner {\n        for (uint256 i = 0; i < modules.length; ++i) {\n            ModuleDefinition memory module = modules[i];\n            for (uint256 j = 0; j < module.selectors.length; ++j) {\n                bytes4 selector = module.selectors[j];\n                emit VTableUpdate(selector, delegates[selector], module.implementation);\n                delegates[selector] = module.implementation;\n            }\n        }\n    }\n}\n"
    },
    "contracts/gardens/BaseGardenModule.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\n\nimport {VTableBeaconProxy} from '../proxy/VTableBeaconProxy.sol';\nimport {VTableBeacon} from '../proxy/VTableBeacon.sol';\n\n/**\n * @title BaseGardenModule\n *\n * Class that every GardenModule should inherit\n */\ncontract BaseGardenModule is ERC20Upgradeable, ReentrancyGuard {\n    /* ============ Events ============ */\n\n    /* ============ Constants ============ */\n\n    uint8 internal constant MAX_EXTRA_CREATORS = 4;\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address internal reserveAsset;\n\n    // Address of the controller\n    IBabController internal controller;\n\n    // Address of the rewards distributor\n    IRewardsDistributor internal rewardsDistributor;\n\n    // The person that creates the garden\n    address internal creator;\n\n    bool internal active; // DEPRECATED;\n    bool internal privateGarden;\n\n    uint256 internal principal; // DEPRECATED;\n\n    // The amount of funds set aside to be paid as rewards. Should NEVER be spent\n    // on anything else ever.\n    uint256 internal reserveAssetRewardsSetAside;\n\n    uint256 internal reserveAssetPrincipalWindow; // DEPRECATED\n    int256 internal absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 internal minLiquidityAsset;\n\n    uint256 internal depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    uint256 internal withdrawalsOpenUntil; // DEPRECATED\n\n    // Contributors\n    mapping(address => IGarden.Contributor) internal contributors;\n    uint256 internal totalContributors;\n    uint256 internal maxContributors; // DEPRECATED\n    uint256 internal maxDepositLimit; // Limits the amount of deposits\n\n    uint256 internal gardenInitializedAt; // Garden Initialized at timestamp\n    // Number of garden checkpoints used to control the garden power and each contributor power with accuracy\n    uint256 internal pid;\n\n    // Min contribution in the garden\n    uint256 internal minContribution; //wei\n    uint256 internal minGardenTokenSupply; // DEPRECATED\n\n    // Strategies variables\n    uint256 internal totalStake;\n    uint256 internal minVotesQuorum; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 internal minVoters;\n    uint256 internal minStrategyDuration; // Min duration for an strategy\n    uint256 internal maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 internal strategyCooldownPeriod;\n\n    address[] internal strategies; // Strategies that are either in candidate or active state\n    address[] internal finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) internal strategyMapping;\n    mapping(address => bool) internal isGardenStrategy; // Security control mapping\n\n    // Keeper debt in reserve asset if any, repaid upon every strategy finalization\n    uint256 internal keeperDebt;\n    uint256 internal totalKeeperFees;\n\n    // Allow internal strategy creators for certain gardens\n    bool internal publicStrategists;\n\n    // Allow public strategy stewards for certain gardens\n    bool internal publicStewards;\n\n    // Addresses for extra creators\n    address[MAX_EXTRA_CREATORS] internal extraCreators;\n\n    // last recorded price per share of the garden during deposit or withdrawal operation\n    uint256 internal lastPricePerShare;\n\n    // last recorded time of the deposit or withdraw in seconds\n    uint256 internal lastPricePerShareTS;\n\n    // Decay rate of the slippage for pricePerShare over time\n    uint256 internal pricePerShareDecayRate;\n\n    // Base slippage for pricePerShare of the garden\n    uint256 internal pricePerShareDelta;\n\n    // Whether or not governance has verified and the category\n    uint256 internal verifiedCategory;\n\n    // Variable that overrides the depositLock with a global one\n    uint256 internal hardlockStartsAt;\n\n    // EIP-1271 signer\n    address internal signer;\n    // Variable that controls whether the NFT can be minted after x amount of time\n    uint256 internal canMintNftAfter;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constructor ============ */\n\n    /* ============ External Functions ============ */\n\n    /* ============ External Getter Functions ============ */\n\n    /* ============ Internal Functions ============ */\n}\n"
    },
    "contracts/gardens/Garden.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\nimport {SignatureChecker} from '../lib/SignatureChecker.sol';\n\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden, ICoreGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IHeart} from '../interfaces/IHeart.sol';\nimport {IERC1271} from '../interfaces/IERC1271.sol';\n\nimport {VTableBeaconProxy} from '../proxy/VTableBeaconProxy.sol';\nimport {VTableBeacon} from '../proxy/VTableBeacon.sol';\n\n/**\n * @title BaseGarden\n *\n * User facing features of Garden plus BeaconProxy\n */\ncontract Garden is ERC20Upgradeable, ReentrancyGuard, VTableBeaconProxy, ICoreGarden, IERC1271 {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n\n    // DO NOT TOUCH for the love of GOD\n    event GardenDeposit(address indexed _to, uint256 reserveToken, uint256 reserveTokenQuantity, uint256 timestamp);\n    event GardenWithdrawal(\n        address indexed _from,\n        address indexed _to,\n        uint256 reserveToken,\n        uint256 reserveTokenQuantity,\n        uint256 timestamp\n    );\n\n    event RewardsForContributor(address indexed _contributor, uint256 indexed _amount);\n    event BABLRewardsForContributor(address indexed _contributor, uint256 _rewards);\n    event StakeBABLRewards(address indexed _contributor, uint256 _babl);\n\n    /* ============ Constants ============ */\n\n    // Wrapped ETH address\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IERC20 private constant BABL = IERC20(0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74);\n\n    // Strategy cooldown period\n    uint256 private constant MIN_COOLDOWN_PERIOD = 60 seconds;\n    uint256 private constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    uint8 private constant MAX_EXTRA_CREATORS = 4;\n    uint256 private constant EARLY_WITHDRAWAL_PENALTY = 25e15;\n    uint256 private constant TEN_PERCENT = 1e17;\n\n    bytes32 private constant DEPOSIT_BY_SIG_TYPEHASH =\n        keccak256(\n            'DepositBySig(uint256 _amountIn,uint256 _minAmountOut,uint256 _nonce,uint256 _maxFee,address _to,address _referrer)'\n        );\n    bytes32 private constant WITHDRAW_BY_SIG_TYPEHASH =\n        keccak256(\n            'WithdrawBySig(uint256 _amountIn,uint256 _minAmountOut,uint256,_nonce,uint256 _maxFee,uint256 _withPenalty)'\n        );\n    bytes32 private constant REWARDS_BY_SIG_TYPEHASH =\n        keccak256('RewardsBySig(uint256 _babl,uint256 _profits,uint256 _nonce,uint256 _maxFee)');\n\n    bytes32 private constant STAKE_REWARDS_BY_SIG_TYPEHASH =\n        keccak256(\n            'StakeRewardsBySig(uint256 _babl,uint256 _profits,uint256 _minAmountOut,uint256 _nonce,uint256 _nonceHeart,uint256 _maxFee,address _to)'\n        );\n\n    uint256 private constant CLAIM_BY_SIG_CAP = 5_500e18; // 5.5K BABL cap per user per bySig tx\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    // Reserve Asset of the garden\n    address public override reserveAsset;\n\n    // Address of the controller\n    IBabController public override controller;\n\n    // Address of the rewards distributor\n    IRewardsDistributor private rewardsDistributor;\n\n    // The person that creates the garden\n    address public override creator;\n\n    bool private active; // DEPRECATED;\n    bool public override privateGarden;\n\n    uint256 private principal; // DEPRECATED;\n\n    // The amount of funds set aside to be paid as rewards. Should NEVER be spent\n    // on anything else ever.\n    uint256 public override reserveAssetRewardsSetAside;\n\n    uint256 private reserveAssetPrincipalWindow; // DEPRECATED\n    int256 public override absoluteReturns; // Total profits or losses of this garden\n\n    // Indicates the minimum liquidity the asset needs to have to be tradable by this garden\n    uint256 public override minLiquidityAsset;\n\n    uint256 public override depositHardlock; // Window of time after deposits when withdraws are disabled for that user\n    uint256 private withdrawalsOpenUntil; // DEPRECATED\n\n    // Contributors\n    mapping(address => IGarden.Contributor) private contributors;\n    uint256 public override totalContributors;\n    uint256 private maxContributors; // DEPRECATED\n    uint256 public override maxDepositLimit; // Limits the amount of deposits\n\n    uint256 public override gardenInitializedAt; // Garden Initialized at timestamp\n    // Number of garden checkpoints used to control the garden power and each contributor power with accuracy\n    uint256 private pid;\n\n    // Min contribution in the garden\n    uint256 public override minContribution; //wei\n    uint256 private minGardenTokenSupply; // DEPRECATED\n\n    // Strategies variables\n    uint256 public override totalStake;\n    uint256 public override minVotesQuorum; // 10%. (0.01% = 1e14, 1% = 1e16)\n    uint256 public override minVoters;\n    uint256 public override minStrategyDuration; // Min duration for an strategy\n    uint256 public override maxStrategyDuration; // Max duration for an strategy\n    // Window for the strategy to cooldown after approval before receiving capital\n    uint256 public override strategyCooldownPeriod;\n\n    address[] private strategies; // Strategies that are either in candidate or active state\n    address[] private finalizedStrategies; // Strategies that have finalized execution\n    mapping(address => bool) public override strategyMapping;\n    mapping(address => bool) public override isGardenStrategy; // Security control mapping\n\n    // Keeper debt in reserve asset if any, repaid upon every strategy finalization\n    uint256 public override keeperDebt;\n    uint256 public override totalKeeperFees;\n\n    // Allow public strategy creators for certain gardens\n    bool public override publicStrategists;\n\n    // Allow public strategy stewards for certain gardens\n    bool public override publicStewards;\n\n    // Addresses for extra creators\n    address[MAX_EXTRA_CREATORS] public override extraCreators;\n\n    // last recorded price per share of the garden during deposit or withdrawal operation\n    uint256 public override lastPricePerShare;\n\n    // last recorded time of the deposit or withdraw in seconds\n    uint256 public override lastPricePerShareTS;\n\n    // Decay rate of the slippage for pricePerShare over time\n    uint256 public override pricePerShareDecayRate;\n\n    // Base slippage for pricePerShare of the garden\n    uint256 public override pricePerShareDelta;\n\n    // Whether or not governance has verified and the category\n    uint256 public override verifiedCategory;\n\n    // Variable that overrides the depositLock with a global one\n    uint256 public override hardlockStartsAt;\n\n    // EIP-1271 signer\n    address private signer;\n    // Variable that controls whether the NFT can be minted after x amount of time\n    uint256 public override canMintNftAfter;\n\n    /* ============ Modifiers ============ */\n\n    function _onlyUnpaused() private view {\n        // Do not execute if Globally or individually paused\n        _require(!controller.isPaused(address(this)), Errors.ONLY_UNPAUSED);\n    }\n\n    /**\n     * Check if msg.sender is keeper\n     */\n    function _onlyKeeperAndFee(uint256 _fee, uint256 _maxFee) private view {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n        _require(_fee <= _maxFee, Errors.FEE_TOO_HIGH);\n    }\n\n    /**\n     * Check if is a valid _signer with a valid nonce\n     */\n    function _onlyValidSigner(\n        address _signer,\n        address _to,\n        uint256 _nonce,\n        bytes32 _hash,\n        bytes memory _signature\n    ) private view {\n        _require(contributors[_to].nonce == _nonce, Errors.INVALID_NONCE);\n        // to prevent replay attacks\n        _require(_signer.isValidSignatureNow(_hash, _signature), Errors.INVALID_SIGNER);\n    }\n\n    function _onlyNonZero(address _address) private pure {\n        _require(_address != address(0), Errors.ADDRESS_IS_ZERO);\n    }\n\n    /* ============ Constructor ============ */\n\n    constructor(VTableBeacon _beacon) VTableBeaconProxy(_beacon) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice\n     *   Deposits the _amountIn in reserve asset into the garden. Gurantee to\n     *   recieve at least _minAmountOut.\n     * @dev\n     *   WARN: If the reserve asset is different than ETH the sender needs to\n     *   have approved the garden.\n     *   Efficient to use of strategies.length == 0, otherwise can consume a lot\n     *   of gas ~2kk. Use `depositBySig` for gas efficiency.\n     * @param _amountIn               Amount of the reserve asset that is received from contributor\n     * @param _minAmountOut           Min amount of Garden shares to receive by contributor\n     * @param _to                     Address to mint Garden shares to\n     * @param _referrer               The user that referred the deposit\n     */\n    function deposit(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        address _referrer\n    ) external payable override nonReentrant {\n        // calculate pricePerShare\n        // if there are no strategies then NAV === liquidReserve\n\n        _internalDeposit(_amountIn, _minAmountOut, _to, msg.sender, _getPricePerShare(), minContribution, _referrer);\n    }\n\n    /**\n     * @notice\n     *   Deposits the _amountIn in reserve asset into the garden. Gurantee to\n     *   recieve at least _minAmountOut.\n     * @param _amountIn               Amount of the reserve asset that is received from contributor.\n     * @param _minAmountOut           Min amount of Garden shares to receive by contributor.\n     * @param _nonce                  Current nonce to prevent replay attacks.\n     * @param _maxFee                 Max fee user is willing to pay keeper. Fee is\n     *                                substracted from the withdrawn amount. Fee is\n     *                                expressed in reserve asset.\n     * @param _pricePerShare          Price per share of the garden calculated off-chain by Keeper.\n     * @param _to                     Address to mint shares to.\n     * @param _fee                    Actual fee keeper demands. Have to be less than _maxFee.\n     * @param _signer                 The user to who signed the signature.\n     * @param _referrer               The user that referred the deposit\n     * @param _signature              Signature by the user to verify deposit parmas.\n     */\n    function depositBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        address _to,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _signer,\n        address _referrer,\n        bytes memory _signature\n    ) external override nonReentrant {\n        _onlyKeeperAndFee(_fee, _maxFee);\n\n        bytes32 hash =\n            keccak256(\n                abi.encode(\n                    DEPOSIT_BY_SIG_TYPEHASH,\n                    address(this),\n                    _amountIn,\n                    _minAmountOut,\n                    _nonce,\n                    _maxFee,\n                    _to,\n                    _referrer\n                )\n            )\n                .toEthSignedMessageHash();\n        _onlyValidSigner(_signer, _to, _nonce, hash, _signature);\n\n        // If a Keeper fee is greater than zero then reduce user shares to\n        // exchange and pay keeper the fee.\n        if (_fee > 0) {\n            // account for non 18 decimals ERC20 tokens, e.g. USDC\n            uint256 feeShares = _reserveToShares(_fee, _pricePerShare);\n            _internalDeposit(\n                _amountIn.sub(_fee),\n                _minAmountOut.sub(feeShares),\n                _to,\n                _signer,\n                _pricePerShare,\n                minContribution > _fee ? minContribution.sub(_fee) : 0,\n                _referrer\n            );\n            // pay Keeper the fee\n            IERC20(reserveAsset).safeTransferFrom(_signer, msg.sender, _fee);\n        } else {\n            _internalDeposit(_amountIn, _minAmountOut, _to, _signer, _pricePerShare, minContribution, _referrer);\n        }\n    }\n\n    /**\n     * @notice\n     *   Withdraws the reserve asset relative to the token participation in the garden\n     *   and sends it back to the sender.\n     * @dev\n     *   ATTENTION. Do not call withPenalty unless certain. If penalty is set,\n     *   it will be applied regardless of the garden state.\n     *   It is advised to first try to withdraw with no penalty and it this\n     *   reverts then try to with penalty.\n     * @param _amountIn         Quantity of the garden token to withdrawal\n     * @param _minAmountOut     Min quantity of reserve asset to receive\n     * @param _to               Address to send component assets to\n     * @param _withPenalty      Whether or not this is an immediate withdrawal\n     * @param _unwindStrategy   Strategy to unwind\n     */\n    function withdraw(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy\n    ) external override nonReentrant {\n        // Get valuation of the Garden with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n\n        _require(msg.sender == _to, Errors.ONLY_CONTRIBUTOR);\n        _withdrawInternal(\n            _amountIn,\n            _minAmountOut,\n            _to,\n            _withPenalty,\n            _unwindStrategy,\n            _getPricePerShare(),\n            _withPenalty ? IStrategy(_unwindStrategy).getNAV() : 0,\n            0\n        );\n    }\n\n    /**\n     * @notice\n     *   Exchanges user's gardens shairs for amount in reserve asset. This\n     *   method allows users to leave garden and reclaim their inital investment\n     *   plus profits or losses.\n     * @dev\n     *   Should be called instead of the `withdraw` to save gas due to\n     *   pricePerShare caculated off-chain. Doesn't allow to unwind strategies\n     *   contrary to `withdraw`.\n     *   The Keeper fee is paid out of user's shares.\n     *   The true _minAmountOut is actually _minAmountOut - _maxFee due to the\n     *   Keeper fee.\n     * @param _amountIn        Quantity of the garden tokens to withdraw.\n     * @param _minAmountOut    Min quantity of reserve asset to receive.\n     * @param _nonce           Current nonce to prevent replay attacks.\n     * @param _maxFee          Max fee user is willing to pay keeper. Fee is\n     *                         substracted from the withdrawn amount. Fee is\n     *                         expressed in reserve asset.\n     * @param _withPenalty     Whether or not this is an immediate withdrawal\n     * @param _unwindStrategy  Strategy to unwind\n     * @param _pricePerShare   Price per share of the garden calculated off-chain by Keeper.\n     * @param _strategyNAV     NAV of the strategy to unwind.\n     * @param _fee             Actual fee keeper demands. Have to be less than _maxFee.\n     * @param _signer          The user to who signed the signature\n     * @param _signature       Signature by the user to verify withdraw parmas.\n     */\n    function withdrawBySig(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee,\n        address _signer,\n        bytes memory _signature\n    ) external override nonReentrant {\n        _onlyKeeperAndFee(_fee, _maxFee);\n\n        bytes32 hash =\n            keccak256(\n                abi.encode(\n                    WITHDRAW_BY_SIG_TYPEHASH,\n                    address(this),\n                    _amountIn,\n                    _minAmountOut,\n                    _nonce,\n                    _maxFee,\n                    _withPenalty\n                )\n            )\n                .toEthSignedMessageHash();\n\n        _onlyValidSigner(_signer, _signer, _nonce, hash, _signature);\n\n        _withdrawInternal(\n            _amountIn,\n            _minAmountOut.sub(_maxFee),\n            payable(_signer),\n            _withPenalty,\n            _unwindStrategy,\n            _pricePerShare,\n            _strategyNAV,\n            _fee\n        );\n    }\n\n    /**\n     * User can claim the rewards from the strategies that his principal\n     * was invested in.\n     */\n    function claimReturns(address[] calldata _finalizedStrategies) external override nonReentrant {\n        uint256[] memory rewards = new uint256[](8);\n        rewards = rewardsDistributor.getRewards(address(this), msg.sender, _finalizedStrategies);\n        _sendRewardsInternal(msg.sender, rewards[5], rewards[6], false);\n    }\n\n    /**\n     * User can claim the rewards from the strategies that his principal\n     * was invested in and stake BABL into Heart Garden\n     */\n    function claimAndStakeReturns(uint256 _minAmountOut, address[] calldata _finalizedStrategies)\n        external\n        override\n        nonReentrant\n    {\n        uint256[] memory rewards = new uint256[](8);\n        rewards = rewardsDistributor.getRewards(address(this), msg.sender, _finalizedStrategies);\n        IGarden heartGarden = IGarden(address(IHeart(controller.heart()).heartGarden()));\n        // User non BABL rewards are sent to user wallet (_profits)\n        // User BABL rewards are sent to this garden from RD to stake them into Heart Garden\n        // on behalf of user\n        _sendRewardsInternal(msg.sender, rewards[5], rewards[6], true); // true = stake babl rewards, false = no stake\n        _approveBABL(address(heartGarden), rewards[5]);\n        heartGarden.deposit(rewards[5], _minAmountOut, msg.sender, address(0));\n        emit StakeBABLRewards(msg.sender, rewards[5]);\n    }\n\n    /**\n     * @notice\n     *   This method allows users\n     *   to claim their rewards either profits or BABL.\n     * @dev\n     *   Should be called instead of the `claimRewards at RD` to save gas due to\n     *   getRewards caculated off-chain.\n     *   The Keeper fee is paid out of user's reserveAsset and it is calculated off-chain.\n     *\n     * @param _babl            BABL rewards from mining program.\n     * @param _profits         Profit rewards in reserve asset.\n     * @param _nonce           Current nonce to prevent replay attacks.\n     * @param _maxFee          Max fee user is willing to pay keeper. Fee is\n     *                         substracted from user wallet in reserveAsset. Fee is\n     *                         expressed in reserve asset.\n     * @param _fee             Actual fee keeper demands. Have to be less than _maxFee.\n     * @param _signer          The user to who signed the signature\n     * @param _signature       Signature by the user to verify claim parmas.\n     */\n    function claimRewardsBySig(\n        uint256 _babl,\n        uint256 _profits,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _fee,\n        address _signer,\n        bytes memory _signature\n    ) external override nonReentrant {\n        _onlyKeeperAndFee(_fee, _maxFee);\n        bytes32 hash =\n            keccak256(abi.encode(REWARDS_BY_SIG_TYPEHASH, address(this), _babl, _profits, _nonce, _maxFee))\n                .toEthSignedMessageHash();\n        _require(_fee > 0, Errors.FEE_TOO_LOW);\n\n        _onlyValidSigner(_signer, _signer, _nonce, hash, _signature);\n        _require(_babl <= CLAIM_BY_SIG_CAP, Errors.MAX_BABL_CAP_REACHED);\n        // pay to Keeper the fee to execute the tx on behalf\n        IERC20(reserveAsset).safeTransferFrom(_signer, msg.sender, _fee);\n        _sendRewardsInternal(_signer, _babl, _profits, false);\n    }\n\n    /**\n     * @notice\n     *   This method allows users\n     *   to stake their BABL rewards and claim their profit rewards.\n     * @dev\n     *   Should be called instead of the `claimAndStakeReturns` to save gas due to\n     *   getRewards caculated off-chain.\n     *   The Keeper fee is paid out of user's reserveAsset and it is calculated off-chain.\n     *\n     * @param _babl            BABL rewards from mining program.\n     * @param _profits         Profit rewards in reserve asset.\n     * @param _minAmountOut    Minimum hBABL as part of the Heart Garden BABL staking\n     * @param _nonce           Current nonce of user in the claiming garden at to prevent replay attacks.\n     * @param _nonceHeart      Current nonce of user in Heart Garden to prevent replay attacks.\n     * @param _maxFee          Max fee user is willing to pay keeper. Fee is\n     *                         substracted from user wallet in reserveAsset. Fee is\n     *                         expressed in reserve asset.\n     * @param _fee             Actual fee keeper demands. Have to be less than _maxFee.\n     * @param _pricePerShare   Price per share of Heart Garden\n     * @param _signer          Signer of the tx\n     * @param _signature       Signature of signer\n     */\n    function claimAndStakeRewardsBySig(\n        uint256 _babl,\n        uint256 _profits,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _nonceHeart,\n        uint256 _maxFee,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _signer,\n        bytes memory _signature\n    ) external override nonReentrant {\n        _onlyKeeperAndFee(_fee, _maxFee);\n        IGarden heartGarden = IHeart(controller.heart()).heartGarden();\n        bytes32 hash =\n            keccak256(\n                abi.encode(\n                    STAKE_REWARDS_BY_SIG_TYPEHASH,\n                    address(heartGarden),\n                    _babl,\n                    _profits,\n                    _minAmountOut,\n                    _nonce,\n                    _nonceHeart,\n                    _maxFee,\n                    _signer\n                )\n            )\n                .toEthSignedMessageHash();\n        _onlyValidSigner(_signer, _signer, _nonce, hash, _signature);\n        _require(_fee > 0, Errors.FEE_TOO_LOW);\n        _require(_babl <= CLAIM_BY_SIG_CAP, Errors.MAX_BABL_CAP_REACHED);\n\n        // pay to Keeper the fee to execute the tx on behalf\n        IERC20(reserveAsset).safeTransferFrom(_signer, msg.sender, _fee);\n\n        // User non BABL rewards are sent to user wallet (_profits)\n        // User BABL rewards are sent to this garden from RD to later stake them into Heart Garden\n        // on behalf of the user\n        _sendRewardsInternal(_signer, _babl, _profits, true); // true = stake babl rewards, false = no stake\n        _approveBABL(address(heartGarden), _babl);\n        // grant permission to deposit\n        signer = _signer;\n        // Now this garden makes a deposit on Heart Garden on behalf of user\n        heartGarden.stakeBySig(\n            _babl,\n            _profits,\n            _minAmountOut,\n            _nonce,\n            _nonceHeart,\n            _maxFee,\n            _signer,\n            _pricePerShare,\n            address(this),\n            _signature\n        );\n        // revoke permission to deposit\n        signer = address(0);\n        emit StakeBABLRewards(_signer, _babl);\n    }\n\n    /**\n     * @notice\n     *   Deposits the _amountIn in reserve asset into the garden. Guarantee to\n     *   receive at least _minAmountOut.\n     * @param _amountIn               Amount of the reserve asset that is received from contributor.\n     * @param _profits                Amount of the reserve asset that is received from contributor.\n     * @param _minAmountOut           Min amount of Garden shares to receive by contributor.\n     * @param _nonce                  Current nonce to prevent replay attacks.\n     * @param _nonceHeart             Current nonce to prevent replay attacks.\n     * @param _maxFee                 Max fee user is willing to pay keeper. Fee is\n     *                                substracted from the withdrawn amount. Fee is\n     *                                expressed in reserve asset.\n     * @param _pricePerShare          Price per share of the garden calculated off-chain by Keeper.\n     * @param _to                     Address to mint shares to.\n     * @param _signer                 The user to who signed the signature.\n     * @param _signature              Signature by the user to verify deposit params.\n     */\n    function stakeBySig(\n        uint256 _amountIn,\n        uint256 _profits,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _nonceHeart,\n        uint256 _maxFee,\n        address _to,\n        uint256 _pricePerShare,\n        address _signer,\n        bytes memory _signature\n    ) external override nonReentrant {\n        _require(controller.isGarden(msg.sender), Errors.ONLY_ACTIVE_GARDEN);\n        _require(address(this) == address(IHeart(controller.heart()).heartGarden()), Errors.ONLY_HEART_GARDEN);\n\n        bytes32 hash =\n            keccak256(\n                abi.encode(\n                    STAKE_REWARDS_BY_SIG_TYPEHASH,\n                    address(this),\n                    _amountIn,\n                    _profits,\n                    _minAmountOut,\n                    _nonce,\n                    _nonceHeart,\n                    _maxFee,\n                    _to\n                )\n            )\n                .toEthSignedMessageHash();\n        _onlyValidSigner(_signer, _to, _nonceHeart, hash, _signature);\n\n        // Keeper fee must have been paid in the original garden\n        _internalDeposit(_amountIn, _minAmountOut, _to, _signer, _pricePerShare, minContribution, address(0));\n    }\n\n    /**\n     * @notice\n     *   Allows Garden contributors to claim an NFT.\n     */\n    function claimNFT() external override {\n        _require(balanceOf(msg.sender) > minContribution, Errors.ONLY_CONTRIBUTOR);\n        IGarden.Contributor storage contributor = contributors[msg.sender];\n        _require(\n            canMintNftAfter > 0 && block.timestamp.sub(contributor.initialDepositAt) > canMintNftAfter,\n            Errors.CLAIM_GARDEN_NFT\n        );\n        IGardenNFT(controller.gardenNFT()).grantGardenNFT(msg.sender);\n    }\n\n    /**\n     * Implements EIP-1271\n     */\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view override returns (bytes4 magicValue) {\n        return\n            ECDSA.recover(_hash, _signature) == signer && signer != address(0)\n                ? this.isValidSignature.selector\n                : bytes4(0);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Gets current strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getStrategies() external view override returns (address[] memory) {\n        return strategies;\n    }\n\n    /**\n     * Gets finalized strategies\n     *\n     * @return  address[]        Returns list of addresses\n     */\n\n    function getFinalizedStrategies() external view override returns (address[] memory) {\n        return finalizedStrategies;\n    }\n\n    function getContributor(address _contributor)\n        external\n        view\n        override\n        returns (\n            uint256 lastDepositAt,\n            uint256 initialDepositAt,\n            uint256 claimedAt,\n            uint256 claimedBABL,\n            uint256 claimedRewards,\n            uint256 withdrawnSince,\n            uint256 totalDeposits,\n            uint256 nonce,\n            uint256 lockedBalance\n        )\n    {\n        IGarden.Contributor memory contributor = contributors[_contributor];\n        return (\n            contributor.lastDepositAt,\n            contributor.initialDepositAt,\n            contributor.claimedAt,\n            contributor.claimedBABL,\n            contributor.claimedRewards,\n            contributor.withdrawnSince,\n            contributor.totalDeposits,\n            contributor.nonce,\n            contributor.lockedBalance\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _sharesToReserve(uint256 _shares, uint256 _pricePerShare) internal view returns (uint256) {\n        // in case of USDC that would with 6 decimals\n        return _shares.preciseMul(_pricePerShare).preciseMul(10**ERC20Upgradeable(reserveAsset).decimals());\n    }\n\n    function _reserveToShares(uint256 _reserve, uint256 _pricePerShare) internal view returns (uint256) {\n        return _reserve.preciseDiv(10**ERC20Upgradeable(reserveAsset).decimals()).preciseDiv(_pricePerShare);\n    }\n\n    function _withdrawInternal(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address payable _to,\n        bool _withPenalty,\n        address _unwindStrategy,\n        uint256 _pricePerShare,\n        uint256 _strategyNAV,\n        uint256 _fee\n    ) internal {\n        _onlyUnpaused();\n        _checkLastPricePerShare(_pricePerShare);\n\n        uint256 prevBalance = balanceOf(_to);\n        _require(prevBalance > 0, Errors.ONLY_CONTRIBUTOR);\n        // Flashloan protection\n        _require(block.timestamp.sub(_getLastDepositAt(_to)) >= depositHardlock, Errors.DEPOSIT_HARDLOCK);\n\n        // Strategists cannot withdraw locked stake while in active strategies\n        // Withdrawal amount has to be equal or less than msg.sender balance minus the locked balance\n        // any amountIn higher than user balance is treated as withdrawAll\n        uint256 lockedBalance = contributors[_to].lockedBalance;\n        _amountIn = _amountIn > prevBalance.sub(lockedBalance) ? prevBalance.sub(lockedBalance) : _amountIn;\n        _require(_amountIn <= prevBalance.sub(lockedBalance), Errors.TOKENS_STAKED);\n\n        uint256 amountOut = _sharesToReserve(_amountIn, _pricePerShare);\n\n        // if withPenaltiy then unwind strategy\n        if (_withPenalty && !(_liquidReserve() >= amountOut)) {\n            amountOut = amountOut.sub(amountOut.preciseMul(EARLY_WITHDRAWAL_PENALTY));\n            // When unwinding a strategy, a slippage on integrations will result in receiving less tokens\n            // than desired so we have have to account for this with a 5% slippage.\n            // TODO: if there is more than 5% slippage that will block\n            // withdrawal\n            _onlyNonZero(_unwindStrategy);\n            IStrategy(_unwindStrategy).unwindStrategy(amountOut.add(amountOut.preciseMul(5e16)), _strategyNAV);\n        }\n\n        _require(amountOut >= _minAmountOut && _amountIn > 0, Errors.RECEIVE_MIN_AMOUNT);\n\n        _require(_liquidReserve() >= amountOut, Errors.MIN_LIQUIDITY);\n\n        _burn(_to, _amountIn);\n        _safeSendReserveAsset(_to, amountOut.sub(_fee));\n        if (_fee > 0) {\n            // If fee > 0 pay Accountant\n            IERC20(reserveAsset).safeTransfer(msg.sender, _fee);\n        }\n        _updateContributorWithdrawalInfo(_to, amountOut, prevBalance, balanceOf(_to), _amountIn);\n        contributors[_to].nonce++;\n\n        emit GardenWithdrawal(_to, _to, amountOut, _amountIn, block.timestamp);\n    }\n\n    function _getPricePerShare() internal view returns (uint256) {\n        if (strategies.length == 0) {\n            return\n                totalSupply() == 0\n                    ? PreciseUnitMath.preciseUnit()\n                    : _liquidReserve().preciseDiv(uint256(10)**ERC20Upgradeable(reserveAsset).decimals()).preciseDiv(\n                        totalSupply()\n                    );\n        } else {\n            // Get valuation of the Garden with the quote asset as the reserve asset.\n            return IGardenValuer(controller.gardenValuer()).calculateGardenValuation(address(this), reserveAsset);\n        }\n    }\n\n    function _internalDeposit(\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        address _from,\n        uint256 _pricePerShare,\n        uint256 _minContribution,\n        address _referrer\n    ) private {\n        _onlyUnpaused();\n        _onlyNonZero(_to);\n        _checkLastPricePerShare(_pricePerShare);\n\n        bool canDeposit = !privateGarden || IMardukGate(controller.mardukGate()).canJoinAGarden(address(this), _to);\n        _require(_isCreator(_to) || canDeposit, Errors.USER_CANNOT_JOIN);\n\n        if (maxDepositLimit > 0) {\n            // This is wrong; but calculate principal would be gas expensive\n            _require(_liquidReserve().add(_amountIn) <= maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);\n        }\n\n        _require(_amountIn >= _minContribution, Errors.MIN_CONTRIBUTION);\n\n        uint256 reserveAssetBalanceBefore = IERC20(reserveAsset).balanceOf(address(this));\n        // If reserve asset is WETH and user sent ETH then wrap it\n        if (reserveAsset == WETH && msg.value > 0) {\n            IWETH(WETH).deposit{value: msg.value}();\n        } else {\n            // Transfer ERC20 to the garden\n            IERC20(reserveAsset).safeTransferFrom(_from, address(this), _amountIn);\n        }\n\n        // Make sure we received the correct amount of reserve asset\n        _require(\n            IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetBalanceBefore) == _amountIn,\n            Errors.MSG_VALUE_DO_NOT_MATCH\n        );\n\n        uint256 previousBalance = balanceOf(_to);\n        uint256 normalizedAmountIn = _amountIn.preciseDiv(uint256(10)**ERC20Upgradeable(reserveAsset).decimals());\n        uint256 sharesToMint = normalizedAmountIn.preciseDiv(_pricePerShare);\n\n        // make sure contributor gets desired amount of shares\n        _require(sharesToMint >= _minAmountOut, Errors.RECEIVE_MIN_AMOUNT);\n\n        // mint shares\n        _mint(_to, sharesToMint);\n\n        // Adds rewards\n        controller.addAffiliateReward(_from, _referrer != address(0) ? _referrer : _from, _amountIn);\n        // We need to update at Rewards Distributor smartcontract for rewards accurate calculations\n        _updateContributorDepositInfo(_to, previousBalance, _amountIn, sharesToMint);\n        contributors[_to].nonce++;\n\n        emit GardenDeposit(_to, _minAmountOut, _amountIn, block.timestamp);\n    }\n\n    /**\n     * @param _contributor     Contributor address to send rewards to\n     * @param _babl            BABL rewards from mining program.\n     * @param _profits         Profit rewards in reserve asset.\n     * @param _stake           Whether user wants to stake in Heart or not its BABL rewards.\n     */\n    function _sendRewardsInternal(\n        address _contributor,\n        uint256 _babl,\n        uint256 _profits,\n        bool _stake\n    ) internal {\n        _onlyUnpaused();\n        IGarden.Contributor storage contributor = contributors[_contributor];\n        _require(contributor.nonce > 0, Errors.ONLY_CONTRIBUTOR); // have been user garden\n        _require(_babl > 0 || _profits > 0, Errors.NO_REWARDS_TO_CLAIM);\n        _require(reserveAssetRewardsSetAside >= _profits, Errors.RECEIVE_MIN_AMOUNT);\n        // Avoid replay attack between claimRewardsBySig and claimRewards or even between 2 of each\n        contributor.nonce++;\n        _require(block.timestamp > contributor.claimedAt, Errors.ALREADY_CLAIMED);\n        contributor.claimedAt = block.timestamp; // Checkpoint of this claim\n        if (_profits > 0) {\n            contributor.claimedRewards = contributor.claimedRewards.add(_profits); // Rewards claimed properly\n            reserveAssetRewardsSetAside = reserveAssetRewardsSetAside.sub(_profits);\n            _safeSendReserveAsset(payable(_contributor), _profits);\n            emit RewardsForContributor(_contributor, _profits);\n        }\n        if (_babl > 0) {\n            // If _stake = true, the BABL is sent first to this garden\n            // then it is deposited into Heart Garden on behalf of user\n            uint256 bablSent = rewardsDistributor.sendBABLToContributor(_stake ? address(this) : _contributor, _babl);\n            contributor.claimedBABL = contributor.claimedBABL.add(bablSent); // BABL Rewards claimed properly\n            emit BABLRewardsForContributor(_contributor, bablSent);\n        }\n    }\n\n    /**\n     * Gets liquid reserve available for to Garden.\n     */\n    function _liquidReserve() private view returns (uint256) {\n        uint256 reserve = IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetRewardsSetAside);\n        return reserve > keeperDebt ? reserve.sub(keeperDebt) : 0;\n    }\n\n    // Disable garden token transfers. Allow minting and burning.\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _amount);\n        _require(\n            _from == address(0) || _to == address(0) || (controller.gardenTokensTransfersEnabled() && !privateGarden),\n            Errors.GARDEN_TRANSFERS_DISABLED\n        );\n\n        if (_from != address(0) && _to != address(0)) {\n            uint256 fromBalance = balanceOf(_from);\n\n            uint256 lockedBalance = contributors[_from].lockedBalance;\n            _require(fromBalance.sub(lockedBalance) >= _amount, Errors.TOKENS_STAKED);\n\n            _updateContributorWithdrawalInfo(_from, 0, fromBalance, fromBalance.sub(_amount), _amount);\n            _updateContributorDepositInfo(_to, balanceOf(_to), 0, _amount);\n        }\n    }\n\n    function _safeSendReserveAsset(address payable _to, uint256 _amount) private {\n        if (reserveAsset == WETH) {\n            // Check that the withdrawal is possible\n            // Unwrap WETH if ETH balance lower than amount\n            if (address(this).balance < _amount) {\n                IWETH(WETH).withdraw(_amount.sub(address(this).balance));\n            }\n            // Send ETH\n            Address.sendValue(_to, _amount);\n        } else {\n            // Send reserve asset\n            IERC20(reserveAsset).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * Approves BABL staking amount for claim and stake rewards\n     * Only used to approve Heart Garden to stake\n     */\n    function _approveBABL(address _garden, uint256 _amount) internal {\n        _require(BABL.balanceOf(address(this)) >= _amount, Errors.NOT_ENOUGH_BABL);\n        BABL.safeApprove(address(_garden), _amount);\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorDepositInfo(\n        address _contributor,\n        uint256 _previousBalance,\n        uint256 _amountIn,\n        uint256 _sharesIn\n    ) private {\n        IGarden.Contributor storage contributor = contributors[_contributor];\n        // If new contributor, create one, increment count, and set the current TS\n        if (_previousBalance == 0 || contributor.initialDepositAt == 0) {\n            totalContributors = totalContributors.add(1);\n            contributor.initialDepositAt = block.timestamp;\n        }\n        // We make checkpoints around contributor deposits to give the right rewards afterwards\n        contributor.totalDeposits = contributor.totalDeposits.add(_amountIn);\n        contributor.lastDepositAt = block.timestamp;\n        // RD checkpoint for accurate rewards\n        rewardsDistributor.updateGardenPowerAndContributor(\n            address(this),\n            _contributor,\n            _previousBalance,\n            _sharesIn,\n            true // true = deposit , false = withdraw\n        );\n    }\n\n    /**\n     * Updates the contributor info in the array\n     */\n    function _updateContributorWithdrawalInfo(\n        address _contributor,\n        uint256 _amountOut,\n        uint256 _previousBalance,\n        uint256 _balance,\n        uint256 _tokensToBurn\n    ) private {\n        IGarden.Contributor storage contributor = contributors[_contributor];\n        // If withdrawn everything\n        if (_balance == 0) {\n            contributor.lastDepositAt = 0;\n            contributor.initialDepositAt = 0;\n            contributor.withdrawnSince = 0;\n            contributor.totalDeposits = 0;\n            totalContributors = totalContributors.sub(1);\n        } else {\n            contributor.withdrawnSince = contributor.withdrawnSince.add(_amountOut);\n        }\n        // RD checkpoint for accurate rewards\n        rewardsDistributor.updateGardenPowerAndContributor(\n            address(this),\n            _contributor,\n            _previousBalance,\n            _tokensToBurn,\n            false // true = deposit , false = withdraw\n        );\n    }\n\n    // Checks if an address is a creator\n    function _isCreator(address _creator) private view returns (bool) {\n        return\n            _creator != address(0) &&\n            (extraCreators[0] == _creator ||\n                extraCreators[1] == _creator ||\n                extraCreators[2] == _creator ||\n                extraCreators[3] == _creator ||\n                _creator == creator);\n    }\n\n    /**\n      @notice\n        Validates that pricePerShare is within acceptable range; if not reverts\n      @dev\n        Allowed slippage between deposits and withdrawals in terms of the garden price per share is:\n\n        slippage = lastPricePerShare % (pricePerShareDelta + timePast * pricePerShareDecayRate);\n\n        For example, if lastPricePerShare is 1e18 and slippage is 10% then deposits with pricePerShare between\n        9e17 and 11e17 allowed immediately. After one year (100% change in time) and with a decay rate 1x;\n        deposits between 5e17 and 2e18 are possible. Different gardens should have different settings for\n        slippage and decay rate due to various volatility of the strategies. For example, stable gardens\n        would have low slippage and decay rate while some moonshot gardens may have both of them\n        as high as 100% and 10x.\n      @param _pricePerShare  Price of the graden share to validate against historical data\n    */\n    function _checkLastPricePerShare(uint256 _pricePerShare) private {\n        uint256 slippage = pricePerShareDelta > 0 ? pricePerShareDelta : 25e16;\n        uint256 decay = pricePerShareDecayRate > 0 ? pricePerShareDecayRate : 1e18;\n        // if no previous record then just pass the check\n        if (lastPricePerShare != 0) {\n            slippage = slippage.add(block.timestamp.sub(lastPricePerShareTS).preciseDiv(365 days).preciseMul(decay));\n            if (_pricePerShare > lastPricePerShare) {\n                _require(\n                    _pricePerShare.sub(lastPricePerShare) <= lastPricePerShare.preciseMul(slippage),\n                    Errors.PRICE_PER_SHARE_WRONG\n                );\n            } else {\n                _require(\n                    lastPricePerShare.sub(_pricePerShare) <=\n                        lastPricePerShare.sub(lastPricePerShare.preciseDiv(slippage.add(1e18))),\n                    Errors.PRICE_PER_SHARE_WRONG\n                );\n            }\n        }\n        lastPricePerShare = _pricePerShare;\n        lastPricePerShareTS = block.timestamp;\n    }\n\n    // Assign extra creators\n    function _assignExtraCreator(uint8 _index, address _newCreator) private {\n        _require(!_isCreator(_newCreator), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        _require(extraCreators[_index] == address(0), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        extraCreators[_index] = _newCreator;\n    }\n\n    function _getLastDepositAt(address _to) private view returns (uint256) {\n        return hardlockStartsAt > contributors[_to].lastDepositAt ? hardlockStartsAt : contributors[_to].lastDepositAt;\n    }\n}\n\ncontract GardenV20 is Garden {\n    constructor(VTableBeacon _beacon) Garden(_beacon) {}\n}\n"
    },
    "contracts/lib/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\nimport {IERC1271} from '../interfaces/IERC1271.sol';\n\n/**\n * @dev Signature verification helper: Provide a single mechanism to verify both private-key (EOA) ECDSA signature and\n * ERC1271 contract sigantures. Using this instead of ECDSA.recover in your contract will make them compatible with\n * smart contract wallets such as Argent and Gnosis.\n *\n * Note: unlike ECDSA signatures, contract signature's are revocable, and the outcome of this function can thus change\n * through time. It could return true at block N and false at block N+1 (or the opposite).\n *\n */\n\nlibrary SignatureChecker {\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        if (Address.isContract(signer)) {\n            try IERC1271(signer).isValidSignature(hash, signature) returns (bytes4 magicValue) {\n                return magicValue == IERC1271(signer).isValidSignature.selector;\n            } catch {\n                return false;\n            }\n        } else {\n            return ECDSA.recover(hash, signature) == signer;\n        }\n    }\n}\n"
    },
    "contracts/proxy/VTableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/proxy/Proxy.sol';\n\nimport './VTable.sol';\nimport './modules/VTableUpdateModule.sol';\n\n/**\n * @title VTableProxy\n */\ncontract VTableProxy is Proxy {\n    using VTable for VTable.VTableStore;\n\n    bytes4 private constant _FALLBACK_SIGN = 0xffffffff;\n\n    constructor(address updatemodule) {\n        VTable.VTableStore storage vtable = VTable.instance();\n\n        vtable.setOwner(msg.sender);\n        vtable.setFunction(VTableUpdateModule(updatemodule).updateVTable.selector, updatemodule);\n    }\n\n    function _implementation() internal view virtual override returns (address module) {\n        VTable.VTableStore storage vtable = VTable.instance();\n\n        module = vtable.getFunction(msg.sig);\n        if (module != address(0)) return module;\n\n        module = vtable.getFunction(_FALLBACK_SIGN);\n        if (module != address(0)) return module;\n\n        revert('VTableProxy: No implementation found');\n    }\n}\n"
    },
    "contracts/proxy/VTable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n/**\n * @title VTable\n */\nlibrary VTable {\n    // bytes32 private constant _VTABLE_SLOT = bytes32(uint256(keccak256(\"openzeppelin.vtable.location\")) - 1);\n    bytes32 private constant _VTABLE_SLOT = 0x13f1d5ea37b1d7aca82fcc2879c3bddc731555698dfc87ad6057b416547bc657;\n\n    struct VTableStore {\n        address _owner;\n        mapping(bytes4 => address) _delegates;\n    }\n\n    /**\n     * @dev Get singleton instance\n     */\n    function instance() internal pure returns (VTableStore storage vtable) {\n        bytes32 position = _VTABLE_SLOT;\n        assembly {\n            vtable.slot := position\n        }\n    }\n\n    /**\n     * @dev Ownership management\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function getOwner(VTableStore storage vtable) internal view returns (address) {\n        return vtable._owner;\n    }\n\n    function setOwner(VTableStore storage vtable, address newOwner) internal {\n        emit OwnershipTransferred(vtable._owner, newOwner);\n        vtable._owner = newOwner;\n    }\n\n    /**\n     * @dev VTableManagement\n     */\n    event VTableUpdate(bytes4 indexed selector, address oldImplementation, address newImplementation);\n\n    function getFunction(VTableStore storage vtable, bytes4 selector) internal view returns (address) {\n        return vtable._delegates[selector];\n    }\n\n    function setFunction(\n        VTableStore storage vtable,\n        bytes4 selector,\n        address module\n    ) internal {\n        emit VTableUpdate(selector, vtable._delegates[selector], module);\n        vtable._delegates[selector] = module;\n    }\n}\n"
    },
    "contracts/proxy/modules/VTableUpdateModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../VTable.sol';\n\ncontract VTableUpdateModule {\n    using VTable for VTable.VTableStore;\n\n    event VTableUpdate(bytes4 indexed selector, address oldImplementation, address newImplementation);\n\n    struct ModuleDefinition {\n        address implementation;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @dev Updates the vtable\n     */\n    function updateVTable(ModuleDefinition[] calldata modules) public {\n        VTable.VTableStore storage vtable = VTable.instance();\n        require(VTable.instance().getOwner() == msg.sender, 'VTableOwnership: caller is not the owner');\n\n        for (uint256 i = 0; i < modules.length; ++i) {\n            ModuleDefinition memory module = modules[i];\n            for (uint256 j = 0; j < module.selectors.length; ++j) {\n                vtable.setFunction(module.selectors[j], module.implementation);\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/modules/VTableOwnershipModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '../VTable.sol';\n\ncontract VTableOwnershipModule {\n    using VTable for VTable.VTableStore;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, 'VTableOwnership: caller is not the owner');\n        _;\n    }\n\n    /**\n     * @dev Reads ownership for the vtable\n     */\n    function owner() public view virtual returns (address) {\n        return VTable.instance().getOwner();\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        VTable.instance().setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), 'VTableOwnership: new owner is the zero address');\n        VTable.instance().setOwner(newOwner);\n    }\n}\n"
    },
    "contracts/MardukGate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IMardukGate} from './interfaces/IMardukGate.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title MardukGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists without NFT and checks Ishtar Gate when needed\n */\ncontract MardukGate is IMardukGate, Ownable {\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission);\n    event GardenCreationPower(address indexed _member, bool _creation);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n    IIshtarGate private ishtarGate;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => mapping(address => bool)) public isOverriden;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => bool) public betaAccess;\n    mapping(address => uint256) public gardenAccessCount;\n\n    mapping(address => address[]) public invitesPerGarden;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == controller, 'Controller must match');\n        require(_isCreator(IGarden(_garden), msg.sender), 'Only creator can give access to garden');\n        require(IBabController(controller).isGarden(address(_garden)));\n        require(gardenAccessCount[_garden] <= maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _ishtarGate         Address of the ishtar gate\n     */\n    constructor(IBabController _controller, IIshtarGate _ishtarGate) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        require(address(_ishtarGate) != address(0), 'Ishtar Gate must exist');\n        controller = _controller;\n        ishtarGate = _ishtarGate;\n        maxNumberOfInvites = ishtarGate.maxNumberOfInvites() > 0 ? ishtarGate.maxNumberOfInvites() : 100;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Gives user access to a specific garden via Marduk Gate\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override returns (uint256) {\n        require(\n            _isCreator(IGarden(_garden), msg.sender) || msg.sender == address(_garden),\n            'Only creator or garden can change params'\n        );\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Uses Marduk Gate to grant a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Grants an user/remove garden creation capabilities via Marduk Gate.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Grants a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can access the beta\n     *\n     * @param _user                     Address of the user\n     * @return bool               Whether or not the user can access the beta\n     */\n    function canAccessBeta(address _user) external view override returns (bool) {\n        return IERC721(address(ishtarGate)).balanceOf(_user) > 0 || betaAccess[_user];\n    }\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return ishtarGate.canCreate(_user) || canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= JUST_LP;\n        }\n        return ishtarGate.canJoinAGarden(_garden, _user);\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= STEWARD;\n        }\n        return ishtarGate.canVoteInAGarden(_garden, _user);\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @param _user                       Address of the user\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        if (_isCreator(IGarden(_garden), _user)) {\n            return true;\n        }\n        if (isOverriden[_garden][_user]) {\n            return permissionsByCommunity[_garden][_user] >= STRATEGIST;\n        }\n        return ishtarGate.canAddStrategiesInAGarden(_garden, _user);\n    }\n\n    /**\n     * Returns all the invites sent from a specific garden\n     *\n     * @param _garden                     Address of the _garden\n     * @return address[]                  All the invites sent\n     */\n    function getInvitesPerGarden(address _garden) external view returns (address[] memory) {\n        return invitesPerGarden[_garden];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Grants access to an user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        require(_permission <= 3, 'Permission out of bounds');\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            require(gardenAccessCount[_garden] < maxNumberOfInvites, 'Max Number of invites reached');\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n            invitesPerGarden[_garden].push(_user);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        isOverriden[_garden][_user] = true;\n        betaAccess[_user] = true;\n        emit GardenAccess(_user, _garden, _permission);\n        return 0;\n    }\n\n    /**\n     * Grants access to an user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate);\n        return 0;\n    }\n\n    // Checks if an address is a creator\n    function _isCreator(IGarden _garden, address _member) private view returns (bool) {\n        return\n            _member != address(0) &&\n            (_garden.extraCreators(0) == _member ||\n                _garden.extraCreators(1) == _member ||\n                _garden.extraCreators(2) == _member ||\n                _garden.extraCreators(3) == _member ||\n                _member == _garden.creator());\n    }\n}\n"
    },
    "contracts/IshtarGate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IIshtarGate} from './interfaces/IIshtarGate.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\n\n/**\n * @title IshtarGate\n * @author Babylon Finance\n *\n * Contract that implements guestlists for Babylon Finance using an NFT\n */\ncontract IshtarGate is ERC721, IIshtarGate, Ownable {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n\n    event IshtarGateAwarded(address indexed _member, uint256 indexed _newItemId);\n    event GardenAccess(address indexed _member, address indexed _garden, uint8 _permission, uint256 _tokenId);\n    event GardenCreationPower(address indexed _member, bool _creation, uint256 _tokenId);\n    event GateURIUpdated(string indexed _newURI, string indexed _oldURI);\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    // Address of the Ishtar Gate JSON (Shared JSON)\n    string public override tokenURI;\n\n    uint256 public override maxNumberOfInvites;\n\n    // Permissions by community user\n    mapping(address => mapping(address => uint8)) public permissionsByCommunity;\n    mapping(address => bool) public canCreateAGarden;\n    mapping(address => uint256) public gardenAccessCount;\n\n    uint8 public constant NONE = 0;\n    uint8 public constant JUST_LP = 1;\n    uint8 public constant STEWARD = 2;\n    uint8 public constant STRATEGIST = 3;\n\n    Counters.Counter private _tokenIds;\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGardenCreator(address _garden) {\n        require(address(_garden) != address(0), 'Garden must exist');\n        IGarden garden = IGarden(_garden);\n        require(garden.controller() == controller, 'Controller must match');\n        require(msg.sender == garden.creator(), 'Only creator can give access to garden');\n        require(IBabController(controller).isGarden(address(_garden)));\n        require(gardenAccessCount[_garden] <= maxNumberOfInvites, 'The number of contributors must be below the limit');\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _tokenURI           URL of the Ishtar Gate JSON metadata\n     */\n    constructor(IBabController _controller, string memory _tokenURI) ERC721('IshtarGate', 'ISHT') {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = _controller;\n        tokenURI = _tokenURI;\n        maxNumberOfInvites = 10;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Changs the number of invites we are going to give per garden\n     *\n     * @param _maxNumberOfInvites               New max number of invites per garden\n     */\n    function setMaxNumberOfInvites(uint256 _maxNumberOfInvites) external override onlyOwner {\n        require(_maxNumberOfInvites > maxNumberOfInvites, 'Invites must be higher');\n        maxNumberOfInvites = _maxNumberOfInvites;\n    }\n\n    /**\n     * Updates the token URI of the gate NFT\n     *\n     * @param _tokenURI               Address of the tokenURI\n     */\n    function updateGardenURI(string memory _tokenURI) external override onlyOwner {\n        string memory oldURI = tokenURI;\n        tokenURI = _tokenURI;\n        emit GateURIUpdated(tokenURI, oldURI);\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function setGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) external override onlyGardenCreator(_garden) returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        return _setIndividualGardenAccess(_user, _garden, _permission);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to a specific garden\n     *\n     * @param _garden             Community that the gate grants access to\n     * @param _users              Addresses of the users\n     * @param _perms              List of permissions of what each user can do in the community\n     */\n    function grantGardenAccessBatch(\n        address _garden,\n        address[] calldata _users,\n        uint8[] calldata _perms\n    ) external override onlyGardenCreator(_garden) returns (bool) {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            require(address(_users[i]) != address(0), 'User must exist');\n            _setIndividualGardenAccess(_users[i], _garden, _perms[i]);\n        }\n        return true;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function setCreatorPermissions(address _user, bool _canCreate) external override onlyOwner returns (uint256) {\n        return _setCreatorPermissions(_user, _canCreate);\n    }\n\n    /**\n     * Awards the ishtar gate to a list of users with permissions to create gardens\n     *\n     * @param _users              Addresses of the users\n     * @param _perms              Lists of booleans\n     */\n    function grantCreatorsInBatch(address[] calldata _users, bool[] calldata _perms)\n        external\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_users.length == _perms.length, 'Permissions and users must match');\n        for (uint8 i = 0; i < _users.length; i++) {\n            _setCreatorPermissions(_users[i], _perms[i]);\n        }\n        return true;\n    }\n\n    /* ============ Getter Functions ============ */\n\n    /**\n     * Check if a user can create gardens\n     *\n     * @param _user                     Address of the user\n     * @return _canCreate               Whether or not the user can create\n     */\n    function canCreate(address _user) external view override returns (bool) {\n        return balanceOf(_user) > 0 && canCreateAGarden[_user];\n    }\n\n    /**\n     * Check if a user can join a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canJoin                   Whether or not the user can join\n     */\n    function canJoinAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= JUST_LP || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can vote in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canVote                   Whether or not the user can vote\n     */\n    function canVoteInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STEWARD || IGarden(_garden).creator() == _user);\n    }\n\n    /**\n     * Check if a user can add strategies in a specific garden\n     *\n     * @param _user                       Address of the user\n     * @param _garden                     Address of the _garden\n     * @return _canStrategize             Whether or not the user can create strategies\n     */\n    function canAddStrategiesInAGarden(address _garden, address _user) external view override returns (bool) {\n        return\n            balanceOf(_user) > 0 &&\n            (permissionsByCommunity[_garden][_user] >= STRATEGIST || IGarden(_garden).creator() == _user);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Gives a new gate to the user or retrieve the existing one\n     *\n     * @param _user               Address of the user\n     */\n    function _createOrGetGateNFT(address _user) private returns (uint256) {\n        uint256 newItemId = 0;\n        if (balanceOf(_user) == 0) {\n            _tokenIds.increment();\n            newItemId = _tokenIds.current();\n            _safeMint(_user, newItemId);\n            _setTokenURI(newItemId, tokenURI);\n            emit IshtarGateAwarded(_user, newItemId);\n        } else {\n            newItemId = tokenOfOwnerByIndex(_user, 0);\n        }\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     * @param _garden             Community that the gate grants access to\n     * @param _permission        Permissions of what user can do in the community\n     */\n    function _setIndividualGardenAccess(\n        address _user,\n        address _garden,\n        uint8 _permission\n    ) private returns (uint256) {\n        require(_permission <= 3, 'Permission out of bounds');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        if (_permission > 0 && permissionsByCommunity[_garden][_user] == 0) {\n            require(gardenAccessCount[_garden] < maxNumberOfInvites, 'Max Number of invites reached');\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].add(1);\n        }\n        if (_permission == 0 && permissionsByCommunity[_garden][_user] > 0) {\n            gardenAccessCount[_garden] = gardenAccessCount[_garden].sub(1);\n        }\n        permissionsByCommunity[_garden][_user] = _permission;\n        emit GardenAccess(_user, _garden, _permission, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Awards the ishtar gate to a user and give/remove him garden creation capabilities.\n     *\n     * @param _user               Address of the user\n     * @param _canCreate          Boolean with permissions as to whether the user can create gardens\n     */\n    function _setCreatorPermissions(address _user, bool _canCreate) private returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        uint256 newItemId = _createOrGetGateNFT(_user);\n        canCreateAGarden[_user] = _canCreate;\n        emit GardenCreationPower(_user, _canCreate, newItemId);\n        return newItemId;\n    }\n}\n"
    },
    "contracts/integrations/borrow/AaveBorrowIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\nimport {IWETH} from '../../interfaces/external/weth/IWETH.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {BorrowIntegration} from './BorrowIntegration.sol';\n\n/**\n * @title AaveBorrowIntegration\n * @author Babylon Finance\n *\n * Abstract class that houses aave borring/lending logic.\n */\ncontract AaveBorrowIntegration is BorrowIntegration {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n    uint256 constant interestRateMode = 2; // Variable Rate Interest\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     * @param _maxCollateralFactor    Max collateral factor allowed (from 0 to a 100)\n     */\n    constructor(IBabController _controller, uint256 _maxCollateralFactor)\n        BorrowIntegration('aaveborrow', _controller, _maxCollateralFactor)\n    {}\n\n    /* ============ External Functions ============ */\n    /**\n     * Get the amount of borrowed debt that needs to be repaid\n     * @param asset   The underlying asset\n     *\n     */\n    function getBorrowBalance(address _strategy, address asset) public view override returns (uint256) {\n        (, uint256 currentStableDebt, uint256 currentVariableDebt, , , , , , ) = dataProvider.getUserReserveData(asset, _strategy);\n        // Account for both stable and variable debt\n        return currentStableDebt.add(currentVariableDebt);\n    }\n\n    /**\n     * Get the amount of collateral supplied\n     * hparam asset   The collateral asset\n     *\n     */\n    function getCollateralBalance(\n        address _strategy,\n        address /* asset */\n    ) external view override returns (uint256) {\n        (\n            uint256 totalCollateral, // uint256 totalDebt, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n            ,\n            ,\n\n        ) = lendingPool.getUserAccountData(_strategy);\n        return totalCollateral;\n    }\n\n    /**\n     * Get the remaining liquidity available to borrow\n     *\n     */\n    function getRemainingLiquidity(address _strategy) public view override returns (uint256) {\n        (\n            ,\n            ,\n            // uint256 totalCollateral,\n            // uint256 totalDebt,\n            uint256 borrowingPower, // uint256 borrowingPower, // uint256 liquidationThreshold, // uint256 ltv,\n            ,\n            ,\n\n        ) =\n            // uint256 healthFactor\n            lendingPool.getUserAccountData(_strategy);\n        return borrowingPower;\n    }\n\n    function _getCollateralFactor(address _assetToken) internal view virtual override returns (uint256) {\n        (, uint256 ltv, , , , , , , , ) = dataProvider.getReserveConfigurationData(_assetToken);\n        return ltv.mul(1e14);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return borrow token calldata\n     *\n     * @param  _strategy                 Address of the strategy executing\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getBorrowCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'borrow(address,uint256,uint256,uint16,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                0,\n                _strategy\n            );\n\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Return repay borrowed asset calldata\n     *\n     * @param  _strategy                 Address of the strategy executing it\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getRepayCalldata(\n        address _strategy,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'repay(address,uint256,uint256,address)',\n                _asset,\n                _amount,\n                interestRateMode,\n                _strategy\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getCollateralAsset(\n        address asset,\n        uint8 /* _borrowOp */\n    ) internal pure override returns (address) {\n        return asset;\n    }\n\n    function _getSpender(\n        address /* asset */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/Heart.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport {IHypervisor} from './interfaces/IHypervisor.sol';\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGovernor} from './interfaces/external/oz/IGovernor.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IHeart} from './interfaces/IHeart.sol';\nimport {IWETH} from './interfaces/external/weth/IWETH.sol';\nimport {ICToken} from './interfaces/external/compound/ICToken.sol';\nimport {ICEther} from './interfaces/external/compound/ICEther.sol';\nimport {IComptroller} from './interfaces/external/compound/IComptroller.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {IMasterSwapper} from './interfaces/IMasterSwapper.sol';\nimport {IVoteToken} from './interfaces/IVoteToken.sol';\nimport {IERC1271} from './interfaces/IERC1271.sol';\n\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {SafeDecimalMath} from './lib/SafeDecimalMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\nimport {Errors, _require, _revert} from './lib/BabylonErrors.sol';\nimport {ControllerLib} from './lib/ControllerLib.sol';\n\n/**\n * @title Heart\n * @author Babylon Finance\n *\n * Contract that assists The Heart of Babylon garden with BABL staking.\n *\n */\ncontract Heart is OwnableUpgradeable, IHeart, IERC1271 {\n    using SafeERC20 for IERC20;\n    using PreciseUnitMath for uint256;\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n    using ControllerLib for IBabController;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not a keeper in the protocol\n     */\n    function _onlyKeeper() private view {\n        _require(controller.isValidKeeper(msg.sender), Errors.ONLY_KEEPER);\n    }\n\n    /* ============ Events ============ */\n\n    event FeesCollected(uint256 _timestamp, uint256 _amount);\n    event LiquidityAdded(uint256 _timestamp, uint256 _wethBalance, uint256 _bablBalance);\n    event BablBuyback(uint256 _timestamp, uint256 _wethSpent, uint256 _bablBought);\n    event GardenSeedInvest(uint256 _timestamp, address indexed _garden, uint256 _wethInvested);\n    event FuseLentAsset(uint256 _timestamp, address indexed _asset, uint256 _assetAmount);\n    event BABLRewardSent(uint256 _timestamp, uint256 _bablSent);\n    event ProposalVote(uint256 _timestamp, uint256 _proposalId, bool _isApprove);\n    event UpdatedGardenWeights(uint256 _timestamp);\n\n    /* ============ Constants ============ */\n\n    // Only for offline use by keeper/fauna\n    bytes32 private constant VOTE_PROPOSAL_TYPEHASH =\n        keccak256('ProposalVote(uint256 _proposalId,uint256 _amount,bool _isApprove)');\n    bytes32 private constant VOTE_GARDEN_TYPEHASH = keccak256('GardenVote(address _garden,uint256 _amount)');\n\n    // Visor\n    IHypervisor private constant visor = IHypervisor(0xF19F91d7889668A533F14d076aDc187be781a458);\n\n    // Address of Uniswap factory\n    IUniswapV3Factory internal constant factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    uint24 private constant FEE_LOW = 500;\n    uint24 private constant FEE_MEDIUM = 3000;\n    uint24 private constant FEE_HIGH = 10000;\n    uint256 private constant DEFAULT_TRADE_SLIPPAGE = 25e15; // 2.5%\n\n    // Tokens\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 private constant BABL = IERC20(0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74);\n    IERC20 private constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    IERC20 private constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 private constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    IERC20 private constant FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    IERC20 private constant FEI = IERC20(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);\n\n    // Fuse\n    address private constant BABYLON_FUSE_POOL_ADDRESS = 0xC7125E3A2925877C7371d579D29dAe4729Ac9033;\n\n    // Value Amount for protect purchases in DAI\n    uint256 private constant PROTECT_BUY_AMOUNT_DAI = 2e21;\n\n    /* ============ Immutables ============ */\n\n    IBabController private immutable controller;\n    IGovernor private immutable governor;\n    address private immutable treasury;\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n\n    // Heart garden address\n    IGarden public override heartGarden;\n\n    // Variables to handle garden seed investments\n    address[] public override votedGardens;\n    uint256[] public override gardenWeights;\n\n    // Min Amounts to trade\n    mapping(address => uint256) public override minAmounts;\n\n    // Fuse pool Variables\n    // Mapping of asset addresses to cToken addresses in the fuse pool\n    mapping(address => address) public override assetToCToken;\n    // Which asset is going to receive the next batch of liquidity in fuse\n    address public override assetToLend;\n\n    // Timestamp when the heart was last pumped\n    uint256 public override lastPumpAt;\n\n    // Timestamp when the votes were sent by the keeper last\n    uint256 public override lastVotesAt;\n\n    // Amount to gift to the Heart of Babylon Garden weekly\n    uint256 public override weeklyRewardAmount;\n    uint256 public override bablRewardLeft;\n\n    // Array with the weights to distribute to different heart activities\n    // 0: Treasury\n    // 1: Buybacks\n    // 2: Liquidity BABL-ETH\n    // 3: Garden Seed Investments\n    // 4: Fuse Pool\n    uint256[] public override feeDistributionWeights;\n\n    // Metric Totals\n    // 0: fees accumulated in weth\n    // 1: Money sent to treasury\n    // 2: babl bought in babl\n    // 3: liquidity added in weth\n    // 4: amount invested in gardens in weth\n    // 5: amount lent on fuse in weth\n    // 6: weekly rewards paid in babl\n    uint256[7] public override totalStats;\n\n    // Trade slippage to apply in trades\n    uint256 public override tradeSlippage;\n\n    // Asset to use to buy protocol wanted assets\n    address public override assetForPurchases;\n\n    // Bond Assets with the discount\n    mapping(address => uint256) public override bondAssets;\n\n    // EIP-1271 signer\n    address private signer;\n\n    uint256 private constant MIN_PUMP_WETH = 15e17; // 1.5 ETH\n\n    /* ============ Initializer ============ */\n\n    /**\n     * Set controller and governor addresses\n     *\n     * @param _controller             Address of controller contract\n     * @param _governor               Address of governor contract\n     */\n    constructor(IBabController _controller, IGovernor _governor) initializer {\n        _require(address(_controller) != address(0), Errors.ADDRESS_IS_ZERO);\n        _require(address(_governor) != address(0), Errors.ADDRESS_IS_ZERO);\n\n        controller = _controller;\n        treasury = _controller.treasury();\n        governor = _governor;\n    }\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _feeWeights             Weights of the fee distribution\n     */\n    function initialize(uint256[] calldata _feeWeights) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        updateFeeWeights(_feeWeights);\n        updateMarkets();\n        updateAssetToLend(address(DAI));\n        minAmounts[address(DAI)] = 500e18;\n        minAmounts[address(USDC)] = 500e6;\n        minAmounts[address(WETH)] = 5e17;\n        minAmounts[address(WBTC)] = 3e6;\n        // Self-delegation to be able to use BABL balance as voting power\n        IVoteToken(address(BABL)).delegate(address(this));\n        tradeSlippage = DEFAULT_TRADE_SLIPPAGE;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Function to pump blood to the heart\n     *\n     * Note: Anyone can call this. Keeper in Defender will be set up to do it for convenience.\n     */\n    function pump() public override {\n        _require(address(heartGarden) != address(0), Errors.HEART_GARDEN_NOT_SET);\n        _require(block.timestamp.sub(lastPumpAt) >= 1 weeks, Errors.HEART_ALREADY_PUMPED);\n        _require(block.timestamp.sub(lastVotesAt) < 1 weeks, Errors.HEART_VOTES_MISSING);\n        // Consolidate all fees\n        _consolidateFeesToWeth();\n        uint256 wethBalance = WETH.balanceOf(address(this));\n        // Use fei to pump if needed\n        if (wethBalance < MIN_PUMP_WETH) {\n            uint256 feiPriceInWeth = IPriceOracle(controller.priceOracle()).getPrice(address(FEI), address(WETH));\n            uint256 feiNeeded = MIN_PUMP_WETH.sub(wethBalance).preciseMul(feiPriceInWeth).preciseMul(105e16); // a bit more just in case\n            if (FEI.balanceOf(address(this)) >= feiNeeded) {\n                _trade(address(FEI), address(WETH), feiNeeded);\n            }\n        }\n        _require(wethBalance >= 15e17, Errors.HEART_MINIMUM_FEES);\n        // Send 10% to the treasury\n        IERC20(WETH).safeTransferFrom(address(this), treasury, wethBalance.preciseMul(feeDistributionWeights[0]));\n        totalStats[1] = totalStats[1].add(wethBalance.preciseMul(feeDistributionWeights[0]));\n        // 30% for buybacks\n        _buyback(wethBalance.preciseMul(feeDistributionWeights[1]));\n        // 25% to BABL-ETH pair\n        _addLiquidity(wethBalance.preciseMul(feeDistributionWeights[2]));\n        // 15% to Garden Investments\n        _investInGardens(wethBalance.preciseMul(feeDistributionWeights[3]));\n        // 20% lend in fuse pool\n        _lendFusePool(address(WETH), wethBalance.preciseMul(feeDistributionWeights[4]), address(assetToLend));\n        // Add BABL reward to stakers (if any)\n        _sendWeeklyReward();\n        lastPumpAt = block.timestamp;\n    }\n\n    /**\n     * Function to vote for a proposal\n     *\n     * Note: Only keeper can call this. Votes need to have been resolved offchain.\n     * Warning: Gardens need to delegate to heart first.\n     */\n    function voteProposal(uint256 _proposalId, bool _isApprove) external override {\n        _onlyKeeper();\n        // Governor does revert if trying to cast a vote twice or if proposal is not active\n        IGovernor(governor).castVote(_proposalId, _isApprove ? 1 : 0);\n        emit ProposalVote(block.timestamp, _proposalId, _isApprove);\n    }\n\n    /**\n     * Resolves garden votes for this cycle\n     *\n     * Note: Only keeper can call this\n     * @param _gardens             Gardens that are going to receive investment\n     * @param _weights             Weight for the investment in each garden normalied to 1e18 precision\n     */\n    function resolveGardenVotes(address[] memory _gardens, uint256[] memory _weights) public override {\n        _onlyKeeper();\n        _require(_gardens.length == _weights.length, Errors.HEART_VOTES_LENGTH);\n        delete votedGardens;\n        delete gardenWeights;\n        for (uint256 i = 0; i < _gardens.length; i++) {\n            votedGardens.push(_gardens[i]);\n            gardenWeights.push(_weights[i]);\n        }\n        lastVotesAt = block.timestamp;\n        emit UpdatedGardenWeights(block.timestamp);\n    }\n\n    function resolveGardenVotesAndPump(address[] memory _gardens, uint256[] memory _weights) external override {\n        resolveGardenVotes(_gardens, _weights);\n        pump();\n    }\n\n    /**\n     * Updates fuse pool market information and enters the markets\n     *\n     */\n    function updateMarkets() public override {\n        controller.onlyGovernanceOrEmergency();\n        // Enter markets of the fuse pool for all these assets\n        address[] memory markets = IComptroller(BABYLON_FUSE_POOL_ADDRESS).getAllMarkets();\n        for (uint256 i = 0; i < markets.length; i++) {\n            address underlying = ICToken(markets[i]).underlying();\n            assetToCToken[underlying] = markets[i];\n        }\n        IComptroller(BABYLON_FUSE_POOL_ADDRESS).enterMarkets(markets);\n    }\n\n    /**\n     * Set the weights to allocate to different heart initiatives\n     *\n     * @param _feeWeights             Array of % (up to 1e18) with the fee weights\n     */\n    function updateFeeWeights(uint256[] calldata _feeWeights) public override {\n        controller.onlyGovernanceOrEmergency();\n        delete feeDistributionWeights;\n        for (uint256 i = 0; i < _feeWeights.length; i++) {\n            feeDistributionWeights.push(_feeWeights[i]);\n        }\n    }\n\n    /**\n     * Updates the next asset to lend on fuse pool\n     *\n     * @param _assetToLend             New asset to lend\n     */\n    function updateAssetToLend(address _assetToLend) public override {\n        controller.onlyGovernanceOrEmergency();\n        _require(assetToLend != _assetToLend, Errors.HEART_ASSET_LEND_SAME);\n        _require(assetToCToken[_assetToLend] != address(0), Errors.HEART_ASSET_LEND_INVALID);\n        assetToLend = _assetToLend;\n    }\n\n    /**\n     * Updates the next asset to purchase assets from strategies at a premium\n     *\n     * @param _purchaseAsset             New asset to purchase\n     */\n    function updateAssetToPurchase(address _purchaseAsset) external override {\n        controller.onlyGovernanceOrEmergency();\n        _require(\n            _purchaseAsset != assetForPurchases && _purchaseAsset != address(0),\n            Errors.HEART_ASSET_PURCHASE_INVALID\n        );\n        assetForPurchases = _purchaseAsset;\n    }\n\n    /**\n     * Updates the next asset to purchase assets from strategies at a premium\n     *\n     * @param _assetToBond              Bond to update\n     * @param _bondDiscount             Bond discount to apply 1e18\n     */\n    function updateBond(address _assetToBond, uint256 _bondDiscount) public override {\n        controller.onlyGovernanceOrEmergency();\n        bondAssets[_assetToBond] = _bondDiscount;\n    }\n\n    /**\n     * Adds a BABL reward to be distributed weekly back to the heart garden\n     *\n     * @param _bablAmount             Total amount to distribute\n     * @param _weeklyRate             Weekly amount to distribute\n     */\n    function addReward(uint256 _bablAmount, uint256 _weeklyRate) external override {\n        controller.onlyGovernanceOrEmergency();\n        // Get the BABL reward\n        IERC20(BABL).safeTransferFrom(msg.sender, address(this), _bablAmount);\n        bablRewardLeft = bablRewardLeft.add(_bablAmount);\n        weeklyRewardAmount = _weeklyRate;\n    }\n\n    /**\n     * Updates the min amount to trade a specific asset\n     *\n     * @param _asset                Asset to edit the min amount\n     * @param _minAmountOut            New min amount\n     */\n    function setMinTradeAmount(address _asset, uint256 _minAmountOut) external override {\n        controller.onlyGovernanceOrEmergency();\n        minAmounts[_asset] = _minAmountOut;\n    }\n\n    /**\n     * Updates the heart garden address\n     *\n     * @param _heartGarden                New heart garden address\n     */\n    function setHeartGardenAddress(address _heartGarden) external override {\n        controller.onlyGovernanceOrEmergency();\n        heartGarden = IGarden(_heartGarden);\n    }\n\n    /**\n     * Updates the tradeSlippage\n     *\n     * @param _tradeSlippage                Trade slippage\n     */\n    function setTradeSlippage(uint256 _tradeSlippage) external override {\n        controller.onlyGovernanceOrEmergency();\n        tradeSlippage = _tradeSlippage;\n    }\n\n    /**\n     * Tell the heart to lend an asset on Fuse\n     *\n     * @param _assetToLend                  Address of the asset to lend\n     * @param _lendAmount                   Amount of the asset to lend\n     */\n    function lendFusePool(address _assetToLend, uint256 _lendAmount) external override {\n        controller.onlyGovernanceOrEmergency();\n        // Lend into fuse\n        _lendFusePool(_assetToLend, _lendAmount, _assetToLend);\n    }\n\n    /**\n     * Heart borrows using its liquidity\n     * Note: Heart must have enough liquidity\n     *\n     * @param _assetToBorrow              Asset that the heart is receiving from sender\n     * @param _borrowAmount               Amount of asset to transfet\n     */\n    function borrowFusePool(address _assetToBorrow, uint256 _borrowAmount) external override {\n        controller.onlyGovernanceOrEmergency();\n        address cToken = assetToCToken[_assetToBorrow];\n        _require(cToken != address(0), Errors.HEART_INVALID_CTOKEN);\n        _require(ICToken(cToken).borrow(_borrowAmount) == 0, Errors.NOT_ENOUGH_COLLATERAL);\n    }\n\n    /**\n     * Repays Heart fuse pool position\n     * Note: We must have the asset in the heart\n     *\n     * @param _borrowedAsset              Borrowed asset that we want to pay\n     * @param _amountToRepay              Amount of asset to transfer\n     */\n    function repayFusePool(address _borrowedAsset, uint256 _amountToRepay) external override {\n        controller.onlyGovernanceOrEmergency();\n        address cToken = assetToCToken[_borrowedAsset];\n        IERC20(_borrowedAsset).safeApprove(cToken, _amountToRepay);\n        _require(ICToken(cToken).repayBorrow(_amountToRepay) == 0, Errors.AMOUNT_TOO_LOW);\n    }\n\n    /**\n    * Trades one asset for another in the heart\n    * Note: We must have the _fromAsset _fromAmount available.\n\n    * @param _fromAsset                  Asset to exchange\n    * @param _toAsset                    Asset to receive\n    * @param _fromAmount                 Amount of asset to exchange\n    * @param _minAmountOut                  Min amount of received asset\n    */\n    function trade(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAmount,\n        uint256 _minAmountOut\n    ) external override {\n        controller.onlyGovernanceOrEmergency();\n        _require(IERC20(_fromAsset).balanceOf(address(this)) >= _fromAmount, Errors.AMOUNT_TOO_LOW);\n        uint256 boughtAmount = _trade(_fromAsset, _toAsset, _fromAmount);\n        _require(boughtAmount >= _minAmountOut, Errors.SLIPPAGE_TOO_HIH);\n    }\n\n    /**\n     * Strategies can sell wanted assets by the protocol to the heart.\n     * Heart will buy them using borrowings in stables.\n     * Heart returns WETH so master swapper will take it from there.\n     * Note: Strategy needs to have approved the heart.\n     *\n     * @param _assetToSell                  Asset that the heart is receiving from strategy to sell\n     * @param _amountToSell                 Amount of asset to sell\n     */\n    function sellWantedAssetToHeart(address _assetToSell, uint256 _amountToSell) external override {\n        _require(controller.isSystemContract(msg.sender), Errors.NOT_A_SYSTEM_CONTRACT);\n        _require(controller.protocolWantedAssets(_assetToSell), Errors.HEART_ASSET_PURCHASE_INVALID);\n        _require(assetForPurchases != address(0), Errors.INVALID_ADDRESS);\n        // Uses on chain oracle to fetch prices\n        uint256 pricePerTokenUnit = IPriceOracle(controller.priceOracle()).getPrice(_assetToSell, assetForPurchases);\n        _require(pricePerTokenUnit != 0, Errors.NO_PRICE_FOR_TRADE);\n        uint256 amountInPurchaseAssetOffered = pricePerTokenUnit.preciseMul(_amountToSell);\n        _require(\n            IERC20(assetForPurchases).balanceOf(address(this)) >= amountInPurchaseAssetOffered,\n            Errors.BALANCE_TOO_LOW\n        );\n        IERC20(_assetToSell).safeTransferFrom(msg.sender, address(this), _amountToSell);\n        // Buy it from the strategy plus 1% premium\n        uint256 wethTraded = _trade(assetForPurchases, address(WETH), amountInPurchaseAssetOffered.preciseMul(101e16));\n        // Send weth back to the strategy\n        IERC20(WETH).safeTransfer(msg.sender, wethTraded);\n    }\n\n    /**\n     * Users can bond an asset that belongs to the program and receive a discount on hBABL.\n     * Note: Heart needs to have enough BABL to satisfy the discount.\n     * Note: User needs to approve the asset to bond first.\n     *\n     * @param _assetToBond                  Asset that the user wants to bond\n     * @param _amountToBond                 Amount to be bonded\n     * @param _minAmountOut                 Min amount of Heart garden shares to recieve\n     */\n    function bondAsset(\n        address _assetToBond,\n        uint256 _amountToBond,\n        uint256 _minAmountOut,\n        address _referrer\n    ) external override {\n        _require(bondAssets[_assetToBond] > 0 && _amountToBond > 0, Errors.AMOUNT_TOO_LOW);\n        // Total value adding the premium\n        uint256 bondValueInBABL =\n            _bondToBABL(\n                _assetToBond,\n                _amountToBond,\n                IPriceOracle(controller.priceOracle()).getPrice(_assetToBond, address(BABL))\n            );\n        // Get asset to bond from sender\n        IERC20(_assetToBond).safeTransferFrom(msg.sender, address(this), _amountToBond);\n        // Deposit on behalf of the user\n        _require(BABL.balanceOf(address(this)) >= bondValueInBABL, Errors.AMOUNT_TOO_LOW);\n\n        BABL.safeApprove(address(heartGarden), bondValueInBABL);\n\n        heartGarden.deposit(bondValueInBABL, _minAmountOut, msg.sender, _referrer);\n    }\n\n    /**\n     * Users can bond an asset that belongs to the program and receive a discount on hBABL.\n     * Note: Heart needs to have enough BABL to satisfy the discount.\n     * Note: User needs to approve the asset to bond first.\n     *\n     * @param _assetToBond                  Asset that the user wants to bond\n     * @param _amountToBond                 Amount to be bonded\n     */\n    function bondAssetBySig(\n        address _assetToBond,\n        uint256 _amountToBond,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint256 _nonce,\n        uint256 _maxFee,\n        uint256 _priceInBABL,\n        uint256 _pricePerShare,\n        uint256 _fee,\n        address _contributor,\n        address _referrer,\n        bytes memory _signature\n    ) external override {\n        _onlyKeeper();\n        _require(_fee <= _maxFee, Errors.FEE_TOO_HIGH);\n        _require(bondAssets[_assetToBond] > 0 && _amountToBond > 0, Errors.AMOUNT_TOO_LOW);\n\n        // Get asset to bond from contributor\n        IERC20(_assetToBond).safeTransferFrom(_contributor, address(this), _amountToBond);\n        // Deposit on behalf of the user\n        _require(BABL.balanceOf(address(this)) >= _amountIn, Errors.AMOUNT_TOO_LOW);\n\n        // verify that _amountIn is correct compare to _amountToBond\n        uint256 val = _bondToBABL(_assetToBond, _amountToBond, _priceInBABL);\n        uint256 diff = val > _amountIn ? val.sub(_amountIn) : _amountIn.sub(val);\n        // allow 0.1% deviation\n        _require(diff < _amountIn.div(1000), Errors.INVALID_AMOUNT);\n\n        BABL.safeApprove(address(heartGarden), _amountIn);\n\n        // Pay the fee to the Keeper\n        IERC20(BABL).safeTransfer(msg.sender, _fee);\n\n        // grant permission to deposit\n        signer = _contributor;\n        heartGarden.depositBySig(\n            _amountIn,\n            _minAmountOut,\n            _nonce,\n            _maxFee,\n            _contributor,\n            _pricePerShare,\n            0,\n            address(this),\n            _referrer,\n            _signature\n        );\n        // revoke permission to deposit\n        signer = address(0);\n    }\n\n    /**\n     * Heart will protect and buyback BABL whenever the price dips below the intended price protection.\n     * Note: Asset for purchases needs to be setup and have enough balance.\n     *\n     * @param _bablPriceProtectionAt        BABL Price in DAI to protect\n     * @param _bablPrice                    Market price of BABL in DAI\n     * @param _purchaseAssetPrice           Price of purchase asset in DAI\n     * @param _slippage                     Trade slippage on UinV3 to control amount of arb\n     * @param _hopToken            Hop token to use for UniV3 trade\n     */\n    function protectBABL(\n        uint256 _bablPriceProtectionAt,\n        uint256 _bablPrice,\n        uint256 _purchaseAssetPrice,\n        uint256 _slippage,\n        address _hopToken\n    ) external override {\n        _onlyKeeper();\n        _require(assetForPurchases != address(0), Errors.HEART_ASSET_PURCHASE_INVALID);\n        _require(_bablPriceProtectionAt > 0 && _bablPrice <= _bablPriceProtectionAt, Errors.AMOUNT_TOO_HIGH);\n\n        _require(\n            SafeDecimalMath.normalizeAmountTokens(\n                assetForPurchases,\n                address(DAI),\n                _purchaseAssetPrice.preciseMul(IERC20(assetForPurchases).balanceOf(address(this)))\n            ) >= PROTECT_BUY_AMOUNT_DAI,\n            Errors.NOT_ENOUGH_AMOUNT\n        );\n\n        uint256 exactAmount = PROTECT_BUY_AMOUNT_DAI.preciseDiv(_bablPrice);\n        uint256 minAmountOut = exactAmount.sub(exactAmount.preciseMul(_slippage == 0 ? tradeSlippage : _slippage));\n\n        uint256 bablBought =\n            _trade(\n                assetForPurchases,\n                address(BABL),\n                SafeDecimalMath.normalizeAmountTokens(\n                    address(DAI),\n                    assetForPurchases,\n                    PROTECT_BUY_AMOUNT_DAI.preciseDiv(_purchaseAssetPrice)\n                ),\n                minAmountOut,\n                _hopToken != address(0) ? _hopToken : address(WETH)\n            );\n\n        totalStats[2] = totalStats[2].add(bablBought);\n\n        emit BablBuyback(block.timestamp, PROTECT_BUY_AMOUNT_DAI, bablBought);\n    }\n\n    // solhint-disable-next-line\n    receive() external payable {}\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * Getter to get the whole array of voted gardens\n     *\n     * @return            The array of voted gardens\n     */\n    function getVotedGardens() external view override returns (address[] memory) {\n        return votedGardens;\n    }\n\n    /**\n     * Getter to get the whole array of garden weights\n     *\n     * @return            The array of weights for voted gardens\n     */\n    function getGardenWeights() external view override returns (uint256[] memory) {\n        return gardenWeights;\n    }\n\n    /**\n     * Getter to get the whole array of fee weights\n     *\n     * @return            The array of weights for the fees\n     */\n    function getFeeDistributionWeights() external view override returns (uint256[] memory) {\n        return feeDistributionWeights;\n    }\n\n    /**\n     * Getter to get the whole array of total stats\n     *\n     * @return            The array of stats for the fees\n     */\n    function getTotalStats() external view override returns (uint256[7] memory) {\n        return totalStats;\n    }\n\n    /**\n     * Implements EIP-1271\n     */\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view override returns (bytes4 magicValue) {\n        address recovered = ECDSA.recover(_hash, _signature);\n        return recovered == signer && recovered != address(0) ? this.isValidSignature.selector : bytes4(0);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _bondToBABL(\n        address _assetToBond,\n        uint256 _amountToBond,\n        uint256 _priceInBABL\n    ) private view returns (uint256) {\n        return\n            SafeDecimalMath.normalizeAmountTokens(_assetToBond, address(BABL), _amountToBond).preciseMul(\n                _priceInBABL.preciseMul(uint256(1e18).add(bondAssets[_assetToBond]))\n            );\n    }\n\n    /**\n     * Consolidates all reserve asset fees to weth\n     *\n     */\n    function _consolidateFeesToWeth() private {\n        address[] memory reserveAssets = controller.getReserveAssets();\n        for (uint256 i = 0; i < reserveAssets.length; i++) {\n            address reserveAsset = reserveAssets[i];\n            uint256 balance = IERC20(reserveAsset).balanceOf(address(this));\n            // Trade if it's above a min amount (otherwise wait until next pump)\n            if (reserveAsset != address(BABL) && reserveAsset != address(WETH) && balance > minAmounts[reserveAsset]) {\n                totalStats[0] = totalStats[0].add(_trade(reserveAsset, address(WETH), balance));\n            }\n            if (reserveAsset == address(WETH)) {\n                totalStats[0] = totalStats[0].add(balance);\n            }\n        }\n        emit FeesCollected(block.timestamp, IERC20(WETH).balanceOf(address(this)));\n    }\n\n    /**\n     * Buys back BABL through the uniswap V3 BABL-ETH pool\n     *\n     */\n    function _buyback(uint256 _amount) private {\n        // Gift 50% BABL back to garden and send 50% to the treasury\n        uint256 bablBought = _trade(address(WETH), address(BABL), _amount); // 50%\n        IERC20(BABL).safeTransfer(address(heartGarden), bablBought.div(2));\n        IERC20(BABL).safeTransfer(treasury, bablBought.div(2));\n        totalStats[2] = totalStats[2].add(bablBought);\n        emit BablBuyback(block.timestamp, _amount, bablBought);\n    }\n\n    /**\n     * Adds liquidity to the BABL-ETH pair through the hypervisor\n     *\n     * Note: Address of the heart needs to be whitelisted by Visor.\n     */\n    function _addLiquidity(uint256 _wethBalance) private {\n        // Buy BABL again with half to add 50/50\n        uint256 wethToDeposit = _wethBalance.preciseMul(5e17);\n        uint256 bablTraded = _trade(address(WETH), address(BABL), wethToDeposit); // 50%\n        BABL.safeApprove(address(visor), bablTraded);\n        IERC20(WETH).safeApprove(address(visor), wethToDeposit);\n        uint256 oldTreasuryBalance = visor.balanceOf(treasury);\n        uint256 shares = visor.deposit(wethToDeposit, bablTraded, treasury);\n        _require(\n            shares == visor.balanceOf(treasury).sub(oldTreasuryBalance) && visor.balanceOf(treasury) > 0,\n            Errors.HEART_LP_TOKENS\n        );\n        totalStats[3] += _wethBalance;\n        emit LiquidityAdded(block.timestamp, wethToDeposit, bablTraded);\n    }\n\n    /**\n     * Invests in gardens using WETH converting it to garden reserve asset first\n     *\n     * @param _wethAmount             Total amount of weth to invest in all gardens\n     */\n    function _investInGardens(uint256 _wethAmount) private {\n        for (uint256 i = 0; i < votedGardens.length; i++) {\n            address reserveAsset = IGarden(votedGardens[i]).reserveAsset();\n            uint256 amountTraded;\n            if (reserveAsset != address(WETH)) {\n                amountTraded = _trade(address(WETH), reserveAsset, _wethAmount.preciseMul(gardenWeights[i]));\n            } else {\n                amountTraded = _wethAmount.preciseMul(gardenWeights[i]);\n            }\n            // Gift it to garden\n            IERC20(reserveAsset).safeTransfer(votedGardens[i], amountTraded);\n            emit GardenSeedInvest(block.timestamp, votedGardens[i], _wethAmount.preciseMul(gardenWeights[i]));\n        }\n        totalStats[4] += _wethAmount;\n    }\n\n    /**\n     * Lends an amount of WETH converting it first to the pool asset that is the lowest (except BABL)\n     *\n     * @param _fromAsset            Which asset to convert\n     * @param _fromAmount           Total amount of weth to lend\n     * @param _lendAsset            Address of the asset to lend\n     */\n    function _lendFusePool(\n        address _fromAsset,\n        uint256 _fromAmount,\n        address _lendAsset\n    ) private {\n        address cToken = assetToCToken[_lendAsset];\n        _require(cToken != address(0), Errors.HEART_INVALID_CTOKEN);\n        uint256 assetToLendBalance = _fromAmount;\n        // Trade to asset to lend if needed\n        if (_fromAsset != _lendAsset) {\n            assetToLendBalance = _trade(\n                address(_fromAsset),\n                _lendAsset == address(0) ? address(WETH) : _lendAsset,\n                _fromAmount\n            );\n        }\n        if (_lendAsset == address(0)) {\n            // Convert WETH to ETH\n            IWETH(WETH).withdraw(_fromAmount);\n            ICEther(cToken).mint{value: _fromAmount}();\n        } else {\n            IERC20(_lendAsset).safeApprove(cToken, assetToLendBalance);\n            ICToken(cToken).mint(assetToLendBalance);\n        }\n        uint256 assetToLendWethPrice = IPriceOracle(controller.priceOracle()).getPrice(_lendAsset, address(WETH));\n        uint256 assettoLendBalanceInWeth = assetToLendBalance.preciseMul(assetToLendWethPrice);\n        totalStats[5] = totalStats[5].add(assettoLendBalanceInWeth);\n        emit FuseLentAsset(block.timestamp, _lendAsset, assettoLendBalanceInWeth);\n    }\n\n    /**\n     * Sends the weekly BABL reward to the garden (if any)\n     */\n    function _sendWeeklyReward() private {\n        if (bablRewardLeft > 0) {\n            uint256 bablToSend = bablRewardLeft < weeklyRewardAmount ? bablRewardLeft : weeklyRewardAmount;\n            uint256 currentBalance = IERC20(BABL).balanceOf(address(this));\n            bablToSend = currentBalance < bablToSend ? currentBalance : bablToSend;\n            IERC20(BABL).safeTransfer(address(heartGarden), bablToSend);\n            bablRewardLeft = bablRewardLeft.sub(bablToSend);\n            emit BABLRewardSent(block.timestamp, bablToSend);\n            totalStats[6] = totalStats[6].add(bablToSend);\n        }\n    }\n\n    /**\n     * Trades _tokenIn to _tokenOut using Uniswap V3\n     *\n     * @param _tokenIn             Token that is sold\n     * @param _tokenOut            Token that is purchased\n     * @param _amount              Amount of tokenin to sell\n     */\n    function _trade(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amount\n    ) private returns (uint256) {\n        if (_tokenIn == _tokenOut) {\n            return _amount;\n        }\n        // Uses on chain oracle for all internal strategy operations to avoid attacks\n        uint256 pricePerTokenUnit = IPriceOracle(controller.priceOracle()).getPrice(_tokenIn, _tokenOut);\n        _require(pricePerTokenUnit != 0, Errors.NO_PRICE_FOR_TRADE);\n\n        // minAmount must have receive token decimals\n        uint256 exactAmount =\n            SafeDecimalMath.normalizeAmountTokens(_tokenIn, _tokenOut, _amount.preciseMul(pricePerTokenUnit));\n        uint256 minAmountOut = exactAmount.sub(exactAmount.preciseMul(tradeSlippage));\n\n        return _trade(_tokenIn, _tokenOut, _amount, minAmountOut, address(0));\n    }\n\n    /**\n     * Trades _tokenIn to _tokenOut using Uniswap V3\n     *\n     * @param _tokenIn             Token that is sold\n     * @param _tokenOut            Token that is purchased\n     * @param _amount              Amount of tokenin to sell\n     * @param _minAmountOut        Min amount of tokens out to recive\n     * @param _hopToken            Hop token to use for UniV3 trade\n     */\n    function _trade(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amount,\n        uint256 _minAmountOut,\n        address _hopToken\n    ) private returns (uint256) {\n        ISwapRouter swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n        // Approve the router to spend token in.\n        TransferHelper.safeApprove(_tokenIn, address(swapRouter), _amount);\n        bytes memory path;\n        if (\n            (_tokenIn == address(FRAX) && _tokenOut != address(DAI)) ||\n            (_tokenOut == address(FRAX) && _tokenIn != address(DAI))\n        ) {\n            _hopToken = address(DAI);\n        } else {\n            if (\n                (_tokenIn == address(FEI) && _tokenOut != address(USDC)) ||\n                (_tokenOut == address(FEI) && _tokenIn != address(USDC))\n            ) {\n                _hopToken = address(USDC);\n            }\n        }\n        if (_hopToken != address(0)) {\n            uint24 fee0 = _getUniswapPoolFeeWithHighestLiquidity(_tokenIn, _hopToken);\n            uint24 fee1 = _getUniswapPoolFeeWithHighestLiquidity(_tokenOut, _hopToken);\n            // Have to use WETH for BABL because the most liquid pari is WETH/BABL\n            if (_tokenOut == address(BABL) && _hopToken != address(WETH)) {\n                path = abi.encodePacked(\n                    _tokenIn,\n                    fee0,\n                    _hopToken,\n                    fee1,\n                    address(WETH),\n                    _getUniswapPoolFeeWithHighestLiquidity(address(WETH), _tokenOut),\n                    _tokenOut\n                );\n            } else {\n                path = abi.encodePacked(_tokenIn, fee0, _hopToken, fee1, _tokenOut);\n            }\n        } else {\n            uint24 fee = _getUniswapPoolFeeWithHighestLiquidity(_tokenIn, _tokenOut);\n            path = abi.encodePacked(_tokenIn, fee, _tokenOut);\n        }\n\n        ISwapRouter.ExactInputParams memory params =\n            ISwapRouter.ExactInputParams(path, address(this), block.timestamp, _amount, _minAmountOut);\n        return swapRouter.exactInput(params);\n    }\n\n    /**\n     * Returns the FEE of the highest liquidity pool in univ3 for this pair\n     * @param sendToken               Token that is sold\n     * @param receiveToken            Token that is purchased\n     */\n    function _getUniswapPoolFeeWithHighestLiquidity(address sendToken, address receiveToken)\n        private\n        view\n        returns (uint24)\n    {\n        IUniswapV3Pool poolLow = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_LOW));\n        IUniswapV3Pool poolMedium = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_MEDIUM));\n        IUniswapV3Pool poolHigh = IUniswapV3Pool(factory.getPool(sendToken, receiveToken, FEE_HIGH));\n\n        uint128 liquidityLow = address(poolLow) != address(0) ? poolLow.liquidity() : 0;\n        uint128 liquidityMedium = address(poolMedium) != address(0) ? poolMedium.liquidity() : 0;\n        uint128 liquidityHigh = address(poolHigh) != address(0) ? poolHigh.liquidity() : 0;\n        if (liquidityLow >= liquidityMedium && liquidityLow >= liquidityHigh) {\n            return FEE_LOW;\n        }\n        if (liquidityMedium >= liquidityLow && liquidityMedium >= liquidityHigh) {\n            return FEE_MEDIUM;\n        }\n        return FEE_HIGH;\n    }\n}\n\ncontract HeartV5 is Heart {\n    constructor(IBabController _controller, IGovernor _governor) Heart(_controller, _governor) {}\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/gardens/AdminGardenModule.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {LowGasSafeMath} from '../lib/LowGasSafeMath.sol';\nimport {SafeDecimalMath} from '../lib/SafeDecimalMath.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {Errors, _require, _revert} from '../lib/BabylonErrors.sol';\nimport {AddressArrayUtils} from '../lib/AddressArrayUtils.sol';\nimport {PreciseUnitMath} from '../lib/PreciseUnitMath.sol';\nimport {Math} from '../lib/Math.sol';\n\nimport {IPriceOracle} from '../interfaces/IPriceOracle.sol';\nimport {IRewardsDistributor} from '../interfaces/IRewardsDistributor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IStrategyFactory} from '../interfaces/IStrategyFactory.sol';\nimport {IGardenValuer} from '../interfaces/IGardenValuer.sol';\nimport {IStrategy} from '../interfaces/IStrategy.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\nimport {IMardukGate} from '../interfaces/IMardukGate.sol';\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IAdminGarden} from '../interfaces/IGarden.sol';\nimport {IVoteToken} from '../interfaces/IVoteToken.sol';\n\nimport {VTableBeaconProxy} from '../proxy/VTableBeaconProxy.sol';\nimport {VTableBeacon} from '../proxy/VTableBeacon.sol';\nimport {ControllerLib} from '../lib/ControllerLib.sol';\nimport {BaseGardenModule} from './BaseGardenModule.sol';\n\n/**\n * @title AdminGardenModule\n *\n * Class that holds common garden-related state and functions\n */\ncontract AdminGardenModule is BaseGardenModule, IAdminGarden {\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using PreciseUnitMath for int256;\n    using SafeDecimalMath for int256;\n\n    using SafeCast for uint256;\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    using Address for address;\n    using AddressArrayUtils for address[];\n\n    using SafeERC20 for IERC20;\n    using ECDSA for bytes32;\n\n    using ControllerLib for IBabController;\n\n    /* ============ Events ============ */\n\n    /* ============ Constants ============ */\n\n    // Strategy cooldown period\n    uint256 private constant MIN_COOLDOWN_PERIOD = 60 seconds;\n    uint256 private constant MAX_COOLDOWN_PERIOD = 7 days;\n\n    uint256 private constant TEN_PERCENT = 1e17;\n\n    /* ============ Structs ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Checks if the address passed is a creator in the garden\n     */\n    function _onlyCreator(address _creator) private view {\n        _require(_isCreator(_creator), Errors.ONLY_CREATOR);\n    }\n\n    function _onlyNonZero(address _address) private pure {\n        _require(_address != address(0), Errors.ADDRESS_IS_ZERO);\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * When a new Garden is created.\n     * All parameter validations are on the BabController contract. Validations are performed already on the\n     * BabController.\n     * WARN: If the reserve Asset is different than WETH the gardener needs to have approved the controller.\n     *\n     * @param _reserveAsset                     Address of the reserve asset ERC20\n     * @param _controller                       Address of the controller\n     * @param _creator                          Address of the creator\n     * @param _name                             Name of the Garden\n     * @param _symbol                           Symbol of the Garden\n     * @param _gardenParams                     Array of numeric garden params\n     * @param _initialContribution              Initial Contribution by the Gardener\n     * @param _publicGardenStrategistsStewards  Public garden, public strategists rights and public stewards rights\n     */\n    function initialize(\n        address _reserveAsset,\n        IBabController _controller,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) public payable override initializer {\n        __ERC20_init(_name, _symbol);\n\n        controller = _controller;\n        reserveAsset = _reserveAsset;\n        creator = _creator;\n\n        rewardsDistributor = IRewardsDistributor(controller.rewardsDistributor());\n\n        _onlyNonZero(address(rewardsDistributor));\n\n        privateGarden = !(controller.allowPublicGardens() && _publicGardenStrategistsStewards[0]);\n        publicStrategists = !privateGarden && _publicGardenStrategistsStewards[1];\n        publicStewards = !privateGarden && _publicGardenStrategistsStewards[2];\n\n        _require(\n            _gardenParams[3] > 0 &&\n                _initialContribution >= _gardenParams[3] &&\n                _initialContribution <= _gardenParams[0],\n            Errors.MIN_CONTRIBUTION\n        );\n\n        gardenInitializedAt = block.timestamp;\n\n        _updateGardenParams(\n            _gardenParams[0],\n            _gardenParams[1],\n            _gardenParams[2],\n            _gardenParams[3],\n            _gardenParams[4],\n            _gardenParams[5],\n            _gardenParams[6],\n            _gardenParams[7],\n            _gardenParams[8],\n            _gardenParams[9],\n            _gardenParams[10],\n            0 // stack overflow otherwise\n        );\n        canMintNftAfter = _gardenParams[11];\n    }\n\n    /* ============ External Functions ============ */\n\n    /*\n     * Creator transfer his creator rights to another account.\n     * Must be a creator or an aux creator\n     * @param _newCreator  New creator address\n     * @param _index       Index of the creator if it is in the extra\n     */\n    function transferCreatorRights(address _newCreator, uint8 _index) external override {\n        _onlyCreator(msg.sender);\n        _require(!_isCreator(_newCreator), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        // Make sure creator can still have normal permissions after renouncing\n        // Creator can only renounce to 0x in public gardens\n        _require(_newCreator != address(0) || !privateGarden, Errors.CREATOR_CANNOT_RENOUNCE);\n        if (msg.sender == creator) {\n            creator = _newCreator;\n            return;\n        }\n        _require(extraCreators[_index] == msg.sender, Errors.ONLY_CREATOR);\n        extraCreators[_index] = _newCreator;\n    }\n\n    /*\n     * Governance can transfer garden owners to a different owner if original creator renounced\n     * Must be a creator or an aux creator\n     * @param _newCreator   New creator address\n     * @param _newCreators  Addresses of the new creators\n     */\n    function updateCreators(address _newCreator, address[MAX_EXTRA_CREATORS] memory _newCreators) external override {\n        controller.onlyGovernanceOrEmergency();\n        // Make sure creator can still have normal permissions after renouncing\n        // Creator can only renounce to 0x in public gardens\n        _require(_newCreator != address(0) && creator == address(0), Errors.CREATOR_CANNOT_RENOUNCE);\n        creator = _newCreator;\n        extraCreators[0] = _newCreators[0];\n        extraCreators[1] = _newCreators[1];\n        extraCreators[2] = _newCreators[2];\n        extraCreators[3] = _newCreators[3];\n    }\n\n    /*\n     * Governance can mark a garden as verified\n     * @param _verifiedCategory   New verified category\n     */\n    function verifyGarden(uint256 _verifiedCategory) external override {\n        controller.onlyGovernanceOrEmergency();\n        verifiedCategory = _verifiedCategory;\n    }\n\n    /*\n     * Creator can reset the garden hardlock for all users\n     * @param _hardlockStartsAt       New global hardlock starts at\n     */\n    function resetHardlock(uint256 _hardlockStartsAt) external override {\n        _onlyCreator(msg.sender);\n        _require(_hardlockStartsAt <= block.timestamp, Errors.RESET_HARDLOCK_INVALID);\n        hardlockStartsAt = _hardlockStartsAt;\n    }\n\n    /**\n     * Makes a previously private garden public\n     */\n    function makeGardenPublic() external override {\n        _onlyCreator(msg.sender);\n        _require(privateGarden && controller.allowPublicGardens(), Errors.GARDEN_ALREADY_PUBLIC);\n        privateGarden = false;\n    }\n\n    /**\n     * Gives the right to create strategies and/or voting power to garden users\n     */\n    function setPublicRights(bool _publicStrategists, bool _publicStewards) external override {\n        _onlyCreator(msg.sender);\n        _require(!privateGarden, Errors.GARDEN_IS_NOT_PUBLIC);\n        publicStrategists = _publicStrategists;\n        publicStewards = _publicStewards;\n    }\n\n    /*\n     * Adds extra creators. Only the original creator can call this.\n     * Can only be called if all the addresses are zero\n     * @param _newCreators  Addresses of the new creators\n     */\n    function addExtraCreators(address[MAX_EXTRA_CREATORS] memory _newCreators) external override {\n        _require(msg.sender == creator, Errors.ONLY_FIRST_CREATOR_CAN_ADD);\n        _assignExtraCreator(0, _newCreators[0]);\n        _assignExtraCreator(1, _newCreators[1]);\n        _assignExtraCreator(2, _newCreators[2]);\n        _assignExtraCreator(3, _newCreators[3]);\n    }\n\n    /**\n     * Updates Garden Params\n     * Can only be called by the creator\n     * @param _newParams  New params\n     */\n    function updateGardenParams(uint256[12] memory _newParams) external override {\n        _onlyCreator(msg.sender);\n        _updateGardenParams(\n            _newParams[0], // uint256 _maxDepositLimit\n            _newParams[1], // uint256 _minLiquidityAsset,\n            _newParams[2], // uint256 _depositHardlock,\n            _newParams[3], // uint256 _minContribution,\n            _newParams[4], // uint256 _strategyCooldownPeriod,\n            _newParams[5], // uint256 _minVotesQuorum,\n            _newParams[6], // uint256 _minStrategyDuration,\n            _newParams[7], // uint256 _maxStrategyDuration,\n            _newParams[8], // uint256 _minVoters\n            _newParams[9], // uint256 _pricePerShareDecayRate\n            _newParams[10], // uint256 _pricePerShareDelta\n            _newParams[11] //  uint256 _canMintNftAfter\n        );\n    }\n\n    /**\n     * PRIVILEGE FUNCTION to delegate Garden voting power itself into a delegatee\n     * To be used by Garden Creator only.\n     * Compatible with BABL and COMP and few others ERC20Comp related tokens\n     * @param _token         Address of BABL or any other ERC20Comp related governance token\n     * @param _delegatee     Address to delegate token voting power into\n     */\n    function delegateVotes(address _token, address _delegatee) external override {\n        _onlyCreator(msg.sender);\n        _require(_token != address(0) && _delegatee != address(0), Errors.ADDRESS_IS_ZERO);\n        IVoteToken(_token).delegate(_delegatee);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     *  Updates Garden params\n     *\n     * @param _maxDepositLimit             Max deposit limit\n     * @param _minLiquidityAsset           Number that represents min amount of liquidity denominated in ETH\n     * @param _depositHardlock             Number that represents the time deposits are locked for\n     *                                     an user after he deposits\n     * @param _minContribution             Min contribution to the garden\n     * @param _strategyCooldownPeriod      How long after the strategy has been activated, will it be ready\n     *                                     to be executed\n     * @param _minVotesQuorum              Percentage of votes needed to activate an strategy (0.01% = 1e14, 1% = 1e16)\n     * @param _minStrategyDuration         Min duration of an strategy\n     * @param _maxStrategyDuration         Max duration of an strategy\n     * @param _minVoters                   The minimum amount of voters needed for quorum\n     * @param _pricePerShareDecayRate      Decay rate of price per share\n     * @param _pricePerShareDelta          Base slippage for price per share\n     * @param _canMintNftAfter             Can mint nft after secs\n     */\n    function _updateGardenParams(\n        uint256 _maxDepositLimit,\n        uint256 _minLiquidityAsset,\n        uint256 _depositHardlock,\n        uint256 _minContribution,\n        uint256 _strategyCooldownPeriod,\n        uint256 _minVotesQuorum,\n        uint256 _minStrategyDuration,\n        uint256 _maxStrategyDuration,\n        uint256 _minVoters,\n        uint256 _pricePerShareDecayRate,\n        uint256 _pricePerShareDelta,\n        uint256 _canMintNftAfter\n    ) private {\n        _require(\n            _minLiquidityAsset >= controller.minLiquidityPerReserve(reserveAsset) && _minLiquidityAsset > 0,\n            Errors.MIN_LIQUIDITY\n        );\n        _require(_depositHardlock > 0, Errors.DEPOSIT_HARDLOCK);\n        _require(\n            _strategyCooldownPeriod <= MAX_COOLDOWN_PERIOD && _strategyCooldownPeriod >= MIN_COOLDOWN_PERIOD,\n            Errors.NOT_IN_RANGE\n        );\n        _require(_minVotesQuorum >= TEN_PERCENT.div(2) && _minVotesQuorum <= TEN_PERCENT.mul(5), Errors.VALUE_TOO_LOW);\n        _require(\n            _maxStrategyDuration >= _minStrategyDuration &&\n                _minStrategyDuration >= 1 days &&\n                _maxStrategyDuration <= 500 days,\n            Errors.DURATION_RANGE\n        );\n        _require(_minVoters >= 1 && _minVoters < 10, Errors.MIN_VOTERS_CHECK);\n\n        maxDepositLimit = _maxDepositLimit;\n        minContribution = _minContribution;\n        strategyCooldownPeriod = _strategyCooldownPeriod;\n        minVotesQuorum = _minVotesQuorum;\n        minVoters = _minVoters;\n        minStrategyDuration = _minStrategyDuration;\n        maxStrategyDuration = _maxStrategyDuration;\n        minLiquidityAsset = _minLiquidityAsset;\n        depositHardlock = _depositHardlock;\n        pricePerShareDecayRate = _pricePerShareDecayRate;\n        pricePerShareDelta = _pricePerShareDelta;\n        canMintNftAfter = _canMintNftAfter;\n    }\n\n    // Checks if an address is a creator\n    function _isCreator(address _creator) private view returns (bool) {\n        return\n            _creator != address(0) &&\n            (extraCreators[0] == _creator ||\n                extraCreators[1] == _creator ||\n                extraCreators[2] == _creator ||\n                extraCreators[3] == _creator ||\n                _creator == creator);\n    }\n\n    // Assign extra creators\n    function _assignExtraCreator(uint8 _index, address _newCreator) private {\n        _require(!_isCreator(_newCreator), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        _require(extraCreators[_index] == address(0), Errors.NEW_CREATOR_MUST_NOT_EXIST);\n        extraCreators[_index] = _newCreator;\n    }\n}\n"
    },
    "contracts/mocks/ERC1271WalletMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ECDSA} from '@openzeppelin/contracts/cryptography/ECDSA.sol';\n\nimport {IERC1271} from '../interfaces/IERC1271.sol';\n\ncontract ERC1271WalletMock is Ownable, IERC1271 {\n    constructor(address originalOwner) {\n        transferOwnership(originalOwner);\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature) public view override returns (bytes4 magicValue) {\n        return ECDSA.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0);\n    }\n}\n"
    },
    "contracts/gardens/GardenFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/UpgradeableBeacon.sol';\n\nimport {SafeBeaconProxy} from '../proxy/SafeBeaconProxy.sol';\nimport {IGardenFactory} from '../interfaces/IGardenFactory.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden, ICoreGarden, IAdminGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenFactory\n * @author Babylon Finance\n *\n * Factory to deploy Gardens on-chain\n */\ncontract GardenFactory is IGardenFactory {\n    IBabController private immutable controller;\n    UpgradeableBeacon private immutable beacon;\n\n    constructor(IBabController _controller, UpgradeableBeacon _beacon) {\n        require(address(_controller) != address(0), 'Controller is zero');\n        require(address(_beacon) != address(0), 'Beacon is zero');\n\n        controller = IBabController(_controller);\n        beacon = _beacon;\n    }\n\n    /**\n     * Creates a garden using minimal proxies\n     * @param _reserveAsset             Address of the reserve asset ERC20\n     * @param _creator                  Address of the creator\n     * @param _name                     Name of the Garden\n     * @param _symbol                   Symbol of the Garden\n     * @param _tokenURI                 URL of the garden NFT JSON\n     * @param _seed                     Seed to regenerate the garden NFT\n     * @param _gardenParams             Array of numeric params in the garden\n     * @param _initialContribution      Initial Contribution by the Gardener\n     * @param _publicGardenStrategistsStewards Public strategist rights and\n     * public stewards rights\n     */\n    function createGarden(\n        address _reserveAsset,\n        address _creator,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        uint256 _seed,\n        uint256[] calldata _gardenParams,\n        uint256 _initialContribution,\n        bool[] memory _publicGardenStrategistsStewards\n    ) external override returns (address) {\n        require(msg.sender == address(controller), 'Only the controller can create gardens');\n        address payable proxy =\n            payable(\n                new SafeBeaconProxy(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        IAdminGarden.initialize.selector,\n                        _reserveAsset,\n                        controller,\n                        _creator,\n                        _name,\n                        _symbol,\n                        _gardenParams,\n                        _initialContribution,\n                        _publicGardenStrategistsStewards\n                    )\n                )\n            );\n        IGardenNFT(controller.gardenNFT()).saveGardenURIAndSeed(proxy, _tokenURI, _seed);\n        return proxy;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "contracts/gardens/GardenNFT.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\n//\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {Counters} from '@openzeppelin/contracts/utils/Counters.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\nimport {IGarden} from '../interfaces/IGarden.sol';\nimport {IGardenNFT} from '../interfaces/IGardenNFT.sol';\n\n/**\n * @title GardenNFT\n * @author Babylon Finance\n *\n * Contract the NFT for each Garden\n */\ncontract GardenNFT is ERC721, IGardenNFT {\n    using Counters for Counters.Counter;\n\n    /* ============ Events ============ */\n\n    event GardenNFTAwarded(address indexed _member, uint256 indexed _newItemId);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyGarden {\n        require(\n            controller.isSystemContract(msg.sender) && IGarden(msg.sender).controller() == controller,\n            'Only the garden can mint the NFT'\n        );\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Address of the Controller contract\n    IBabController public controller;\n\n    Counters.Counter private _tokenIds;\n    mapping(address => string) public override gardenTokenURIs;\n    mapping(address => uint256) public override gardenSeeds;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Sets the protocol controller\n     *\n     * @param _controller         Address of controller contract\n     * @param _name               Name of the garden\n     * @param _symbol             Symbol of the garden\n     */\n    constructor(\n        address _controller,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(address(_controller) != address(0), 'Controller must exist');\n        controller = IBabController(_controller);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Awards the garden NFT to a user and gives him access to a specific garden\n     *\n     * @param _user               Address of the user\n     */\n    function grantGardenNFT(address _user) external override onlyGarden returns (uint256) {\n        require(address(_user) != address(0), 'User must exist');\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(_user, newItemId);\n        _setTokenURI(newItemId, gardenTokenURIs[msg.sender]);\n        emit GardenNFTAwarded(_user, newItemId);\n        return newItemId;\n    }\n\n    /**\n     * Saves the Garden URI and seed\n     *\n     * @param _garden               Address of the garden\n     * @param _gardenTokenURI     Garden Token URI\n     */\n    function saveGardenURIAndSeed(\n        address _garden,\n        string memory _gardenTokenURI,\n        uint256 _seed\n    ) external override {\n        require(controller.isSystemContract(msg.sender), 'Only a system contract can call this');\n        gardenTokenURIs[_garden] = _gardenTokenURI;\n        gardenSeeds[_garden] = _seed;\n    }\n}\n"
    },
    "contracts/GardenValuer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {SignedSafeMath} from '@openzeppelin/contracts/math/SignedSafeMath.sol';\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {IGarden} from './interfaces/IGarden.sol';\nimport {IStrategy} from './interfaces/IStrategy.sol';\nimport {IPriceOracle} from './interfaces/IPriceOracle.sol';\nimport {PreciseUnitMath} from './lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath as SafeMath} from './lib/LowGasSafeMath.sol';\n\n/**\n * @title GardenValuer\n * @author Babylon Finance\n *\n * Contract that returns the valuation of a Garden using price oracle data used in contracts\n * that are external to the system.\n *\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract GardenValuer {\n    using PreciseUnitMath for int256;\n    using PreciseUnitMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    // Instance of the Controller contract\n    address public controller;\n\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables and map asset pairs to their oracles\n     *\n     * @param _controller             Address of controller contract\n     */\n    constructor(address _controller) {\n        require(_controller != address(0), 'Incorrect address');\n        controller = _controller;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Gets the valuation of a Garden using data from the price oracle.\n     * Adds all the active strategies plus the reserve asset and ETH.\n     * Note: this works for external\n     * positions and negative (debt) positions.\n     *\n     * Note: There is a risk that the valuation is off if airdrops aren't retrieved\n     *\n     * @param _garden               Garden instance to get valuation\n     * @param _quoteAsset           Quote asset for the valuation\n     *\n     * @return                 Token valuation in terms of quote asset in precise units 1e18\n     */\n    function calculateGardenValuation(address _garden, address _quoteAsset) external view returns (uint256) {\n        IPriceOracle priceOracle = IPriceOracle(IBabController(controller).priceOracle());\n        require(\n            address(priceOracle) != address(0) &&\n                _garden != address(0) &&\n                _quoteAsset != address(0) &&\n                IBabController(controller).isSystemContract(_garden),\n            'Incorrect input data'\n        );\n        address reserveAsset = IGarden(_garden).reserveAsset();\n        uint256 totalSupply = ERC20(_garden).totalSupply();\n        // If there are no tokens return 0\n        if (totalSupply == 0) {\n            return 0;\n        }\n        uint8 quoteAssetDecimals = ERC20(_quoteAsset).decimals();\n\n        uint256 reservePrice;\n        // Get price of the reserveAsset in _quoteAsset\n        if (reserveAsset == _quoteAsset) {\n            // meaning 1 reserveAsset equals to 1 _quoteAsset\n            reservePrice = 1 ether;\n        } else {\n            reservePrice = priceOracle.getPrice(reserveAsset, _quoteAsset);\n        }\n\n        address[] memory strategies = IGarden(_garden).getStrategies();\n        uint256 valuation;\n        for (uint256 j = 0; j < strategies.length; j++) {\n            IStrategy strategy = IStrategy(strategies[j]);\n            // strategies return their valuation in garden's reserveAsset\n            valuation = valuation.add(strategy.getNAV());\n        }\n\n        // Add garden reserve assets and garden's reserve asset\n        valuation = valuation.add(ERC20(reserveAsset).balanceOf(address(_garden)));\n\n        // Subtract the reserves set aside for rewards\n        valuation = valuation.sub(IGarden(_garden).reserveAssetRewardsSetAside());\n\n        // Subtract Keeper debt\n        valuation = valuation.sub(IGarden(_garden).keeperDebt());\n\n        // Get the valuation in terms of the quote asset\n        valuation = valuation.preciseMul(reservePrice);\n\n        if (quoteAssetDecimals < 18) {\n            valuation = valuation.mul(10**(18 - quoteAssetDecimals));\n        }\n\n        return valuation.preciseDiv(ERC20(_garden).totalSupply());\n    }\n}\n"
    },
    "contracts/integrations/lend/AaveLendIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\nimport {AaveToken} from '../../interfaces/external/aave/AaveToken.sol';\nimport {ILendingPool} from '../../interfaces/external/aave/ILendingPool.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/external/aave/ILendingPoolAddressesProvider.sol';\nimport {IProtocolDataProvider} from '../../interfaces/external/aave/IProtocolDataProvider.sol';\nimport {IStakedAave} from '../../interfaces/external/aave/IStakedAave.sol';\n\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {LendIntegration} from './LendIntegration.sol';\n\n/**\n * @title AaveLendIntegration\n * @author Babylon Finance Protocol\n *\n * Aave lend integration.\n */\ncontract AaveLendIntegration is LendIntegration {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n\n    /* ============ Constant ============ */\n\n    ILendingPool constant lendingPool = ILendingPool(address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9)); // Mainnet\n    IProtocolDataProvider constant dataProvider =\n        IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d)); // Mainnet\n\n    address private constant stkAAVE = 0x4da27a545c0c5B758a6BA100e3a049001de870f5;\n\n    /* ============ Struct ============ */\n\n    /* ============ Events ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller             Address of the controller\n     */\n    constructor(IBabController _controller) LendIntegration('aavelend', _controller) {}\n\n    function getInvestmentTokenAmount(address _address, address _assetToken) public view override returns (uint256) {\n        return IERC20(_getInvestmentToken(_assetToken)).balanceOf(_address);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getHealthFactor(address _strategy) internal view override returns (uint256) {\n        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(_strategy);\n        return healthFactor;\n    }\n\n    function _getRewardToken() internal pure override returns (address) {\n        return AAVE;\n    }\n\n    function _getCollateralFactor(address _assetToken) internal view virtual override returns (uint256) {\n        (, , uint256 collateral, , , , , , , ) = dataProvider.getReserveConfigurationData(_assetToken);\n        return collateral.mul(1e14);\n    }\n\n    function _getRewardsAccrued(address _strategy) internal view override returns (uint256) {\n        return IStakedAave(stkAAVE).stakerRewardsToClaim(_strategy);\n    }\n\n    function _isInvestment(address _assetToken) internal view override returns (bool) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress != address(0);\n    }\n\n    function _getExpectedShares(\n        address, /* _assetToken */\n        uint256 _numTokensToSupply\n    ) internal pure override returns (uint256) {\n        // love it 😍\n        return _numTokensToSupply;\n    }\n\n    function _getExchangeRatePerToken(\n        address /* _assetToken */\n    ) internal pure override returns (uint256) {\n        // love it 😍\n        return 1;\n    }\n\n    /**\n     * Claim rewards calldata\n     *\n     * hparam  _strategy                 Address of the strategy\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _claimRewardsCallData(address _strategy)\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('claimRewards(address,uint256)', _strategy, IERC20(stkAAVE).balanceOf(_strategy));\n\n        return (stkAAVE, 0, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * hparam  _asset                    Address of the asset to deposit\n     * hparam  _amount                   Amount of the token to deposit\n     * hparam  _borrowOp                Type of Borrow op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address, /* _asset */\n        uint256, /* _amount */\n        uint256 /* _borrowOp */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Returns calldata for supplying tokens.\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getSupplyCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature(\n                'deposit(address,uint256,address,uint16)',\n                _assetToken,\n                _numTokensToSupply,\n                _strategy,\n                0\n            );\n        return (address(lendingPool), 0, methodData);\n    }\n\n    /**\n     * Returns calldata for redeeming the collateral\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getRedeemCalldata(\n        address _strategy,\n        address _assetToken,\n        uint256 _numTokensToSupply\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('withdraw(address,uint256,address)', _assetToken, _numTokensToSupply, _strategy);\n        return (address(lendingPool), 0, methodData);\n    }\n\n    function _getSpender(\n        address /* _investmentAddress */\n    ) internal pure override returns (address) {\n        return address(lendingPool);\n    }\n\n    function _getInvestmentToken(address _assetToken) internal view override returns (address) {\n        (address aTokenAddress, , ) = dataProvider.getReserveTokensAddresses(_assetToken);\n        return aTokenAddress;\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/AaveToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface AaveToken {\n    function underlyingAssetAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/aave/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\ninterface IStakedAave {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function stakerRewardsToClaim(address input) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/cream/ICreamPriceOracleProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ICToken} from '../compound/ICToken.sol';\n\ninterface ICreamPriceOracleProxy {\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\n}\n"
    },
    "contracts/governance/Assistant.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n\nimport {IWETH} from '../interfaces/external/weth/IWETH.sol';\nimport {IHypervisor} from '../interfaces/IHypervisor.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\nimport {ControllerLib} from '../lib/ControllerLib.sol';\n\nimport 'hardhat/console.sol';\n\ncontract Assistant is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using ControllerLib for IBabController;\n\n    /* ============ Events ============ */\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n    /* ============ Constants ============ */\n\n    /* ============ Constructor ============ */\n\n    function initialize() public {\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    /* ============ External Functions ============ */\n\n    function setupUIGovernor() external {}\n\n    // We need to send BABL to assistant first\n    function rewardProphets(address[] calldata _addresses) external {\n        require(address(msg.sender) == 0x97FcC2Ae862D03143b393e9fA73A32b563d57A6e, 'Only multisig');\n        IERC20 BABL = IERC20(0xF4Dc48D260C93ad6a96c5Ce563E70CA578987c74);\n        // BABL.safeTransferFrom(msg.sender, address(this), 2e18 * _addresses.length);\n        uint256 length = _addresses.length;\n        for (uint256 i = 0; i < length; ) {\n            BABL.transfer(_addresses[i], 2e18);\n            ++i;\n        }\n    }\n\n    /* ============ External Getter Functions ============ */\n    /* ============ Internal Only Function ============ */\n\n    // Can receive ETH\n    // solhint-disable-next-line\n    receive() external payable {}\n}\n\ncontract AssistantV9 is Assistant {}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/integrations/passive/PickleJarIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IJar} from '../../interfaces/external/pickle/IJar.sol';\n\n/**\n * @title PickleJarIntegration\n * @author Babylon Finance Protocol\n *\n * Pickle Jar Integration\n */\ncontract PickleJarIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('pickle_jar', _controller) {}\n\n    /* ============ Internal Functions ============ */\n    function _getSpender(\n        address _jar,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _jar;\n    }\n\n    function _getExpectedShares(address _jar, uint256 _amount) internal view override returns (uint256) {\n        // Normalize to 18 decimals\n        uint256 amoountNormalized = SafeDecimalMath.normalizeAmountTokens(IJar(_jar).token(), _jar, _amount);\n        return amoountNormalized.preciseDiv(IJar(_jar).getRatio());\n    }\n\n    function _getPricePerShare(address _jar) internal view override returns (uint256) {\n        return IJar(_jar).getRatio();\n    }\n\n    function _getInvestmentAsset(address _jar) internal view override returns (address lptoken) {\n        return IJar(_jar).token();\n    }\n\n    function _getResultAsset(address _jar) internal view virtual override returns (address) {\n        return _jar;\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address token = _getInvestmentAsset(_asset);\n        require(token != address(0), 'Pickle jar does not exist');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('deposit(uint256)', _maxAmountIn);\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Withdraw all and claim\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256)', _investmentTokensIn);\n        // Go through the reward pool instead of the booster\n        return (_asset, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/pickle/IJar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IJar is IERC20 {\n    function token() external view returns (address);\n\n    function reward() external view returns (address);\n\n    function claimInsurance() external; // NOTE: Only yDelegatedVault implements this\n\n    function getRatio() external view returns (uint256);\n\n    function depositAll() external;\n\n    function balance() external view returns (uint256);\n\n    function deposit(uint256) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256) external;\n\n    function earn() external;\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/integrations/passive/LidoStakeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IStETH} from '../../interfaces/external/lido/IStETH.sol';\nimport {IWstETH} from '../../interfaces/external/lido/IWstETH.sol';\n\n/**\n * @title LidoStakeIntegration\n * @author Babylon Finance Protocol\n *\n * Lido Integration\n */\ncontract LidoStakeIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    IStETH private constant stETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    IWstETH private constant wstETH = IWstETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n    address private constant curveSteth = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('lidostaking', _controller) {}\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(address _asset, uint8 _op) internal pure override returns (address) {\n        if (_op == 1) {\n            return curveSteth;\n        }\n        return _asset;\n    }\n\n    function _getExpectedShares(address _asset, uint256 _amount) internal view override returns (uint256) {\n        uint256 shares = stETH.getSharesByPooledEth(_amount);\n        if (_asset == address(wstETH)) {\n            return wstETH.getWstETHByStETH(shares);\n        }\n        return shares;\n    }\n\n    function _getPricePerShare(address _asset) internal view override returns (uint256) {\n        uint256 shares = 1e18;\n        // wrapped steth\n        if (_asset == address(wstETH)) {\n            shares = wstETH.getStETHByWstETH(shares);\n        }\n        return stETH.getPooledEthByShares(shares);\n    }\n\n    function _getInvestmentAsset(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        // Both take ETH\n        return address(0);\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData;\n        if (_asset == address(stETH)) {\n            methodData = abi.encodeWithSignature('submit(address)', controller.treasury());\n        } else {\n            // wstETH is just a raw transfer and does both\n            methodData = bytes('');\n        }\n\n        return (_asset, _maxAmountIn, methodData);\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _asset                    Address of the asset to deposit\n     * @param  _amount                   Amount of the token to deposit\n     * @param  _op                       Type of op\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _asset,\n        uint256 _amount,\n        uint256 _op,\n        address /* _strategy */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        if (_op == 1 && _asset == address(wstETH)) {\n            // Exit 0p && wsteth need to unwrap before redeeming\n            bytes memory methodData = abi.encodeWithSignature('unwrap(uint256)', _amount);\n            return (address(wstETH), 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address, /* _asset */\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData =\n            abi.encodeWithSignature('exchange(int128,int128,uint256,uint256)', 1, 0, _investmentTokensIn, 1);\n        // Need to swap via curve. Lido doesn't implement withdraw yet\n        return (curveSteth, 0, methodData);\n    }\n\n    function _preActionNeedsApproval() internal pure override returns (address) {\n        return address(wstETH);\n    }\n\n    function _getAssetAfterExitPreAction(\n        address /* _asset */\n    ) internal pure override returns (address) {\n        return address(stETH);\n    }\n}\n"
    },
    "contracts/integrations/passive/HarvestVaultIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\n\nimport {IHarvestVault} from '../../interfaces/external/harvest/IVault.sol';\n\n/**\n * @title HarvestIntegration\n * @author Babylon Finance Protocol\n *\n * Harvest v2 Vault Integration\n */\ncontract HarvestVaultIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('harvestvaults', _controller) {}\n\n    /* ============ External Functions ============ */\n\n    /* ============ Internal Functions ============ */\n\n    function _getSpender(\n        address _vault,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _vault;\n    }\n\n    function _getExpectedShares(address _vault, uint256 _amount) internal view override returns (uint256) {\n        // Normalizing pricePerShare returned by Harvest\n        return\n            _amount.preciseDiv(IHarvestVault(_vault).getPricePerFullShare()).div(\n                10**PreciseUnitMath.decimals().sub(ERC20(_vault).decimals())\n            );\n    }\n\n    function _getPricePerShare(address _vault) internal view override returns (uint256) {\n        return IHarvestVault(_vault).getPricePerFullShare();\n    }\n\n    function _getInvestmentAsset(address _vault) internal view override returns (address) {\n        return IHarvestVault(_vault).underlying();\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.deposit.selector, _maxAmountIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _investmentAddress              Address of the investment\n     * @param  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _investmentAddress,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSelector(IHarvestVault.withdraw.selector, _investmentTokensIn);\n\n        return (_investmentAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/harvest/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IHarvestVault {\n    function underlyingBalanceInVault() external view returns (uint256);\n\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    function governance() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n    function deposit(uint256 amountWei) external;\n\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256 numberOfShares) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/integrations/passive/HarvestV3StakeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {SafeDecimalMath} from '../../lib/SafeDecimalMath.sol';\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {IGarden} from '../../interfaces/IGarden.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {PassiveIntegration} from './PassiveIntegration.sol';\nimport {IHarvestV3Stake} from '../../interfaces/external/harvest/IHarvestV3Stake.sol';\n\n/**\n * @title HarvestV3StakeIntegration\n * @author Babylon Finance Protocol\n *\n * Harvest V3 Stake Integration\n */\ncontract HarvestV3StakeIntegration is PassiveIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller) PassiveIntegration('harvest_stake_v3', _controller) {}\n\n    /* ============ Internal Functions ============ */\n    function _getSpender(\n        address _stakingPool,\n        uint8 /* _op */\n    ) internal pure override returns (address) {\n        return _stakingPool;\n    }\n\n    function _getExpectedShares(\n        address, /* _asset */\n        uint256 _amount\n    ) internal pure override returns (uint256) {\n        return _amount;\n    }\n\n    function _getPricePerShare(\n        address /* _asset */\n    ) internal pure override returns (uint256) {\n        return 1e18;\n    }\n\n    function _getInvestmentAsset(address _asset) internal view override returns (address lptoken) {\n        return IHarvestV3Stake(_asset).lpToken();\n    }\n\n    function _getResultAsset(address _investment) internal view virtual override returns (address) {\n        return _investment;\n    }\n\n    /**\n     * Return join investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * @param  _asset                          Address of the vault\n     * hparam  _investmentTokensOut            Amount of investment tokens to send\n     * hparam  _tokenIn                        Addresses of tokens to send to the investment\n     * @param  _maxAmountIn                    Amounts of tokens to send to the investment\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getEnterInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256, /* _investmentTokensOut */\n        address, /* _tokenIn */\n        uint256 _maxAmountIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address lpToken = _getInvestmentAsset(_asset);\n        require(lpToken != address(0), 'Harvest V3 Stake pool does not exist');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('stake(uint256)', _maxAmountIn);\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata which is already generated from the investment API\n     *\n     * hparam  _strategy                       Address of the strategy\n     * hparam  _asset                          Address of the investment\n     * hparam  _investmentTokensIn             Amount of investment tokens to receive\n     * hparam  _tokenOut                       Addresses of tokens to receive\n     * hparam  _minAmountOut                   Amounts of investment tokens to receive\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getExitInvestmentCalldata(\n        address, /* _strategy */\n        address _asset,\n        uint256 _investmentTokensIn,\n        address, /* _tokenOut */\n        uint256 /* _minAmountOut */\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Withdraw all and claim\n        bytes memory methodData = abi.encodeWithSignature('withdraw(uint256)', _investmentTokensIn);\n        // Go through the reward pool instead of the booster\n        return (_asset, 0, methodData);\n    }\n\n    /**\n     * Return exit investment calldata to execute after exit if any\n     *\n     * @param  _pool                           Address of the reward pool\n     * hparam  _amount                         Amount of tokens\n     * @param  _passiveOp                      enter is 0, exit is 1\n     *\n     * @return address                         Target contract address\n     * @return uint256                         Call value\n     * @return bytes                           Trade calldata\n     */\n    function _getPostActionCallData(\n        address _pool,\n        uint256, /* _amount */\n        uint256 _passiveOp\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Don't do anything on enter\n        if (_passiveOp == 0) {\n            return (address(0), 0, bytes(''));\n        }\n        // Withdraw all and claim\n        bytes memory methodData = abi.encodeWithSignature('getAllRewards()');\n        // Go through the reward pool instead of the booster\n        return (_pool, 0, methodData);\n    }\n\n    function _getRewards(address _strategy, address _asset)\n        internal\n        view\n        override\n        returns (address token, uint256 balance)\n    {\n        IHarvestV3Stake pool = IHarvestV3Stake(_asset);\n        IPriceOracle oracle = IPriceOracle(IBabController(controller).priceOracle());\n        address reserveAsset = IGarden(IStrategy(_strategy).garden()).reserveAsset();\n        uint256 rewardsLength = pool.rewardTokensLength();\n        uint256 totalAmount = 0;\n        if (rewardsLength > 0) {\n            for (uint256 i = 0; i < rewardsLength; i++) {\n                uint256 rewardAmount = pool.earned(i, _strategy);\n                totalAmount = totalAmount.add(\n                    oracle.getPrice(pool.rewardTokens(i), reserveAsset).preciseMul(rewardAmount)\n                );\n            }\n        }\n        return (reserveAsset, totalAmount);\n    }\n}\n"
    },
    "contracts/interfaces/external/harvest/IHarvestV3Stake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IHarvestV3Stake {\n    function earned(uint256 i, address account) external view returns (uint256);\n\n    function rewardTokensLength() external view returns (uint256);\n\n    function lpToken() external view returns (address);\n\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getAllRewards() external;\n\n    function rewardTokens(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/integrations/pool/CurvePoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {ICurveMetaRegistry} from '../../interfaces/ICurveMetaRegistry.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {ControllerLib} from '../../lib/ControllerLib.sol';\n\n/**\n * @title CurvePoolIntegration\n * @author Babylon Finance Protocol\n *\n * Curve liquidity providing integration\n */\ncontract CurvePoolIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n    using ControllerLib for IBabController;\n\n    /* ============ Constant ============ */\n    address private constant TRICRYPTO2 = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46; // Pool only takes ETH\n    address private constant cvxCRVPool = 0x9D0464996170c6B9e75eED71c68B99dDEDf279e8; // Pool only takes CRV for us\n    address private constant palstkaave = 0x48536EC5233297C367fd0b6979B75d9270bB6B15; // Pool only takes CRV for us\n    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52; // crv\n    address private constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B; // cvx\n    ICurveMetaRegistry private immutable curveMetaRegistry;\n\n    /* ============ State Variables ============ */\n\n    // Registry of first party pools\n\n    // Mapping of pools to deposit contract\n    mapping(address => address) private poolToDeposit;\n\n    // Whether to deposit using the underlying coins\n    mapping(address => bool) private usesUnderlying;\n\n    // Whether it supports the underlying param in add liquidity and remove liquidity\n    mapping(address => bool) private supportsUnderlyingParam;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     */\n    constructor(IBabController _controller, ICurveMetaRegistry _curveMetaRegistry)\n        PoolIntegration('curve_pool', _controller)\n    {\n        require(address(_controller) != address(0), 'invalid address');\n        require(address(_curveMetaRegistry) != address(0), 'invalid address');\n\n        usesUnderlying[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = true; // aave\n        usesUnderlying[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = true; // compound\n        usesUnderlying[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = true; // usdt\n        usesUnderlying[0x06364f10B501e868329afBc005b3492902d6C763] = true; // PAX\n        usesUnderlying[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = true; // ironbank\n        usesUnderlying[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = true; // busd\n        usesUnderlying[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = true; // y\n        usesUnderlying[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = true; // susd\n        usesUnderlying[0x8925D9d9B4569D737a48499DeF3f67BaA5a144b9] = true; // yv2\n        usesUnderlying[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = true; // saave\n\n        poolToDeposit[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = 0xeB21209ae4C2c9FF2a86ACA31E123764A3B6Bc06; // compound\n        poolToDeposit[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = 0xac795D2c97e60DF6a99ff1c814727302fD747a80; // usdt\n        poolToDeposit[0x06364f10B501e868329afBc005b3492902d6C763] = 0xA50cCc70b6a011CffDdf45057E39679379187287; // pax\n        poolToDeposit[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = 0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB; // busd\n        poolToDeposit[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = 0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3; // y\n        poolToDeposit[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = 0xFCBa3E75865d2d561BE8D220616520c171F12851; // susd\n\n        supportsUnderlyingParam[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = true; // aave\n        supportsUnderlyingParam[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = true; // ironbank\n        supportsUnderlyingParam[0x8925D9d9B4569D737a48499DeF3f67BaA5a144b9] = true; // yv2\n        supportsUnderlyingParam[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = true; // saave\n\n        curveMetaRegistry = _curveMetaRegistry;\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(bytes calldata _pool, bool forNAV) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 ncoins = curveMetaRegistry.getNCoins(poolAddress);\n        address[] memory result = new address[](ncoins);\n        address[8] memory coins =\n            curveMetaRegistry.getCoinAddresses(poolAddress, usesUnderlying[poolAddress] && !forNAV);\n        for (uint8 i = 0; i < ncoins; i++) {\n            result[i] = coins[i];\n        }\n        return result;\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory poolTokens = getPoolTokens(_pool, false);\n        uint256[] memory result = new uint256[](curveMetaRegistry.getNCoins(poolAddress));\n        if (poolAddress == TRICRYPTO2) {\n            result[0] = 0;\n            result[1] = 0;\n            result[2] = uint256(1e18);\n            return result;\n        }\n        // cvxCRV\n        if (poolAddress == cvxCRVPool) {\n            result[0] = uint256(1e18);\n            result[1] = 0;\n            return result;\n        }\n        // If it's a meta pool, deposit and withdraw from the stable one\n        if (curveMetaRegistry.isMeta(poolAddress)) {\n            result[0] = uint256(1e18);\n        } else {\n            for (uint8 i = 0; i < poolTokens.length; i++) {\n                result[i] = uint256(1e18).div(poolTokens.length);\n            }\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata, /* _pool */\n        address, /* _poolToken */\n        uint256 /* _maxAmountsIn */\n    ) external pure override returns (uint256) {\n        // return 1 since _poolTokensOut are not used\n        return 1;\n    }\n\n    function getPoolMinAmountsOut(\n        bytes calldata _pool,\n        uint256 /* _liquidity */\n    ) external view override returns (uint256[] memory _minAmountsOut) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256[] memory result = new uint256[](curveMetaRegistry.getNCoins(poolAddress));\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return curveMetaRegistry.isPool(poolAddress);\n    }\n\n    function _getSpender(\n        bytes calldata _pool,\n        uint8 /* _opType */\n    ) internal view override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return poolAddress;\n    }\n\n    function _totalSupply(\n        address /* _pool */\n    ) internal pure override returns (uint256) {\n        return uint256(1e18);\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata _tokensIn,\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 poolCoins = curveMetaRegistry.getNCoins(poolAddress); //_decodeOpDataAsUint8(_pool, 0);\n        // Encode method data for Garden to invoke\n        bytes memory methodData = _getAddLiquidityMethodData(poolAddress, poolCoins, _maxAmountsIn, _poolTokensOut);\n\n        uint256 value = 0;\n        // If any is eth, set as value\n        for (uint256 i = 0; i < poolCoins; i++) {\n            if (_tokensIn[i] == address(0) || _tokensIn[i] == ETH_ADD_CURVE) {\n                value = _maxAmountsIn[i];\n            }\n        }\n        // If we need a deposit contract to deposit underlying, switch\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return (poolAddress, value, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        uint256 poolCoins = curveMetaRegistry.getNCoins(poolAddress); //_decodeOpDataAsUint8(_pool, 0);\n\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = _getRemoveLiquidityMethodData(poolAddress, poolCoins, _minAmountsOut, _poolTokensIn);\n        if (poolToDeposit[poolAddress] != address(0)) {\n            poolAddress = poolToDeposit[poolAddress];\n        }\n        return (poolAddress, 0, methodData);\n    }\n\n    function _getAddLiquidityMethodData(\n        address _poolAddress,\n        uint256 ncoins,\n        uint256[] calldata _maxAmountsIn,\n        uint256 minMintAmount\n    ) private view returns (bytes memory) {\n        if (ncoins == 2) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[2],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[2],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 3) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[3],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[3],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 4) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[4],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[4],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        minMintAmount\n                    );\n            }\n        }\n        if (ncoins == 5) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[5],uint256,bool)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        _maxAmountsIn[4],\n                        minMintAmount,\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'add_liquidity(uint256[5],uint256)',\n                        _maxAmountsIn[0],\n                        _maxAmountsIn[1],\n                        _maxAmountsIn[2],\n                        _maxAmountsIn[3],\n                        _maxAmountsIn[4],\n                        minMintAmount\n                    );\n            }\n        }\n        return bytes('');\n    }\n\n    function _getRemoveLiquidityMethodData(\n        address _poolAddress,\n        uint256 ncoins,\n        uint256[] calldata _minAmountsOut,\n        uint256 _poolTokensIn\n    ) private view returns (bytes memory) {\n        // For meta remove everything in the stable coin\n        if (curveMetaRegistry.isMeta(_poolAddress) || _poolAddress == cvxCRVPool) {\n            return\n                abi.encodeWithSignature(\n                    'remove_liquidity_one_coin(uint256,int128,uint256)',\n                    _poolTokensIn,\n                    int128(0),\n                    _minAmountsOut[0]\n                );\n        }\n        if (ncoins == 2) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[2],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        true\n                    );\n            } else {\n                if (_poolAddress == palstkaave) {\n                    return\n                        abi.encodeWithSignature(\n                            'remove_liquidity_one_coin(uint256,uint256,uint256)',\n                            _poolTokensIn,\n                            uint256(0),\n                            _minAmountsOut[0]\n                        );\n                }\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[2])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1]\n                    );\n            }\n        }\n        if (ncoins == 3) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[3],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[3])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2]\n                    );\n            }\n        }\n        if (ncoins == 4) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[4],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[4])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3]\n                    );\n            }\n        }\n        if (ncoins == 5) {\n            if (supportsUnderlyingParam[_poolAddress]) {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[5],bool)',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[3],\n                        _minAmountsOut[4],\n                        true\n                    );\n            } else {\n                return\n                    abi.encodeWithSignature(\n                        'remove_liquidity(uint256,uint256[5])',\n                        _poolTokensIn,\n                        _minAmountsOut[0],\n                        _minAmountsOut[1],\n                        _minAmountsOut[2],\n                        _minAmountsOut[3],\n                        _minAmountsOut[4]\n                    );\n            }\n        }\n        return bytes('');\n    }\n\n    function _getLpToken(address _pool) internal view override returns (address) {\n        // For Deposits & stable swaps that support it get the LP token, otherwise get the pool\n        return curveMetaRegistry.getLpToken(_pool);\n    }\n\n    function _getUnderlyingAndRate(bytes calldata _pool, uint256 _i) internal view override returns (address, uint256) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return curveMetaRegistry.getUnderlyingAndRate(poolAddress, _i);\n    }\n\n    function _getRewardTokens(\n        address /* _pool */\n    ) internal pure override returns (address[] memory) {\n        address[] memory rewards = new address[](2);\n        rewards[0] = CRV;\n        rewards[1] = CVX;\n        return rewards;\n    }\n}\n"
    },
    "contracts/integrations/trade/CurveTradeIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {IStrategy} from '../../interfaces/IStrategy.sol';\nimport {ICurveMetaRegistry} from '../../interfaces/ICurveMetaRegistry.sol';\n\nimport {LowGasSafeMath as SafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {ControllerLib} from '../../lib/ControllerLib.sol';\n\nimport {TradeIntegration} from './TradeIntegration.sol';\n\n/**\n * @title CurveTradeIntegration\n * @author Babylon Finance Protocol\n *\n * Curve trade integration\n */\ncontract CurveTradeIntegration is TradeIntegration {\n    using SafeMath for uint256;\n    using ControllerLib for IBabController;\n\n    /* ============ Modifiers ============ */\n\n    /* ============ State Variables ============ */\n\n    /* ============ Constants ============ */\n\n    ICurveMetaRegistry private immutable curveMetaRegistry;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _curveMetaRegistry            Address of the curve meta registry\n     */\n    constructor(IBabController _controller, ICurveMetaRegistry _curveMetaRegistry)\n        TradeIntegration('curve_trade', _controller)\n    {\n        require(address(_curveMetaRegistry) != address(0), 'Address needs to be valid');\n        curveMetaRegistry = _curveMetaRegistry;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Executes the trade through curve.\n     *\n     * hparam _strategy             Address of the strategy\n     * @param _sendToken            Address of the token to be sent to the exchange\n     * @param _sendQuantity         Units of reserve asset token sent to the exchange\n     * @param _receiveToken         Address of the token that will be received from the exchange\n     */\n    function _getTradeCallData(\n        address, /* _strategy */\n        address _sendToken,\n        uint256 _sendQuantity,\n        address _receiveToken\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        (address curvePool, address realSendToken, address realReceiveToken) =\n            _getPoolAndTokens(_sendToken, _receiveToken);\n        require(curvePool != address(0), 'No curve pool');\n        (uint256 i, uint256 j, bool underlying) =\n            curveMetaRegistry.getCoinIndices(curvePool, realSendToken, realReceiveToken);\n        // Palstakeaave. TODO: Add others\n        bytes memory methodData;\n        // palStkAAVE/AAVE pool\n        if (curvePool == 0x48536EC5233297C367fd0b6979B75d9270bB6B15) {\n            methodData = abi.encodeWithSignature('exchange(uint256,uint256,uint256,uint256)', i, j, _sendQuantity, 1);\n        } else {\n            methodData = abi.encodeWithSignature(\n                'exchange(int128,int128,uint256,uint256)',\n                int128(i),\n                int128(j),\n                _sendQuantity,\n                1\n            );\n            if (underlying) {\n                methodData = abi.encodeWithSignature(\n                    'exchange_underlying(int128,int128,uint256,uint256)',\n                    int128(i),\n                    int128(j),\n                    _sendQuantity,\n                    1\n                );\n            }\n        }\n\n        return (curvePool, realSendToken == ETH_ADD_CURVE ? _sendQuantity : 0, methodData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the TokenTaker address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function _getSpender(address _swapTarget) internal pure override returns (address) {\n        return _swapTarget;\n    }\n\n    /**\n     * Return pre action calldata\n     *\n     * @param  _sendToken               Address of the asset to send\n     * hparam  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPreActionCallData(\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Unwrap WETH to ETH\n        (, address _realSendToken, ) = _getPoolAndTokens(_sendToken, _receiveToken);\n        if (_realSendToken == ETH_ADD_CURVE) {\n            bytes memory methodData = abi.encodeWithSignature('withdraw(uint256)', _sendQuantity);\n            return (WETH, 0, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    /**\n     * Return post action calldata\n     *\n     * hparam  _sendToken               Address of the asset to send\n     * @param  _receiveToken            Address of the asset to receive\n     * @param  _sendQuantity            Amount of the asset to send\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getPostActionCallData(\n        address _sendToken,\n        address _receiveToken,\n        uint256 _sendQuantity\n    )\n        internal\n        view\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        // Wrap ETH to WETH\n        (, , address _realReceiveToken) = _getPoolAndTokens(_sendToken, _receiveToken);\n        if (_realReceiveToken == ETH_ADD_CURVE) {\n            bytes memory methodData = abi.encodeWithSignature('deposit()');\n            return (WETH, _sendQuantity, methodData);\n        }\n        return (address(0), 0, bytes(''));\n    }\n\n    function _getPostActionToken(\n        address /* _receiveToken */\n    ) internal pure override returns (address) {\n        return ETH_ADD_CURVE;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _getPoolAndTokens(address _sendToken, address _receiveToken)\n        private\n        view\n        returns (\n            address,\n            address,\n            address\n        )\n    {\n        address curvePool = curveMetaRegistry.findPoolForCoins(_sendToken, _receiveToken, 0);\n        if (_sendToken == WETH && curvePool == address(0)) {\n            _sendToken = ETH_ADD_CURVE;\n            curvePool = curveMetaRegistry.findPoolForCoins(ETH_ADD_CURVE, _receiveToken, 0);\n        }\n        if (_receiveToken == WETH && curvePool == address(0)) {\n            _receiveToken = ETH_ADD_CURVE;\n            curvePool = curveMetaRegistry.findPoolForCoins(_sendToken, ETH_ADD_CURVE, 0);\n        }\n        return (curvePool, _sendToken, _receiveToken);\n    }\n}\n"
    },
    "contracts/CurveMetaRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {IBabController} from './interfaces/IBabController.sol';\nimport {ICurveMetaRegistry} from './interfaces/ICurveMetaRegistry.sol';\nimport {IPriceTri} from './interfaces/external/curve/IPriceTri.sol';\nimport {ICurvePoolV3} from './interfaces/external/curve/ICurvePoolV3.sol';\nimport {ICurveAddressProvider} from './interfaces/external/curve/ICurveAddressProvider.sol';\nimport {ICurveRegistry} from './interfaces/external/curve/ICurveRegistry.sol';\nimport {IFactoryRegistry} from './interfaces/external/curve/IFactoryRegistry.sol';\nimport {ICryptoRegistry} from './interfaces/external/curve/ICryptoRegistry.sol';\nimport {ICryptoFactoryRegistry} from './interfaces/external/curve/ICryptoFactoryRegistry.sol';\n\nimport {ControllerLib} from './lib/ControllerLib.sol';\n\n/**\n * @title CurveMetaRegistry\n * @author Babylon Finance Protocol\n *\n * Abstraction for all the different Curve registries\n */\ncontract CurveMetaRegistry is ICurveMetaRegistry {\n    using ControllerLib for IBabController;\n\n    /* ============ Constants ============ */\n\n    // Address of Curve Address provider\n    ICurveAddressProvider internal constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    address private constant TRI_CURVE_POOL_2_LP = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;\n\n    IBabController public immutable controller;\n\n    /* ============ State Variables ============ */\n\n    // Registry of first party pools\n    ICurveRegistry public curveRegistry;\n\n    // Registry of user created pools\n    IFactoryRegistry public factoryRegistry;\n\n    // Registry of first party crypto pools\n    ICryptoRegistry public cryptoRegistry;\n\n    // Registry of third party crypto pools\n    ICryptoFactoryRegistry public cryptoRegistryF;\n\n    mapping(address => address) public cryptoFactoryLpTokenToPools;\n\n    // Mapping of pool to registryId\n    mapping(address => uint8) public poolToRegistry;\n\n    // 0 means doesnt exist\n    // 1 means first party normal\n    // 2 means factory pools\n    // 3 means crypto first party\n    // 4 means crypto third party\n\n    /* ============ Modifiers ============ */\n\n    /* ============ Constructor ============ */\n\n    constructor(IBabController _controller) {\n        require(address(_controller) != address(0), 'Controller is not valid');\n        controller = _controller;\n        curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        factoryRegistry = IFactoryRegistry(curveAddressProvider.get_address(3));\n        cryptoRegistry = ICryptoRegistry(curveAddressProvider.get_address(5));\n        cryptoRegistryF = ICryptoFactoryRegistry(curveAddressProvider.get_address(6));\n\n        _updateMapping(4, ICurveRegistry(address(cryptoRegistryF)));\n        _updateMapping(2, ICurveRegistry(address(factoryRegistry)));\n        _updateMapping(3, ICurveRegistry(address(cryptoRegistry)));\n        _updateMapping(1, curveRegistry);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Updates the mapping of pools for gas efficiency\n     *\n     */\n    function updatePoolsList() public override {\n        controller.onlyGovernanceOrEmergency();\n        _updateMapping(4, ICurveRegistry(address(cryptoRegistryF)));\n        _updateMapping(3, ICurveRegistry(address(cryptoRegistry)));\n        _updateMapping(2, ICurveRegistry(address(factoryRegistry)));\n        _updateMapping(1, curveRegistry);\n    }\n\n    /**\n     * Updates the addresses of the registries themselves\n     *\n     */\n    function updateCryptoRegistries() external override {\n        controller.onlyGovernanceOrEmergency();\n        curveRegistry = ICurveRegistry(curveAddressProvider.get_registry());\n        factoryRegistry = IFactoryRegistry(curveAddressProvider.get_address(3));\n        cryptoRegistry = ICryptoRegistry(curveAddressProvider.get_address(5));\n        cryptoRegistryF = ICryptoFactoryRegistry(curveAddressProvider.get_address(6));\n        updatePoolsList();\n    }\n\n    /**\n     * Gets the coin addresses of a pool\n     * @param _getUnderlying          Whether or not to get the underlying coins\n     *\n     * @return address[8]             Addresses of the pool assets. Array of size 8 (filled with 0)\n     */\n    function getCoinAddresses(address _pool, bool _getUnderlying) external view override returns (address[8] memory) {\n        uint256 registryKind = poolToRegistry[_pool];\n        if (_getUnderlying) {\n            if (registryKind == 1) {\n                return curveRegistry.get_underlying_coins(_pool);\n            }\n            if (registryKind == 2) {\n                try factoryRegistry.get_underlying_coins(_pool) returns (address[8] memory coins) {\n                    return coins;\n                } catch {\n                    // try normal. Some pools revert\n                    _getUnderlying = false;\n                }\n            }\n            if (registryKind > 2) {\n                // crypto pools only have normal\n                _getUnderlying = false;\n            }\n        }\n        if (!_getUnderlying) {\n            if (registryKind == 1) {\n                return curveRegistry.get_coins(_pool);\n            }\n            if (registryKind == 2) {\n                address[4] memory addressesF = factoryRegistry.get_coins(_pool);\n                return [\n                    addressesF[0],\n                    addressesF[1],\n                    addressesF[2],\n                    addressesF[3],\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(0)\n                ];\n            }\n            if (registryKind == 3) {\n                return cryptoRegistry.get_coins(_pool);\n            }\n            if (registryKind == 4) {\n                address[2] memory addressesCF = cryptoRegistryF.get_coins(_pool);\n                return [\n                    addressesCF[0],\n                    addressesCF[1],\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(0)\n                ];\n            }\n        }\n    }\n\n    /**\n     * Gets the number of coins of a curve pool\n     * @param _pool                   Pool Address\n     *\n     * @return uint256                Number of coins in the pool\n     */\n    function getNCoins(address _pool) public view override returns (uint256) {\n        uint256 registryKind = poolToRegistry[_pool];\n        if (registryKind == 1) {\n            return curveRegistry.get_n_coins(_pool)[0];\n        }\n        if (registryKind == 2) {\n            uint256 coins = factoryRegistry.get_n_coins(_pool);\n            if (coins == 0) {\n                // Try through meta\n                (coins, ) = factoryRegistry.get_meta_n_coins(_pool);\n            }\n            return coins;\n        }\n        if (registryKind == 3) {\n            return cryptoRegistry.get_n_coins(_pool);\n        }\n        // Crypto factory always two\n        return 2;\n    }\n\n    /**\n     * Gets the lp token from a curve pool address\n     * @param _pool                   Pool Address\n     *\n     * @return address                Address of the lp token\n     */\n    function getLpToken(address _pool) external view override returns (address) {\n        uint256 registryKind = poolToRegistry[_pool];\n        // For Deposits & stable swaps that support it get the LP token, otherwise get the pool\n        if (registryKind == 1) {\n            return curveRegistry.get_lp_token(_pool);\n        }\n        if (registryKind == 3) {\n            return cryptoRegistry.get_lp_token(_pool);\n        }\n        // Factory pools use the pool as the token\n        if (registryKind == 2) {\n            return _pool;\n        }\n        return cryptoRegistryF.get_token(_pool);\n    }\n\n    /**\n     * Gets the pool from a curve lp token\n     * @param _lpToken                Address of the lp token\n     *\n     * @return address                Address of the pool, 0 if it doesn't exist\n     */\n    function getPoolFromLpToken(address _lpToken) public view override returns (address) {\n        // Factory pools use the pool as the token\n        if (poolToRegistry[_lpToken] == 2) {\n            return _lpToken;\n        }\n        address cryptoFactoryPool = cryptoFactoryLpTokenToPools[_lpToken];\n        if (cryptoFactoryPool != address(0)) {\n            return cryptoFactoryPool;\n        }\n        // For Deposits & stable swaps that support it get the LP token, otherwise get the pool\n        try curveRegistry.get_pool_from_lp_token(_lpToken) returns (address pool) {\n            if (pool != address(0)) {\n                return pool;\n            }\n        } catch {}\n        try cryptoRegistry.get_pool_from_lp_token(_lpToken) returns (address pool2) {\n            return pool2;\n        } catch {\n            return address(0);\n        }\n    }\n\n    /**\n     * Returns whether the pool is a meta pool\n     * @param _pool                   Pool Address\n     *\n     * @return bool                Whether the pool is a meta pool or not\n     */\n    function isMeta(address _pool) external view override returns (bool) {\n        uint256 registryKind = poolToRegistry[_pool];\n        if (registryKind != 1 && registryKind != 2) {\n            return false;\n        }\n        if (registryKind == 1) {\n            return curveRegistry.is_meta(_pool);\n        }\n        return factoryRegistry.is_meta(_pool);\n    }\n\n    /**\n     * Returns the virtual price of an lp token from curve\n     * @param _lpToken                Lp token Address\n     *\n     * @return uint256                Whether the pool is a meta pool or not\n     */\n    function getVirtualPriceFromLpToken(address _lpToken) external view override returns (uint256) {\n        address pool = getPoolFromLpToken(_lpToken);\n        uint256 registryKind = poolToRegistry[pool];\n        // Normal pools\n        if (registryKind == 1) {\n            return curveRegistry.get_virtual_price_from_lp_token(_lpToken);\n        }\n        if (registryKind == 2) {\n            // Factory registry do not have the method but pools do\n            return ICurvePoolV3(pool).get_virtual_price();\n        }\n        // Special case tricrypto 2\n        if (_lpToken == TRI_CURVE_POOL_2_LP) {\n            return IPriceTri(0xE8b2989276E2Ca8FDEA2268E3551b2b4B2418950).lp_price();\n        }\n        // for crypto pools get directly from the pool the lp price\n        try ICurvePoolV3(pool).lp_price() returns (uint256 price) {\n            return price;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns the underlying asset and the rate of conversion at the index i\n     * @param _pool                   Pool Address\n     * @param _i                      Asset index\n     *\n     * @return address                Address of the underlying asset. 0 if none\n     * @return uint256                Rate of conversion between the underlying and the asset\n     */\n    function getUnderlyingAndRate(address _pool, uint256 _i) external view override returns (address, uint256) {\n        uint256 registryKind = poolToRegistry[_pool];\n\n        if (registryKind == 1) {\n            return (curveRegistry.get_underlying_coins(_pool)[_i], curveRegistry.get_rates(_pool)[_i]);\n        }\n        if (registryKind == 2) {\n            return (factoryRegistry.get_underlying_coins(_pool)[_i], factoryRegistry.get_rates(_pool)[_i]);\n        }\n        // No underlying\n        return (address(0), 0);\n    }\n\n    /**\n     * Finds a pool given those tokens and the index _i\n     * @param _fromToken              Token 1\n     * @param _toToken                Token 2\n     * @param _i                      Index of the pool to retrieve (if more than one)\n     *\n     * @return address                Address of the pool\n     */\n    function findPoolForCoins(\n        address _fromToken,\n        address _toToken,\n        uint256 _i\n    ) external view override returns (address) {\n        address result = curveRegistry.find_pool_for_coins(_fromToken, _toToken, _i);\n        if (result != address(0)) {\n            return result;\n        }\n        result = factoryRegistry.find_pool_for_coins(_fromToken, _toToken, _i);\n        if (result != address(0)) {\n            return result;\n        }\n        result = cryptoRegistry.find_pool_for_coins(_fromToken, _toToken, _i);\n        if (result != address(0)) {\n            return result;\n        }\n        return cryptoRegistryF.find_pool_for_coins(_fromToken, _toToken, _i);\n    }\n\n    /**\n     * Gets the indices of two tokens given a pool address\n     * @param _pool                   Pool address\n     * @param _fromToken              Token 1\n     * @param _toToken                Token 2\n     *\n     * @return uint256                Index of token 1\n     * @return uint256                Index of token 2\n     * @return bool                   Whether or not is underlying\n     */\n    function getCoinIndices(\n        address _pool,\n        address _fromToken,\n        address _toToken\n    )\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        uint256 registryKind = poolToRegistry[_pool];\n        bool underlying = false;\n        uint256 oneIndex;\n        uint256 twoIndex;\n        if (registryKind == 1) {\n            (int128 oneIndexI, int128 twoIndexI, bool underlyingI) =\n                curveRegistry.get_coin_indices(_pool, _fromToken, _toToken);\n            oneIndex = uint256(oneIndexI);\n            twoIndex = uint256(twoIndexI);\n            underlying = underlyingI;\n        }\n        if (registryKind == 2) {\n            (int128 oneIndexI, int128 twoIndexI, bool underlyingI) =\n                factoryRegistry.get_coin_indices(_pool, _fromToken, _toToken);\n            oneIndex = uint256(oneIndexI);\n            twoIndex = uint256(twoIndexI);\n            underlying = underlyingI;\n        }\n        if (registryKind == 3) {\n            (oneIndex, twoIndex) = cryptoRegistry.get_coin_indices(_pool, _fromToken, _toToken);\n        }\n        if (registryKind == 4) {\n            (oneIndex, twoIndex) = cryptoRegistryF.get_coin_indices(_pool, _fromToken, _toToken);\n        }\n        return (oneIndex, twoIndex, underlying);\n    }\n\n    /**\n     * Returns whether or not a given address is a curve pool\n     * @param _poolAddress            Pool address\n     *\n     * @return bool                   Whether or not is underlying\n     */\n    function isPool(address _poolAddress) external view override returns (bool) {\n        return poolToRegistry[_poolAddress] != 0;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    // Function to the update the registry mappings\n    function _updateMapping(uint8 _index, ICurveRegistry _registry) internal {\n        for (uint256 i = 0; i < _registry.pool_count(); i++) {\n            address pool = _registry.pool_list(i);\n            poolToRegistry[pool] = _index;\n            // Adds lptoken to pool for cryptofactory pools\n            if (_index == 4) {\n                cryptoFactoryLpTokenToPools[ICurvePoolV3(pool).token()] = pool;\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/IPriceTri.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n// See https://mobile.twitter.com/curvefinance/status/1441538795493478415\n// https://etherscan.io/address/0xE8b2989276E2Ca8FDEA2268E3551b2b4B2418950#readContract\ninterface IPriceTri {\n    function lp_price() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/IFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IFactoryRegistry {\n    function get_pool_from_lp_token(address _lpToken) external view returns (address);\n\n    function get_lp_token(address _pool) external view returns (address);\n\n    function find_pool_for_coins(\n        address _from,\n        address _to,\n        uint256 _i\n    ) external view returns (address);\n\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\n\n    function get_n_coins(address _pool) external view returns (uint256);\n\n    function get_meta_n_coins(address _pool) external view returns (uint256, uint256);\n\n    function get_rates(address _pool) external view returns (uint256[8] memory);\n\n    function get_virtual_price_from_lp_token(address _lpToken) external view returns (uint256);\n\n    function is_meta(address _pool) external view returns (bool);\n\n    function pool_count() external view returns (uint256);\n\n    function pool_list(uint256 i) external view returns (address);\n\n    function get_pool_name(address _pool) external view returns (string memory);\n\n    function get_A(address _pool) external view returns (uint256);\n\n    function get_coins(address _pool) external view returns (address[4] memory);\n\n    function get_underlying_coins(address _pool) external view returns (address[8] memory);\n\n    function get_coin_indices(\n        address _pool,\n        address _from,\n        address _to\n    )\n        external\n        view\n        returns (\n            int128,\n            int128,\n            bool\n        );\n}\n"
    },
    "contracts/interfaces/external/curve/ICryptoRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICryptoRegistry {\n    function find_pool_for_coins(\n        address _from,\n        address _to,\n        uint256 _i\n    ) external view returns (address);\n\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\n\n    function get_n_coins(address _pool) external view returns (uint256);\n\n    function get_coins(address _pool) external view returns (address[8] memory);\n\n    function get_virtual_price_from_lp_token(address _lpToken) external view returns (uint256);\n\n    function get_pool_from_lp_token(address _lpToken) external view returns (address);\n\n    function get_lp_token(address _pool) external view returns (address);\n\n    function pool_count() external view returns (uint256);\n\n    function pool_list(uint256 i) external view returns (address);\n\n    function get_A(address _pool) external view returns (uint256);\n\n    function get_coin_indices(\n        address _pool,\n        address _from,\n        address _to\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/ICryptoFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ICryptoFactoryRegistry {\n    function find_pool_for_coins(\n        address _from,\n        address _to,\n        uint256 _i\n    ) external view returns (address);\n\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\n\n    function get_coins(address _pool) external view returns (address[2] memory);\n\n    function get_pool_from_lp_token(address _lpToken) external view returns (address);\n\n    function get_token(address _pool) external view returns (address);\n\n    function pool_count() external view returns (uint256);\n\n    function pool_list(uint256 i) external view returns (address);\n\n    function get_A(address _pool) external view returns (uint256);\n\n    function get_coin_indices(\n        address _pool,\n        address _from,\n        address _to\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/mocks/RevertOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {PriceOracle} from '../PriceOracle.sol';\nimport {ITokenIdentifier} from '../interfaces/ITokenIdentifier.sol';\nimport {IBabController} from '../interfaces/IBabController.sol';\n\n/**\n * @title PriceOracle\n * @author Babylon Finance Protocol\n *\n * Uses Uniswap V3 to get a price of a token pair\n */\ncontract RevertOracle is PriceOracle {\n    constructor(ITokenIdentifier _tokenIdentifier, IBabController _controller)\n        PriceOracle(_tokenIdentifier, _controller)\n    {}\n\n    function getPrice(\n        address, /* _tokenIn */\n        address /* _tokenOut */\n    ) public pure override returns (uint256) {\n        require(false, 'Price not found');\n        return 0;\n    }\n}\n"
    },
    "contracts/integrations/pool/BalancerIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\nimport {PoolIntegration} from './PoolIntegration.sol';\nimport {PreciseUnitMath} from '../../lib/PreciseUnitMath.sol';\nimport {LowGasSafeMath} from '../../lib/LowGasSafeMath.sol';\nimport {BytesLib} from '../../lib/BytesLib.sol';\nimport {IBFactory} from '../../interfaces/external/balancer/IBFactory.sol';\nimport {IBPool} from '../../interfaces/external/balancer/IBPool.sol';\n\n/**\n * @title BalancerIntegration\n * @author Babylon Finance Protocol\n *\n * Balancer protocol trade integration\n */\ncontract BalancerIntegration is PoolIntegration {\n    using LowGasSafeMath for uint256;\n    using PreciseUnitMath for uint256;\n    using BytesLib for uint256;\n\n    /* ============ State Variables ============ */\n\n    IBFactory public coreFactory;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _coreFactoryAddress           Address of Balancer core factory address\n     */\n    constructor(IBabController _controller, address _coreFactoryAddress) PoolIntegration('balancer', _controller) {\n        require(address(_controller) != address(0) && _coreFactoryAddress != address(0), 'invalid address');\n        coreFactory = IBFactory(_coreFactoryAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function getPoolTokens(\n        bytes calldata _pool,\n        bool /* forNAV */\n    ) public view override returns (address[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return IBPool(poolAddress).getCurrentTokens();\n    }\n\n    function getPoolWeights(bytes calldata _pool) external view override returns (uint256[] memory) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        address[] memory poolTokens = IBPool(poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint8 i = 0; i < poolTokens.length; i++) {\n            result[i] = IBPool(poolAddress).getNormalizedWeight(poolTokens[i]);\n        }\n        return result;\n    }\n\n    function getPoolTokensOut(\n        bytes calldata _pool,\n        address _poolToken,\n        uint256 _maxAmountsIn\n    ) external view override returns (uint256) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 tokenBalance = IBPool(poolAddress).getBalance(_poolToken);\n        return IBPool(poolAddress).totalSupply().preciseMul(_maxAmountsIn.preciseDiv(tokenBalance));\n    }\n\n    function getPoolMinAmountsOut(bytes calldata _pool, uint256 _liquidity)\n        external\n        view\n        override\n        returns (uint256[] memory _minAmountsOut)\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        uint256 lpTokensTotalSupply = IBPool(poolAddress).totalSupply();\n        address[] memory poolTokens = IBPool(poolAddress).getCurrentTokens();\n        uint256[] memory result = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            result[i] = IERC20(poolTokens[i])\n                .balanceOf(poolAddress)\n                .mul(_liquidity)\n                .div(lpTokensTotalSupply)\n                .preciseMul(1e18 - SLIPPAGE_ALLOWED);\n        }\n        return result;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _isPool(bytes memory _pool) internal view override returns (bool) {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        return coreFactory.isBPool(poolAddress);\n    }\n\n    function _getSpender(\n        bytes calldata _pool,\n        uint8 /* _opType */\n    ) internal pure override returns (address) {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        return poolAddress;\n    }\n\n    /**\n     * Return join pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensOut            Amount of pool tokens to send\n     * hparam  _tokensIn                 Addresses of tokens to send to the pool\n     * @param  _maxAmountsIn             Amounts of tokens to send to the pool\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getJoinPoolCalldata(\n        address, /* _strategy */\n        bytes calldata _pool,\n        uint256 _poolTokensOut,\n        address[] calldata, /* _tokensIn */\n        uint256[] calldata _maxAmountsIn\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddress(_pool);\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('joinPool(uint256,uint256[])', _poolTokensOut, _maxAmountsIn);\n\n        return (poolAddress, 0, methodData);\n    }\n\n    /**\n     * Return exit pool calldata which is already generated from the pool API\n     *\n     * hparam  _strategy                 Address of the strategy\n     * @param  _pool                     OpData e.g. Address of the pool\n     * @param  _poolTokensIn             Amount of pool tokens to receive\n     * hparam  _tokensOut                Addresses of tokens to receive\n     * @param  _minAmountsOut            Amounts of pool tokens to receive\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function _getExitPoolCalldata(\n        address, /* _strategy */\n        bytes memory _pool,\n        uint256 _poolTokensIn,\n        address[] calldata, /* _tokensOut */\n        uint256[] calldata _minAmountsOut\n    )\n        internal\n        pure\n        override\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address poolAddress = BytesLib.decodeOpDataAddressAssembly(_pool, 12);\n        require(_poolTokensIn > 0, '_poolTokensIn has to not 0');\n        require(_minAmountsOut.length > 1, 'Has to provide _minAmountsOut');\n        // Encode method data for Garden to invoke\n        bytes memory methodData = abi.encodeWithSignature('exitPool(uint256,uint256[])', _poolTokensIn, _minAmountsOut);\n\n        return (poolAddress, 0, methodData);\n    }\n}\n"
    },
    "contracts/interfaces/external/balancer/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {IBPool} from './IBPool.sol';\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n\n    function newBPool() external returns (IBPool);\n}\n"
    },
    "contracts/interfaces/external/balancer/IBPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IBPool {\n    function isPublicSwap() external view returns (bool);\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address t) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getCurrentTokens() external view returns (address[] memory tokens);\n\n    function getFinalTokens() external view returns (address[] memory tokens);\n\n    function getDenormalizedWeight(address token) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getNormalizedWeight(address token) external view returns (uint256);\n\n    function getBalance(address token) external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function getController() external view returns (address);\n\n    function setSwapFee(uint256 swapFee) external;\n\n    function setController(address manager) external;\n\n    function setPublicSwap(bool external_) external;\n\n    function finalize() external;\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) external;\n\n    function unbind(address token) external;\n\n    function gulp(address token) external;\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut);\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external returns (uint256 tokenAmountIn);\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 tokenAmountOut);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) external pure returns (uint256 spotPrice);\n\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256 tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/integrations/pool/SushiswapPoolIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.7.6;\n\nimport {UniswapPoolIntegration} from './UniswapPoolIntegration.sol';\nimport {IBabController} from '../../interfaces/IBabController.sol';\n\n/**\n * @title SushiswapPoolIntegration\n * @author Babylon Finance Protocol\n *\n * Sushiswap Protocol pool integration\n */\ncontract SushiswapPoolIntegration is UniswapPoolIntegration {\n    /* ============ Constructor ============ */\n\n    /**\n     * Creates the integration\n     *\n     * @param _controller                   Address of the controller\n     * @param _sushiswapRouterAddress         Address of Sushiswap router\n     */\n    constructor(IBabController _controller, address _sushiswapRouterAddress)\n        UniswapPoolIntegration(_controller, _sushiswapRouterAddress)\n    {\n        name = 'sushiswap_pool';\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999,
      "details": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}